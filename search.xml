<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AQS</title>
    <url>/2023/11/12/AQS/</url>
    <content><![CDATA[<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS是什么：AQS，是AbstractQueuedSynchronizer简称，直翻过来叫抽象的<code>队列式同步器</code>， 也可以称作队列同步器，它是java.util.concurrent.lock包下的一个工具类。直观来讲，AQS是Java提供的一个类，这个类是被Abstract修饰的，需要被子类继承。也就是说<strong>AQS是Java并发中用以解决多线程访问共享资源问题的同步机制的基本的框架</strong>（或者说是一种规范），<strong>为Java并发同步组件提供统一的底层支持</strong>。即，AQS是个为各个同步组件提供基本框架的一个抽象类。</p>
<p>AQS做了什么：<code>提供解决同步问题的基础框架</code>。AQS类内维护了一个volatile int型的变量state，用于表示同步状态（锁的释放与获取），同时提供了一些列诸如getstate、setstate、compareAndSetState的方法来管理该同步状态，这些方法是子类中需要重写的部分，并且，AQS提供了模板方法去调用这些重写的方法；另外，AQS用一个虚拟的CLH FIFO的双向队列来管理被阻塞的线程。</p>
<p>AQS的整体框架如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/82077ccf14127a87b77cefd1ccf562d3253591.png" alt="img"></p>
<ul>
<li><p>有颜色的为方法，没颜色的为属性。</p>
</li>
<li><p>框架共分为5层，从上到下，由浅入深，从AQS对外暴露的API到底层基础数据。</p>
</li>
<li><p>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。</p>
<p>当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</p>
</li>
</ul>
<h4 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h4><p>AQS核心思想是：</p>
<ul>
<li><p>如果被请求的共享资源空闲，那么就将当前<strong>请求资源的线程</strong>设置为有效的工作线程，将共享资源设置为锁定状态；</p>
</li>
<li><p>如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p>
</li>
</ul>
<p>CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的<strong>虚拟双向队列（FIFO）</strong>，AQS是通过将每条<strong>请求共享资源的线程</strong>封装成一个节点来实现锁的分配。</p>
<p>原理如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/7132e4cef44c26f62835b197b239147b18062.png" alt="img"></p>
<p>AOS使用一个Volatile修饰的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值得修改。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL limit 1和limit 10000，1性能一样吗</title>
    <url>/2023/10/11/MySQL%E7%9A%84limit/</url>
    <content><![CDATA[<p> 考虑两条MySQL语句的执行，其中key1是二级索引，id是主键。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from my_table order by key1 limit 1;</span><br></pre></td></tr></table></figure>

<p>该条语句，key1是二级索引，本身就是有序的，那么当查询一条语句之后，它就会直接回表查询具体的数据然后返回。</p>
<p>但是如果SQL变为下面的写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from my_table order by key1 limit 10000, 1;</span><br></pre></td></tr></table></figure>

<p>执行这条语句就会发现它走了全表的扫描 + filesort，它并没有像想象中的那样，扫描到10001的索引，然后回表返回结果。</p>
<h1 id="limit的执行"><a href="#limit的执行" class="headerlink" title="limit的执行"></a>limit的执行</h1><p>MySQL分为Server层和具体的存储引擎层，Server层是统一的，而存储引擎我们这里默认使用InnoDB。</p>
<p>当具体执行一个带有limit操作的SQL时，它并不会在存储引擎层进行过滤，存储引擎查询到所需要的所有数据，然后返回给Server层，Server层依据具体的查询需求来进行过滤，也就是说需要先查询10001条数据返回给Server，然后进行过滤。</p>
<h1 id="优化器选择"><a href="#优化器选择" class="headerlink" title="优化器选择"></a>优化器选择</h1><p>优化器在执行这个查询时会有两种选择</p>
<ol>
<li>全表扫描，然后返回，过滤掉不需要的数据。</li>
<li>第二种查询方案涉及到数据返回策略，InnoDB在执行查询索引时，查找到一条满足条件的数据后，会进行回表，查找完整数据，然后返回给Server层，Server层在返回给用户时发现还有limit，所以要做限制，就不能进行返回，并开始计数。直到引擎层给Server层返回了10001条数据后，才可以完成limit操作，之后再将结果返回给用户，也就是说这里需要进行10001次回表操作，并且要查询10001行数据，然后前10000行全部被Server层丢弃。</li>
</ol>
<p>这两种方案会由优化器决定走哪一种，但不管走哪一种，都需要进行大量的回表操作。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>当执行 <code>limit 1</code> 和执行 <code>limit 10000，1</code>时，性能上的差距还是很大的。并且由于MySQL内存有限，在查询前10000行数据时，难免会有数据页被移出内存，然后从磁盘中加载新的数据页，这也会消耗一定的时间。</p>
]]></content>
      <categories>
        <category>个人心得</category>
        <category>场景分析</category>
      </categories>
      <tags>
        <tag>场景分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的方法调用</title>
    <url>/2023/11/17/Java%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>Java中方法的重载，在编译过程中可以完成识别，而具体调用哪一个方法，Java编译器会根据所传入<strong>参数的声明类型（注意与实际类型区分比如声明的是一个List，实际实例化传入的可能是一个ArrayList）</strong>来选取重载方法。选取过程分以下三个阶段：</p>
<ol>
<li>在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法；（这里是只找普通方法）</li>
<li>如果在第 1 个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；（加入自动装箱拆箱的方法）</li>
<li>如果在第 2 个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况 下选取重载方法。（所有方法）</li>
</ol>
<p>如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么它会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是<strong>形式参数类型的继承关系</strong>。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(String s, Object obj, Object... args)</span> &#123; ... &#125;</span><br><span class="line">invoke(<span class="literal">null</span>, <span class="number">1</span>); <span class="comment">// 调用第二个invoke方法</span></span><br><span class="line">invoke(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用第二个invoke方法</span></span><br><span class="line">invoke(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">1</span>&#125;); <span class="comment">// 只有手动绕开可变长参数的语法糖</span></span><br></pre></td></tr></table></figure>

<p>为什么会调用第二个呢？因为String 类型 是Object 的子类，所以编译器会认为它更贴合（范围更小）。</p>
<p>而如果子类继承父类，而且有一个方法和父类中非私有的方法同名，而且参数相同，如果两个方法都是静态的，那么子类中会隐藏父类的方法，如果不是静态切都不是私有的，那么子类的方法相当于重写了父类的方法。</p>
<h4 id="JVM-的静态绑定和动态绑定"><a href="#JVM-的静态绑定和动态绑定" class="headerlink" title="JVM 的静态绑定和动态绑定"></a>JVM 的静态绑定和动态绑定</h4><p>Java 虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）。方法描述符，是由方法的<strong>参数类型</strong>以及<strong>返回类型</strong>所构成。在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么 Java 虚拟机会在<strong>类的验证阶段</strong>报错。</p>
<p>因为描述符包含了返回类型，所以说并不会限制同一个类中有方法名和参数一样，但返回值不一样的方法。而在上述提到的子类有一个父类同名，同返回值，同参数的非私有，非静态方法，才会被虚拟机判定为重写。</p>
<p>因为重载方法在编译阶段已经区分，可以认为虚拟机层面没有重载的概念。因此，<strong>重载也被称为静态绑定</strong>（static binding），或者编译时多态 （compile-time polymorphism）；而<strong>重写则被称为动态绑定</strong>（dynamic binding）。</p>
<p>这个说法在虚拟机语境下并不完全正确，因为某个类的重载方法可能会被它的子类所重写，因此，Java编译器会对所有非私有方法的调用，编译为需要动态绑定的类型（考虑子类继承父类，并重写父类的方法。此时通过子类调用重写的方法，并不能在编译期间确定）。</p>
<p>确切地说，Java 虚拟机中的<strong>静态绑定指的是在解析时便能够直接识别目标方法的情况</strong>，而<strong>动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法</strong>的情况。</p>
<h4 id="调用指令的符号引用"><a href="#调用指令的符号引用" class="headerlink" title="调用指令的符号引用"></a>调用指令的符号引用</h4><p>在编译过程中，并不知道目标方法的具体内存地址（编译阶段该对象并没有被实例化，似乎没实例化说法不太准确，gpt说是并不需要知到。有了符号引用后，在运行时，JVM会将符号引用解析为实际的地址引用）。</p>
<p>因此，Java 编译器会暂时用<strong>符号引用（这个符号引用应该就是暂时指代该方法）</strong>来表示该目标方法。这一符号引用包括目标方法所在的<strong>类</strong>或<strong>接口</strong>的名字，以及目标方法的<strong>方法名</strong>和<strong>方法描述符</strong>。</p>
<p>符号引用存储在 class 文件的常量池之中。根据目标方法是否为接口方法，这些引用可分为接口符号引用和非接口符号引用。</p>
<h4 id="虚方法调用"><a href="#虚方法调用" class="headerlink" title="虚方法调用"></a>虚方法调用</h4><p>Java 里所有非私有实例方法调用都会被编译成 invokevirtual 指令， 而接口方法调用都会被编译成 invokeinterface 指令。这两种指令，均属于 Java 虚拟机中的 <strong>虚方法调用</strong>。</p>
<p>Java 虚拟机需要根据调用者的动态类型，来确定虚方法调用的目标方法。这个过程我们称之为<strong>动态绑定</strong>。（这里，调用者的动态类型，应该是受Java多态的影响，即List list &#x3D; new ArrayList这种写法，List是一个接口，并不知道它的实例化是哪一个，需要根据具体的动态类型来决定调用的是它的哪一个实现）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里的打印结果是123</span></span><br><span class="line">        test.testExe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testExe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">        father.fatherMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="type">int</span> test;</span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fatherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">childMethod</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fatherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法表（用于优化动态绑定，即虚方法）"><a href="#方法表（用于优化动态绑定，即虚方法）" class="headerlink" title="方法表（用于优化动态绑定，即虚方法）"></a>方法表（用于优化动态绑定，即虚方法）</h4><p>Java 虚拟机中采取了一种用空间换取时间的策略来实现动态绑定。它为每个类生成一张方法表，用以快速定位目标方法。</p>
<p>方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。这些方法可能是具体的，可执行的方法，也可能是抽象的方法。方法表有以下两个特征：</p>
<ol>
<li>子类的方法表中包含了父类的方法表中的所有方法。</li>
<li>子类重写了父类方法时，该方法在子类中的索引值与父类中的一样。即通过索引只能找到子类的方法。</li>
</ol>
<p>在符号引用解析为实际引用的时候，对于静态绑定的调用而言，实际引用是直接指向具体的目标方法，而动态绑定，则是实际引用则是指向了方法表的索引值（并不仅是索引值）。</p>
<p>在执行过程中，Java 虚拟机将获取调用者的实际类型，并在该实际类型的虚方法表中，根据 索引值获得目标方法。这个过程便是动态绑定。</p>
<p>使用了方法表的动态绑定与静态绑定相比，仅仅多出几个内存解引用操作：访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值所对应的目标方法。</p>
<p>这种优化仅存在于<strong>解释执行</strong>中，或者<strong>即时编译代码的最坏情况</strong>中。这是因为即时编译还有另外两种更好的优化，<strong>内联缓存</strong> （inlining cache）和<strong>方法内联</strong>（method inlining）。</p>
<h4 id="内联缓存"><a href="#内联缓存" class="headerlink" title="内联缓存"></a>内联缓存</h4><p>它能够缓存虚方法调用中调用者的<strong>动态类型</strong>，以及<strong>该类型所对应的目标方法</strong>。在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接 调用该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定，即当内联缓存没有命中的情况下，Java 虚拟机需要重新使用方法表进行动态绑定。</p>
<p>Java虚拟机采用的是单态的，即只会缓存对应方法的一种实例，那么在一种极端的情况下，两个不同的类型频繁调同一个 方法，就会导致缓存被频繁的切换，而且每次都需要去重新绑定一下。情况如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal makes a sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat meows&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 在不同的调用者（不同的对象类型）上轮流调用相同的虚方法</span></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                animal1.makeSound(); <span class="comment">// Dog 调用</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                animal2.makeSound(); <span class="comment">// Cat 调用</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>Jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK动态代理和CGlib动态代理</title>
    <url>/2023/10/23/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGlib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h1><p>JDK动态代理是Spring动态代理的默认实现方法。如果我们的类实现了一个接口，那么Spring就会使用这种方法，因为使用JDK动态代理的一个缺陷就是代理的类必须实现接口。</p>
<p><code>JDK</code>实现动态代理需要两个组件，首先第一个就是<code>InvocationHandler</code>接口。我们在使用<code>JDK</code>的动态代理时，需要编写一个类，去实现这个接口，然后重写<code>invoke</code>方法，这个方法其实就是我们提供的代理方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里是一个动态的代理类，只需要传入对应的类，就会执行对应类的对应方法</span></span><br><span class="line"><span class="comment"> * 也就是说我们只用实现这一个代理类就行了，我们所有相同的代理实现都可以用该类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里的Method，我们通过new Proxy创建的一个代理对象，调用它的哪个方法，这里传过来的就是哪个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object o, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------插入前置通知代码-------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行相应的目标方法，rs是方法的返回值</span></span><br><span class="line">        <span class="comment">// 这里是执行被代理对象的方法。由于被代理对象是传进来的，所以一个方法就可以了。</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">rs</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;------插入后置处理代码-------------&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> rs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后<code>JDK</code>动态代理需要使用的第二个组件就是<code>Proxy</code>这个类，我们可以通过这个类的<code>newProxyInstance</code>方法，返回一个代理对象。生成的代理类实现了原来那个类的所有接口，并对接口的方法进行了代理，我们通过代理对象调用这些方法时，底层将通过反射，调用我们实现的<code>invoke</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">IHello</span> <span class="variable">iHello2</span> <span class="operator">=</span> (IHello) Proxy.newProxyInstance(IHello.class.getClassLoader(), <span class="comment">// 加载接口的类加载器</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;IHello.class&#125;, <span class="comment">// 一组接口</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(<span class="keyword">new</span> <span class="title class_">HelloImpl</span>())); <span class="comment">// 自定义的InvocationHandle</span></span><br><span class="line"><span class="comment">// 这里执行哪个方法，传给MyInvocationHandler的Method就是哪个方法</span></span><br><span class="line">iHello2.sayHello();</span><br></pre></td></tr></table></figure>

<p>JDK动态代理的要求：</p>
<ul>
<li>委托类和代理类实现的公共接口</li>
<li>实现公共接口的具体委托类</li>
<li>InvocationHandler接口被Proxy类回调处理，一般实现 InvocationHandler 接口的类具有委托类引用，接口方法 invoke 中添加公共代码并调用委托类的接口方法</li>
<li>JDK提供生成动态代理类的核心类Proxy</li>
</ul>
<p>JDK的动态代理，是创建了一个匿名类来继承Proxy类，然后实现了需要被代理的接口。因为Java只能单继承，所以代理类不能通过继承来实现。</p>
<h1 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h1><p>若需要代理的类没有实现接口，此时<code>JDK</code>的动态代理将没有办法使用，于是<code>Spring</code>会使用<code>CGLib</code>的动态代理来生成代理对象。</p>
<p>CGLib是基于继承的，如果对应的类无法被继承，或者对应方法无法被重写，那么CGLib也无法生成代理对象。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL驱动加载</title>
    <url>/2023/11/02/MySQL%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h1><p>使用Java代码连接MySQL需要走以下流程（使用框架也要做对应的配置）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">driverClassName</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="comment">// 注册驱动</span></span><br><span class="line">    Class.forName(driverClassName);</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里边涉及到一个问题，为什么一定要写一句<code>Class.forName(driverClassName)</code>？</p>
<blockquote>
<p>这里首先涉及到Java的类加载机制</p>
<p>想要使用一个类，则必须要求该类已经被加载到JVM中，加载的过程实际上就是<strong>通过类的全限定名来获取定义该类二进制字节流</strong>，然后将这个字节流所表示的静态存储结构转换为方法去的动态运行时数据结构。同时在在内存中实例化一个java.lang.Class对象，作为方法区中该类的数据访问入口(供我们使用)。</p>
<p>​																																								—— 出自《深入理解Java虚拟机》</p>
</blockquote>
<p>其实在一开始，我并不了解<code>Class.forName()</code>是干嘛的，后边了解到它用作加载类，官方解释为：在运行时动态的加载一个类，返回值为生成的Class对象。所以这行代码的目的，就是将<code>com.mysql.cj.jdbc.Driver</code>类加载到Jvm中了。</p>
<p>这里，<code>forName</code>方法的具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">// 注意这个true，该参数用来标识在将该类加载后是否进行初始化操作。</span></span><br><span class="line">    <span class="keyword">return</span> forName0(className, <span class="literal">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; forName0(String name, <span class="type">boolean</span> initialize,ClassLoader loader,Class&lt;?&gt; caller);</span><br></pre></td></tr></table></figure>

<p>到这里，也就是说这一行代码不仅加载了对应的类，也做了初始化操作。</p>
<p>至于说后续为什么可以直接在<code>DriverManager</code>使用，就要看Driver类里面实现了什么。</p>
<p>MySQL的驱动实现了Java官方提供的Driver接口，这也是每一个数据库厂商所必须要做的事情。而且他们都需要以下这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title class_">java</span>.sql.Driver &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里也是规范的一种，要求每个厂商都把自己的驱动注册到驱动管理里面</span></span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类中定义了一个静态代码块，静态代码快中创建了一个驱动类实例注册给了DriverManager，而静态代码块的内容会在初始化的过程中执行，所以才能通过<code>DriverManager.getConnection</code>直接获取一个连接。</p>
<h1 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h1><p>在jdbc4.0之后，使用了spi机制，破坏了双亲委派机制。也就是说我们不再需要写哪一行<code>Class.forName(driverClassName);</code></p>
<p>我们只需要将对应的驱动类的jar包放到工程的<code>class path</code>下，驱动类会 自动被加载。</p>
<blockquote>
<p>SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。</p>
<p>SPI的目的是为了提前使用某些未被实现的方法。定义一组接口，然后直接通过接口使用它的方法，但是这些方法还未被实现，留给第三方去实现，这就是spi的目的。</p>
<p>还有一种说法，SPI，为了解耦，从配置里获取某个接口的具体实现类。</p>
</blockquote>
<p>为了支持这个新特性，各个数据库厂商的jar包都有一个<code>META-INF/services</code>目录，里面有一个<code>java.sql.Driver</code>，这里指定了driver的全限定名。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231102102705989.png" alt="image-20231102102705989" style="zoom:80%;" />

<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>JDBC的driver接口是定义在JDK中的，但是它的实现类，确在一个jar包中，放在classpath下。就存在以下问题：</p>
<ul>
<li><code>DriverManager</code>类会加载每个Driver接口的实现类并管理它们，但是<code>DriverManager</code>类自身是 <code>jre/lib/rt.jar</code> 里的类，是由<code>bootstrap classloader</code>加载的。</li>
<li>根据类加载机制，<strong>某个类需要引用其它类的时候，虚拟机将会用这个类的classloader去加载被引用的类</strong>，但是<code>bootstrap classloader</code>是无法加载这个driver的（<code>bootstrap classloader</code>只能加载Java 的核心类库包）。</li>
<li>因此只能在DriverManager里强行指定下层classloader来加载Driver实现类，而这就会打破双亲委派模型。</li>
</ul>
<p>具体的做法是，添加了一个线程上下文类加载器<code>Thread Context ClassLoader</code>，在启动类加载器中获取应用程序类加载器。<strong>Thread.setContextClassLoaser()</strong> 设置线程上下文类加载器，如果创建线程的时候没有设置，会从父类继承一个，默认应用程序类加载器。</p>
]]></content>
      <categories>
        <category>个人心得</category>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL的最左前缀原则</title>
    <url>/2023/11/03/MySQL%E7%9A%84%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h1><p>比如我们建立了一个（姓名，年龄）的索引，那么它可以用来匹配按名字的查找，但是按照年龄就不行。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p>
<p>MySQL的索引中，有一种形式，叫做联合索引。即它可以创建多个字段联合起来的索引。语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create index index_name on table_name(column_1, column_2, column_3)</span><br></pre></td></tr></table></figure>

<p>这种联合索引的好处在于：</p>
<ol>
<li><p>创建联合索引，<strong>相当于</strong>创建了column_1，（column_1，column_2），（column_1，column_2，column_3）这三个索引。但是实际上只存在一个索引。这可以大大减小插入数据时修改索引所消耗的时间。</p>
</li>
<li><p>存在联合索引时，如果只查询联合索引这些字段，可以省去回表的时间。</p>
</li>
<li><p>通过联合索引可以筛选出来更少的数据。比如说下面的查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select from table where col1 = 1 and col2 = 2 and col3 = 3</span><br></pre></td></tr></table></figure>

<p>如果只有第一个索引，那么查询完满足第一个条件的数据后，还需要回表去看是否满足第二个条件，第二个条件满足完后还需要看第三个条件。但是如果有联合索引，可以直接查出来满足所有的，这里其实也是满足不回表。</p>
</li>
</ol>
<h1 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h1><p>假设存在联合索引（a，b，c），那么索引结构中，首先是按照a字段有序的，当a相同的时候，b是有序的，b相同后c才是有序的。但是整体来看，索引中b和c都是无序的。</p>
<p>所以说，当出现以下查询时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select from table where b = 1 and c = 1</span><br></pre></td></tr></table></figure>

<p>是无法走索引的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select from table where b = 1 and c = 1 and a = 1</span><br></pre></td></tr></table></figure>

<p>当有a的时候，是可以走索引的。因为MySQL执行器是有优化的，会把sql改成以下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select from table where a = 1 and b = 1 and c = 1</span><br></pre></td></tr></table></figure>

<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231103161043899.png" alt="image-20231103161043899"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
        <category>索引</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring事务失效场景</title>
    <url>/2023/10/31/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h3 id="事务失效"><a href="#事务失效" class="headerlink" title="事务失效"></a>事务失效</h3><blockquote>
<p>写在前面</p>
<p><strong>Spring的事务是通过AOP这种代理的方式实现的。</strong></p>
</blockquote>
<p>事务失效的场景有以下几个</p>
<h4 id="1-访问权限问题"><a href="#1-访问权限问题" class="headerlink" title="1.访问权限问题"></a>1.访问权限问题</h4><p>java的访问权限主要有四种：private、default、protected、public，如果我们加注解的方法不是public，那么事务就会返回空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="comment">// 这里，方法不是public修饰，而spring要求被代理的方法必须是public</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">         saveData(userModel);</span><br><span class="line">         updateData(userModel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-方法用final修饰"><a href="#2-方法用final修饰" class="headerlink" title="2.方法用final修饰"></a>2.方法用final修饰</h4><p>一般用final修饰的方法，都是在该方法不想被子类重写，但是如果将事务方法定义为final，则会导致问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span>&#123;</span><br><span class="line">        saveData(userModel);</span><br><span class="line">        updateData(userModel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring的事务，是通过AOP实现的，而AOP则是通过jdk动态代理或者cglib动态代理，来帮我们生成一个代理类，然后重写对应的方法。final修饰的方法没有办法被重写，所以无法使用事务。</p>
<h4 id="3-方法内部调用"><a href="#3-方法内部调用" class="headerlink" title="3.方法内部调用"></a>3.方法内部调用</h4><p>在某个Service类的某个方法里，调用另一个事务方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        updateStatus(userModel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateStatus</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">        doSameThing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法，调用的是该方法本身，想要事务生效，要走spring的调用。即需要调用<code>UserService.add()</code>, <code>userService.updateStatus()</code>，spring才能为其生成代理对象，然后事务才能生效，直接调用该方法事务无法生效。</p>
<p>如何解决：</p>
<p><strong>1、新增Service类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Servcie</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    prvate ServiceB serviceB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        queryData1();</span><br><span class="line">        queryData2();</span><br><span class="line">        serviceB.doSave(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Servcie</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSave</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        addData1();</span><br><span class="line">        updateData2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、在Service中注入自己（spring三级缓存会解决循环依赖问题）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Servcie</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    prvate ServiceA serviceA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        queryData1();</span><br><span class="line">        queryData2();</span><br><span class="line">        serviceA.doSave(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSave</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        addData1();</span><br><span class="line">        updateData2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、通过AopContent类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Servcie</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        queryData1();</span><br><span class="line">        queryData2();</span><br><span class="line">        ((ServiceA)AopContext.currentProxy()).doSave(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSave</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        addData1();</span><br><span class="line">        updateData2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-未被spring管理"><a href="#4-未被spring管理" class="headerlink" title="4.未被spring管理"></a>4.未被spring管理</h4><p>只有该bean被spring管理的情况下，才能生成代理对象，事务才可以生效。通过@Controller、@Service、@Component、@Repository等注解，可以自动实现bean实例化和依赖注入的功能，如果类没有这类注解，事务无法生效。</p>
<h4 id="5-多线程调用"><a href="#5-多线程调用" class="headerlink" title="5.多线程调用"></a>5.多线程调用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RoleService roleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            roleService.doOtherThing();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOtherThing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存role表数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述案例中，<code>add</code>方法在调用另一个事务方法<code>doOtherThing</code>的时候，开启了一个新的线程，这会导致一个问题，即两个方法不是在同一个线程里面调用的，那么他们两个获取到的数据库连接就不是同一个，那他们就是两个事务。</p>
<p>原因：<strong>spring的事务是通过数据库连接来实现的，当前线程中保存一个map，key是数据源，value是数据库连接。</strong>通常所说的事务，指的是同一个数据库连接，同一个数据库连接才能同时提交和回滚，不同的线程无法实现。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring的事务传播</title>
    <url>/2023/10/15/Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD/</url>
    <content><![CDATA[<h3 id="事务传播"><a href="#事务传播" class="headerlink" title="事务传播"></a>事务传播</h3><blockquote>
<p>写在前面</p>
<p><strong>Spring的事务是通过AOP这种代理的方式实现的。</strong></p>
</blockquote>
<p>事务传播就是多个事务方法相互调用时，事务如何在这些方法间传播。比如事务方法A调用了方法B，那么方法B有无事务以及方法B对事务的要求不同都会对方法A的事务执行造成影响，而方法A的事务对方法B的事务执行也有影响，这种影响就由两个方法定义的事务传播类型所决定。</p>
<p>spring中的事务传播定义了七种类型：<strong>REQUIRED、SUPPORTS、MANDATORY、REQUIRES_NEW、NOT_SUPPORTED、NEVER、NESTED</strong>。这七种类型以枚举的形式存储在<code>org.springframework.transaction.annotation</code>的<code>Propagation</code>。</p>
<p>下面根据集体的例子来解释每一个情况。</p>
<p>假设现在有两个方法A和B，A会在ATable中插入一条数据，B会在BTable中插入一条数据。伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将传入参数a存入ATable</span></span><br><span class="line">pubilc <span class="keyword">void</span> <span class="title function_">A</span><span class="params">(a)</span>&#123;</span><br><span class="line">    insertIntoATable(a);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将传入参数b存入BTable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">B</span><span class="params">(b)</span>&#123;</span><br><span class="line">    insertIntoBTable(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设没有事务时，如下场景：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMain</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 调用A入参a1</span></span><br><span class="line">    A(a1);</span><br><span class="line">    <span class="comment">// 调用testB</span></span><br><span class="line">    testB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 调用B入参b1</span></span><br><span class="line">    B(b1);</span><br><span class="line">    <span class="comment">// 发生异常抛出</span></span><br><span class="line">    <span class="keyword">throw</span> Exception;</span><br><span class="line">    <span class="comment">// 调用B入参b2</span></span><br><span class="line">    B(b2);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下，a1和b1这两条数据会存入对用的数据库，而b2这条数据会因为异常而没有入库。</p>
<h4 id="REQUIRED（Spring默认的事务传播）"><a href="#REQUIRED（Spring默认的事务传播）" class="headerlink" title="REQUIRED（Spring默认的事务传播）"></a>REQUIRED（Spring默认的事务传播）</h4><blockquote>
<p><strong>如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务</strong></p>
</blockquote>
<p>使用场景如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMain</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 调用A入参a1</span></span><br><span class="line">    A(a1);</span><br><span class="line">    <span class="comment">// 调用testB</span></span><br><span class="line">    testB();    </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 调用B入参b1</span></span><br><span class="line">    B(b1);</span><br><span class="line">    <span class="comment">// 发生异常抛出</span></span><br><span class="line">    <span class="keyword">throw</span> Exception;</span><br><span class="line">    <span class="comment">// 调用B入参b2</span></span><br><span class="line">    B(b2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下，数据库的状态会停留在没有执行这两个方法的状态。</p>
<p><code>testMain()</code>声明了事务，它执行时会创建事务，在执行<code>testB()</code>的时候，它就会加入<code>testMain()</code>的事务，而不会自己创建。</p>
<h4 id="SUPPORTS"><a href="#SUPPORTS" class="headerlink" title="SUPPORTS"></a>SUPPORTS</h4><blockquote>
<p><strong>当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMain</span><span class="params">()</span>&#123;</span><br><span class="line">    A(a1);  <span class="comment">//调用A入参a1</span></span><br><span class="line">    testB();    <span class="comment">//调用testB</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.SUPPORTS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>&#123;</span><br><span class="line">    B(b1);  <span class="comment">//调用B入参b1</span></span><br><span class="line">    <span class="keyword">throw</span> Exception;     <span class="comment">//发生异常抛出</span></span><br><span class="line">    B(b2);  <span class="comment">//调用B入参b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下，a1和b1会插入数据库，b2不会插入，因为<code>testMain()</code>是没有事务的，所以执行<code>testB()</code>方法时，无法加入其他的事务。</p>
<h4 id="MANDATORY"><a href="#MANDATORY" class="headerlink" title="MANDATORY"></a>MANDATORY</h4><blockquote>
<p><strong>当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。</strong></p>
</blockquote>
<p>上面的代码在这种情况下，执行结果就是a1存储数据库，而b1和b2没有存入，因为<code>testMain()</code>没有事务而产生报错。</p>
<h4 id="REQUIRES-NEW"><a href="#REQUIRES-NEW" class="headerlink" title="REQUIRES_NEW"></a>REQUIRES_NEW</h4><blockquote>
<p><strong>创建一个新事务，如果存在当前事务，则挂起该事务。</strong>可以理解为在执行时，不论当前是否存在事务，总是会新建一个事务。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMain</span><span class="params">()</span>&#123;</span><br><span class="line">    A(a1);  <span class="comment">//调用A入参a1</span></span><br><span class="line">    testB();    <span class="comment">//调用testB</span></span><br><span class="line">    <span class="keyword">throw</span> Exception;     <span class="comment">//发生异常抛出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>&#123;</span><br><span class="line">    B(b1);  <span class="comment">//调用B入参b1</span></span><br><span class="line">    B(b2);  <span class="comment">//调用B入参b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况下，a1没有存入成功，而b1和b2会存入成功。因为<code>testB()</code>会新建一个事务，而不是采用<code>testMain()</code>的事务。</p>
<h4 id="NOT-SUPPORTED"><a href="#NOT-SUPPORTED" class="headerlink" title="NOT_SUPPORTED"></a>NOT_SUPPORTED</h4><blockquote>
<p><strong>始终以非事务方式执行,如果当前存在事务，则挂起当前事务</strong>，可以理解为始终不执行事务。</p>
</blockquote>
<h4 id="NEVER"><a href="#NEVER" class="headerlink" title="NEVER"></a>NEVER</h4><blockquote>
<p><strong>不使用事务，如果当前事务存在，则抛出异常</strong></p>
</blockquote>
<h4 id="NESTED"><a href="#NESTED" class="headerlink" title="NESTED"></a>NESTED</h4>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring的IoC</title>
    <url>/2023/09/30/Spring%E7%9A%84IoC/</url>
    <content><![CDATA[<h1 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h1><p>1、解析xml文件，将xml中读取到的内容利用<code>ClassPathXmlResource</code>来进行存储。</p>
<p>2、初始化一个工厂，该工厂可以自由选择，比如<code>SimpleBeanFactory</code>或者<code>AutowireCapableBeanFactory</code>，又或者是<code>BeanFactory</code>，取决于场景需要。</p>
<p>3、实例化一个<code>XmlBeanDefinitionReader</code>，该类需要传入第二步生成的工厂，它的主要作用就是解析存储在<code>ClassPathXmlResource</code>中的属性，将它封装为一个<code>BeanDefinition</code>，然后存储在一个map中，map的key为对象的名字，value就是<code>BeanDefinition</code>。用于后续创建bean时，根据名称取到<code>BeanDefinition</code>，然后<code>BeanDefinition</code>中取得属性。</p>
<p>4、到此为止，上面的三步是为了初始化并且存储一些对象的信息，这些信息都来自xml中的配置。之后，调用<code>refresh()</code>来进行具体的创建。</p>
<p>5、在单例模式下，<code>refresh()</code>会先从存放了所有bean实例的map中根据名字取该元素，如果不为空，则直接返回，如果为空，则从毛坯实例中尝试获取该元素（存储毛坯实例是为了解决循环依赖的问题，创建一个空的对象，所有属性都不赋值，用于注入），如果还是为空，则执行创建。</p>
<p>6、创建的流程就是获取到之前存储的<code>BeanDefinition</code>，然后先创建一个毛坯实例，这里是利用Java的反射以及<code>BeanDefinition</code>中存储的<code>getConstructorArgumentValues</code>信息，来进行创建，只创建空的类，类的所有属性都不赋值。之后将毛坯实例进行存储。</p>
<p>7、这一步是将上一步创建的毛坯实例属性进行赋值，从<code>BeanDefinition</code>中获取到<code>PropertyValues</code>，然后遍历，调用<code>setXXX</code>方法进行赋值。</p>
<p>8、创建完后，将bean存储到第五步刚开始取元素的那个map当中，并返回本次创建的实例。如果没有采用注解，到这里就已经创建结束了。</p>
<p>9、如果创建的元素当中有属性使用了注解，则会调用<code>AutowiredAnnotationBeanPostProcessor</code>的<code>postProcessBeforeInitialization</code>方法，该方法会遍历传入实例的所有属性，如果发现带有@Autowired注解，那么就去工厂中获取到对应的实例，并进行注入，然后返回该对象。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>2^32 怎么表示4GB</title>
    <url>/2023/11/21/%E5%86%85%E5%AD%98%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="2-32-怎么表示4GB"><a href="#2-32-怎么表示4GB" class="headerlink" title="2^32 怎么表示4GB"></a>2^32 怎么表示4GB</h1><p>一般来说，32位最大支持4GB内存，怎么计算出来的呢？</p>
<p>如果按照这样计算： 2^32 bit &#x3D; 2^29 byte &#x3D; 2^19 KB &#x3D; 2^9 MB &#x3D; 0.5 GB，其实并不够4GB。</p>
<p>但其实，计算机规定8bit&#x3D;1byte 就是1字节&#x3D;8位，内存的大小就根据格子的多少来进行计算的。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231121111621868.png" alt="image-20231121111621868" style="zoom:67%;" />

<p>实际上，4GB &#x3D;  2^2 GB &#x3D; 2^12 MB &#x3D; 2^22 KB &#x3D; 2^32 byte &#x3D; 2^35 bit。也就是说，4GB需要35位。</p>
<p><strong>实际上内存是把8个bit排成1组， 每1组成为1个单位， 大小是1byte(字节）， cpu每一次只能访问1个byte， 而不能单独去访问具体的1个小格子(bit). 1个byte字节就是内存的最小的IO单位。</strong></p>
<p>即这里3^32次方，后面的单位并不是bit，而是byte。</p>
<p>计算机操作系统会给内存每1个字节分配1个内存地址, cpu只需要知道某个数据类型的地址, 就可以直接去到读影的内存位置去提取数据了。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>单点登录</title>
    <url>/2023/10/13/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h1 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h1><p>一个真正的单点登录流程如下：该流程属于不同域下的单点登录。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/637ec3d1265a44629a45aa7571a77c9f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p>
<ul>
<li>用户进入 A 系统，没有登录凭证（ticket），A 系统给他跳到 SSO。</li>
<li>SSO 没登录过，也就没有 sso 系统下没有凭证（怎么感知到的）（注意这个和前面 A ticket 是两回事），输入账号密码登录。</li>
<li>SSO 账号密码验证成功，通过接口返回做两件事：一是种下 sso 系统下凭证（记录用户在 SSO 登录状态）；二是下发一个 ticket。</li>
<li>客户端拿到 ticket，保存起来，带着请求系统 A 接口。</li>
<li>系统 A 校验 ticket，成功后正常处理业务请求。</li>
<li>此时用户第一次进入系统 B，没有登录凭证（ticket），B 系统给他跳到 SSO。</li>
<li>SSO 登录过，系统下有凭证，不用再次登录，只需要下发 ticket。</li>
<li>客户端拿到 ticket，保存起来，并携带ticket请求系统B的接口。</li>
</ul>
<p>至此，还存在问题，SSO 域下返回的数据要怎么存，才能在访问 A 的时候带上？因为浏览器对跨域有严格限制，cookie、localStorage 等方式都是有域限制的。</p>
<p>下面这张图是一个更细致的流程：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/6dabc898da7149d9b8972a7830825bc9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p>
<ul>
<li>在 SSO 域下，SSO 不是通过接口把 ticket 直接返回，而是通过一个带 code 的 URL 重定向到系统 A 的接口上，这个接口通常在 A 向 SSO 注册时约定。相当于提前定义好了一个接口来接收SSO系统返回的code。</li>
<li>浏览器被重定向到 A 域下，带着 code 访问了 A 的 callback 接口，callback 接口通过 code 换取 ticket。</li>
<li>这个 code 不同于 ticket，code 是一次性的，暴露在 URL 中，只为了传一下换 ticket，换完就失效。</li>
<li>callback 接口拿到 ticket 后，在自己的域下 set cookie 成功。</li>
<li>在后续请求中，只需要把 cookie 中的 ticket 解析出来，去 SSO 验证就好。</li>
</ul>
<p>这里，用户第一次请求时，由于本地没有cookie，所以验证会失败，跳转到SSO系统去验证，而这个验证也会因为没有cookie而失败，所以要求用户进行登录。当登录完成过后，会跳转到系统A提前定义好的接口，并携带code，此时也会在用户本地存储SSO域的一个cookie。该接口会拿到code后去SSO系统换取ticket，拿到ticket后会向SSO系统验证这个ticket是否正确（防止有人伪造ticket而直接请求接口），如果正确则可以正常处理。</p>
<p>此时如果用户使用系统B，因为本地已经有SSO域的cookie 了，携带者去请求SSO就可以，然后可以直接下发凭证。</p>
]]></content>
  </entry>
  <entry>
    <title>可重复读隔离级别会出现幻读吗</title>
    <url>/2023/10/30/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%B9%BB%E8%AF%BB%E5%90%97/</url>
    <content><![CDATA[<p>放在最前面：<strong>InnoDB的默认事务隔离级别是可重复读</strong></p>
<h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><p>MySQL的隔离级别包括四种：<strong>读未提交</strong>（read uncommitted）、<strong>读提交</strong>（read committed）、<strong>可重复读</strong>（repeatable read）和<strong>串行化</strong>（serializable ）。</p>
<ul>
<li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li>串行化，对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ul>
<p>前两种隔离级别，是一定会出现幻读。而<strong>可重复读隔离级</strong>别是采用MVCC，即一致性视图来解决<strong>不可重复读的问题</strong>。具体而言，就是采用快照的方式，事务开启的时候会有一个版本号，然后数据是否可见都是基于版本号来判断的，低于该版本号的数据可见，高于的都不可见。</p>
<p>而可重复读隔离级别下，如果事务A开启后，事务B做了一定的修改并提交事务，在事务A还未提交的时候，对事务B提交的数据做了修改，这个修改是在事务B提交数据的基础上进行修改的，因为不这样的话会导致事务B提交的数据丢失。那也就意味着此次修改会修改数据的事务版本号，后续进行查询的时候，该版本号就可能会导致幻读的问题，以及查询结果与认为中的不一致问题。这也是为什么在可重复读隔离级别下仍然会出现幻读的问题。</p>
<p>上述问题有一个原因：<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong>当前读意味着会读取最新的数据。</p>
<p>其实除了Update语句外，select语句如果加了锁，即<code>for share</code>或者<code>for update </code>也是当前读。</p>
<p>实现可重复读的核心是<strong>一致性读</strong>，而更新数据必须使用<strong>当前读</strong>，这也是为什么会失效的原因。</p>
<h1 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h1><p>在可重复读的隔离级别下，普通读都是<strong>快照读</strong>，是看不见其他事务修改的数据的，幻读的问题只会发生在<strong>当前读</strong>。即<code>select for update</code>  或者<code>select for share</code>这种。</p>
<p>幻读是指在一个事务（假定事务A）的两次查询中，第二次查询查到了第一次没有的数据。发生幻读的根本原因是另外的事务（假定事务B）添加或修改了数据，该数据正好满足事务A的查询条件。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>可重复读的隔离级别，在某些场景下是无法防止幻读的问题，需要用到间隙锁来解决。</p>
]]></content>
      <categories>
        <category>个人心得</category>
        <category>场景分析</category>
      </categories>
      <tags>
        <tag>场景分析</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用3m内存来找到1G文件中词频前100的单词</title>
    <url>/2023/10/17/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A81m%E5%86%85%E5%AD%98%E6%9D%A5%E6%89%BE%E5%88%B01G%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%8D%E9%A2%91%E5%89%8D100%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<p>题目原场景与标题相似，只不过文件的每一行是一个单词，然后在内存只有3m空间，需要获取到1G文件中所有单词频率前100的单词。</p>
<p>想到了用bitmap。</p>
<h1 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h1><p>bitmap往往是做一个映射，来减小数原数据占用空间的大小。在Java中，一个int类型的大小是32位，也就是32bit，它占4字节，也就是4byte，现考虑如下场景：</p>
<p>现在要存储三个数字，比如说5，16，20，如果用一个int数组存储，那么就需要3 * 4 &#x3D; 12字节，但是我们可以换一个思路，比如说使用byte数组，1byte是8位，也就是说可以通过这8位的值位0或1，来代表是否存在数字0-7。那么原来的4字节，就可以代表数字0-31是否存在于集合当中。具体如下表所示</p>
<table>
<thead>
<tr>
<th>数组值</th>
<th>1</th>
<th>1</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>1</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>说明</td>
<td>值为1，代表存在数字0</td>
<td>值为1，代表存在数字1</td>
<td>值为0，代表不存在数字2</td>
<td>值为0，代表不存在数字3</td>
<td>值为0，代表不存在数字4</td>
<td>值为0，代表不存在数字5</td>
<td>值为1，代表存在数字6</td>
<td>值为1，代表存在数字7</td>
</tr>
</tbody></table>
<p>通过这种转换，我们就使用了1字节存储原来需要16字节（4个数字0，1，6，7）才可以存储的集合。</p>
<p>在具体的实现中，我们初始化一个byte数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br></pre></td></tr></table></figure>

<p>我们在计算某一个数字是否存在时，我们要先计算该数字在byte[]数组中的下标，当计算完下标之后，我们就需要将该数字移位，计算出它在该下标在哪一位。</p>
<p>这里的bytes[i]就是上面表格中的样子。每一个byte的大小为2^8 - 1，可以表示0~2^8 - 1。</p>
<h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>1GB大小的文件，全部存储单词，我们假设平均每个单词的长度为10，查阅资料得知Java中空字符串占用40字节，我们做一个大致的估算，一个单词长度为10，那么每个单词占用空间大小就是60字节（一个char[]数组中每个字符占2字节）。那么这1GB大小的文件当中一共有1 * 1024 * 1024 &#x2F; 60 &#x3D; 17476个单词。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">对象头（<span class="number">8</span> 字节）+ 引用 (<span class="number">4</span> 字节 )  + <span class="type">char</span> 数组（<span class="number">16</span> 字节）+ <span class="number">1</span>个 <span class="type">int</span>（<span class="number">4</span>字节）+ <span class="number">1</span>个<span class="type">long</span>（<span class="number">8</span>字节）= <span class="number">40</span> 字节</span><br></pre></td></tr></table></figure>

<p>一个最笼统的思路，我们可以对每一个单词做一个Hash，然后将他映射到一个bitmap上，通过这种转化，原先1G大小的单词，就可以通过该映射存储到对应的位置。</p>
<p>但是这种思路好像没办法解决对应的问题，因为bitmap只能存储0或者1，如果存在两个相同的单词，并不能够进行统计，并且还有Hash冲突的可能。</p>
<h1 id="另外一个思路"><a href="#另外一个思路" class="headerlink" title="另外一个思路"></a>另外一个思路</h1><p>这是一个经典的top k的问题，所以说一般采用大根堆或者小根堆来处理。但是文件比较大，内存又比较小，这时就引入另一种解决问题的方案，分治。</p>
<p>即我们可以先通过hash，将这一个文件打散，这里可以确定地一点是，相同地单词一定可以hash到一个文件中，不同的单词有可能hash到一个文件中，可以经过多次打散，具体可以看内存中可以读入多少个单词。然后记录每个文件中的top k ，最终将所有文件的统计结果做一个合并即可。</p>
]]></content>
      <categories>
        <category>个人心得</category>
        <category>场景分析</category>
      </categories>
      <tags>
        <tag>场景分析</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分片</title>
    <url>/2023/10/02/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87/</url>
    <content><![CDATA[<h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><p>对数据进行分片的策略，主要有三种：水平分片、垂直分片和混合分片，具体如下图所示。水平分片和垂直分片是通过数据切分的操作方向来区分的，而混合分片 是它们的组合体。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002105033499.png" alt="image-20231002105033499" style="zoom: 67%;" />

<h3 id="水平分片"><a href="#水平分片" class="headerlink" title="水平分片"></a>水平分片</h3><p>水平分片有点类似于负载均衡，从流量角度来看，是负载均衡，从数据存储角度来看，是水平分片。</p>
<p>水平分片算法有两个最关键的因素，一是，如何对数据进行划分，即数据划分，二是，分片是 否支持动态分裂与合并，即数据平衡。</p>
<h4 id="数据划分"><a href="#数据划分" class="headerlink" title="数据划分"></a>数据划分</h4><p>数据划分主要有两种方案，一种是基于模运算，一种是基于范围划分。基于模运算比较简单，不再阐述。而基于范围划分，又分为基于关键词划分和基于关键词的 Hash 值划分两种方式。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002110024878.png" alt="image-20231002110024878" style="zoom:67%;" />

<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002110040276.png" alt="image-20231002110040276" style="zoom:67%;" />

<p>这两种分片都是给每一个分片分配一个固定的范围，两者的不同区别在于一个是直接拿关键词进行划分，另一个是利用了关键词的Hash值进行划分。看似区别不大，但是会影响数据的分布。</p>
<h5 id="基于关键词划分"><a href="#基于关键词划分" class="headerlink" title="基于关键词划分"></a>基于关键词划分</h5><p>基于<strong>关键词划分</strong>的好处是，分片后数据的分布依然保留了关键词的顺序，我们可以方便地进行区间查询，因为某个关键词区间的数据都是连续存储的。</p>
<p>但是基于关键词划分也会带来问题，即<strong>数据分布不均匀和访问的热度不均匀</strong>。比如说按照地区进行划分，那么某些省份人数多，这个分片的数据就会多，人数少，分片数据就少。而且数据分布不均时，数据多的分片被访问到的概率也会变大。</p>
<p>如果基于自增 ID 或者时间等关键词对数据进行分片的时候，即使数据是均匀分布的，对于一般的业务场景来说，往往新产生数据的访问热度，也是远远大于历史数据的，这也会导致访问的热度不均匀。</p>
<p>很明显，数据的分布与关键词的分布是一致的。</p>
<h5 id="基于关键词的hash值"><a href="#基于关键词的hash值" class="headerlink" title="基于关键词的hash值"></a>基于关键词的hash值</h5><p>基于关键词的 Hash 值划分就可以上述问题，它通过对关键词进行 Hash 运算，然后基于计算后的 Hash 值范围对数据进行划分，一个好的 Hash 算法可以处理数据倾斜并让它均匀分布。这样可以解决数据分布和访问热度不均的问题。</p>
<p>但导致的问题就是无法高效的进行范围查询。</p>
<h4 id="数据平衡"><a href="#数据平衡" class="headerlink" title="数据平衡"></a>数据平衡</h4><p>根据数据分片是否支持<strong>动态的分裂与合并</strong>，我们可以将水平分片的数据平衡方式分为<strong>静态分片</strong>和<strong>动态分片</strong>。</p>
<p>静态分片是指在系统设计之初，数据分片的数目和区间就预估好了，数据划分后不能再变化。</p>
<p>动态分片则可以在运行时，根据分片的负载和容量做调整。</p>
<p>因为动态分片在运行时分区时可以进行分裂与合并的，不需要担心数据分布的问题，所以动态分片与基于关键词的划分，往往是一个 比较好的组合方式，它避免了基于关键词划分的问题，还保留了数据基于关键词有序的优点。</p>
<p>但是，在基于关键词的划分中，基于自增 ID 或者时间戳等原因，导致的访问冷热不均匀的问题，即使是在动态分片中也不能很好地解决，因为数据的热点往往集中在最新的一个分片区间上。而基于关键词的 Hash 值划分的方式，则可以很方便地将最新的热点数据分布到多个分片 上，很好地解决这个问题。</p>
<p>动态分片存在冷启动的问题。当一个基于动态分片的存储系统启动时，通常是从一个分片开始，当数据量不断增长后，再动态进行分裂。在第一次进行分裂前，所有的读写请求都由 第一个分片来进行处理，而其他的节点则都属于空闲状态。关于这个问题，一个比较好的解决 方式是，动态分片在冷启动时，预分裂为多个分片来缓解。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002112557636.png" alt="image-20231002112557636" style="zoom:67%;" />

<h3 id="垂直分片"><a href="#垂直分片" class="headerlink" title="垂直分片"></a>垂直分片</h3><p>水平分片策 略将整个数据集的条数作为划分的对象，每一个分片负责处理一定的数据条数。而垂直分片策略则是将数据 Schema 的字段集个数作为划分的对象，每一个分片负责处理一个或几个字段 的全部数据，具体如下图所示。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002164951470.png" alt="image-20231002164951470" style="zoom: 80%;" />

<p>如果垂直分片策略的处理方式为一个字段一个分片，那么垂直分片策略就等价于列式存储了，所以列式存储是垂直分片策略的一种特殊情况，也是最常见的情况。</p>
<p>列式存储往往用于大数据分析当中，这类数据的特点是一次写入，多次查询（从不修改），而且是按列读取，每次只关心一列或者几列，每张表都很宽，比如上百列。而且查询无规律，不能索引覆盖。</p>
<h4 id="列式存储"><a href="#列式存储" class="headerlink" title="列式存储"></a>列式存储</h4><p>如果是行式存储，当我们只需要读取一列时，有两种方案，第一个是挨个读取每一行的数据，但是只取出自己要的那一列，这会导致读取数据的量放大很多。如果我们只读取那一列，这会导致我们读取时不是按顺序读取，会对读取造成性能影响。</p>
<p>读多写少的场景，会减少列式存储对写性能的影响。一般来说，数据写入存储系统是以 行的形式写入的，而列式存储会导致一行数据的写入操作，按字段拆分为多个写入操作，使写入放大。</p>
<p>大数据场景，采用列式存储非常适合压缩存储，比如下图：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002192207839.png" alt="image-20231002192207839" style="zoom:67%;" />

<p>好处是使用压缩会大大减小存储成本，提高了存储效率，但是在存储和读取数据时，需要多一步，即找到数据的编码，需要消耗额外的CPU资源。</p>
<h3 id="混合分片策略"><a href="#混合分片策略" class="headerlink" title="混合分片策略"></a>混合分片策略</h3><p>根据水平分片和垂直分片的策略，混合分片可以分为<strong>垂直水平分片</strong>策略和<strong>水平垂直分片</strong>策略。前者先 进行垂直分片，再进行水平分片，而后者先进行水平分片，然后再进行垂直分片。具体如下图：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002192630321.png" alt="image-20231002192630321" style="zoom: 80%;" />

<p>垂直水平分片看着不怎么滴，不过多介绍。</p>
<p>水平垂直分片更像是两者的结合提。先水平划分，划分完后在每一个分片内部再采用列式存储，这样可以保留水平分片和垂直分片的优点。</p>
<h3 id="行列存储比较"><a href="#行列存储比较" class="headerlink" title="行列存储比较"></a>行列存储比较</h3><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002193058865.png" alt="image-20231002193058865" style="zoom:80%;" />

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入浅出分布式技术原理》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>多主复制</title>
    <url>/2023/10/04/%E5%A4%9A%E4%B8%BB%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h1 id="多主复制"><a href="#多主复制" class="headerlink" title="多主复制"></a>多主复制</h1><p>在主从复制的场景中，只有一个主节点，所有的写入操作都要先经过主节点，主节点压力大的问题还是没能解决。而且单主节点的容灾效果也不是很好。</p>
<p>为了达到好的容灾效果，各个机房的距离应该足够远，尽可能的分布在不同的地区，那么这种场景下，用户直接读写自己最近的数据中心，网络延迟最小，效果最好。因此就出现了多住复制。</p>
<h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p>它是指在一个数据系统中，存在多个主从 复制单元，每一个主从复制单元都可以处理读写请求，一个主从复制单元的主副本处理了写请 求后，需要复制到其他的主从复制单元的主副本，具体的流程见下图：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231004112141400.png" alt="image-20231004112141400" style="zoom: 80%;" />

<p>有几点需要注意：</p>
<p>首先，每一个主从复制单元内部是一个常规的主 从复制模式，这里的主副本、从副本之间的复制可以是同步的，也可以是异步的。</p>
<p>其次，多个主从复制单元之间，每一个主副本都会将自己的修改复制到其他的主副本，主副本 之间的复制可以是同步的，也可以是异步的。</p>
<p>如果主副本之间的复制是同步的，那么一个主副本的写入，需要等待复制到其他的主副本成功 后，才能返回给用户，但是，这样却失去了多主复制最重要的一个优点，即多个主副本都可以独立处理写入，这就导致整个模式 退化为主从复制的形式。所以一般来说，多主复制的主副本之间，大多采用异步模式。</p>
<p>但采用异步复制也会出现问题，如果多个主副本同时成功修 改一个数据，当主副本之间复制这个数据的修改时，会出现冲突，我们就不知道以哪一个主副 本的写入结果为准了，该问题在同步复制时可以让用户决定哪个为主。</p>
<h2 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h2><p>冲突主要由两种形式，</p>
<p>首先是由于更新导致的冲突，多个主副本同时更新了一个数据，导致这个数据的版本是非线性的，出现了分叉，具体见下图：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231004124557885.png" alt="image-20231004124557885">其次，由于新增导致的冲突，多个主副本同时新增了一个含有唯一性约束的数据，导致数据的唯一性约束被破坏。例如，在酒店预订业务中，一个时段内一个房间只能预订给一个用户，如 果多个用户在多个主副本上，同时发起预订操作，就可能出现同一个时段内，一个房间被多个 用户预定成功的情况。</p>
<h3 id="避免冲突"><a href="#避免冲突" class="headerlink" title="避免冲突"></a>避免冲突</h3><p>由上可知，冲突是多个主副本同时 修改了一个数据，或者破坏了数据的唯一性约束导致的，那么我们就对数据进行分片，让不同的主数据负责不同的数据分片，这个方式可以在一定程度上避免冲突，但是会导致两个问题：</p>
<p>首先，一个修改操作可能会修改多个分片数据，这样我们就没有办法通过分片来隔离修改了。</p>
<p>其次，由于就近接入和故障等原因，我们会将出现故障的主副本流量切换到其他的主副本，这 时也会出现写入冲突的情况。</p>
<p>注意：这里的分片，并不是每个主副本只保留一部分数据，而是每个主副本仍然保留全量的数据，但是只负责主动的修改某一部分，其他部分等待其他主副本进行同步。</p>
<h4 id="写时解决冲突"><a href="#写时解决冲突" class="headerlink" title="写时解决冲突"></a>写时解决冲突</h4><p>写时解决冲突有两种实现，预定义解决冲突和自定义解决冲突。</p>
<p>预定义解决冲突，是指由存储系统预先定义好规则，在冲突发生时依据预先定义好的规则，自动来解决冲突，主要有以下几种：</p>
<ol>
<li>从操作维度来处理，最后写入获胜。也就是为每一个写操作分配一个时间戳，如果发生 冲突，只保留时间戳最大的版本数据，其他的修改都丢弃，但是这个方法会导致修改丢失。</li>
<li>从副本维度来处理，最高优先级写入获胜。也就是为每一个副本都排好优先级，如果发 生冲突，只保留优先级最高的副本修改数据，其他的修改都丢弃。</li>
<li>从数据结构和算法的维度来处理，通过研究一些可以自动解决冲突的数据结构来解决问题。目前不成熟。</li>
</ol>
<p>自定义解决冲突，它是由业务系统来定义冲突的解决方式，如果发生冲突 了，存储系统就依据业务系统定义的方式执行。</p>
<p>自定义冲突解决的处理逻辑是，在主副本之间复制变更日志时，如果检测到冲突，就调用用户 自定义的冲突处理程序来进行处理。由于主副本之间的数据复制是异步的，所以一般都是后台 执行，不会提示用户。</p>
<h4 id="读时解决冲突"><a href="#读时解决冲突" class="headerlink" title="读时解决冲突"></a>读时解决冲突</h4><p>读时解决冲突的思路和写时解决冲突的思路正好相反，即在写入数据时，如果检测到冲突，不 用立即进行处理，只需要将所有冲突的写入版本都记录下来。当下一次读取数据时，会将所有的数据版本都返回给业务层，在业务层解决冲突，那么读时解决冲突的方式有下面两种：</p>
<ol>
<li>由用户来解决冲突。业务层将冲突提示给用户，让用户来解决。</li>
<li>自定义解决冲突。业务层先依据业务情况，自定义好解决冲突的处理程序，当检 测到冲突时，直接调用处理程序来解决。</li>
</ol>
<h2 id="多主复制的关键问题"><a href="#多主复制的关键问题" class="headerlink" title="多主复制的关键问题"></a>多主复制的关键问题</h2><p>1、正确解决冲突的难度非常大。</p>
<p>2、异步模式的多主复制会存在数据一致性的问题。因为多个主副本都是独立写入的，而他们之间是通过异步复制的方式。</p>
<p>3、多个主副本之间的复制拓扑结构问题。一般来说，多主复制的主副本之间的复制拓扑结 构主要有三种：环形拓扑、星形拓扑以及全部至全部拓扑，具体见下图：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231004155403956.png" alt="image-20231004155403956" style="zoom:80%;" />

<p>前两种，如果一个主副本出现问题，则会导致整个副本的数据无法同步，而第三种虽然一个挂了不影响，但是他们主副本之间同步的时延却要大很多。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入浅出分布式技术原理》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>索引下推</title>
    <url>/2023/11/07/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/</url>
    <content><![CDATA[<h1 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h1><p>首先，MySQL的结构图如下：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231107091604104.png" alt="image-20231107091604104" style="zoom:80%;" />

<p>其中，Server层所做的事情，就是负责SQL的语法解析，生成执行计划，并调用存储引擎层去执行数据的存储核检索，<strong>判断引擎返回的数据是否满足where条件</strong>。<code>索引下推</code>就是指将上层（Server层）负责的事情，交给了下层（引擎层）去处理。具体的查询区别如下：</p>
<p>在没有使用索引下推时：</p>
<ul>
<li>存储引擎读取索引记录；</li>
<li>根据索引中的主键值，定位并读取完整的行记录；</li>
<li>存储引擎把记录交给<code>Server</code>层去检测该记录是否满足<code>WHERE</code>条件。</li>
</ul>
<p>而使用了索引下推的查询过程：</p>
<ul>
<li>存储引擎读取索引记录（不是完整的行记录）；</li>
<li>判断<code>WHERE</code>条件部分能否用<strong>索引中的列来做检查</strong>，条件不满足，则处理下一行索引记录；</li>
<li>条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；</li>
<li>存储引擎把记录交给<code>Server</code>层，<code>Server</code>层检测该记录是否满足<code>WHERE</code>条件的<strong>其余部分</strong>。</li>
</ul>
<p>这里的优化点在于，可以提前根据索引中的数据过滤掉一部分不满足的值，这一部分数据不需要回表查询，也不需要交由Server层去处理。</p>
<p>但是要注意，这个提前判断只能判断索引中存在的值，比如说where条件中有a , b , c 三个字段，但是这个索引（<strong>只能是二级索引，也叫辅助索引</strong>）是建立在a 和 b上面的，那么就只能提前判断a 和 b 是否满足，去除这两个不满足的，然后回表查询数据，返回给Server 然后去判断 c 是否满足条件。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
        <category>索引</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL为什么会卡一下</title>
    <url>/2023/04/05/MySQL/MySQL%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8D%A1%E4%B8%80%E4%B8%8B/</url>
    <content><![CDATA[<p>InnoDB在处理更新操作时，它并不会直接把数据直接写入磁盘，而是先在内存找到对应的数据页做修改，之后把修改写入redo log，然后这一次更新操作就算完成了。（这里也存在数据页不在内存的情况，那么它会直接将数据修改的操作写入change buffer，然后记录redo log）。</p>
<p>这些被修改过的数据页，或者说内存中的数据页与磁盘中的数据页不一样的，就叫做脏页。而MySQL卡的那一下，就是把脏页写回内存时发生的。</p>
<h1 id="写回脏页的时机"><a href="#写回脏页的时机" class="headerlink" title="写回脏页的时机"></a>写回脏页的时机</h1><p>1、redo log满了</p>
<p>redo log是一个循环队列，当它写满时，系统会停止当前的操作，把redo log中记录的一部分操作所对应的脏页写回内存，然后在redo log中腾出足够的地方。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230405145823007.png" alt="image-20230405145823007" style="zoom:50%;" />

<p>2、内存满了</p>
<p>在这种情况下，内存里无法加载更多的内存页，需要淘汰掉一部分内存页，而淘汰掉的内存页如果有脏页，就会把他们写入磁盘。</p>
<p>3、MySQL空闲时</p>
<p>4、MySQL正常关闭的情况。</p>
<h1 id="情况1和2对性能的影响"><a href="#情况1和2对性能的影响" class="headerlink" title="情况1和2对性能的影响"></a>情况1和2对性能的影响</h1><p>情况1是需要避免的，因为发生这种情况后，整个系统就无法处理新的请求。</p>
<p>情况2是一种常态，<strong>InnoDB用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：</strong></p>
<ul>
<li>第一种是，还没有使用的；</li>
<li>第二种是，使用了并且是干净页；</li>
<li>第三种是，使用了并且是脏页。</li>
</ul>
<p>而当要读入的数据页没有在内存的时候，就必须到缓冲池中申请一个数据页。这时候只能把最久不使用的数据页从内存中淘汰掉：如果要淘汰的是一个干净页，就直接释放出来复用；但如果是脏页呢，就必须将脏页先刷到磁盘，变成干净页后才能复用。</p>
<p>如果一个查询要淘汰的数据页太多，那么就会很明显的影响性能。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL45讲》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>MySQL45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>文件系统</title>
    <url>/2023/11/10/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>文件系统将硬盘空间以块进行划分，每个文件占用其中的几个块，然后再通过一个<strong>文件控制块 FCB</strong> 记录每个文件占据的硬盘数据块。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231115093943594.png" alt="image-20231115093943594" style="zoom:67%;" />

<p>在linux中，这个文件控制块就是inode，想要访问文件，就要先获取这个inode，然后在inode中查找文件数据块的索引表，根据索引中记录的硬盘地址信息来访问硬盘，读写数据。</p>
<p>inode的结构是固定的，只有15个索引，前12个索引直接指向数据块地址，第13个索引记录索引地址，即不直接指向数据块，而是指向一张索引表，每张索引表可以记录256个索引，访问这里的数据需要多一次查找。第 14 个索引记录二级索引地址，第 15 个索引记录三级索引地址。</p>
<h1 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h1><p>RAID，即独立硬盘冗余阵列，将多块硬盘通过硬件 RAID 卡或者软件 RAID 的方案管理起 来，使其共同对外提供服务。</p>
<p>RAID 的核心思路其实是利用文件系统<strong>将数据写入硬盘中不同数据块的特性</strong>，将多块硬盘上的空闲空间看做一个整体，进行数据写入，也就是说，一个文件的 多个数据块可能写入多个硬盘。</p>
<p>RAID常用的方式有5种，分别是 RAID 0、RAID 1、RAID 10、 RAID 5 和 RAID 6。</p>
<h2 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h2><p>该方式是将一个文件的数据分成N块，然后同时写入N个硬盘，这样单个文件可以存储在N个硬盘上，文件容量可以扩大N倍，理论上读写速度也扩大N倍。但是有一个问题，这N个磁盘任何一个损坏，就会导致文件的不完整。文件可用性降低。</p>
<h2 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h2><p>利用两块硬盘进行数据备份，文件同时向两块硬盘写入，这样任何一块硬盘损坏都不会出现文件数据丢失的情况，文件的可用性得到提升。</p>
<h2 id="RAID-10"><a href="#RAID-10" class="headerlink" title="RAID 10"></a>RAID 10</h2><p>将多块硬盘进行两两分组，文件数据分成 N 片，每个分组 写入一片，每个分组内的两块硬盘再进行数据备份。这样既扩大了文件的容量，又提高了文件 的可用性。但是这种方式硬盘的利用率只有 50%，有一半的硬盘被用来做数据备份。</p>
<h2 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID 5"></a>RAID 5</h2><p>RAID 5 针对 RAID 10 硬盘浪费的情况，将数据分成 N-1 片，再利用这 N-1 片数据进行位运算，计算一片校验数据，然后将这 N 片数据写入 N 个硬盘。这样任何一块硬盘损坏，都可以 利用校验片的数据和其他数据进行计算得到这片丢失的数据，而硬盘的利用率也提高到( N - 1&#x2F;N)。</p>
<h1 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h1><p>文件的inode，是以索引的方式记录每个文件所在的磁盘位置，如果这些索引记录的不是在本地的磁盘位置，而是记录一个其他服务器的地址，那么查询到的数据块就不止是本地磁盘，还可以是其他服务器的磁盘。这样磁盘的容量就是整个分布式集群的大小，读写速度也会加快。</p>
<p>这样的文件系统就是分布式文件系统，将文件分成很多片，同时向多台服务器写入，然后做好备份，解决单一服务器崩溃导致文件缺失的情况。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>限流</title>
    <url>/2023/09/26/%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<p>如果系统只有熔断机制，当流量激增的时候，就相当于被动的等待熔断机制的触发，此时就需要另外的手段来防止系统负载过高，限流就是一个很好的方案，要主动出击，防止服务挂掉。</p>
<h1 id="为什么需要限流"><a href="#为什么需要限流" class="headerlink" title="为什么需要限流"></a>为什么需要限流</h1><ol>
<li>熔断处理的方式不够优雅。熔断是等到系统过载之后才触发的，即先发生过载，等系统故障后才会介入，让系统恢复。这样的处理方式会导致系统的不必要抖动。</li>
<li>熔断机制是最后的底线。虽然熔断可以解决雪崩问题，但是它应该作为系统稳定性保障的 最后一道防线，正确使用熔断的思路应该是，在其他方法用尽 之后，如果过载问题依旧存在，这时熔断才会被动触发。</li>
<li>在快速失败的时候，需要能考虑调用方的重要程度。熔断是调用方依据响应结果自适应来触发的，在被调用方出现过载的时候，所有的调用方都将受到影响。但是不同接口的重要程度不一样，需要保证有些接口优先处理。</li>
<li>在多租户的情况下，不能让一个租户的问题影响到其他的租户，我们需要对每一个租户分配一定的配额，谁超过了就对谁进行限流，保证租户之间的隔离性。</li>
</ol>
<h1 id="如何实现限流"><a href="#如何实现限流" class="headerlink" title="如何实现限流"></a>如何实现限流</h1><p>限流一般有固定的限流算法，有以下几种：</p>
<h2 id="固定窗口和滑动窗口"><a href="#固定窗口和滑动窗口" class="headerlink" title="固定窗口和滑动窗口"></a>固定窗口和滑动窗口</h2><p>固定窗口就是定义一个“固定”的统计周期，比如 10 秒、30 秒或者 1 分钟，然后在每个周 期里，统计当前周期中被接收到的请求数量，经过计数器累加后，如果超过设定的阈值就触发 限流，直到进入下一个周期后，计数器清零，流量接收再恢复正常状态，如下图所示：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230926104828548.png" alt="image-20230926104828548" style="zoom:80%;" />

<p>存在的问题：</p>
<ol>
<li><p>抗抖动性差。由于流量突增使请求超过预期，导致流量可能在一个统计周期的前 10 ms 内就达到了 100 次，给服务的处理能力造成一定压力，同时后面的 1990 ms 将会触发限流。 </p>
<p>这个问题虽然可以通过减小统计周期来改善，但是因为统计周期变小，每个周期的阈值也会变 小，一个小的流量抖动就会导致限流的发生，所以系统的抗抖动能力就变得更差了。</p>
</li>
<li><p>如果上一个统计周期的流量集中在最后 10 ms ，而现在这个统计周期的流量集中在前 10 ms ，那么这 20 ms 的时间内会出现 200 次调用，这就超过了我们预期的 2 秒内不能超 过 100 次请求的目的了。这时候，我们就需要使用“滑动窗口”算法来改善这个问题了。</p>
</li>
</ol>
<p>滑动窗口就是固定窗口的优化，它对固定窗口做了进一步切分，将统计周期的粒度切分 得更细，比如 1 分钟的固定窗口，切分为 60 个 1 秒的滑动窗口，然后统计的时间范围随着时 间的推移同步后移，如下图所示。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230926110157298.png" alt="image-20230926110157298" style="zoom:80%;" />

<p>但是这里要注意一个问题，如果滑动窗口的统计窗口切分得过细，会增加系统性能和资源损耗 的压力。同时，滑动窗口和固定窗口一样面临抗抖动性差的问题。</p>
<h2 id="漏桶"><a href="#漏桶" class="headerlink" title="漏桶"></a>漏桶</h2><p>如下图所示，“漏桶”就像一个漏斗，进来的水量就像访问流量一样，而出去的水量 就像是我们的系统处理请求一样。当访问流量过大时，这个漏斗中就会积水，如果水太多了就会溢出。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230926110501239.png" alt="image-20230926110501239"></p>
<p>该算法相对于滑动窗口和固定窗口做了两个改进点，第一，增加了一个桶来缓存请求，在流量突增的时候，可以先缓存起来，直到超过桶的容量才触发限流；第二，对出口的流量上限做了限制，使上游流量的抖动不会扩散到下游服务。</p>
<p>漏桶提供流量整形能力有一定的代价，超过漏桶流出速率的请求，需要先在漏桶中排队等待，其中流出速率是漏桶限流的防线，一般会设置得相对保守，可是这样就无法完全利用系 统的性能，就增加了请求的排队时间。</p>
<h2 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h2><p>令牌桶算法的核心是固定“进口”速率，限流器在一个一定容量的桶内，按照一定的速率放入 Token ，然后在处理程序去处理请求的时候，需要拿到 Token 才能处理；如果拿不到，就进行限流。</p>
<p>因此，当大量的流量进入时，只要令牌的生成速度大于等于请求被处理的速度，那么此时系统处理能力就是极限的。<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230926112343201.png" alt="image-20230926112343201" style="zoom:80%;" /></p>
<p>令牌桶算法相对于漏桶，虽然提高了系统的资源利用率，但是却放弃了一定的流量整形能力，也就是当请求流量突增的时候，上游流量的抖动可能会扩散到下游服务。</p>
<h1 id="单节点限流"><a href="#单节点限流" class="headerlink" title="单节点限流"></a>单节点限流</h1><p>单节点限流比较简单，可以基于内存来做，需要注意两点：</p>
<ol>
<li><p>限流机制作用的位置是客户端还是服务端，即选择客户端限流还是服务端限流。一般来说，熔断机制作用的位置是客户端，限流机制作用的位置更多是服务端，因为熔断更强调自适应，让作用点分散在客户端是没有问题的，而限流机制则更强调控制，它的作用点在服务端的控制能力会更强。</p>
<p>将作用点放置在服务端，会给服务端带来性能压力。如果将作用点放置在客户端，这就是一个天然的分布式模式，每一个调用方的客户端执行自己的限流逻辑，而将作用点放置在服务端时，服务端要执行所有请求的限流逻辑， 就需要更多的内存来缓存请求，以及更多的 CPU 来执行限流逻辑。</p>
</li>
<li><p>如果触发限流后，我们应该直接抛弃请求还是阻塞等待，即否决式限流和阻塞式限流。一般来说，如果我们可以控制流量产生的速率，那么阻塞式限流就是一个更好的选择，因为它既可以实现限流的目的，又不会抛弃请求；</p>
<p>如果我们不能控制流量产生的速率，那么阻塞式限流将会因为请求积压，出现大量系统资源占用的情况，很容易引发雪崩，这时否决式限流将是 更好的选择。</p>
</li>
</ol>
<h1 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h1><p>为了系统的高可用，一般每个服务都会有多个实例，所以在进行限流时，需要协调该服务的多个实例，进行统一限流。主要方案有以下几点。</p>
<p>1、进行集中限流。该方案可以借助一个外部存储，比如Redis，然后采用令牌桶算法。但是会带来问题，每次请求都需要先去Redis获取令牌，会导致Redis成为性能瓶颈，并且限流器故障会导致所有请求都被拒绝，而且每次请求都多了一次网络调用，增加时延。</p>
<p>2、将分布式限流进行本地化处理。限流器在获得一个服务限额的总阈值后， 将这个总阈值按一定的策略分配给服务的实例，每一个实例依据分配的阈值进行单节点限流。这里要考虑如果每个服务器的配置不一样，那么分配的流量就需要不同.</p>
<p>一个折中的方案：该方案建立在集中式限流的基础上，为了解决每次请求 都需要，通过网络访问限流器获取令牌的问题，客户端只有在令牌数不足时，才会通过限流器 获取令牌，并且一次获取一批令牌。即令牌由集中式限流器生成，但是具体的限流策略是在每个客户端本地处理。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入浅出分布式技术原理》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务隔离（2）</title>
    <url>/2023/04/02/MySQL/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h2 id="到底是隔离还是不隔离"><a href="#到底是隔离还是不隔离" class="headerlink" title="到底是隔离还是不隔离"></a>到底是隔离还是不隔离</h2><p>假如现在有如下表：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>k</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
</tr>
</tbody></table>
<p>现在执行如下操作：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230402142051361.png" alt="image-20230402142051361"></p>
<p><strong>在可重复读的隔离下，这里面事务B读取到的k的值是3，而事务A读取到的k是1</strong>。下面看具体原因。</p>
<p>在MySQL中，有两个视图概念：</p>
<p>第一个是view，这里就是查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。</p>
<p>另一个是InnoDB在实现MVCC时用到的一致性读视图，即consistent read view，用于支持RC（Read Committed，读提交）和RR（Repeatable Read，可重复读）隔离级别的实现。</p>
<p>可重复读隔离主要用到第二个视图。</p>
<h3 id="“快照”在MVCC里是怎么工作的？"><a href="#“快照”在MVCC里是怎么工作的？" class="headerlink" title="“快照”在MVCC里是怎么工作的？"></a>“快照”在MVCC里是怎么工作的？</h3><p>在可重复读隔离级别下，事务启动时就拍了个快照，这个快照是基于整个库的。但是这个快照并不需要拷贝整个数据库的数据，具体做法如下：</p>
<p>InnoDB的每一个事务都有一个唯一的事务ID，叫作transaction id。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的。</p>
<p>而每一行的数据都是有多个版本。每次事务进行更新数据时，都会生成一个新的版本的数据，然后这个新数据会绑定这个事务ID，记为row trx_id。也就是说，数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的row trx_id，通过这个row trx_id可以知道是哪个事务更新的数据。</p>
<p>一个具体的例子如下图所示：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230402144408772.png" alt="image-20230402144408772"></p>
<p>这里V4是最新的版本，但是数据库只存了V4，它前面的版本V1和V2以及V3并不是真实存在的，而是每次需要的时候根据当前版本和undo log计算出来的。比如，需要V2的时候，就是通过V4依次执行U3、U2算出来。</p>
<p>按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务。但是事务执行期间，其他事务的更新对他不可见。</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>InnoDB为每一个事务构造了一个数组，用来保存事务启动的瞬间，当前启动了但是还没提交的事务。</p>
<p>通过这个数组，我们可以将系统中的所有事务划分为3个部分，小于数组中最小ID的是已经提交了的事务，高于数组最大值是还没开始的事务，数组中的是已经开始的但是还没提交的事务。如下图所示：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230402152032322.png" alt="image-20230402152032322"></p>
<p>针对当前事务，如果一个数据的row trx_id是在绿色区域，那么一定是可见的，如果在红色区域，则不可见。而处于黄色区域的数据，则分为两种情况，如果该row trx_id位于数组中，则说明该事务还没提交，那么就是不可见的，如果不在该数组中，说明已经提交了，则是可见的数据。这里可见得数据直接读取即可，不可见得数据是需要根据undo log进行回滚得数据。</p>
<p>要注意这里的一个可能的误区，这个数组并不一定是连续的，比如它可以是[50, 53, 60, 62]这种，而不连续的部分说明事务已经提交了。</p>
<p>通过这种设计，如果一个数据的row trx_id小于数组中得最小值，则直接按当前值读取，如果大于，则根据情况，看是否可见，如果不可见则需要根据undo log 进行回滚操作。</p>
<h2 id="开头的问题"><a href="#开头的问题" class="headerlink" title="开头的问题"></a>开头的问题</h2><p>现在看开头的那个问题。假设事务A的id是100，那么事务B的id是101，事务C的id是102。假设id &#x3D; 1那一行的row trx_id的值是90。</p>
<p>那么事务A中，事务创建的数组就只有 100，而事务B创建的数组有100，101。事务C创建的数组有100，101，102。</p>
<p>那么从结果上看，值为(1，1)的数据版本号为90， (1，2)数据的版本号为102（事务C修改的）， (1，3)的数据版本号为101（事务B修改的）。</p>
<p>所以事务A在执行查询操作时，发现数据（1，3）的版本号为102，高于数组最大值，是不可见的状态，所以他要退回，一直退到（1，1）这个状态，版本号为90，小于数组中的值，是可见的，所以事务A查到的k &#x3D; 1。</p>
<p>同理，事务B在执行查找时，发现当前数据（1，3）的版本号为101，是它自己的版本，所以直接展示k &#x3D; 3。注意，这里展示k &#x3D; 3是因为直接展示了最终结果，在事务B修改操作时，把k的版本号改为了事务B的id。</p>
<h2 id="更新逻辑"><a href="#更新逻辑" class="headerlink" title="更新逻辑"></a>更新逻辑</h2><p>这里针对上面事务B中的update语句将数据改为（1，3）做出解释：在事务B中，如果修改数据之前，执行一次查询操作，它读到的k的值的确是1，但此时的set k&#x3D;k+1是在（1,2）的基础上进行的操作，否则它将使得事务C的修改无效，导致数据不一致。</p>
<h2 id="事务的可重复读是怎么实现的"><a href="#事务的可重复读是怎么实现的" class="headerlink" title="事务的可重复读是怎么实现的"></a>事务的可重复读是怎么实现的</h2><p>简单来说，就是读操作，需要判断当前数据版本是否可见，不可见就回滚到可见版本。而写操作，则直接在当前版本进行修改。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL45讲》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
        <category>事务</category>
      </categories>
      <tags>
        <tag>MySQL45讲</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务隔离</title>
    <url>/2023/03/30/MySQL/MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/</url>
    <content><![CDATA[<h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务就是要保证一组数据库操作，要么全部成功，要么全部失败。也就是ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）。</p>
<h2 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h2><p>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念（隔离级别越高，效率越低）。</p>
<h3 id="SQL标准的隔离级别"><a href="#SQL标准的隔离级别" class="headerlink" title="SQL标准的隔离级别"></a>SQL标准的隔离级别</h3><p>1、读未提交：一个事务还没提交时，它做的变更就能被其他事务看到。</p>
<p>2、读提交：一个事务提交后，它做的变更才能被其他事务看到。</p>
<p>3、可重复读：一个事务执行过程中看到的数据，总是和 这个事务开始时看到的数据时一致的。该事务未提交的变更对其他事务也是不可见的。</p>
<p>4、串行化：将事务串行执行，如果出现冲突，则后执行的事务必须等前面的执行完才可以执行。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230330100101877.png" alt="image-20230330100101877"></p>
<p>假如数据库只有一列，且只有一个值c &#x3D; 1，执行上面事务时，不同隔离级别得到的结果如下：</p>
<p>1、读未提交：虽然事务b没提交，但是可以被事务A看到，所以V1的值是2，提交后查询到的V2还是2提交事务后查到的V3还是2。</p>
<p>2、读提交：因为这种隔离级别只有提交后才能被看到，所以查询V1时，因为B没提交，所以是1，而V2和V3因为B提交了事务，所作的就该可以被看到，所以V2和V3都是2。</p>
<p>3、可重复读：因为可重复读会保证事务期间查询到的数据和事务开始时一致，那么在事务提交前，V1和V2的值都会是1，而V3因为事务结束，而且事务B已经提交，所以结果是2。</p>
<p>4、串行化：在这种隔离级别下，由于事务A先开始，所以事务B在修改时会被阻塞，直到A提交后，才可以执行。所以V1和V2的值都是1，而V3在提交事务A后才查询，此时B已经被唤醒执行并且提交，所以值是2。</p>
<h3 id="隔离的实现"><a href="#隔离的实现" class="headerlink" title="隔离的实现"></a>隔离的实现</h3><p>在可重复读的隔离级别下，事务启动时会创建一个视图，整个事务存在期间都是用这个视图。</p>
<p>在读提交隔离级别下，这个试图是每个SQL语句开始执行的时候创建的。</p>
<p>读未提交没有视图的概念，它永远返回最新值。</p>
<p>串行化是通过加锁避免并行访问。</p>
<h4 id="可重复读的实现"><a href="#可重复读的实现" class="headerlink" title="可重复读的实现"></a>可重复读的实现</h4><p>每条记录更新时都会同时记录一条回滚操作，记录上的最新值都可以通过回滚操作回到前一个状态值。</p>
<p>假设一个值从1被按顺序改成了2，3，4，那么回滚日志就会有类似记录：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230330103610703.png" alt="image-20230330103610703"></p>
<p>有了上面的记录，我们实现不同隔离级别下，对同一条记录查询到不同的值。比如在A、B、C里面，值分别是1，2，4。简单来说，就是同一个值在系统中可以保存多个版本。但是并非真正的保存至，像上面的视图，如果要获取A，就只能从C开始一步一步回滚。</p>
<h3 id="事务的开启方式"><a href="#事务的开启方式" class="headerlink" title="事务的开启方式"></a>事务的开启方式</h3><p>以下两种：</p>
<p>1、显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。</p>
<p>2、set autocommit&#x3D;0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL45讲》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
        <category>事务</category>
      </categories>
      <tags>
        <tag>MySQL45讲</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL全局锁和表锁</title>
    <url>/2023/04/01/MySQL/MySQL%E5%85%A8%E5%B1%80%E9%94%81%E5%92%8C%E8%A1%A8%E9%94%81/</url>
    <content><![CDATA[<p><strong>根据加锁的范围，MySQL里面的锁大致可以分成全局锁、表级锁和行锁三类</strong></p>
<h1 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h1><p>全局锁就是对整个数据库实例进行加锁。它的一个经典使用场景就是做全库的逻辑备份，也就是把整个库的数据都查出来存成文本。</p>
<p>加了全局锁之后，整个数据库系统就变为了只读状态，意味着很多业务不可以进行。但是如果不加，那么考虑以下情况：</p>
<p>现在有一个用户余额表以及用户库存表，假设用户购买商品时发起了逻辑备份，如果先备份余额表，后备份商品表，那么在扣除余额前余额表备份完成，添加商品到用户库存后才备份的库存表，这时如果用备份进行恢复，那么就会导致用户账户没有扣钱，但是却多了库存。如果反过来，则会导致用户账户被扣，而且没有商品。</p>
<p>而我们会发现，在真正导出数据时，是可以对数据库做修改。这是因为导出数据前，数据库开启了一个<strong>可重复读</strong>隔离级别的事务，保证了在事务执行期间读到的数据和事务开始时是一致的。</p>
<h1 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h1><p>MySQL的表级锁有两种，一种是表锁，一种是元数据锁（MDL），</p>
<h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>可以使用<strong>lock tables … read&#x2F;write</strong>给数据库加表锁，可以使用unlock tables主动释放锁，也可以在客户端断开时自动释放。</p>
<p> 但是需要注意，加了表锁以后，其他线程无法访问这个表，而且加锁的线程接下来的操作也会受到限制。</p>
<p>比如线程A对执行了以下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lock tables t1 read, t2 write</span><br></pre></td></tr></table></figure>

<p>那么其他所有线程写t1，读写t2的语句都会被阻塞，同时在线程A释放锁之前，它只能对表t1进行读操作，t2进行读写操作，而且不允许操作其他表。</p>
<h2 id="元数据锁（MDL）"><a href="#元数据锁（MDL）" class="headerlink" title="元数据锁（MDL）"></a>元数据锁（MDL）</h2><p>MDL锁并不用显式使用，在访问一个表时会被自动追加。它的作用是保证读写的正确性。</p>
<p>假如一个线程在遍历一张表获取数据，此时有另外一个线程删除了表中的一列，这样肯定是不行的。所以在MySQL5.5版本引入了MDL锁。当对一个表做增删改查操作时，加MDL共享锁（读锁），当需要对表结构做调整时，加MDL（排他锁）写锁。</p>
<p>MDL<strong>读锁</strong>之间不互斥，所以加读锁可以允许有多个线程同时对一张表进行增删改查。</p>
<p><strong>读锁与写锁</strong>之间以及<strong>写锁</strong>之间是互斥的，这就意味着如果有线程在进行正删改查时是不可以进行表结构调整，而调整时也不能进行增删改查。</p>
<p>正是由于上面的原因，考虑以下场景：</p>
<p>在一个事务中，线程A执行了查询语句，加了MDL读锁，线程B也执行查询操作，也加了MDL读锁，之后线程C试图修改表结构，需要MDL写锁，这时由于事务没有结束，线程A加的MDL读锁未释放，就会导致线程C被阻塞。但是后续申请MDL读锁的操作也会被线程C阻塞，这就导致了整个表的数据不可访问，严重时会导致数据库崩溃。</p>
<h1 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h1><p>MySQL的行锁是由各个存储引擎实现的，有些引擎是不支持行锁的。</p>
<h2 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h2><p>考虑以下场景：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230401155349241.png" alt="image-20230401155349241"></p>
<p>事务B会被阻塞，直到事务A提交。这就意味着，事务A持有了id &#x3D; 1和id &#x3D; 2的行锁，但是在修改完它并不会立即释放该锁，而是等到事务结束后才释放。这个就是两阶段锁协议。</p>
<p>根据这个协议，我们应该在事务中需要锁多个行时，要把最可能造成冲突的、最可能影响并发度的锁尽量往后放。</p>
<h2 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h2><p>死锁，简单来说，就是线程A对资源C加了锁，线程B也对资源D加了锁，而线程A释放锁需要资源D，线程B释放锁需要资源C，就会导致死锁。</p>
<p>在MySQL中，考虑以下情况：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230401160812101.png" alt="image-20230401160812101"></p>
<p>事务A对id &#x3D; 1的行加了锁， 事务B对id &#x3D; 2的行加了锁，然后事务A在修改 id &#x3D; 2时会被阻塞，事务B修改id &#x3D; 1时会被阻塞。但此时，他们两个会互相等待对方释放资源，导致死锁。</p>
<p>在MySQL中，可以设置超时时间，或者发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务。将innodb_deadlock_detect参数设置未on表示开启死锁检测。</p>
<p>但是死锁的检测是一个时间复杂度为O(N)的操作，即每一个被堵住的线程，都要去判断是不是因为自己的加入导致了死锁，判断的方法就是遍历之前的线程去做判断。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>InnoDB行锁是<strong>通过给索引上的索引项加锁来实现的</strong>。这个索引项指的是在B+树索引结构中，指向一个具体行记录的索引项。索引项是一个键值和一个指向数据页和行号的指针。</p>
<p>InnoDB的索引是建立在数据页上面，而每一个数据页里面有很多条记录，每条记录都有一个对应的索引项。行锁就是锁住了这个索引项，也就是对应的每一条记录。</p>
<p>这也就意味着，如果查询或者修改的条件字段没有索引，那么就不会加行锁，而是直接加表锁。</p>
<p>比如说下面语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update table1 set name = 1 where age = 20</span><br></pre></td></tr></table></figure>

<p>如果age字段没有索引，那么就会对table1整张表加锁。如果age有索引，那么就会加行锁。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
        <category>锁</category>
      </categories>
      <tags>
        <tag>MySQL45讲</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL怎么保证主备一致</title>
    <url>/2023/04/19/MySQL/MySQL%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4/</url>
    <content><![CDATA[<p>MySQL在进行主备同步时，主库会直接把binlog拿到从库中去执行。这里就涉及到binlog的一些内容。</p>
<h1 id="binlog的三种格式"><a href="#binlog的三种格式" class="headerlink" title="binlog的三种格式"></a>binlog的三种格式</h1><p>binlog有三种格式，分别是statement，row和mixed。其中第三种是前两种的混合方式。</p>
<h2 id="这三种日志的区别"><a href="#这三种日志的区别" class="headerlink" title="这三种日志的区别"></a>这三种日志的区别</h2><p>假如说执行如下sql语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from t where a &gt;= 4 and t_modified &lt;= &#x27;2018-11-10&#x27; limit 1;</span><br></pre></td></tr></table></figure>

<p>如果说binlog的格式为statement，那么binlog中会记录一个事务，事务中会执行这个sql。也就是说，该设置下，相当于把该条sql语句直接拿到从库中去执行。</p>
<p>如果说格式为row，那么binglog中会记录很多的内容，但是总的来说，它能够根据这些内容，去从库中直接定位到主库删除的那一条记录。就比如说，主库删除主键是1的那一行，如果记录为row格式，那么从库一定可以定位到从库中主键是1的那一行。</p>
<p>为什么说要定位到从库主键是1的这一行呢？</p>
<p>因为如果格式为statement，那么直接在从库中执行上述语句，可能会导致一些主备不一致的情况。</p>
<p>上述语句，如果走索引a，那么会找到第一条a &gt;&#x3D; 4的记录后，就直接删除。而走索引t_modified，则会找到第一条满足t_modified &lt;&#x3D; ‘2018-11-10’的后，就直接删除。这样的话，如果主备的索引不一致，那么就会导致删除不同的行，导致主备不一致。</p>
<p>而mixed就是结合了两者的优点。因为row格式需要记录 太多的内容，会占用大量的空间。比如我删除10万行数据，row格式就需要10万条记录。而statement格式只需要记录一条sql，但有可能会导致主备不一致，所以采用结合的方式。由系统判断该sql是否会产生主备不一致的可能，如果会就用row记录，否则用statement。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL45讲》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
        <category>日志</category>
      </categories>
      <tags>
        <tag>MySQL45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL分库分表</title>
    <url>/2023/04/27/MySQL/MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><p>分库分表是一种常见的数据分片方式，它不同于集群那种完全的备份数据，而是每个数据库或者每张表只存储整个数据的一部分，这样可以保证总数据量不变的情况下，每个数据库和每张表少存储一些数据。</p>
<p>而且在数据写入时，也会变为往一个库或者一张表写变为往多个库或者多张表写，提高并发写入能力。</p>
<h1 id="如何对数据库做垂直拆分"><a href="#如何对数据库做垂直拆分" class="headerlink" title="如何对数据库做垂直拆分"></a>如何对数据库做垂直拆分</h1><p>垂直拆分就是对数据库竖着拆分，也就是将<strong>数据库的表</strong>拆分到多个<strong>不同的数据库中</strong>。</p>
<p>垂直拆分的原则一般是按照业务类型来拆分，核心思想是专库专用，将业务耦合度比较高的表拆分到单独的库中。</p>
<h1 id="如何对数据库做水平拆分"><a href="#如何对数据库做水平拆分" class="headerlink" title="如何对数据库做水平拆分"></a>如何对数据库做水平拆分</h1><p>水平拆分指的是将<strong>单一数据表</strong>按照某一种规则拆分到<strong>多个数据库</strong>和<strong>多个数据表</strong>中，关注点在数据的特点。</p>
<h2 id="拆分规则"><a href="#拆分规则" class="headerlink" title="拆分规则"></a>拆分规则</h2><p>1、按照某一个字段的哈希值做拆分，这种拆分规则比较适用于实体表。</p>
<p>比如说我们想把用户表拆分成 16 个库，每个库是 64 张表，那么可以先对用户 ID 做哈希，哈希的目的是将 ID 尽量打散，然后再对 16 取余，这样就得到了分库后的索引值；对 64 取余，就得到了分表后的索引值。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230427202234676.png" alt="image-20230427202234676" style="zoom:67%;" />

<p>2、按照某一个字段的区间来拆分，比较常用的是时间字段。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230427202322368.png" alt="image-20230427202322368" style="zoom:67%;" />

<h1 id="分库分表带来的问题"><a href="#分库分表带来的问题" class="headerlink" title="分库分表带来的问题"></a>分库分表带来的问题</h1><p>分库分表引入的一个最大的问题就是<strong>引入了分库分表键，也叫做分区键，</strong>也就是我们对数据库做分库分表所依据的字段。</p>
<p>这也就要求我们后续所有的查询都要带上分区或者分库所用的字段，否则就要遍历所有的库。</p>
<p>一个解决办法就是，我们可以建立一个其他字段和分区字段的映射，当需要根据其他字段查找时，我们先找到它所对应的id，然后再根据id来查询这个具体的值。</p>
<p>另一方面，我们无法通过join来连接两个库的表，只能查询到后端然后进行处理。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《高并发系统设计 40 问》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>高并发系统设计</category>
        <category>数据库篇</category>
      </categories>
      <tags>
        <tag>分库分表</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL怎么保证数据不丢失</title>
    <url>/2023/04/18/MySQL/MySQL%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1/</url>
    <content><![CDATA[<h1 id="binlog的写入机制"><a href="#binlog的写入机制" class="headerlink" title="binlog的写入机制"></a>binlog的写入机制</h1><p>总的流程：先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。</p>
<p>但是需要注意，一个事务的binlog无论多大，都需要一次性写入，这就涉及到binlog cache的保存。</p>
<p>每一个线程都会有一个binlog cache，可以设置其大小。如果超过大小限制，就要暂存在磁盘当中。但是所有的线程共享一个binlog file，也就是说，每个线程的binlog cache，都会存入到同一个文件。</p>
<p>一个具体的例子如下：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230418143649904.png" alt="image-20230418143649904" style="zoom:67%;" />

<p>上图中的write操作，其实只是把binlog cache的内容写入文件系统的缓存，并没有直接同步到磁盘，而fsync才是真正的将文件系统缓存的内容写入到磁盘上。</p>
<p>write 和fsync的时机，是由参数sync_binlog控制的：</p>
<ol>
<li>sync_binlog&#x3D;0的时候，表示每次提交事务都只write，不fsync；</li>
<li>sync_binlog&#x3D;1的时候，表示每次提交事务都会执行fsync；</li>
<li>sync_binlog&#x3D;N(N&gt;1)的时候，表示每次提交事务都write，但累积N个事务后才fsync。</li>
</ol>
<h1 id="redo-log的写入机制"><a href="#redo-log的写入机制" class="headerlink" title="redo log的写入机制"></a>redo log的写入机制</h1><p>redo log 每次写入时，生成的redo log会先写入redo log buffer，而redo log buffer里面的内容并不需要每次写完后都同步到磁盘。</p>
<p>因为事务还没提交时，数据库异常重启，这部分日志会丢失，但是因为事务没提交，所以不会对数据一致性造成影响。因为事务只有在提交时，事务内所作的修改才真正起作用。</p>
<p><strong>但是事务还没提交时，redo log buffer里面的内容也会有刷入磁盘的情况。</strong></p>
<h2 id="redo-log可能存在的三种状态"><a href="#redo-log可能存在的三种状态" class="headerlink" title="redo log可能存在的三种状态"></a>redo log可能存在的三种状态</h2><p>1、存在于redo log buffer中，也就是还在MySQL进程中。</p>
<p>2、写入了文件系统的缓存当中。</p>
<p>3、写入了磁盘当中。</p>
<h2 id="redo-log的写入策略"><a href="#redo-log的写入策略" class="headerlink" title="redo log的写入策略"></a>redo log的写入策略</h2><p>为了控制redo log的写入策略，InnoDB提供了innodb_flush_log_at_trx_commit参数，控制写入策略：</p>
<ol>
<li>设置为0的时候，表示每次事务提交时都只是把redo log留在redo log buffer中;</li>
<li>设置为1的时候，表示每次事务提交时都将redo log直接持久化到磁盘；</li>
<li>设置为2的时候，表示每次事务提交时都只是把redo log写到page cache。</li>
</ol>
<p>InnoDB有一个后台线程，每隔1秒，就会把redo log buffer中的日志，调用write写到文件系统的page cache，然后调用fsync持久化到磁盘。</p>
<p>这也就解释了为什么会有没提交事务的redo log也被写入了磁盘当中。因为事务执行时，日志就会先写入redo log buffer中，后台线程会在事务没提交时，将数据刷入磁盘当中。</p>
<p>另外两种会导致事务没提交时，redo log 被写入磁盘：</p>
<p><strong>一种是，redo log buffer占用的空间即将达到 innodb_log_buffer_size一半的时候，后台线程会主动写盘。</strong>但这里只是写入文件系统的缓存中，不是写入磁盘。</p>
<p><strong>另一种是，并行的事务提交的时候，顺带将这个事务的redo log buffer持久化到磁盘。</strong>比如说事务A执行了一半，它已经写入了一部分日志到redo log buffer中。如果此时另一个事务提交了，而且innodb_flush_log_at_trx_commit参数设置的是1，那么它就会直接将redo log buffer中的内容直接写入磁盘，这样事务A的一部分日志就被写入了磁盘当中。</p>
<h1 id="双一配置"><a href="#双一配置" class="headerlink" title="双一配置"></a>双一配置</h1><p>两阶段提交的流程是：时序上redo log先prepare， 再写binlog，最后再把redo log commit。</p>
<p>将innodb_flush_log_at_trx_commit设置为1时，redo log在处于prepare阶段时，就会刷新到磁盘当中。</p>
<p>通常我们说MySQL的“双1”配置，指的就是sync_binlog和innodb_flush_log_at_trx_commit都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是redo log（prepare 阶段），一次是binlog。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL45讲》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
        <category>日志</category>
      </categories>
      <tags>
        <tag>MySQL45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL普通索引和唯一索引</title>
    <url>/2023/04/03/MySQL/MySQL%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>假如有一张表，它需要存储用户的身份证号以及姓名，业务层已经保证了身份证号唯一，此时有以下查询:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name from table where id_card = &quot;xxxxyy&quot;</span><br></pre></td></tr></table></figure>

<p>为了提高效率，我们会在id_card上面加索引，那么到底是加唯一索引还是普通索引呢？我们可以从这两种索引对查询语句以及更新语句的性能影响来进行分析。</p>
<h1 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h1><p>假设执行的语句是select id from T where k&#x3D;5。对于两种索引执行过程如下：</p>
<p>普通索引：他会先找到k &#x3D; 5的这一条数据，然后会继续往下找，直到第一条不满足k &#x3D; 5的数据。</p>
<p>唯一索引：因为索引保证了唯一性，所以碰到第一条为5的记录后，就可以直接返回。</p>
<p>这一点的不同带来的性能差距很小。因为InnoDB的数据是以<strong>数据页</strong>为单位来读的，意味着读一条数据，会将那条数据所在的页都加载到内存当中，所以读取k &#x3D; 5的时候，大概率后续几条数据会在同一个数据页中，此时性能差异很小。一个特殊情况是后续几条数据和k &#x3D; 5不在同一个页中，那么此时效率会有点低。</p>
<h1 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h1><h2 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h2><p>MySQL在更新数据时，如果数据页不在内存中，就会先将更新操作写入change buffer中，等到下次查询该数据时，将change buffer中的操作执行到具体的数据。</p>
<p>除了查询的时候会进行数据同步外，后台也会有线程定期对change buffer中的操作执行到具体的数据。</p>
<p>change buffer在内存中也有拷贝，也会被写入到磁盘。</p>
<h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><p>对于唯一索引来说，在更新数据前他需要先判断该操作是否满足唯一性约束，进行判断就意味着必须要将数据页读到内存。这也就意味着唯一索引在进行修改时，修改数据所在的数据页一定在内存中。</p>
<p><strong>也就是说，change buffer只有普通索引才可以使用。</strong></p>
<p>针对于一个更新，分为两种情况：</p>
<p>如果要更新的数据在内存中，那么两种索引的更新情况类似，只不过唯一索引多了一次判断，影响不大。</p>
<p>但是如果数据不在内存中，那么唯一索引需要先把数据查询出来放入内存，然后再更新，而普通索引写入change buffer即可。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>由于在进行合并的时候，change buffer记录的变更越多（也就是这个页面上要更新的次数越多），收益就越大。</p>
<p>因此，对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。</p>
<h1 id="change-buffer-和-redo-log"><a href="#change-buffer-和-redo-log" class="headerlink" title="change buffer 和 redo log"></a>change buffer 和 redo log</h1><p>这两种设计原理，都是为了减少随机的磁盘读取。现在考虑执行下面的语句:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into t(id,k) values(id1,k1),(id2,k2);</span><br></pre></td></tr></table></figure>

<p>这里我们假设k1所在的数据页在内存中，而k2所在的数据页不在内存中。那么这条更新语句要做的处理如下：</p>
<p>1、因为k1数据页在内存中，则直接更新k1数据所在的数据页即可。</p>
<p>2、因为k2数据页不在内存，就在change buffer中记录类似于我要插入k2这条记录即可。</p>
<p>3、将上述两个动作记录redo log中。</p>
<p>这样，插入就执行完成了。两次内存操作，一次磁盘操作。</p>
<p>在执行完上面的插入操作后，如果继续执行下面语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from t where k in (k1, k2)。</span><br></pre></td></tr></table></figure>

<p>由于k1所在的数据页还在内存当中，直接从内存中读取返回，而k2所在的数据页不在内存中，则从磁盘读取，然后于change buffer整合，返回正确的结果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以，如果要简单地对比这两个机制在提升更新性能上的收益的话，<strong>redo log 主要节省的是随机写磁盘的IO消耗（转成顺序写），而change buffer主要节省的则是随机读磁盘的IO消耗。</strong></p>
<p>增删改操作都涉及到从磁盘中读取数据页加载到内存，而使用了change buffer后，直接将增删改操作记录到change buffer中即可，下次做查询操作时进行整合即可，减少读磁盘的次数。</p>
<p>而redo log是在增删改操作时，先将操作记录redo log，然后将数据在数据库缓存（buffer pool）中修改。由于这部分数据是在内存当中，没有同步到磁盘，而此时数据库异常关闭，可以通过redo log来恢复这段期间的数据，保证数据的一致性。</p>
<h2 id="一个小疑问"><a href="#一个小疑问" class="headerlink" title="一个小疑问"></a>一个小疑问</h2><p>我最开始比较疑惑为什么插入操作会涉及到考虑数据页是否在内存当中，原因是MySQL在插入数据时，会先找到这条语句所对应的数据页，然后把数据插入到对应的数据页中。所以说，即使是插入操作，也要确保数据页在内存中。如果在插入时使用了 Change Buffer 技术，那么可以将这些插入操作暂时缓存到 Change Buffer 中，等到后续查询这个数据页的时候，再将 Change Buffer 中的数据一次性刷新到对应的数据页中，这样就可以减少磁盘 IO 操作，提高系统的性能。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL45讲》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
        <category>索引</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>MySQL45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的next-key lock</title>
    <url>/2023/04/16/MySQL/MySQL%E7%9A%84next-key%20lock/</url>
    <content><![CDATA[<p>InnoDB引擎为了解决幻读带来的问题，引入了间隙锁。而间隙锁和行锁组合起来叫做next-key lock，他是一个左开右闭的区间，代表锁住对应数据行以及数据行之间的间隙。</p>
<p>比如现在有两行数据，（5，5，5）和（10，10，10）。在可重复读得隔离级别下执行如下sql ，，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table where id = 7</span><br></pre></td></tr></table></figure>

<p>就会锁住(5, 10]之间的间隙，以及第（10，10，10）这一行。因为锁是加在索引上面，而索引是有序的，所以需要保证这两条数据间没有新的数据插入。</p>
<p>在《MySQL45讲》中给出了加锁的一些规则：</p>
<ol>
<li>原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。</li>
<li>原则2：查找过程中访问到的对象才会加锁。</li>
<li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。</li>
<li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候（比如查询id &#x3D; 5，而最后一个值是id &#x3D; 10，那么就会变为间隙锁），next-key lock退化为间隙锁。</li>
<li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ol>
<p>假如现在有如下表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure>

<p>下面我们看一些具体的例子。</p>
<h1 id="等值查询间隙锁"><a href="#等值查询间隙锁" class="headerlink" title="等值查询间隙锁"></a>等值查询间隙锁</h1><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416152532725.png" alt="image-20230416152532725"></p>
<p>课程中讲的是：</p>
<p>1、根据原则1，加锁单位是next-key lock，session A加锁范围就是(5,10]；</p>
<p>2、同时根据优化2，这是一个等值查询(id&#x3D;7)，而id&#x3D;10不满足查询条件，next-key lock退化成间隙锁，因此最终加锁的范围是(5,10)。</p>
<p>所以插入（8，8，8）失败，而update10成功。</p>
<p>这里有一个疑问：为什么没有根据优化1，将（5，10]的next-key lock转变为行锁呢？</p>
<p>个人理解：虽然是唯一索引的等值操作，但是查询条件是id &#x3D; 7，而表中的值是id &#x3D; 5和 id &#x3D; 10这两条记录，并不相等，所以没有退化成行锁。</p>
<h1 id="非唯一索引等值锁"><a href="#非唯一索引等值锁" class="headerlink" title="非唯一索引等值锁"></a>非唯一索引等值锁</h1><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416152814309.png" alt="image-20230416152814309"></p>
<p>这个例子中，由于数据是（0，0，0）（5，5，5）（10，10，10），而查询条件是c &#x3D; 5，所以会先在（0，5]之间加上next-key lock。</p>
<p>但是c是非唯一索引，所以需要遍历到不满足条件的为止，也就是说会访问到c &#x3D; 10这一行。所以还会给（5，10]加上锁，但是该锁最后一行c &#x3D; 10并不满足c &#x3D; 5的查询条件，所以会退化为间隙锁，也就是（5，10），并不锁c &#x3D; 10这一行。</p>
<p>而这个查询语走索引c，却只查询了id，恰好是覆盖索引，并不会回表，也就是说只锁了索引c，而没有锁索引id，那么意味着sessionB要操作的数据并没有加锁，所以B成功了，而C失败了。</p>
<h1 id="主键索引范围锁"><a href="#主键索引范围锁" class="headerlink" title="主键索引范围锁"></a>主键索引范围锁</h1><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416154441303.png" alt="image-20230416154441303" style="zoom: 50%;" />

<p>sessionA会先找到id &#x3D; 5这一行，然后是id &#x3D; 10这一行，所以会加（5，10]的next-key lock。但是id &#x3D; 10满足了查询条件，所以这个锁会退化为行锁，只锁id &#x3D; 10这一行。</p>
<p>但是查询还有第二个条件id  &lt;  11，则会继续往后走，查找到id &#x3D; 15这一行。所以会加（10，15]的next-key lock。由于查询条件id &lt; 11在id &#x3D; 15这一行不满足，所以无法退化成间隙锁，也即是说15这一行也会被锁住。就会导致如图的情况。</p>
<h1 id="非唯一索引范围锁"><a href="#非唯一索引范围锁" class="headerlink" title="非唯一索引范围锁"></a>非唯一索引范围锁</h1><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416160330625.png" alt="image-20230416160330625" style="zoom:50%;" />

<p>这个例子中，由于查询所有的值，所以走索引c需要回表。意味着不仅要锁索引c，也要锁id。</p>
<p>在第一次用c&#x3D;10定位记录的时候，索引c上加了(5,10]这个next-key lock后，由于索引c是非唯一索引，没有优化规则，也就是说不会变为行锁，因此最终sesion A加的锁是，索引c上的(5,10] 和(10,15] 这两个next-key lock。</p>
<p>所以插入8 和修改c &#x3D; 15也都会被阻塞。</p>
<h1 id="非唯一索引上存在”等值”的例子"><a href="#非唯一索引上存在”等值”的例子" class="headerlink" title="非唯一索引上存在”等值”的例子"></a>非唯一索引上存在”等值”的例子</h1><p>假如新插入了一行记录（30，10，30）那么索引c就会变为如下：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416162231844.png" alt="image-20230416162231844" style="zoom: 67%;" />

<p>那么如下操作：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416162440432.png" alt="image-20230416162440432"></p>
<p>这里会加5，10以及10，15的锁，然后不包括端点。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
        <category>锁</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的幻读</title>
    <url>/2023/04/14/MySQL/MySQL%E7%9A%84%E5%B9%BB%E8%AF%BB/</url>
    <content><![CDATA[<p>这篇文章将介绍MySQL幻读相关的内容。</p>
<p>假设数据库中有以下表：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>c</th>
<th>d</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>10</td>
<td>10</td>
<td>10</td>
</tr>
<tr>
<td>15</td>
<td>15</td>
<td>15</td>
</tr>
<tr>
<td>20</td>
<td>20</td>
<td>20</td>
</tr>
<tr>
<td>25</td>
<td>25</td>
<td>25</td>
</tr>
</tbody></table>
<p>其中id是主键，c上建立有普通索引。</p>
<p>以下讨论场景除非必要说明，否则都是在可重复读的隔离级别下。</p>
<h1 id="什么是幻读"><a href="#什么是幻读" class="headerlink" title="什么是幻读"></a>什么是幻读</h1><p>现在考虑以下场景：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414141001291.png" alt="image-20230414141001291" style="zoom:50%;" />

<p>其中，select * from table for update表示当前读，并且加上写锁。</p>
<p>幻读就是指在同一个事务中执行相同的sql，后一次查询看到了前一次没看到的数据。就比如Q3比Q2多了一条数据。</p>
<p>Q2看到Q1并不被称为幻读，幻读仅仅指新插入的数据。</p>
<p>在可重复读的隔离级别下，普通查询是看不到其他插入的数据，只有当前读（要能读到所有已经提交的记录的最新值）才有可能出现幻读。</p>
<h1 id="幻读存在的问题"><a href="#幻读存在的问题" class="headerlink" title="幻读存在的问题"></a>幻读存在的问题</h1><h2 id="1、语义的破坏"><a href="#1、语义的破坏" class="headerlink" title="1、语义的破坏"></a>1、语义的破坏</h2><p>session A已经声明了写锁，即要锁住d &#x3D; 5的行，不允许其他事务进行读写，而后续却插入了一条d &#x3D; 5的数据。</p>
<p>考虑另一个更明显的场景：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414143724913.png" alt="image-20230414143724913" style="zoom: 50%;" />

<p>sessionB将id &#x3D; 0的这一行的d改成了5，然后又把c改成了5，也就是说变化为从（0，0，5）-&gt;（0，5，5）。这样破坏了sessionA要锁住所有d&#x3D;5的行的加锁声明。</p>
<p>sessionC也是同样的道理，修改了d &#x3D; 5，id &#x3D; 1的行。</p>
<h2 id="2、数据一致性问题"><a href="#2、数据一致性问题" class="headerlink" title="2、数据一致性问题"></a>2、数据一致性问题</h2><p>现在在sessionA追加一条语句：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414144337377.png" alt="image-20230414144337377" style="zoom:50%;" />

<p>此时，sessionA要锁住d &#x3D; 5的这一行，然后把d 改为100，即sessionA在T1要做的操作为将（5，5，5）-&gt; (5，5，100)。</p>
<p>在T2时刻，id &#x3D; 0这一行变成了（0，5，5）</p>
<p>在T4时刻，数据库多了一条（1，5，5）的记录。</p>
<p>但是我们看binlog的内容：</p>
<p>在T2时刻，sessionB提交，写入两条语句，两条update。</p>
<p>T4时刻，sessionC提交，写入两条语句，一条insert，一条update。</p>
<p>把上面的语句放在一起，顺序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* sessionB */</span><br><span class="line">update t set d = 5 where id = 0; /*(0,0,5)*/</span><br><span class="line">update t set c = 5 where id = 0; /*(0,5,5)*/</span><br><span class="line"></span><br><span class="line">/* sessionC */</span><br><span class="line">insert into t values(1,1,5); /*(1,1,5)*/</span><br><span class="line">update t set c = 5 where id = 1; /*(1,5,5)*/</span><br><span class="line"></span><br><span class="line">/* sessionA */</span><br><span class="line">update t set d = 100 where d = 5;/*所有d=5的行，d改成100*/</span><br></pre></td></tr></table></figure>

<p>通过这个语句的顺序，如果我们要拿它来恢复数据，最终恢复出来的数据会变为： (0,5,100)、(1,5,100) 和 (5,5,100)。</p>
<p>而正确的数据应该是（0，5，5），（1，5，5）和（5，5，100）。因为在可重复读隔离级别下，事务A没提交，事务B和C看不到A的修改，而事务A在提交之前看不到B和C的修改。</p>
<p>这里的数据不一致是因为我们假设了select * from t where d&#x3D;5 for update这条语句只给id &#x3D; 5这一样加锁导致的。</p>
<p>现在我们假设把扫描过程中的所有行都加锁，场景如下：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414150914211.png" alt="image-20230414150914211" style="zoom:50%;" />

<p>这个时候，id &#x3D; 0的这一行在修改时，由于被加了锁，所以无法执行。也就是说现在的执行顺序如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into t values(1,1,5); /*(1,1,5)*/</span><br><span class="line">update t set c=5 where id=1; /*(1,5,5)*/</span><br><span class="line"></span><br><span class="line">update t set d=100 where d=5;/*所有d=5的行，d改成100*/</span><br><span class="line"></span><br><span class="line">update t set d=5 where id=0; /*(0,0,5)*/</span><br><span class="line">update t set c=5 where id=0; /*(0,5,5)*/</span><br></pre></td></tr></table></figure>

<p>此时，id &#x3D; 0的这一行数据正确，但是新插入的id &#x3D; 1的问题还是没有解决。</p>
<p><strong>也就是说，即使把所有的记录都加上锁，还是阻止不了新插入的记录</strong>，这也是为什么要单独解决幻读。</p>
<h1 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h1><p>即使我们在一开始就锁住所有行，但是由于插入语句是在行的间隙进行的，所以InnoDB的解决办法是引入了间隙锁(Gap Lock)。比如开头的表，有6行数据，7个间隙。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414151304834.png" alt="image-20230414151304834" style="zoom:67%;" />

<p>这样，当你执行 select * from t where d&#x3D;5 for update的时候，就不止是给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。</p>
<p>间隙锁和间隙锁之间不冲突，两个事务可以在同一个间隙加间隙锁，与间隙锁冲突的是往间隙插入数据的操作。</p>
<p><strong>间隙锁和行锁合称next-key lock</strong>，每个next-key lock是前开后闭区间，</p>
<p>间隙锁只有在可重复读的隔离级别下才有。而且引入间隙锁会降低并发度，并且有可能造成死锁。</p>
<p>另外一种解决幻读的方式是采用读提交的隔离级别加binlog_format&#x3D;row。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>MySQL45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引</title>
    <url>/2023/03/31/MySQL/MySQL%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>索引的出现其实就是为了提高数据查询的效率。</p>
<h2 id="索引常见的模型"><a href="#索引常见的模型" class="headerlink" title="索引常见的模型"></a>索引常见的模型</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>适合等值查询，不适合范围查询。因为会出现哈希冲突，冲突后采用链地址法解决。就会导致发生冲突后要遍历整个链表。</p>
<h3 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h3><p>适合等值查询以及范围查询。有序数组在单值查询可以使用二分法快速查找，范围找到一个然后往左右遍历即可，但是它插入数据时要维护这个有序数组就比较麻烦，适合用于静态存储引擎。</p>
<h3 id="搜索树"><a href="#搜索树" class="headerlink" title="搜索树"></a>搜索树</h3><p>二叉搜索树的特点是：左边小，右边大（相对根节点）查找效率和二分一样，O(LogN)。但是为了保证这个效率，就需要保证它是平衡二叉树（考虑插入数据是正序或者倒序情况，会退化成链表），为了确保平衡，插入时间复杂度也是O(LogN)</p>
<p>多叉树：孩子节点从左到右依次递增。</p>
<p>二叉树搜索效率最高，但是往往采用多叉树，因为索引还要写入磁盘，意味着我们查询索引可能也要读取磁盘。考虑一种情况，100万数据量，那么二叉树高20，如果这些索引没有在内存当中，那么就需要去读取20个数据块。</p>
<p>每次从磁盘读取数据都是按照<strong>数据块</strong>来读取的，而不是仅仅查找那一条记录。而MySQL并不是一开始就把所有的索引都加载到内存当中，而是按需加载。MySQL有一个缓冲池，当需要访问索引时，会先在缓冲池中查看有没有，如果没有就从磁盘读取，然后写入缓冲池中。</p>
<p>N叉树的N一般是1200。考虑到树根的数据块总是在内存中，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。</p>
<h2 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h2><p>假如有如下表：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>k</th>
<th>name</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>1</td>
<td>null</td>
</tr>
<tr>
<td>200</td>
<td>2</td>
<td>null</td>
</tr>
<tr>
<td>300</td>
<td>3</td>
<td>null</td>
</tr>
<tr>
<td>500</td>
<td>5</td>
<td>null</td>
</tr>
<tr>
<td>600</td>
<td>6</td>
<td>null</td>
</tr>
</tbody></table>
<p>其中ID是主键，k上有索引。那么它的索引结构大致如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230331104745662.png" alt="image-20230331104745662"></p>
<p>在InnoDB中，索引类型分为主键索引和非主键索引。</p>
<p>主键索引的<strong>叶子节点存的是整行数据</strong>。在InnoDB里，主键索引也被称为<strong>聚簇索引</strong>（clustered index）。</p>
<p>非主键索引的<strong>叶子节点内容是主键的值</strong>。在InnoDB里，非主键索引也被称为<strong>二级索引</strong>（secondary index）。</p>
<p>其中，如果是按照主键索引查询，那么只会搜索上图的第一颗树，然后找到对应记录直接返回行数据即可。但是如果是按照k这个索引来查询，那么会现根据k索引查找到对应数据的主键，然后去第一颗树中查找对应的实际数据。</p>
<h2 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h2><p>索引的插入可能会导致数据的其他数据的移位，在极端情况下，如果要插入的索引页满了，那么就会导致页分裂。这个页分裂的过程就是B+树页分裂的过程。</p>
<p>最重要的一点，B+树的索引是建立在数据所在的数据页上的，而不是直接建立在数据。其实通过索引找到数据页后，还要在数据页中去找具体的数据，才能返回。</p>
<h2 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from T where k between 3 and 5</span><br></pre></td></tr></table></figure>

<p>首先在非主键索引树上找到k &#x3D; 3的值，取得ID &#x3D; 300，然后去主键索引树上查找ID &#x3D;  300所对应的具体值。然后在非主键索引树上找下一个值，k &#x3D; 5，找ID，然后拿ID去查主键索引。然后继续去下一个，发现k &#x3D; 6，大于5，查找结束。</p>
<p>这个从非主键索引查找完去主键索引查找的过程就叫做回表。</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ID from T where k between 3 and 5</span><br></pre></td></tr></table></figure>

<p>执行这个语句时，虽然会走非主键索引，但是索引的值存的是ID，即索引里面包含了所有要查询的数据，这就是覆盖索引。<strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p>
<h2 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h2><p>比如我们建立了一个（姓名，年龄）的索引，那么它可以用来匹配按名字的查找，但是按照年龄就不行。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p>
<h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>比如我们已经建立了（姓名，年龄），此时要执行以下SQL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from tuser where name like &#x27;张%&#x27; and age=10 and ismale=1;</span><br></pre></td></tr></table></figure>

<p>假如数据库表数据如下：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>name</th>
<th>age</th>
<th>ismale</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>李四</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>123</td>
<td>10</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>张三</td>
<td>10</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>张三</td>
<td>10</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>张三</td>
<td>30</td>
<td>1</td>
</tr>
<tr>
<td>6</td>
<td>张六</td>
<td>40</td>
<td>0</td>
</tr>
</tbody></table>
<p>在执行这条语句时，如果没有索引下推，则每次按索引找到姓张的后，都需要回表去查看对应的一整行数据，来判断后两个字段是否一致。但是有了索引下推，可以在这里直接判断age是否满足条件，可以减少回表的次数。注意，这里的索引是联合索引，如果没有下推，即便是索引里有age字段，也不会进行判断。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL45讲》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
        <category>索引</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>MySQL45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引失效的情况</title>
    <url>/2023/04/12/MySQL/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<h1 id="条件字段函数操作"><a href="#条件字段函数操作" class="headerlink" title="条件字段函数操作"></a>条件字段函数操作</h1><p>假如我们现在有如下需求，我们要统计一张表2021年和2022年8月份的记录，那么SQL语句可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select column_1, column_2 from table_1 where month(record_time) = 7;</span><br></pre></td></tr></table></figure>

<p>虽然数据库表在record_time上加了索引（结构图如下），但是这个sql还是会执行的特别慢。</p>
<img src="C:\Users\郭俊豪\AppData\Roaming\Typora\typora-user-images\image-20230412151341061.png" alt="image-20230412151341061" style="zoom:67%;" />

<p>因为在用month函数对record_time做计算后，得到的数字是记录的月份，而索引的值却并不是一个单独的数字，所以会导致它走全表扫描。</p>
<p>也就是说，<strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 无法使用id这个索引</span><br><span class="line">select * from table_1 where id + 1 = 1000 </span><br><span class="line"></span><br><span class="line">// 可以使用</span><br><span class="line">select * from table_1 where id = 1000 - 1</span><br></pre></td></tr></table></figure>

<h1 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h1><p>现在有如下例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from tradelog where id = 110717;</span><br></pre></td></tr></table></figure>

<p>其中，id是一个varchar类型的值，虽然它上面有索引，但还是走了全表扫描。这里就是因为id是varchar，而输入的值是数字，导致类型转换。</p>
<p>而发生转换要走全表索引的原因是转换相当于一个函数调用，上面语句相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from tradelog where CAST(id AS signed int) = 110717;</span><br></pre></td></tr></table></figure>

<p>而对索引字段使用函数会导致无法使用索引。</p>
<h1 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h1><p>假如有如下语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select d.* from tradelog l, trade_detail d where d.tradeid = l.tradeid and l.id = 2</span><br></pre></td></tr></table></figure>

<p>这是一个简单的连表操作，其中tradelog为驱动表，trade_detail为被驱动表，tradeid为关联字段。</p>
<p>但是使用explain却发现在tradelog上使用了索引，但是在trade_detail上却走了全表扫描。</p>
<p>这个语句的执行流程是，从驱动表中找到一行数据，然后去被驱动表查找对值一样的数据组成结果集，过程如下：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230412153535466.png" alt="image-20230412153535466" style="zoom: 67%;" />

<p>而这里走全表扫描的原因是发生了类型的转换。这里两个表的字段一个类型是utf8，另一个是utf8mb4，导致实际执行的sql相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from trade_detail  where CONVERT(traideid USING utf8mb4)=$L2.tradeid.value; </span><br></pre></td></tr></table></figure>

<p>CONVERT()函数，在这里的意思是把输入的字符串转成utf8mb4字符集。</p>
<p>而这里导致全表扫描的原因也是因为对索引字段加了函数操作。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL45讲》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
        <category>索引</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>MySQL45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL表空间回收</title>
    <url>/2023/04/06/MySQL/MySQL%E8%A1%A8%E7%A9%BA%E9%97%B4%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h1 id="数据删除流程"><a href="#数据删除流程" class="headerlink" title="数据删除流程"></a>数据删除流程</h1><p>假如现在有如下数据：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230406143630354.png" alt="image-20230406143630354"></p>
<p>假如此时我们要删除R4的数据，InnoDB引擎只会把R4这个记录标记为删除。如果之后需要再300和600之间插入数据，可能会复用这个位置。所以这时删除一条数据时空间不会变小。</p>
<p>如果我们删除一整个页的数据，那么这整个数据页都可以复用。</p>
<p>如果删除了一整张表，那么所有的数据页都会被标记为可用。</p>
<p>以上这三个删除都是针对delete命令。</p>
<p>也就是说，delete命令只会把对应的数据标记为可以复用，下次需要写对应位置的数据时，直接覆盖掉原来的数据，并没有真正的释放空间。如果这些位置没有被复用，就会造成空间的浪费。</p>
<p>不仅删除会导致这些空洞，插入数据也会。因为如果插入的数据不是按照索引有序的，就有可能导致页分裂。比如数据页A已经存满了，此时又有一条数据需要插入数据页A，此时会导致B+树页分裂，会多出一个数据页，但是数据页A和新数据页都不会存满数据。</p>
<h1 id="重建表"><a href="#重建表" class="headerlink" title="重建表"></a>重建表</h1><p>如果想要消除表里面的空洞，就需要重建表。即把数据按照有序的方式从表A插入到表B当中，然后利用表B替换掉表A。在这个过程中，表A不能有更新操作。</p>
<h2 id="Online-DDL"><a href="#Online-DDL" class="headerlink" title="Online DDL"></a>Online DDL</h2><p>在MySQL 5.6之前，重建表的逻辑和上面说的类似，但是5.6之后对此做了优化，大致过程如下：</p>
<p>先生成一个临时文件，然后遍历表A的数据，生成一颗B+树（这里生成的B+树就是顺序生成的），然后用一个日志（row log）记录在扫描A时一些其他操作对表A的修改。然后先将生成的B+树存入临时文件，再把日志操作用于临时文件，之后用临时文件替换表A。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL45讲》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
        <category>执行流程</category>
      </categories>
      <tags>
        <tag>MySQL45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL读写分离存在的问题</title>
    <url>/2023/04/23/MySQL/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在MySQL的一主多从的架构中，往往有以下两种设计方案：</p>
<p>1、由客户端决定连接哪个数据库</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230423105127688.png" alt="image-20230423105127688" style="zoom:67%;" />

<p>2、由代理决定请求分发到哪一个数据库</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230423105207833.png" alt="image-20230423105207833" style="zoom:67%;" />

<p>但不管是哪种方案，都存在过期读的问题，即主库和从库存在一定的时延，用户刚做一个修改，然后立马发起查询，就有可能查到过期数据。以下给出几种解决方案。</p>
<h1 id="强制走主库"><a href="#强制走主库" class="headerlink" title="强制走主库"></a>强制走主库</h1><p>该方案将请求分为了两类：</p>
<p>1、必须拿到最新数据的，就强制走主库查询。</p>
<p>2、对于可以读取到旧数据的，就走从库查询。</p>
<h1 id="Sleep-方案"><a href="#Sleep-方案" class="headerlink" title="Sleep 方案"></a>Sleep 方案</h1><p>该方案的设计很简单，读从库之前先sleep一段时间。</p>
<p>它假设大多情况下主备延迟在1秒之内，所以简单的sleep可以拿到最新的数据。</p>
<h1 id="判断主备无延迟方案"><a href="#判断主备无延迟方案" class="headerlink" title="判断主备无延迟方案"></a>判断主备无延迟方案</h1><p>这里有几种办法，第一种是从库查询前，先判断seconds_behind_master是否已经等于0。如果还不等于0 ，那就必须等到这个参数变为0才能执行查询请求。</p>
<p>第二种和第三种方案，都是通过对比主库和从库的日志执行位点来判断是否有延迟，即通过对比主库和从库执行的日志，来判断，要比对比时间准确。</p>
<p>但是这里也存在问题，主库存在一部分日志刚刚提交，而从库还没收到该日志，也会导致有一定的延迟。</p>
<h1 id="配合semi-sync"><a href="#配合semi-sync" class="headerlink" title="配合semi-sync"></a>配合semi-sync</h1><p>这里引入了半同步复制，semi-sync做了这样的设计：</p>
<ol>
<li>事务提交的时候，主库把binlog发给从库；</li>
<li>从库收到binlog以后，发回给主库一个ack，表示收到了；</li>
<li>主库收到这个ack以后，才能给客户端返回“事务完成”的确认。</li>
</ol>
<p>这样可以保证如果从库发送过确认消息，就代表收到了日志。这样，semi-sync配合前面关于位点的判断，就能够确定在从库上执行的查询请求，可以避免过期读。</p>
<p>但是该方案适合一主一从的架构，如果一主多从，那么一个从库响应，就默认已经同步成功，但是其他从库不确定。如果此时查询走的是其他从库，则还是会有问题。</p>
<p>而且存在一种情况，如果高峰期日志写的很快，可能会导致主库位点一直不一致的情况，就出现从库迟迟无法响应的问题。</p>
<h1 id="等主库位点方案"><a href="#等主库位点方案" class="headerlink" title="等主库位点方案"></a>等主库位点方案</h1><p>该方案涉及到以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select master_pos_wait(file, pos[, timeout]);</span><br></pre></td></tr></table></figure>

<p>该命令在从库执行，参数file和pos指向从库上的某个文件以及对应位置，timeout可选，表示这个函数最多的等待时间。</p>
<p>这个命令正常返回的结果是一个正整数M，表示从命令开始执行，到应用完file和pos表示的binlog位置，执行了多少事务。</p>
<p>那么我们的查询逻辑变为以下：</p>
<p>1、主库执行完事务后，执行show master status得到当前主库执行到的File和Position；</p>
<p>2、从库查询之间，先执行master_pos_wait（File，Position）</p>
<p>3、如果返回 &gt;&#x3D; 0的正整数，则在该从库执行查询，否则到主库查询。</p>
<h1 id="GTID方案"><a href="#GTID方案" class="headerlink" title="GTID方案"></a>GTID方案</h1><p>该方案和上述等主库位点方案思路一致，只不过是后续MySQL做了优化。</p>
<p>我们不再需要去主库执行show master status来获取位点，而是主库执行完后，直接返回一个事务的GTID，然后从库执行时，只需要在从库执行select wait_for_executed_gtid_set(gtid1, 1)，该命令也是用于等待主从同步的命令。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL45讲》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>MySQL45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>order by是怎么工作的</title>
    <url>/2023/04/10/MySQL/order%20by%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</url>
    <content><![CDATA[<p>假设我们现在有如下表，其中<strong>id是主键，city上有普通索引</strong>。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>city</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>杭州</td>
<td>张三</td>
<td>22</td>
</tr>
<tr>
<td>2</td>
<td>杭州</td>
<td>李四</td>
<td>23</td>
</tr>
<tr>
<td>3</td>
<td>郑州</td>
<td>王五</td>
<td>24</td>
</tr>
<tr>
<td>……</td>
<td>……</td>
<td>……</td>
<td>……</td>
</tr>
</tbody></table>
<p>现在需要查出city为杭州的人的性命和年龄，并按照年龄排序的前100个人。那么sql语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select city, name, age from t where city=&#x27;杭州&#x27; order by name limit 100;</span><br></pre></td></tr></table></figure>

<h1 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h1><p>先初始化sort_buffer，这是一块用于排序的内存，然后确定放入city，name，age三个字段。</p>
<p>之后，会在city索引树中找到值为杭州的记录，然后去主键索引取这一行的值存入sort_buffer，直到city不为杭州。</p>
<p>然后在sort_buffer中使用快排根据name字段进行排序，对排序结果取前100行返回给客户端。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230410155143209.png" alt="image-20230410155143209" style="zoom: 67%;" />

<p>其中，如果取出的数据量太大，无法存入sort_buffer，则需要利用磁盘临时文件辅助排序。</p>
<h1 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h1><p>上述情况可以把所有数据都放入sort_buffer中进行排序，但是如果不能全部放入，会把原来的文件分成多份，借助临时文件来进行归并排序。如果一行的数据量太大，则要分的份数太多，会影响性能。</p>
<p>MySQL提供了一个参数，max_length_for_sort_data用于限制排序的行数据的长度。比如我们设置它为16，如果sort_buffer在初始时确定放入字段的长度超过16，则会采用rowid排序。</p>
<p>现在的排序过程如下：</p>
<p>初始化sort_buffer，确定放入id和name字段（只放入排序相关的字段）。</p>
<p>这之后的步骤与上面的排序过程类似，不过在sort_buffer内排序完成后，需要根据id去主键上取city，name，age字段后，再返回给用户。相当于多了一次回表操作。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230410160554644.png" alt="image-20230410160554644" style="zoom:67%;" />

<h1 id="全字段排序和rowid排序"><a href="#全字段排序和rowid排序" class="headerlink" title="全字段排序和rowid排序"></a>全字段排序和rowid排序</h1><p>如果内存足够大，则会优先使用全字段排序，因为可以减少一次回表操作，否则会采用rowid排序。</p>
<p>这里也体现了MySQL的一个设计思想：能用内存就用，尽量减少磁盘访问。</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>上述SQL需要排序是因为数据是无序的，但是如果我们保证了从city索引中取出的数据就是按name有序的，就可以省略掉排序的过程。</p>
<p>所以我们可以建立一个联合索引 (city, name)，然后执行流程如下：</p>
<p>1、从联合索引中找到city为杭州的记录。</p>
<p>2、去主键索引取name、city、age三个字段的值，作为结果集的一部分直接返回。</p>
<p>3、一直重复上述步骤，直到city不为杭州或者够100条记录。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230410161831144.png" alt="image-20230410161831144" style="zoom:67%;" />

<p>这样，就不需要使用临时表了。</p>
<p>如果创建了（city，name，age）的联合索引，则还可以省去回表的操作，进一步优化查询时间。但是会导致索引占用空间过多。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL45讲》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
        <category>执行流程</category>
      </categories>
      <tags>
        <tag>MySQL45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>分库分表时如何保证id唯一</title>
    <url>/2023/04/27/MySQL/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%97%B6%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81id%E5%94%AF%E4%B8%80/</url>
    <content><![CDATA[<h1 id="主键如何选择"><a href="#主键如何选择" class="headerlink" title="主键如何选择"></a>主键如何选择</h1><p>1、使用业务字段作为主键，比如说对于用户表来说，可以使用手机号，email 或者身份证号作为主键。</p>
<p>2、使用生成的唯一 ID 作为主键。</p>
<p>但是第一种并不是每一张表都可以使用的，一些特殊的字段可以使用，比如说身份证，邮箱，手机号，但是这些字段可能存在变更的情况，就比较麻烦，所以最好采取第二种方案。</p>
<p>第二种方案在单表时，可以采用简单的自增id来实现，但是在分库分表的情况下却并不能这样，因为不同库和不同表的自增id会重复。我们需要采取一些其他的办法来实现。</p>
<h1 id="基于-Snowflake-算法搭建发号器"><a href="#基于-Snowflake-算法搭建发号器" class="headerlink" title="基于 Snowflake 算法搭建发号器"></a>基于 Snowflake 算法搭建发号器</h1><p>首先一点是，为什么不采用uuid来当作主键 ？</p>
<p>1、id最好是有序的，某些场景会需要排序，如果按照id则效率高一点，而且id有序分区也会简单。</p>
<p>2、id有序时，将其作为主键，插入数据时效率也会高，如果采用无序的插入，可能会频繁的导致页分裂。</p>
<p>3、uuid作为主键可能会占用大量的空间。</p>
<p>4、uuid并不具备业务含义。</p>
<h2 id="Snowflake-算法"><a href="#Snowflake-算法" class="headerlink" title="Snowflake 算法"></a>Snowflake 算法</h2><p>Snowflake 的核心思想是将 64bit 的二进制数字分成若干部分，每一部分都存储有特定含义的数据，比如说时间戳、机器 ID、序列号等等，最终生成全局唯一的有序 ID。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230427220731511.png" alt="image-20230427220731511"></p>
<p>其中机器ID可以用来标识在不同的机房，12位序列号代表着每个节点每毫秒最多可以生成 4096 的 ID。也可以根据不同的业务来规定每一部分的长度。</p>
<h2 id="具体实现方式"><a href="#具体实现方式" class="headerlink" title="具体实现方式"></a>具体实现方式</h2><p>1、<strong>嵌入到业务代码里，也就是分布在业务服务器中。</strong></p>
<p>这样实现的好处是不需要跨网络调用，性能会好一点。但是业务层的部署可能存在很多分，这就要求我们用更多的机器位，来确保唯一性。</p>
<p>2、<strong>作为独立的服务部署，这也就是我们常说的发号器服务。</strong></p>
<p>这种部署方式需要业务层多一次网络请求来获取id，但是可以减少机器id的位数，留更多的位数给自增信息位。</p>
<p>该算法的一个缺点是依赖于子系统的时间戳，一旦系统时间不准，就有可能生成重复的id。所以当我们发现系统时钟不准时，就可以让发号器拒绝发号，一直到时钟准为止。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《高并发系统设计 40 问》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>高并发系统设计</category>
        <category>数据库篇</category>
      </categories>
      <tags>
        <tag>分库分表</tag>
      </tags>
  </entry>
  <entry>
    <title>一条sql更新语句是如何执行的</title>
    <url>/2023/03/29/MySQL/%E4%B8%80%E6%9D%A1sql%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
    <content><![CDATA[<p>一条修改语句的过程也会涉及到查询语句的流程，不过它会额外涉及到两个日志操作，分别是redo log（重做日志）和 binlog（归档日志）。</p>
<h2 id="redo-log-重做日志"><a href="#redo-log-重做日志" class="headerlink" title="redo log(重做日志)"></a>redo log(重做日志)</h2><p>在MySQL中，如果每一次更新都要写进磁盘，而磁盘又需要找到对应记录的位置，然后再更新，整个过程I&#x2F;O成本，查找都很高，所以MySQL采用WAL技术，全称是Write-Ahead Logging，关键点就是先写日志，然后再写磁盘。</p>
<p>具体做法是，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候。</p>
<p>而InnoDB的redo log大小是固定的，可以进行配置，如果被写满，那么就会从头开始写。可以理解为一个循环队列，如下图所示：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230329094715314.png" alt="image-20230329094715314"></p>
<p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。write pos和checkpoint之间的位置就是空闲的，可以用来记录操作。如果write pos追上checkpoint，就表示写满了，需要清除一些记录，再继续写。</p>
<p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p>
<h2 id="binlog-归档日志"><a href="#binlog-归档日志" class="headerlink" title="binlog(归档日志)"></a>binlog(归档日志)</h2><p>上面提到的redo log是属于引擎层的日志，是InnoDB特有的。而binlog，则是Server层自己的日志。</p>
<h3 id="这两种日志的区别"><a href="#这两种日志的区别" class="headerlink" title="这两种日志的区别"></a>这两种日志的区别</h3><p>1、redo log记录的是对某一个数据页所做的修改，它主要目的是防止数据库宕机重启后有部分修改没来得及同步到磁盘，可以去redo log中查找然后写入磁盘（因为修改数据时采用先写日志，然后修改内存，并不会立即去修改磁盘中的数据）。最简单的说法，他其实是为了保证数据库数据的持久性与完整性。</p>
<p>而binlog则记录了所有对数据库所作的修改，最简单理解就是记录了sql语句，以及对应语句的反向，比如执行delete操作，它不仅会记录这个delete，还会生成对应的insert语句，我们可以用它来将数据恢复到之前的某一时刻。其实就是数据库备份，主备，主主，主从都需要依赖binlog。</p>
<p>2、redo log 是循环写，而binlog是追加写（不会覆盖之前的）。</p>
<p>3、redo log是InnoDB特有的，binlog是MySQL的Server层实现的。</p>
<h2 id="执行一条update语句的流程"><a href="#执行一条update语句的流程" class="headerlink" title="执行一条update语句的流程"></a>执行一条update语句的流程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure>

<p>1、执行器会先找ID&#x3D;2这一行，该数据页本来就在内存当中，就直接返回给执行器，否则先从磁盘读入内存，再返回。</p>
<p>2、执行器拿到行数据，进行修改，然后调用引擎接口写入这行数据。</p>
<p>3、引擎将新输入的数据写入内存，同时将操作更新到redo log，此时redo log 处于prepare转来。然后告知执行器执行完了，随时可以提交事务。</p>
<p>4、执行器生成这个binlog操作，并把binlog写入磁盘。</p>
<p>5、执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交状态。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230329150131900.png" alt="image-20230329150131900"></p>
<p>最后三步，将redo log的写入拆成了两个步骤：prepare和commit，这就是”两阶段提交”。</p>
<h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure>

<p>仍然采用这个例子，假设在执行语句前，c 的值是0。如果我们不采用两阶段提交，先写redo log，然后binlog 或者先写binlog，然后再写redo log。</p>
<p>两阶段提交主要是为了保证两个日志的数据一致性。</p>
<h3 id="先写redo-log后写binlog"><a href="#先写redo-log后写binlog" class="headerlink" title="先写redo log后写binlog"></a>先写redo log后写binlog</h3><p>假设在redo log写完，binlog 还没写完，MySQL异常重启，这时重启之后，我们可以根据redo log把数据库的值恢复到1，但是binlog没写完就崩溃了，所以没有这条记录，如果用binlog进行恢复，那么值就是0。</p>
<h3 id="先写binlog后写redo-log"><a href="#先写binlog后写redo-log" class="headerlink" title="先写binlog后写redo log"></a>先写binlog后写redo log</h3><p>如果binlog写完然后崩溃，但是redo log没写，所以崩溃恢复后的值还是0，但是binlog里面已经记录了把0改为1这条操作，导致数据不一致。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL45讲》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
        <category>日志</category>
      </categories>
      <tags>
        <tag>MySQL45讲</tag>
        <tag>redo log</tag>
      </tags>
  </entry>
  <entry>
    <title>一条sql查询语句是如何执行的</title>
    <url>/2023/03/28/MySQL/%E4%B8%80%E6%9D%A1sql%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
    <content><![CDATA[<h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>Mysql的架构图如下所示：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230328110656604.png" alt="image-20230328110656604"></p>
<p>上图架构中的查询缓存，在myssql8.0及其以上版本已经被移除。</p>
<p>MySQL可以分为<strong>Server层</strong>和<strong>存储引擎层</strong>两部分。</p>
<p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。</p>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>连接器是负责客户端和MySQL进行连接的，在连接器这里会验证用户输入的账号和密码，以及对应的权限。</p>
<p>连接完成后，如果客户端太长时间没有动静，连接器就会将它断开。这个时间由wait_timeout控制，默认8小时。</p>
<p>数据库里面，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>这一步的主要工作就是检查sql语法是否正确。首先是词法分析，然后是语法分析。这一步也会检查这条sql的目的是什么。一般的语法错误，比如找不到一个字段，找不到某张表，都是这个阶段检测出来的。</p>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>执行阶段会先判断是否有权限，如果没有，则会返回错误。</p>
<p>比如下面的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from T where ID=10;</span><br></pre></td></tr></table></figure>

<p>如果id字段没有索引，那么大概的流程是下面的样子：</p>
<ol>
<li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li>
<li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li>
<li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL45讲》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
        <category>执行流程</category>
      </categories>
      <tags>
        <tag>MySQL45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>池化技术</title>
    <url>/2023/04/26/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<p>在后端代码操作MySQL时，需要先与MySQL建立连接， 这个连接需要使用TCP的三次握手，比较的耗时，如果在正常的系统中，每一次执行sql，都要建立连接，连接使用完毕后断开连接，那么就会带来严重的性能影响。因此，池化技术就这样诞生了。</p>
<h1 id="连接池基本配置"><a href="#连接池基本配置" class="headerlink" title="连接池基本配置"></a>连接池基本配置</h1><p>MySQL连接池有两个重要配置，<strong>最小连接数</strong>和<strong>最大连接数</strong>。</p>
<p>如果连接池中有空闲的连接，则直接使用这些已经建立好的连接，如果已有的连接数超过最小连接数，但是没有超过最大连接数，来了新的连接请求，则创建新的连接处理请求。如果当前连接数大于等于最大连接数，则让新的请求排队，如果超时则抛出错误。</p>
<p>还有一种情况是，当前连接池中的连接数小于最小连接数，那么新到的连接请求会直接创建新的连接，而不会使用池子中的连接。</p>
<p>针对于连接池中的连接，我们可以启动一个线程定期检测连接池是否可用，如果不可用就关闭该连接。</p>
<h1 id="用线程池预先创建线程"><a href="#用线程池预先创建线程" class="headerlink" title="用线程池预先创建线程"></a>用线程池预先创建线程</h1><p>jdk1.5中就提供了池化技术。ThreadPoolExecutor 就是其中的一种，它有两个参数coreThreadCount 和 maxThreadCount。</p>
<ul>
<li><p>如果线程池中的线程数少于 coreThreadCount 时，处理新的任务时会创建新的线程；</p>
</li>
<li><p>如果线程数大于 coreThreadCount 则把任务丢到一个队列里面，由当前空闲的线程执行；</p>
</li>
<li><p>当队列中的任务堆积满了的时候，则继续创建线程，直到达到 maxThreadCount；</p>
</li>
<li><p>当线程数达到 maxTheadCount 时还有新的任务提交，那么我们就不得不将它们丢弃了。</p>
</li>
</ul>
<p>流程如下图：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230426152317089.png" alt="image-20230426152317089" style="zoom:67%;" />

<p>注意：JDK原生的线程池会优先把任务放进队列，而不是优先创建线程，这种就比较适合CPU密集型的任务。</p>
<p>因为CPU密集型的任务，如果创建过多的线程去执行任务，那么这些任务会争抢线程，导致频繁的上下文切换，造成性能的损失。</p>
<p>但是我们平时开发的web项目，其实属于I&#x2F;O密集型的任务，因为牵扯到数据库，所以Tomcat就没有采用JDK自带的，而是做了改进，优先创建线程去处理请求。因为I&#x2F;O密集型的大多时间都花费在去磁盘取数据，这段时间并不需要CPU，所以可以创建更多的线程去处理请求。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《高并发系统设计 40 问》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>高并发系统设计</category>
        <category>数据库篇</category>
      </categories>
      <tags>
        <tag>连接池</tag>
      </tags>
  </entry>
  <entry>
    <title>CountDownLatch和CyclicBarrier：如何让多线程步调一致</title>
    <url>/2023/05/14/Java/CountDownLatch%E5%92%8CCyclicBarrier%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%A9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%A5%E8%B0%83%E4%B8%80%E8%87%B4/</url>
    <content><![CDATA[<p> 假如我们要实现一下功能：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514190414839.png" alt="image-20230514190414839" style="zoom:67%;" />

<p>如果单线程处理，那么执行图如下：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514190537547.png" alt="image-20230514190537547" style="zoom:67%;" />

<p>如果想要优化，则可以将获取order的操作并行执行，如下图：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514190619676.png" alt="image-20230514190619676" style="zoom:67%;" />

<p>大致的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (存在未对账订单) &#123;</span><br><span class="line">    <span class="comment">// 查询未对账订单</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">T1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        pos = getPOrders();</span><br><span class="line">    &#125;);</span><br><span class="line">    T1.start();</span><br><span class="line">    <span class="comment">// 查询派送单</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">T2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        dos = getDOrders();</span><br><span class="line">    &#125;);</span><br><span class="line">    T2.start();</span><br><span class="line">    <span class="comment">// 等待T1、T2结束</span></span><br><span class="line">    T1.join();</span><br><span class="line">    T2.join();</span><br><span class="line">    <span class="comment">// 执行对账操作</span></span><br><span class="line">    diff = check(pos, dos);</span><br><span class="line">    <span class="comment">// 差异写入差异库</span></span><br><span class="line">    save(diff);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>但是这样写有一个缺点，就是while循环每次都要创建线程，而创建线程开销又比较的大，所以我们可以用线程池有优化。</p>
<h1 id="用-CountDownLatch-实现线程等待"><a href="#用-CountDownLatch-实现线程等待" class="headerlink" title="用 CountDownLatch 实现线程等待"></a>用 CountDownLatch 实现线程等待</h1><p>因为没有手动创建线程，所以没有join方法，那么如何通知主线程两个子线程已经执行完成了呢？我们可以使用<strong>CountDownLatch</strong></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建2个线程的线程池</span></span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span> (存在未对账订单) &#123;</span><br><span class="line">    <span class="comment">// 计数器初始化为2</span></span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 查询未对账订单</span></span><br><span class="line">    executor.execute(()-&gt; &#123;</span><br><span class="line">        pos = getPOrders();</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 查询派送单</span></span><br><span class="line">    executor.execute(()-&gt; &#123;</span><br><span class="line">        dos = getDOrders();</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待两个查询操作结束</span></span><br><span class="line">    latch.await();</span><br><span class="line">    <span class="comment">// 执行对账操作</span></span><br><span class="line">    diff = check(pos, dos);</span><br><span class="line">    <span class="comment">// 差异写入差异库</span></span><br><span class="line">    save(diff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h1><p>在查询完第一次后进行对比时，可以进行第二次查询，如下图：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514191455335.png" alt="image-20230514191455335" style="zoom:67%;" />

<p>这里有点生产者-消费者的意思了，查询 可以当作生产者，查询玩的计算可以当作消费者。既然是生产者 - 消费者模型，那就需要有个队列，来保存生产者生产的数据，而消费者则从这个队列消费数据。</p>
<p>我们可以用两个队列，一个存储查询订单，一个存储派送订单，然后两个线程，当每个线程都查询一条数据时，通知第三个线程去执行计算。但是这样需要保证查询线程速度一样。</p>
<h2 id="用-CyclicBarrier-实现线程同步"><a href="#用-CyclicBarrier-实现线程同步" class="headerlink" title="用 CyclicBarrier 实现线程同步"></a>用 CyclicBarrier 实现线程同步</h2><p>线程 T1 负责查询订单，当查出一条时，调用 barrier.await() 来将计数器减 1，同时等待计数器变成 0；线程 T2 负责查询派送单，当查出一条时，也调用 barrier.await() 来将计数器减 1，同时等待计数器变成 0；当 T1 和 T2 都调用 barrier.await() 的时候，计数器会减到 0，此时 T1 和 T2 就可以执行下一条语句了，同时会调用 barrier 的回调函数来执行对账操作。</p>
<p>CyclicBarrier 的计数器有自动重置的功能，当减到 0 的时候，会自动重置你设置的初始值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订单队列</span></span><br><span class="line">Vector&lt;P&gt; pos;</span><br><span class="line"><span class="comment">// 派送单队列</span></span><br><span class="line">Vector&lt;D&gt; dos;</span><br><span class="line"><span class="comment">// 执行回调的线程池， 这里好像必须为1</span></span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 计数器的值为2</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>, ()-&gt;&#123;</span><br><span class="line">    executor.execute(()-&gt;check());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断时，将队列中的元素移除</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">P</span> <span class="variable">p</span> <span class="operator">=</span> pos.remove(<span class="number">0</span>);</span><br><span class="line">    <span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> dos.remove(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 执行对账操作</span></span><br><span class="line">    diff = check(p, d);</span><br><span class="line">    <span class="comment">// 差异写入差异库</span></span><br><span class="line">    save(diff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">checkAll</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 循环查询订单库</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">T1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(存在未对账订单)&#123;</span><br><span class="line">            <span class="comment">// 查询订单库</span></span><br><span class="line">            pos.add(getPOrders());</span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    T1.start();  </span><br><span class="line">    <span class="comment">// 循环查询运单库</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">T2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(存在未对账订单)&#123;</span><br><span class="line">            <span class="comment">// 查询运单库</span></span><br><span class="line">            dos.add(getDOrders());</span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    T2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>CountDownLatch 主要用来解决一个线程等待多个线程的场景</strong></p>
<p><strong>CyclicBarrier 是一组线程之间互相等待</strong></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Java并发编程实战》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Copy-on-Write模式</title>
    <url>/2023/05/22/Java/Copy-on-Write/</url>
    <content><![CDATA[<p>Copy-on-Write顾名思义就是<strong>写时复制</strong>。比如String的replace()方法就采用了写时复制，即不修改原字符串，而是创建了一个新的，对于不可变对象的写操作往往都是Copy-on-Write方法解决的。</p>
<h1 id="Copy-on-Write-模式的应用领域"><a href="#Copy-on-Write-模式的应用领域" class="headerlink" title="Copy-on-Write 模式的应用领域"></a>Copy-on-Write 模式的应用领域</h1><p>类 Unix 的操作系统中创建进程的 API 是 fork()，传统的 fork() 函数会创建父进程的一个完整副本，例如父进程的地址空间现在用到了 1G 的内存，那么 fork() 子进程的时候要复制父进程整个进程的地址空间（占有 1G 内存）给子进程，这是比较耗时的。</p>
<p>而 Linux 中 fork() 子进程的时候，并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间；只用在<strong>父进程或者子进程需要写入</strong>的时候才会复制地址空间，从而使父子进程拥有各自的地址空间。</p>
<p>本质上来讲，父子进程的地址空间以及数据都是要隔离的，使用 Copy-on-Write 更多地体现的是一种<strong>延时策略，只有在真正需要复制的时候才复制，而不是提前复制好</strong>，同时 Copy-on-Write 还支持按需复制。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码</title>
    <url>/2023/10/14/Java/HashMap%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h1 id="HashMap源码"><a href="#HashMap源码" class="headerlink" title="HashMap源码"></a>HashMap源码</h1><h2 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    HashMap.Node e;</span><br><span class="line">    <span class="keyword">return</span> (e = <span class="built_in">this</span>.getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> HashMap.Node&lt;K, V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    HashMap.Node[] tab;</span><br><span class="line">    HashMap.Node first;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 这里，先把tab指向了整个类的table，也就是先获取目前存储的所有元素</span></span><br><span class="line">    <span class="comment">// 同时判断是否为空，长度是否大于0，并初始化first的值，n - 1 &amp; hash是为了保证hash值有效</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = <span class="built_in">this</span>.table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (first = tab[n - <span class="number">1</span> &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">// 这里是为了判断是否存在hash冲突，如果hash值相等，并且key也相当，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; ((k = first.key) == key || key != <span class="literal">null</span> &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap.Node e;</span><br><span class="line">        <span class="comment">// 这里是判断冲突后，是否还存在下一个元素</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断此时的结构是否为红黑树，如果是，则遍历红黑树找节点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> HashMap.TreeNode) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((HashMap.TreeNode)first).getTreeNode(hash, key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不是红黑树，那么就是一个链表，直接遍历链表到结尾，找对应元素即可。</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key != <span class="literal">null</span> &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span>((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="getTreeNode"><a href="#getTreeNode" class="headerlink" title="getTreeNode"></a>getTreeNode</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap.TreeNode&lt;K, V&gt; <span class="title function_">getTreeNode</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span> ? <span class="built_in">this</span>.root() : <span class="built_in">this</span>).find(h, k, (Class)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> HashMap.TreeNode&lt;K, V&gt; <span class="title function_">find</span><span class="params">(<span class="type">int</span> h, Object k, Class&lt;?&gt; kc)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先获取到该节点的整个红黑树</span></span><br><span class="line">    HashMap.<span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        HashMap.TreeNode&lt;K, V&gt; pl = p.left;</span><br><span class="line">        HashMap.TreeNode&lt;K, V&gt; pr = p.right;</span><br><span class="line">        <span class="type">int</span> ph;</span><br><span class="line">        <span class="comment">// 首先，是因为发生hash冲突后，才会用这个红黑树来解决hash冲突，那么该树中节点的hash值不是应该全部相等吗？</span></span><br><span class="line">        <span class="comment">// 应该是没有看生成代码的原因，转变为红黑树后，应该要做一次reHash，那么他们就会有新的hash值来用于构建红黑树</span></span><br><span class="line">        <span class="comment">// 这里，就是获取到左子树和右子树的hash值，然后与传入的值进行比较，一直找到相等的</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h) &#123;</span><br><span class="line">            p = pl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) &#123;</span><br><span class="line">            p = pr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里是找到了Hash值相等的</span></span><br><span class="line">            Object pk;</span><br><span class="line">            <span class="comment">// 先判断key值是否相等，如果相等则返回</span></span><br><span class="line">            <span class="keyword">if</span> ((pk = p.key) == k || k != <span class="literal">null</span> &amp;&amp; k.equals(pk)) &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里是仍然有冲突，那么就看该节点的左右子树</span></span><br><span class="line">            <span class="keyword">if</span> (pl == <span class="literal">null</span>) &#123;</span><br><span class="line">                p = pr;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="literal">null</span>) &#123;</span><br><span class="line">                p = pl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 这里是左右子树都不为空</span></span><br><span class="line">                <span class="type">int</span> dir;</span><br><span class="line">                <span class="comment">// 这里由于没有传入比较器，所以不会走if，只会走else</span></span><br><span class="line">                <span class="keyword">if</span> ((kc != <span class="literal">null</span> || (kc = HashMap.comparableClassFor(k)) != <span class="literal">null</span>) &amp;&amp; (dir = HashMap.compareComparables(kc, k, pk)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    p = dir &lt; <span class="number">0</span> ? pl : pr;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 这里是左右子树都不为空，则递归的进行搜索即可</span></span><br><span class="line">                    HashMap.TreeNode q;</span><br><span class="line">                    <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    p = pl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(p != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>个人心得</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>临时表为什么可以重名</title>
    <url>/2023/04/24/MySQL/%E4%B8%B4%E6%97%B6%E8%A1%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%8D/</url>
    <content><![CDATA[<p> 临时表的一些特性：</p>
<p>1、创建语法：create temporary table</p>
<p>2、只有创建该表的session才可以访问，其他线程无法访问</p>
<p>3、临时表可以与普通表重名</p>
<p>4、session中有同名的临时表和普通表时，操作的都是临时表</p>
<h1 id="临时表应用"><a href="#临时表应用" class="headerlink" title="临时表应用"></a>临时表应用</h1><p>在分库分表的场景下，我们现在假设某一个大表ht 按照字段f分为了1024个表，分布在32个数据库上。如下图所示：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424170242139.png" alt="image-20230424170242139" style="zoom: 50%;" />

<p>这种设计下，如果我们执行如下sql：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select v from ht where f = N;</span><br></pre></td></tr></table></figure>

<p>因为该sql使用了分表的字段f，那么我们就可以直接找到数据所在的表。</p>
<p>但是如果是如下sql：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select v from ht where k &gt;= M order by t_modified desc limit 100;</span><br></pre></td></tr></table></figure>

<p>该sql没有使用到分表的字段f，那么只能到所有的分区中去查找满足条件的所有行，然后统一做order by 的操作。</p>
<p>这种情况下，有两种方法：</p>
<p>1、把所有的数据全部查到，然后交给代理层去做排序。这种方法的优点是MySQL查询会很快，但是需要代理层多做额外的处理。</p>
<p>2、把各个分库拿到的数据，汇总到一个MySQL实例的一个表中，然后在这个汇总实例上做逻辑操作。流程如下图：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424171857340.png" alt="image-20230424171857340" style="zoom:67%;" />

<h1 id="为什么临时表可以重名？"><a href="#为什么临时表可以重名？" class="headerlink" title="为什么临时表可以重名？"></a>为什么临时表可以重名？</h1><p>MySQL维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个table_def_key。</p>
<ul>
<li>一个普通表的table_def_key的值是由“库名+表名”得到的，所以如果你要在同一个库下创建两个同名的普通表，创建第二个表的过程中就会发现table_def_key已经存在了。</li>
<li>而对于临时表，table_def_key在“库名+表名”基础上，又加入了“server_id+thread_id”。</li>
</ul>
<p>也就是说，session A和sessionB创建的两个临时表t1，它们的table_def_key不同，磁盘文件名也不同，因此可以并存。</p>
<p>在实现上，每个线程都维护了自己的临时表链表。这样每次session内操作表的时候，先遍历链表，检查是否有这个名字的临时表，如果有就优先操作临时表，如果没有再操作普通表；在session结束的时候，对链表里的每个临时表，执行 “DROP TEMPORARY TABLE +表名”操作。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>MySQL</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>MySQL45讲</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2023/06/25/Java/HashMap/</url>
    <content><![CDATA[<h1 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h1><p>下面是jdk8中的hash方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的作用：<strong>将 key 的 hashCode 值进行处理，得到最终的哈希值</strong>。</p>
<p>如下操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>其中put的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hash-方法的作用"><a href="#hash-方法的作用" class="headerlink" title="hash 方法的作用"></a>hash 方法的作用</h2><p>HashMap 的底层是通过数组的形式实现的，初始大小是 16，在添加第一个元素的时候，需要通过键的哈希码在大小为 16 的数组中确定一个位置，而确定位置的具体计算方法为 <strong>(n - 1) &amp; hash</strong>，其中变量 n 为数组的长度，变量 hash 就是通过 <code>hash()</code> 方法计算后的结果。</p>
<p>而 <strong>(n - 1) &amp; hash</strong> 这个操作是为了去摸运算，不用%来是为了优化算法，减少碰撞概率。</p>
<h1 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h1><p>HashMap 的扩容是通过 resize 方法来实现的，JDK 8 中融入了红黑树（链表长度超过 8 的时候，会将链表转化为红黑树来提高查询效率）。</p>
<h2 id="jdk7的扩容"><a href="#jdk7的扩容" class="headerlink" title="jdk7的扩容"></a>jdk7的扩容</h2><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// newCapacity为新的容量</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 小数组，临时过度下</span></span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="comment">// 扩容前的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="comment">// MAXIMUM_CAPACITY 为最大容量，2 的 30 次方 = 1&lt;&lt;30</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        <span class="comment">// 容量调整为 Integer 的最大值 0x7fffffff（十六进制）=2 的 31 次方-1</span></span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个新的数组（大容量）</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">    <span class="comment">// 把小数组的元素转移到大数组中</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    <span class="comment">// 引用新的大数组</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="comment">// 重新计算阈值</span></span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法接收一个新的容量 newCapacity，然后将 HashMap 的容量扩大到 newCapacity。</p>
<p>首先，方法获取当前 HashMap 的旧数组 oldTable 和旧容量 oldCapacity。</p>
<p>接着，方法创建一个新的数组 newTable，并将旧数组 oldTable 中的元素转移到新数组 newTable 中。转移过程是通过调用 transfer 方法来实现的。该方法遍历旧数组中的每个桶，并将每个桶中的键值对重新计算哈希值后，将其插入到新数组对应的桶中。</p>
<p>转移完成后，方法将 HashMap 内部的数组引用 table 指向新数组 newTable，并重新计算阈值 threshold。</p>
<p>transfer 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="comment">// 新的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="comment">// 遍历小数组</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            <span class="comment">// 拉链法，相同 key 上的不同值</span></span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 是否需要重新计算 hash</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据大数组的容量，和键的 hash 计算元素在数组中的下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">// 同一位置上的新元素被放在链表的头部</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            <span class="comment">// 放在新的数组上</span></span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            <span class="comment">// 链表上的下一个元素</span></span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法接受一个新的 Entry 数组 newTable 和一个布尔值 rehash 作为参数，其中 newTable 表示新的哈希表，rehash 表示是否需要重新计算键的哈希值。</p>
<p>在方法中，首先获取新哈希表（数组）的长度 newCapacity，然后遍历旧哈希表中的每个 Entry。对于每个 Entry，使用拉链法将相同 key 值的不同 value 值存储在同一个链表中。如果 rehash 为 true，则需要重新计算键的哈希值，并将新的哈希值存储在 Entry 的 hash 属性中。</p>
<p>接着，根据新哈希表的长度和键的哈希值，计算 Entry 在新数组中的位置 i，然后将该 Entry 添加到新数组的 i 位置上。由于新元素需要被放在链表的头部，因此将新元素的下一个元素设置为当前数组位置上的元素。</p>
<p>注意，<code>e.next = newTable[i]</code>，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素最终会被放到链表的尾部，这就会导致<strong>在旧数组中同一个链表上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上</strong>。</p>
<h2 id="Java-8-扩容"><a href="#Java-8-扩容" class="headerlink" title="Java 8 扩容"></a>Java 8 扩容</h2><p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table; <span class="comment">// 获取原来的数组 table</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">// 获取数组长度 oldCap</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold; <span class="comment">// 获取阈值 oldThr</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果原来的数组 table 不为空</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的 resize 上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; <span class="comment">// 将新阈值赋值给成员变量 threshold</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap]; <span class="comment">// 创建新数组 newTab</span></span><br><span class="line">    table = newTab; <span class="comment">// 将新数组 newTab 赋值给成员变量 table</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123; <span class="comment">// 如果旧数组 oldTab 不为空</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123; <span class="comment">// 遍历旧数组的每个元素</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123; <span class="comment">// 如果该元素不为空</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>; <span class="comment">// 将旧数组中该位置的元素置为 null，以便垃圾回收</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>) <span class="comment">// 如果该元素没有冲突</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">// 直接将该元素放入新数组</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果该元素是树节点</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap); <span class="comment">// 将该树节点分裂成两个链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 如果该元素是链表</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>; <span class="comment">// 低位链表的头结点和尾结点</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>; <span class="comment">// 高位链表的头结点和尾结点</span></span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123; <span class="comment">// 遍历该链表</span></span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">// 如果该元素在低位链表中</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>) <span class="comment">// 如果低位链表还没有结点</span></span><br><span class="line">                                loHead = e; <span class="comment">// 将该元素作为低位链表的头结点</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e; <span class="comment">// 如果低位链表已经有结点，将该元素加入低位链表的尾部</span></span><br><span class="line">                            loTail = e; <span class="comment">// 更新低位链表的尾结点</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123; <span class="comment">// 如果该元素在高位链表中</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>) <span class="comment">// 如果高位链表还没有结点</span></span><br><span class="line">                                hiHead = e; <span class="comment">// 将该元素作为高位链表的头结点</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e; <span class="comment">// 如果高位链表已经有结点，将该元素加入高位链表的尾部</span></span><br><span class="line">                            hiTail = e; <span class="comment">// 更新高位链表的尾结点</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>); <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123; <span class="comment">// 如果低位链表不为空</span></span><br><span class="line">                        loTail.next = <span class="literal">null</span>; <span class="comment">// 将低位链表的尾结点指向 null，以便垃圾回收</span></span><br><span class="line">                        newTab[j] = loHead; <span class="comment">// 将低位链表作为新数组对应位置的元素</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123; <span class="comment">// 如果高位链表不为空</span></span><br><span class="line">                        hiTail.next = <span class="literal">null</span>; <span class="comment">// 将高位链表的尾结点指向 null，以便垃圾回收</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead; <span class="comment">// 将高位链表作为新数组对应位置的元素</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab; <span class="comment">// 返回新数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、获取原来的数组 table、数组长度 oldCap 和阈值 oldThr。</p>
<p>2、如果原来的数组 table 不为空，则根据扩容规则计算新数组长度 newCap 和新阈值 newThr，然后将原数组中的元素复制到新数组中。</p>
<p>3、如果原来的数组 table 为空但阈值 oldThr 不为零，则说明是通过带参数构造函数创建的 HashMap，此时将阈值作为新数组长度 newCap。</p>
<p>4、如果原来的数组 table 和阈值 oldThr 都为零，则说明是通过无参数构造函数创建的 HashMap，此时将默认初始容量 DEFAULT_INITIAL_CAPACITY（16）和默认负载因子 DEFAULT_LOAD_FACTOR（0.75）计算出新数组长度 newCap 和新阈值 newThr。</p>
<p>5、计算新阈值 threshold，并将其赋值给成员变量 threshold。</p>
<p>6、创建新数组 newTab，并将其赋值给成员变量 table。</p>
<p>7、如果旧数组 oldTab 不为空，则遍历旧数组的每个元素，将其复制到新数组中。</p>
<p>8、返回新数组 newTab。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>集合</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>HotSpot的实现细节</title>
    <url>/2023/04/06/Java/HotSpot%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<h1 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h1><p>目前为止，所有收集器在根节点枚举这一步都必须暂停用户线程。</p>
<p>目前可达性分析算法耗时最长的查找引用链的过程可以与用户线程一起并发，但根节点枚举需要在一个类似于一致性快照才可以进行，这里一致性是指，整个枚举根节点的过程，子系统就像被冻结在某个点，这个过程中对象间的引用关系是不能发生变化的，否则分析的结果没有意义。</p>
<p>在暂停用户线程时，虚拟机使用了一组称为OopMap的数据结构来避免遍历所有的<strong>执行上下文</strong>和<strong>全局引用</strong>的位置。一旦类加载完成时，HotSpot就会把对象内每个偏移量上是什么类型的数据计算出来，也会在特定位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得到这些信息，就不用遍历了。</p>
<h1 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h1><p>上面提到使用OopMap来避免进行遍历所有的引用，但是导致OopMap进行变化的指令特别多，如果为每一条指令都生成OopMap，那么将耗费大量的内存空间。</p>
<p>实际上，HotSpot并没有为每一条都指令都生成对应的OopMap，而是在特定的位置记录了这些信息，这个特定的位置就是安全点。这也就意味着用户代码并不是在任何时候都可以暂停，然后进行垃圾回收，而是必须到达安全点才可以暂停。</p>
<p>安全点还需要考虑如何在垃圾收集发生时让所有线程（这里其实不包括执行JNI调用的线程）都跑到最近的安全点，然后停顿下来。这里有两种方案可供选择：<strong>抢先式中断</strong>（Preemptive Suspension）和<strong>主动式中断</strong>（Voluntary Suspension）</p>
<p>抢先式中断在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。几乎没有虚拟机使用。</p>
<p>主动式中断的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。</p>
<h1 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h1><p>上面的安全点保证了正在执行的代码每隔一段时间都会遇到一个可以进行垃圾回收的点，但是对于那些没在运行的程序，就需要另外考虑。比如用户线程处于sleep状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全点去中断挂起自己，这时候就需要引入安全区域。</p>
<p>安全区域能够保证在一段代码内，引用关系不会发生变化，因此在这段区域内任何地方进行垃圾回收都是安全的。</p>
<p>当用户线程执行到安全区域时，会标识自己已经进入，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</p>
<h1 id="记忆收集卡"><a href="#记忆收集卡" class="headerlink" title="记忆收集卡"></a>记忆收集卡</h1><p>记忆集是一种用于记录从<strong>非收集区域指</strong>向<strong>收集区域</strong>的指针集合的抽象数据结构。存储在新生代当中。</p>
<p>有了记忆集之后，在进行垃圾收集时，收集器只需要通过记忆集判断出某一块非收集区域是否有指向目前正在收集区域的指针就可以了。</p>
<p>一种最常用的实现记忆集的方式是卡表，卡表的每个记录精确到一块内存区域，该区域内有对象含有的跨代指针。</p>
<p>一个具体的卡表结构如下：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230313203352373.png" alt="image-20230313203352373" style="zoom:50%;" />

<p>字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“卡页”（Card Page）。</p>
<p>一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着<strong>跨代指针</strong>，那就将对应卡表的数组元素的值标识为1，称为这个<strong>元素变脏（Dirty）</strong>，没有则标识为0。在垃圾收集发生时，<strong>只要筛选出卡表中变脏的元素</strong>，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。</p>
<h1 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h1><p>在有其他分代区域中的对象引用了本区域的对象时，卡表需要变脏，变脏的时间点原则上在发生引用类型字段赋值的那一刻。但是如何在赋值的那一刻更新维护卡表呢？如果是解释执行的字节码，好处理一点，因为虚拟机负责每条字节码指令的执行。但是在经过即时编译的代码已经是纯粹的机器指令，虚拟机无法处理。</p>
<p>在HotSpot虚拟机中是通过<strong>写屏障</strong>维护卡表状态的。写屏障可以看作在虚拟机层面对引用类型字段赋值这个动作的AOP切面，在引用对象赋值时会产生一个环形通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。在赋值前的屏障叫做写前屏障，赋值后的屏障叫做写后屏障。</p>
<p>卡表在高并发场景下还面临着<strong>伪共享的问题</strong>。伪共享是处理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题。</p>
<p>为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏。</p>
<h1 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入理解Java虚拟机》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>Jvm</tag>
        <tag>深入理解Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>HotSpot虚拟机中的对象</title>
    <url>/2023/04/01/Java/HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>本文所涉及的内容都是基于HostSpot虚拟机而言的。</p>
<h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h1><p>一个对象的创建（这里不包括数组和Class对象），在Java中仅仅是一个new关键字，当虚拟机遇到字节码new指令时，它会先检查指令中的参数能否在常量池（①）中定位到一个<strong>符号引用</strong>（②），并且检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果没有，那必须先执行类加载。</p>
<p>类加载检验通过后，虚拟机会在堆中为它划分一块区域，区域的大小在类加载完成后可以确定。这里划分区域根据不同虚拟机的设计，会有不同的方案。</p>
<p>如果Java堆内存是绝对规整的，一半放用过的，一半放空闲的，中间有一个指针用作分界。那么内存分配只需要将那个指针向空闲的方向移动与对象大小的位置即可，这种分配方式称为指针碰撞。</p>
<p>如果内存是不规整的，即使用的和未使用的内存交错在一起，虚拟机就需要维护一个列表，记录哪些内存是可以使用的，在分配时就需要从虚拟机中找到足够大小的空间划分给对象，并更新列表记录，这种称为空闲列表。</p>
<p>采用那种分配方案取决于堆是否规整，而是否规整又取决于垃圾收集器是否带有空间压缩整理的能力。</p>
<p>由于内存分配是特别频繁的一件事，指针移动这一操作并不是线程安全的，虚拟机采用的解决方案是CAS（③）配上失败重试的方式保证更新操作的原子性。</p>
<p>内存分配完成后，虚拟机会把分配到的内存空间都初始化为零值，这一步保证了对象实例字段在Java代码中可以不赋初始值就可以使用。</p>
<p>接下来，虚拟机就要设置对象的基本属性，比如这个对象是哪个类的实例，如何找到类的元数据，对象的哈希码，对象的GC分代年龄等信息。这些信息被放在<strong>对象头</strong>中。</p>
<h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p>对象在堆中的存储布局可以划分为三个部分，对象头，实例数据，对齐填充。</p>
<p>对象头包括两部分信息，第一部分是存储自身运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID等，这部分被称为Mark Word。这里面的有部分信息会在偏向锁，轻量级锁的实现中用到。</p>
<p>第二部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过该指针确定对象是哪个类的实例。这个指针指向每个对象生成的Class对象，位于方法区中。</p>
<p>数据实例部分是对象真正存储的有效信息，即我们在代码中定义的各种字段。</p>
<p>对齐填充并不是必定存在的，也没有特别含义。</p>
<h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p>对象创建完后，会通过栈上的reference数据来操作堆上的对象，主流访问方式有以下两种：</p>
<h3 id="使用句柄"><a href="#使用句柄" class="headerlink" title="使用句柄"></a>使用句柄</h3><p>如果使用句柄的话，堆中会划分出一块内存来作为句柄池，reference存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自具体的信息。具体结构如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230402092744890.png" alt="image-20230402092744890"></p>
<h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3><p>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，<strong>reference中存储的直接就是对象地址</strong>，如果只是访问对象本身的话，就不需要多一次间接访问的开销。直接指针的最大好处是省略了一次指针定位的开销。</p>
<p>具体结构如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230402092841557.png" alt="image-20230402092841557"></p>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p>①常量池：常量池位于方法区中，用于存放编译器生成的各种<strong>字面量</strong>与<strong>符号引用</strong></p>
<p>②符号引用：在Java虚拟机中，当一个类被加载时，它的类信息会被存储在运行时常量池中，包括类的名称、方法的名称和参数类型等信息，这些信息构成了符号引用。</p>
<p>③CAS操作：类似于版本控制，不过是在字节码层面的。它涉及到3个值，原值A，以及A的副本，要修改的值C。在修改时，它会验证A的值是否等于副本A，如果等，再将C的值写入。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入理解Java虚拟机》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>Jvm</tag>
        <tag>深入理解Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Java与线程</title>
    <url>/2023/03/25/Java/Java%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h1><p>线程是比进程更轻量级的调度执行单位，线程的引入可以把一个进程的资源分配和执行调度分开， 各个线程既可以共享进程资源（内存地址，I&#x2F;O等），又可以独立调度。</p>
<p>实现线程主要有3种方式，使用内核线程实现（1：1实现），使用用户线程实现（1：N实现），使用用户线程加轻量级进程混合实现（N：M实现）。</p>
<h1 id="内核线程的实现"><a href="#内核线程的实现" class="headerlink" title="内核线程的实现"></a>内核线程的实现</h1><p>内核线程（KLT）就是直接由操作系统内核支持的线程。这种线程由内核完成线程切换，由内核操纵调度器调度线程，并负责将线程的任务映射到处理器上。但是程序一般不直接使用内核线程，而是使用他的一种接口，轻量级进程（LWP），就是我们通常意义说的线程，每一个线程都有一个内核线程支持，这种轻量级进程与内核线程是1：1的关系。具体结构如下图所示：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230325151710589.png" alt="image-20230325151710589"></p>
<p>因为每个线程都有内核线程支持，可以当作一个独立的调度单元，即使其中一个被阻塞，也不影响整个进程继续工作。</p>
<p>局限性：由于是基于内核线程，所以线程的创建，同步等操作都需要系统调用。而系统调用需要从用户态切换为内核态。而且每个轻量级进程都需要一个内核线程支持，会消耗一定的内核资源。</p>
<h1 id="用户线程实现"><a href="#用户线程实现" class="headerlink" title="用户线程实现"></a>用户线程实现</h1><p>从广义上讲，一个线程只要不是内核线程，他就是用户线程的一种，从这里看，轻量级进程也属于用户线程。但轻量级线程始终需要建立在内核线程之上，并不具备通常意义上的线程。</p>
<p>而狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。</p>
<p>用户线程没有内核线程的帮助，所以线程的创建、销毁、切换和调度都是用户必须考虑的问题，由于操作系统只把处理器资源分配到进程，所以阻塞如何处理，多处理器系统种如何将线程映射到其他处理器上这类问题解决起来将会异常困难，甚至有些是不可能实现的。</p>
<h2 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h2><p>即存在用户线程，也存在轻量级进程，用户线程还是建立在用户空间之中。而轻量级进程则作为用户线程和内核之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险。具体模型如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230325161956615.png" alt="image-20230325161956615"></p>
<p>一个CPU对应多个内核线程，然后每个内核线程对应着一个轻量级进程，而一个进程又对应了多个用户线程。</p>
<h1 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h1><p>自jdk1.3起，主流java虚拟机的内存模型普遍被替换为基于操作系统原生线程模型来实现，即1：1的线程模型。以HotSpot为例，</p>
<p>它的每一个Java线程都是直接映射到一个操作系统原生线程来实现的，而且中间没有额外的间接结构，所以HotSpot自己是不会去干涉线程调度的（可以设置线程优先级给操作系统提供调度建议），全权交给底下的操作系统去处理，所以何时冻结或唤醒线程、该给线程分配多少处理器执行时间、该把线程安排给哪个处理器核心去执行等，都是由操作系统完成的，也都是由操作系统全权决定的。</p>
<h2 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h2><p>线程调度是指系统为线程分配处理器使用权的过程，调度主要方式有两种，分别是协同式（Cooperative Threads-Scheduling）线程调度和抢占式（Preemptive Threads-Scheduling）线程调度。</p>
<p>协同式调度：线程的执行时间由自己控制，一个线程把自己的工作做完之后，要通知系统去切换到另一个进程去执行。优点是实现简单，而且不会有线程同步的问题，但是缺点也比较明显，线程执行时间不可控，如果一个线程一直不告知系统进行切换，那程序就会一直阻塞在那里。</p>
<p>抢占式调度：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。线程的执行时间是可控的，不会有一个线程阻塞导致整个系统崩溃的问题。</p>
<h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><p>java线程一共有6种状态，一个线程同一时间只能有其中的一种，而且可以通过特定语义进行转换。</p>
<p>1、新建（New）：创建后尚未启动的线程处于这种状态。</p>
<p>2、运行（Runnable）：包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间。</p>
<p>3、无限期等待（Waiting）：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显式唤醒。以下方法会让线程陷入无限期的等待状态：</p>
<p>​	1）没有设置Timeout参数的Object::wait()方法；</p>
<p>​	2）没有设置Timeout参数的Thread::join()方法；</p>
<p>​	3）LockSupport::park()方法。</p>
<p>4、限期等待（Timed Waiting）：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：</p>
<p>​	1）Thread::sleep()方法；</p>
<p>​	2）设置了Timeout参数的Object::wait()方法；</p>
<p>​	3）设置了Timeout参数的Thread::join()方法；</p>
<p>​	4）LockSupport::parkNanos()方法；</p>
<p>​	5）LockSupport::parkUntil()方法。</p>
<p>5、阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</p>
<p>6、结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</p>
<p>转换关系如下图所示：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230325212241436.png" alt="image-20230325212241436"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入理解Java虚拟机》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Jvm</tag>
        <tag>深入理解Java虚拟机</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java先行发生原则</title>
    <url>/2023/03/24/Java/Java%E5%85%88%E8%A1%8C%E5%8F%91%E7%94%9F%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>先行发生是Java内存模型中定义的两项操作之间的偏序关系，比如说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p>
<p>Java语言无须任何同步手段保障就能成立的先行发生规则有且只有以下几种：</p>
<p>1、程序次序规则（Program Order Rule）：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</p>
<p>2、管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后。</p>
<p>3、volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后。</p>
<p>4、线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。</p>
<p>5、线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。</p>
<p>6、线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生。</p>
<p>7、对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</p>
<p>8、传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入理解Java虚拟机》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>内存模型</category>
      </categories>
      <tags>
        <tag>Jvm</tag>
        <tag>深入理解Java虚拟机</tag>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存区域划分（JVM内存模型）</title>
    <url>/2023/03/31/Java/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%88%92%E5%88%86%EF%BC%88JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230331143717622.png" alt="image-20230331143717622"></p>
<h2 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h2><p>该部分可以看作当前线程所执行的字节码的行号指示器。字节码解释器就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
<p>由于Java虚拟机的线程是通过轮流切换线程，然后分配处理器时间来实现的。任何时间，一个处理器（多核处理器就是一个内核）都只会执行一个线程中的一条指令。所以说切换线程后，之前执行到哪里都需要进行保存，所以每一个线程都会有一个独立的程序计数器。</p>
<h2 id="2、Java虚拟机栈"><a href="#2、Java虚拟机栈" class="headerlink" title="2、Java虚拟机栈"></a>2、Java虚拟机栈</h2><p>Java虚拟机栈也是也是<strong>线程私有</strong>的，它的生命周期与线程相同。</p>
<p>该部分描述的是Java方法执行的线程内存模型：每个方法执行时，虚拟机都会创建一个栈帧用于存储局部变量表，操作数栈，动态连接，方法出口等信息。方法被调用到结束，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>该部分存放了编译器可知的Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p>
<p><strong>这里的对象引用，可以理解为在局部变量表中存储了指向堆中具体对象的指针。</strong></p>
<h2 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h2><p>本地方法栈与虚拟机栈的作用是很相似的，区别是虚拟机栈是为虚拟机执行Java方法提供服务，而本地方法栈是为虚拟机使用本地（Native）方法服务。这个本地方法指的是使用Java代码去调用非Java代码的接口，比如说用Java调用C或者C++的接口，这些方法就是本地方法。</p>
<h2 id="4、Java堆"><a href="#4、Java堆" class="headerlink" title="4、Java堆"></a>4、Java堆</h2><p>Java的堆是被所有线程所共享的内存区域，在虚拟机启动时创建，此区域的唯一目的是为了存放<strong>对象实例</strong>，几乎所有的对象实例都是在这里分配内存。</p>
<p>该部分是由垃圾回收器管理的，从回收内存的角度看，由于垃圾收集器大多都是采用分代收集，所以Java堆中会出现新生代，老年代，永久代，Eden空间等。从分配内存的角度看，所有线程共享的Java堆中，可以划分出多个线程私有的分配缓冲区，以提升对象分配效率。</p>
<p>Java堆可以处于物理上不连续的内存空间中，但是在逻辑上他应该被视为连续的。但是对于大对象，最典型的数组，可能会要求连续的内存空间。</p>
<h2 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h2><p>方法区也是各个线程共享的内存区域，<strong>用于存储已经被虚拟机加载了的类型信息</strong>，常量，静态变量，即时编译器编译后的代码缓存等。该部分的垃圾回收发生的相对较少，主要是针对常量池的回收和对类型的卸载。</p>
<p>每个类在编译后都会有一个Class对象，这个Class对象会放在一个.class文件当中，这个就是对类的描述。这个Class对象的作用就是用于运行时提供或者获得某个对象的信息。</p>
<p>比如一个Students类，他编译后会生成一个用于描述Students类的Class对象，该对象记录了Students的属性以及方法。这些内容是存储在方法区当中。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>该部分是方法区的一部分。Class文件中会存储常量池表，用于存放编译器生成的各种<strong>字面量</strong>与<strong>符号引用</strong>。常量池表在类加载后会放到方法区的运行时常量池中。</p>
<p>这里的字面量和符号引用的意思：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这里的12，以及hello world 就是所谓的字面量。而a以及str会被存储在本线程私有的栈中。在类加载的时候，像int a以及String str会被解析成<strong>指向常量池</strong>中<strong>具体常量的直接引用</strong>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入理解Java虚拟机》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>内存模型</category>
      </categories>
      <tags>
        <tag>Jvm</tag>
        <tag>深入理解Java虚拟机</tag>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型之主内存与工作内存</title>
    <url>/2023/03/23/Java/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<p>每秒事务处理数量（TPS）是衡量一个服务性能高低好坏的重要指标之一。它代表着一秒内服务端平均能响应的请求综述，而且TPS值与程序的并发能力又有密切的关系。</p>
<p>为了解决计算机存储设备与处理器运算速度的差距，除了增加缓存外，还有一种优化方法，就是处理器可能会对输入的代码进行乱序执行，处理器在计算后会把乱序的结果进行重组，保证该结果与顺序执行时的一致，但是并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。因此，出现一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。</p>
<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p>可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。</p>
<h1 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h1><p>Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。此处的变量包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数。因为后两个是线程私有的，并不会被共享，也不存在竞争。</p>
<p>Java内存模型没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器是否需要进行调整代码的执行顺序这类优化措施。</p>
<p>Java内存模型规定了所有的变量都存储在主内存中。每条线程还有自己的<strong>工作内存</strong>，线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取，赋值等）都必须在工作内存中进行，而不能直接读写主内存的内容。不同线程也无法直接访问对方工作内存中的变量，<strong>线程间的变量值的传递均需要通过主内存来完成</strong>。</p>
<h1 id="内存见的交互操作"><a href="#内存见的交互操作" class="headerlink" title="内存见的交互操作"></a>内存见的交互操作</h1><p>如何将一个变量从主内存拷贝到工作内存以及如何从工作内存同同步回主内存，Java内存模型定义了8中操作来完成。虚拟机实现时必须保证这些操作是原子的、不可再分的。</p>
<p>lock（锁定）：作用于主内存的变量。把一个变量标识为一条线程独占的。</p>
<p>unlock（解锁）：作用于主内存。把一个处于锁定的变量释放，释放后可以被其他线程锁定。</p>
<p>read（读取）：作用于主内存。把一个变量的值从主内存传输到<strong>线程的工作内存</strong>，用于后续load动作使用。</p>
<p>load（载入）：作用于工作内存。把read操作从主内存中得到的变量值放入工作内存变量的副本中。</p>
<p>use（使用）：作用于工作内存。把工作内存中的一个变量的值传递给执行引擎。当虚拟机遇到一个<strong>需要使用变量的值的字节码指令</strong>时，将会执行这个操作。</p>
<p>assign（赋值）：作用于工作内存。把一个从执行引擎接收的值，赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时，会执行这个操作。</p>
<p>store（存储）：作用于工作内存。把工作内存中一个变量的值传送到主内存中，方便后续write操作使用。</p>
<p>write（写入）：主内存变量。把store操作从工作内存中得到的变量的值放入主内存变量。</p>
<p>如果要把一个变量从主内存拷贝到工作内存，那就要顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序执行store和write操作。Java内存模型只要求上述两个操作必须顺序执行，但不要求是连续执行的。也就是说执行中间可以插入其他的执行。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入理解Java虚拟机》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>内存模型</category>
      </categories>
      <tags>
        <tag>Jvm</tag>
        <tag>深入理解Java虚拟机</tag>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型的可见性、原子性和有序性</title>
    <url>/2023/03/24/Java/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7/</url>
    <content><![CDATA[<h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><p>由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write这六个，我们大致可以认为，基本数据类型的<strong>访问</strong>、<strong>读写</strong>都是具备原子性的。这里的访问和读写只是包括了访问一个变量的值以及给变量赋值，像i++这种操作并不是原子性的。还要注意long 和double的非原子协定，但是这个概率发生很小，可以忽略。</p>
<p>如果应用场景需要一个更大范围的原子性保证，可以使用synchronized关键字。</p>
<h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><p>可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内</p>
<p>存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是此。</p>
<p>普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。</p>
<p>Java的synchronized和fina也具有可见性。</p>
<p>同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</p>
<p>而final关键字的可见性是指：被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值。</p>
<h1 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h1><p>Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内好像表现为串行的语义”（Within-Thread As-If-SerialSemantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。</p>
<p>java提供了volatile和synchronized两个关键字来保证线程之间操作的有序性。volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入理解Java虚拟机》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>内存模型</category>
      </categories>
      <tags>
        <tag>Jvm</tag>
        <tag>深入理解Java虚拟机</tag>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对象的共享</title>
    <url>/2023/04/02/Java/Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoVisibility</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> ready;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReaderThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">                <span class="comment">// 暂停当前正在执行的线程，放弃CPU资源，并执行其他线程。</span></span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ReaderThread</span>().start();</span><br><span class="line">        number = <span class="number">42</span>;</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码，在JDK8以前的版本中，可能会出现死循环或者输出0的情况，这里需要考虑线程执行到一半被中断的情况。</p>
<p>ReaderThread可能会看不到ready的值，导致它会一直处于循环状态。因为Java每个线程对数据的修改只能在工作内存中，然后同步会主内存。另外的一个线程需要从主内存读取才可以看到数据的变化。</p>
<p>而输出0的原因是指令重排序，也就是说虚拟机优化后，先执行了ready &#x3D; true的设定，这一步被ReaderThread看到，而给number赋值的操作在执行时，ReaderThread线程已经执行完毕了，所以打印了0。</p>
<p>但是这段代码在JDK8及其以上版本不会出现问题，因为在JDK8及其以上版本的Java内存模型中，针对静态域和final域的处理有所改进，多个线程间对这些域的访问不再存在可见性问题。</p>
<h2 id="失效数据"><a href="#失效数据" class="headerlink" title="失效数据"></a>失效数据</h2><p>上述代码出现循环的情况展示了非同步导致的一个问题，失效数据。也就是说ReaderThread线程读到的ready值是隐式初始化的一个false，但是这个false其实已经被改为了true，但是它却错误的读到了false。</p>
<h2 id="非原子的64位操作"><a href="#非原子的64位操作" class="headerlink" title="非原子的64位操作"></a>非原子的64位操作</h2><p>非volatile类型的64位的long和double，JVM允许将64位的读操作和写操作分解成两个32位的操作，如果对该变量的读操作和写操作不在同线程中执行，那么可能会读到某个数的高32位和另一个值得低32位，导致线程不安全。</p>
<h2 id="加锁与可见性"><a href="#加锁与可见性" class="headerlink" title="加锁与可见性"></a>加锁与可见性</h2><p>加锁得含义不仅仅局限于互斥行为，还包括可见性。为了确保所有线程都能看到共享变量得最新值，所有执行读操作或者写操作得线程都必须在同一个锁上同步。</p>
<h2 id="volatile变量"><a href="#volatile变量" class="headerlink" title="volatile变量"></a>volatile变量</h2><p>在Java内存模型中，volatile关键字的可见性是通过使用内存屏障来保证的。内存屏障是CPU指令的一种，可以强制CPU在指令序列中插入一条特殊指令，它会让CPU在执行到该指令时停下来，然后刷新缓存中的数据，让数据立即写入主内存，同时让其他CPU缓存中的数据无效，让其他CPU从主内存重新读取数据。</p>
<p>当一个变量被volatile关键字修饰时，Java编译器会在生成的字节码中插入内存屏障指令，这样在访问volatile变量时，读线程会强制从主内存中读取该变量的最新值，而不是使用本地缓存中的旧值。类似地，写线程写入volatile变量时，会强制将该变量的值刷新到主内存中，而不是仅仅保存在本地缓存中。</p>
<p>由于内存屏障的存在，保证了volatile变量的读写操作具有原子性和可见性。读线程读取到的是最新值，写线程写入的也是最新值，其他线程在读写该变量时也能读写到最新的值。因此，使用volatile关键字修饰的变量可以在多线程并发访问时保证数据的正确性。</p>
<h1 id="发布与逃逸"><a href="#发布与逃逸" class="headerlink" title="发布与逃逸"></a>发布与逃逸</h1><p>发布指的使一个对象可以在当前作用域之外的地方使用。例如将一个指向局部变量的指针保存在其他代码可以访问的地方。发布最简单的做法是将一个对象的引用放到一个共有的静态变量当中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Secret&gt; knowSecrets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">    knowSecrets = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而发布knowSecrets对象是，可能会导致在该集合中的对象被间接的发布，因为能拿到knowSecrets，就可以操作其里面的内容。</p>
<h2 id="一个this引用逃逸的例子"><a href="#一个this引用逃逸的例子" class="headerlink" title="一个this引用逃逸的例子"></a>一个this引用逃逸的例子</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisEscape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThisEscape</span><span class="params">(EventSource source)</span> &#123;</span><br><span class="line">        source.registerListener(</span><br><span class="line">            <span class="comment">// 这里是一个匿名的内部类</span></span><br><span class="line">        	<span class="keyword">new</span> <span class="title class_">EventListener</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event e)</span> &#123;</span><br><span class="line">                    doSomething(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里涉及到匿名内部类，一个匿名内部类在构造时，编译器会默认把父类的引用隐式的传进来。也就意味着，上面的onEvent方法，他调用的doSomething可能是父类的某个方法，只不过采用省略写法，没有用this.doSomething(e)。以下是换一种不抽象的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisEscape</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThisEscape</span><span class="params">(EventSource source)</span> &#123;</span><br><span class="line">        source.registerListener(</span><br><span class="line">            <span class="comment">// 这里是一个匿名的内部类</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">EventListener</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">                    add(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num += val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上这种情况，如果在外部类，也就是ThisEscape初始化时，对num进行赋值，初始化还未完成时，却可以通过内部类对num进行修改，就会导致在num未初始化完成时，对其进行了修改。出现这种现象的原因是，ThisEscape的引用被EventListener提前暴露出去。</p>
<h2 id="使用工厂方法来防止this引用逃逸"><a href="#使用工厂方法来防止this引用逃逸" class="headerlink" title="使用工厂方法来防止this引用逃逸"></a>使用工厂方法来防止this引用逃逸</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SafeListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventListener eventListener;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SafeListener</span><span class="params">()</span> &#123;</span><br><span class="line">        eventListener = <span class="keyword">new</span> <span class="title class_">EventListener</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doEvent</span><span class="params">(Event e)</span> &#123;</span><br><span class="line">                <span class="comment">// doSomething(e);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SafeListener <span class="title function_">newInstance</span><span class="params">(EventSource eventSource)</span> &#123;</span><br><span class="line">        <span class="type">SafeListener</span> <span class="variable">safeListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SafeListener</span>();</span><br><span class="line">        eventSource.registerListener(safeListener.eventListener);</span><br><span class="line">        <span class="keyword">return</span> safeListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法，使得注册监听在构造方法之后完成，所以不会导致引用逃逸。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Java并发编程实战》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java并发编程实战</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的I/O</title>
    <url>/2023/05/26/Java/Java%E7%9A%84I-O/</url>
    <content><![CDATA[<h1 id="什么是I-x2F-O流"><a href="#什么是I-x2F-O流" class="headerlink" title="什么是I&#x2F;O流"></a>什么是I&#x2F;O流</h1><p>我们通常把机器或者应用程序接收外界的信息称为输入流（InputStream），从机器或者应用程 序向外输出的信息称为输出流（OutputStream），合称为输入 &#x2F; 输出流（I&#x2F;O Streams）。</p>
<p>Java 的 I&#x2F;O 分为以下两类：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230526110237837.png" alt="image-20230526110237837" style="zoom:67%;" />

<p>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么还要存在字符流呢？</p>
<p>字符到字节必须经过转码，这个过程非常耗时，如果我们不知道编码类型就很容易出现乱码问题，所以提供了直接操作字符的接口。</p>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230526110336147.png" alt="image-20230526110336147" style="zoom:67%;" />

<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230526110352335.png" alt="image-20230526110352335" style="zoom:67%;" />

<h1 id="传统I-x2F-O的性能问题"><a href="#传统I-x2F-O的性能问题" class="headerlink" title="传统I&#x2F;O的性能问题"></a>传统I&#x2F;O的性能问题</h1><h2 id="1-多次内存复制"><a href="#1-多次内存复制" class="headerlink" title="1. 多次内存复制"></a>1. 多次内存复制</h2><p>在传统 I&#x2F;O 中，我们可以通过 InputStream 从源数据中读取数据流输入到缓冲区里，通过 OutputStream 将数据输出到外部设备（包括磁盘、网络），输入操作在操作系统中的具体流程如下：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230526110921118.png" alt="image-20230526110921118" style="zoom:67%;" />

<p>JVM 会发出 read() 系统调用，并通过 read 系统调用向内核发起读请求； </p>
<p>内核向硬件发送读指令，并等待读就绪； </p>
<p>内核把将要读取的数据复制到指向的内核缓存中；</p>
<p>操作系统内核将数据复制到用户空间缓冲区，然后 read 系统调用返回。</p>
<p>数据先从外部设备复制到内核空间，再从内核空间复制到用户空间，这就发生 了两次内存复制操作。</p>
<h2 id="2-阻塞"><a href="#2-阻塞" class="headerlink" title="2. 阻塞"></a>2. 阻塞</h2><p>在传统 I&#x2F;O 中，InputStream 的 read() 是一个 while 循环操作，它会一直等待数据读取，直到数据就绪才会返回。这就意味着如果没有数据就绪，这个读取操作将会一直被挂起，用户线程将会处于阻塞状态。</p>
<p>这种处理方式在少量连接没问题，但在发生大量连接请求时，就需要创建大量监听线程，这时如果线程没有数据就绪就会被挂起，然后进入阻塞状态。 一旦发生线程阻塞，这些线程将会不断地抢夺 CPU 资源，从而导致大量的 CPU 上下文切换，增加系统的性能开销。</p>
<h1 id="如何优化-I-x2F-O-操作"><a href="#如何优化-I-x2F-O-操作" class="headerlink" title="如何优化 I&#x2F;O 操作"></a>如何优化 I&#x2F;O 操作</h1><p>NIO 的发布优化了内存复制以及阻塞导致的 严重性能问题，NIO2提出了从操作系统层面实现的异步 I&#x2F;O。</p>
<h2 id="1-使用缓冲区优化读写流操作"><a href="#1-使用缓冲区优化读写流操作" class="headerlink" title="1. 使用缓冲区优化读写流操作"></a>1. 使用缓冲区优化读写流操作</h2><p>NIO是基于块的，在 NIO 中， 最为重要的两个组件是缓冲区（Buffer）和通道（Channel）。Buffer 是一块连续的内存块， 是 NIO 读写数据的中转地。Channel 表示缓冲数据的源头或者目的地，它用于读取缓冲或者写入数据，是访问缓冲的接口。</p>
<p>NIO 是面向 Buffer。Buffer 可以将文 件一次性读入内存再做后续处理，而传统的方式是边读文件边处理数据。</p>
<h2 id="2-使用-DirectBuffer-减少内存复制"><a href="#2-使用-DirectBuffer-减少内存复制" class="headerlink" title="2. 使用 DirectBuffer 减少内存复制"></a>2. 使用 DirectBuffer 减少内存复制</h2><p>NIO 的 Buffer 除了做了缓冲块优化之外，还提供了一个可以直接访问物理内存的类 DirectBuffer。普通的 Buffer 分配的是 JVM 堆内存，而 DirectBuffer 是直接分配物理内存 (非堆内存)。</p>
<p>数据要输出到外部设备，必须先从用户空间复制到内核空间，再复制到输出设备，而在 Java 中，在用户空间中又存在一个拷贝，那就是从 <strong>Java 堆内存中拷贝到临时的直接内存中</strong>，通过<strong>临时的直接内存拷贝到内存空间中</strong>去。此时的直接内存和堆内存都是属于用户空间。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230526112218554.png" alt="image-20230526112218554" style="zoom:67%;" />

<p>如果单纯使用 Java 堆内存进行数据拷贝，当拷贝的数据量比较大的情况下，Java 堆的 GC 压力会比较大，而使用非堆内存可以减低 GC 的压力。</p>
<p>DirectBuffer 则是直接将步骤简化为数据直接保存到非堆内存，从而减少了一次数据拷贝。</p>
<p>由于 DirectBuffer 申请的是非 JVM 的物理内存，所以创建和销毁的代价很 高。DirectBuffer 申请的内存并不是直接由 JVM 负责垃圾回收，但在 DirectBuffer 包装类被 回收时，会通过 Java Reference 机制来释放该内存块。</p>
<p>MappedByteBuffer 是通过本 地类调用 mmap 进行文件内存映射的，map() 系统调用方法会直接将文件从硬盘拷贝到用户 空间，只进行一次数据拷贝，从而减少了传统的 read() 方法从硬盘拷贝到内核空间这一步。</p>
<h2 id="3-避免阻塞，优化-I-x2F-O-操作"><a href="#3-避免阻塞，优化-I-x2F-O-操作" class="headerlink" title="3. 避免阻塞，优化 I&#x2F;O 操作"></a>3. 避免阻塞，优化 I&#x2F;O 操作</h2><p>传统的 I&#x2F;O 即使使用了缓冲块，依然存在阻塞问题。由于线程池线程数量有限，一旦发生大量 并发请求，超过最大数量的线程就只能等待，直到线程池中有空闲的线程可以被复用。而对 Socket 的输入流进行读取时，读取流会一直阻塞，直到发生以下三种情况的任意一种才会解 除阻塞：</p>
<p>1、有数据可读； </p>
<p>2、连接释放； </p>
<p>3、空指针或 I&#x2F;O 异常。</p>
<p>NIO 发布后，通道和多路复用器这两个基本组件实现 了 NIO 的非阻塞</p>
<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>最开始，在应用程序调用操作系统 I&#x2F;O 接口时，是由 CPU 完成分配，这种方式最大的问题是 “发生大量 I&#x2F;O 请求时，非常消耗 CPU“；之后，操作系统引入了 DMA（直接存储器存 储），内核空间与磁盘之间的存取完全由 DMA 负责，但这种方式依然需要向 CPU 申请权 限，且需要借助 DMA 总线来完成数据的复制操作，如果 DMA 总线过多，就会造成总线冲突。</p>
<p>Channel 有自己的处理器，可以完成内核空间和磁盘之间的 I&#x2F;O 操作。在 NIO 中，我们读取和写入数据都要通过 Channel，由于 Channel 是双向的，所以 读、写可以同时进行。</p>
<h3 id="多路复用器（Selector）"><a href="#多路复用器（Selector）" class="headerlink" title="多路复用器（Selector）"></a>多路复用器（Selector）</h3><p>Selector 是 Java NIO 编程的基础。用于检查一个或多个 NIO Channel 的状态是否处于可 读、可写。</p>
<p>Selector 是基于事件驱动实现的，我们可以在 Selector 中注册 accpet、read 监听事件， Selector 会不断轮询注册在其上的 Channel，如果某个 Channel 上面发生监听事件，这个 Channel 就处于就绪状态，然后进行 I&#x2F;O 操作。</p>
<p>一个线程使用一个 Selector，通过轮询的方式，可以监听多个 Channel 上的事件。我们可以 在注册 Channel 时设置该通道为非阻塞，当 Channel 上没有 I&#x2F;O 操作时，该线程就不会一直 等待了，而是会不断轮询所有 Channel，从而避免发生阻塞。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Java性能调优实战》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>调优</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的NIO</title>
    <url>/2023/07/04/Java/Java%E7%9A%84NIO/</url>
    <content><![CDATA[<h1 id="常见I-x2F-O模型对比"><a href="#常见I-x2F-O模型对比" class="headerlink" title="常见I&#x2F;O模型对比"></a>常见I&#x2F;O模型对比</h1><p>所有的系统I&#x2F;O都分为两个阶段：等待就绪和操作。</p>
<p>比如读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。</p>
<p>其中，<strong>等待就绪的阻塞</strong>是不使用CPU的，是在“空等”；而真正的读写操作的阻塞是使用CPU的，真正在”干活”，而且这个过程非常快，属于memory copy，可以理解为基本不耗时。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230704111300465.png" alt="image-20230704111300465" style="zoom:67%;" />

<h2 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h2><p>以socket.read()为例子：</p>
<p>传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。</p>
<p>对于NIO，如果TCP RecvBuffer有数据，就把数据从网卡读到内存，并且返回给用户；反之则直接返回0，永远不会阻塞。</p>
<p>最新的AIO(Async I&#x2F;O)里面会更进一步：不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。</p>
<p>BIO里用户最关心“我要读”，NIO里用户最关心”我可以读了”，在AIO模型里用户更需要关注的是“读完了”。</p>
<p>NIO一个重要的特点是：socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I&#x2F;O操作是同步阻塞的（消耗CPU但性能非常高）。</p>
<h1 id="结合事件模型使用NIO同步非阻塞特性"><a href="#结合事件模型使用NIO同步非阻塞特性" class="headerlink" title="结合事件模型使用NIO同步非阻塞特性"></a>结合事件模型使用NIO同步非阻塞特性</h1><p>BIO中，之所以需要多线程，是因为在进行I&#x2F;O操作时，无法估计什么时候完成，只能等待，即使通过估算算出来一个大概的时间，也无法通过socket.read()和socket.write()进行返回，所以另外开启一个新的线程是最好的解决办法。</p>
<p><strong>NIO的读写函数可以立刻返回</strong>，这就给了我们不开线程利用CPU的最好机会：如果一个连接不能读写（socket.read()返回0或者socket.write()返回0），我们可以把这件事记下来，<strong>记录的方式通常是在Selector上注册标记位</strong>，然后切换到其它就绪的连接（channel）继续进行读写。</p>
<h2 id="如何使用单线程处理所有I-x2F-O"><a href="#如何使用单线程处理所有I-x2F-O" class="headerlink" title="如何使用单线程处理所有I&#x2F;O"></a>如何使用单线程处理所有I&#x2F;O</h2><p>NIO的主要事件有几个：读就绪、写就绪、有新连接到来。</p>
<p>首先需要注册当这几个事件到来的时候所对应的处理器，然后在合适的时机告诉事件选择器：我对这个事件感兴趣。例如，对于写操作，就是写不出去的时候对写事件感兴趣；对于读操作，就是完成连接和系统没有办法承载新读入的数据的时；对于accept，一般是服务器刚启动的时候；而对于connect，一般是connect失败需要重连或者直接异步调用connect的时候。</p>
<p>其次，用一个死循环选择就绪的事件，会执行系统调用（Linux 2.6之前是select、poll，2.6之后是epoll，Windows是IOCP），<strong>还会阻塞的等待新事件的到来</strong>。新事件到来的时候，会在selector上注册标记位，标示可读、可写或者有连接到来。</p>
<p>注意，<strong>select是阻塞的</strong>，无论是通过操作系统的通知（epoll）还是不停的轮询(select，poll)，这个函数是阻塞的。所以你可以放心大胆地在一个while(true)里面调用这个函数而不用担心CPU空转。</p>
<p>一个最简单的Reactor模式的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ChannelHandler</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelReadable</span><span class="params">(Channel channel)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelWritable</span><span class="params">(Channel channel)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line">    Socket socket;</span><br><span class="line">    Event event;<span class="comment">//读，写或者连接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IO线程主循环:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IoThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        Channel channel;</span><br><span class="line">        <span class="keyword">while</span> (channel = Selector.select()) &#123;<span class="comment">//选择就绪的事件和对应的连接</span></span><br><span class="line">            <span class="keyword">if</span> (channel.event == accept) &#123;</span><br><span class="line">                registerNewChannelHandler(channel);<span class="comment">//如果是新连接，则注册一个新的读写处理器</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (channel.event == write) &#123;</span><br><span class="line">                getChannelHandler(channel).channelWritable(channel);<span class="comment">//如果可以写，则执行写事件</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (channel.event == read) &#123;</span><br><span class="line">                getChannelHandler(channel).channelReadable(channel);<span class="comment">//如果可以读，则执行读事件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Channel，ChannelHandler&gt; handlerMap;<span class="comment">//所有channel的对应事件处理器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="优化线程模型"><a href="#优化线程模型" class="headerlink" title="优化线程模型"></a>优化线程模型</h1><p>NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I&#x2F;O操作都是纯CPU操作，没有必要开启多线程。</p>
<p>而且不开多线程，连接数大的时候减少了线程切换。</p>
<p>真正需要的线程：</p>
<ol>
<li>事件分发器，单线程选择就绪的事件。 </li>
<li>I&#x2F;O处理器，包括connect、read、write等，这种纯CPU操作，一般开启CPU核心个线程就可以。 </li>
<li>业务线程，在处理完I&#x2F;O后，业务一般还会有自己的业务逻辑，有的还会有其他的阻塞I&#x2F;O，如DB操作，RPC等。只要有阻塞，就需要单独的线程。</li>
</ol>
<p>Java的Selector对于Linux系统来说，有一个致命限制：同一个channel的select不能被并发的调用。因此，如果有多个I&#x2F;O线程，必须保证：一个socket只能属于一个IoThread，而一个IoThread可以管理多个socket。</p>
<p>另外连接的处理和读写的处理通常可以选择分开，这样对于海量连接的注册和读写就可以分发。虽然read()和write()是比较高效无阻塞的函数，但毕竟会占用CPU，如果面对更高的并发则无能为力。</p>
<p>NIO在服务端对于解放线程，优化I&#x2F;O和处理海量连接方面有一定的优势。</p>
<p>常见的客户端BIO+连接池模型，可以建立n个连接，然后当某一个连接被I&#x2F;O占用的时候，可以使用其他连接来提高性能。</p>
<p>但多线程的模型面临和服务端相同的问题：如果指望增加连接数来提高性能，则连接数又受制于线程数、线程很贵、无法建立很多线程，则性能遇到瓶颈。</p>
<h1 id="连接顺序请求的Redis"><a href="#连接顺序请求的Redis" class="headerlink" title="连接顺序请求的Redis"></a>连接顺序请求的Redis</h1><p>对于Redis来说，由于服务端是全局串行的，能够保证同一连接的所有请求与返回顺序一致。这样可以使用单线程＋队列，把请求数据缓冲。然后pipeline发送，返回future，然后channel可读时，直接在队列中把future取回来，done()就可以了。</p>
<h1 id="Proactor与Reactor"><a href="#Proactor与Reactor" class="headerlink" title="Proactor与Reactor"></a>Proactor与Reactor</h1><p>一般情况下，I&#x2F;O 复用机制需要事件分发器（event dispatcher）。事件分发器的作用，即将那些读写事件源分发给各读写事件的处理者,开发人员在开始的时候需要在分发器那里注册感兴趣的事件，并提供相应的处理者（event handler)，或者是回调函数；事件分发器在适当的时候，会将请求的事件分发给这些handler或者回调函数。</p>
<p>涉及到事件分发器的两种模式称为：Reactor和Proactor。 Reactor模式是基于同步I&#x2F;O的，而Proactor模式是和异步I&#x2F;O相关的。</p>
<p>在Reactor模式中，事件分发器等待某个事件或者可应用或某个操作的状态发生（比如文件描述符可读写，或者是socket可读写），事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。</p>
<p>而在Proactor模式中，事件处理者（或者代由事件分发器发起）直接发起一个异步读写操作（相当于请求），而实际的工作是由操作系统来完成的。发起时，需要提供的参数包括用于存放读到数据的缓存区、读的数据大小或用于存放外发数据的缓存区，以及这个请求完后的回调函数等信息。事件分发器得知了这个请求，它默默等待这个请求的完成，然后转发完成事件给相应的事件处理者或者回调。</p>
<p>举例来说，在Windows上事件处理者投递了一个异步IO操作（称为overlapped技术），事件分发器等IO Complete事件完成。这种异步模式的典型实现是基于操作系统底层异步API的，所以我们可称之为“系统级别”的或者“真正意义上”的异步，因为具体的读写是由操作系统代劳的。</p>
<h2 id="Reactor中实现读"><a href="#Reactor中实现读" class="headerlink" title="Reactor中实现读"></a>Reactor中实现读</h2><ul>
<li>注册读就绪事件和相应的事件处理器。</li>
<li>事件分发器等待事件。</li>
<li>事件到来，激活分发器，分发器调用事件对应的处理器。</li>
<li>事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li>
</ul>
<h2 id="Proactor中实现读"><a href="#Proactor中实现读" class="headerlink" title="Proactor中实现读"></a>Proactor中实现读</h2><ul>
<li>处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。</li>
<li>事件分发器等待操作完成事件。</li>
<li>在分发器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分发器读操作完成。</li>
<li>事件分发器呼唤处理器。</li>
<li>事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分发器。</li>
</ul>
<p>两个模式的相同点，都是对某个I&#x2F;O事件的事件通知（即告诉某个模块，这个I&#x2F;O操作可以进行或已经完成)。在结构上，两者也有相同点：事件分发器负责提交IO操作（异步)、查询设备是否可操作（同步)，然后当条件满足时，就回调handler；不同点在于，异步情况下（Proactor)，当回调handler时，表示I&#x2F;O操作已经完成；同步情况下（Reactor)，回调handler时，表示I&#x2F;O设备可以进行某个操作（can read 或 can write)。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《美团技术团队》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的线程池</title>
    <url>/2023/04/07/Java/Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>一个线程池的运行流程如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230407104446460.png" alt="image-20230407104446460"></p>
<p> 看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestExecutionWebServer</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">READS</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(READS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;do Something&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// new Thread(task).start();</span></span><br><span class="line">            executor.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被注释掉的那一行，就是没有使用线程池的写法。它会为每一个到来的请求都新建一个线程去执行任务，但是这样做有一个弊端，就是会无限制的创建线程，有100个请求就创建100个线程，然后用完再销毁，频繁的线程创建和销毁会给系统带来很大的压力，而且无休止的创建线程也会导致系统耗尽资源而崩溃。</p>
<p>而使用了线程池，它会固定线程的数量，每次来任务时，就从线程池里面取一个闲置的线程去执行任务，而且线程池里面的线程都是创建好了的，省略了创建线程和销毁线程的资源消耗。</p>
<h1 id="Executor的生命周期"><a href="#Executor的生命周期" class="headerlink" title="Executor的生命周期"></a>Executor的生命周期</h1><p>由于executor以异步的方式执行，所以任意时刻，之前提交的任务状态都是不可知的，可能运行结束，可能还在执行或者排队。所以关闭 时需要将操作中受影响的任务状态返回给应用程序。</p>
<p>为了解决这个问题，Executor扩展了ExecutorService接口，添加了一些有关生命周期的方法。比如说shutdown，shutdownNow，isShutdown等。下面是一个支持关闭的服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestExecutionWebServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">READS</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(READS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (!executor.isShutdown()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; handleRequest(socket);</span><br><span class="line">                executor.execute(task);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!executor.isShutdown()) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do something with socket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。</p>
<p>ThreadPoolExecutor的运行状态有5种：</p>
<p>RUNNING：能接受新提交的任务，也能处理阻塞队列中的任务。</p>
<p>SHUTDOWN：关闭状态，不接受新任务，但可以处理阻塞队列中已保存的任务。</p>
<p>STOP：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。</p>
<p>TIDYING：所有任务已经终止，workerCount（有效线程数）为0。</p>
<p>TERMINATED：在terminated()方法执行完成后进入该状态。</p>
<p>线程转变过程如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230407104821174.png" alt="image-20230407104821174"></p>
<h1 id="任务执行机制"><a href="#任务执行机制" class="headerlink" title="任务执行机制"></a>任务执行机制</h1><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。具体执行过程如下图：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230407105329566.png" alt="image-20230407105329566" style="zoom: 80%;" />

<p>注：这里的核心数是指操作系统的核心线程数，由于Java线程的设计是采用1：1的设计方案，也就是说每一个Java线程都绑定了一个操作系统的核心线程。</p>
<h2 id="任务缓冲"><a href="#任务缓冲" class="headerlink" title="任务缓冲"></a>任务缓冲</h2><p>线程池本质是对任务和线程的管理，做到这一点的关键是将两者解耦，不让两者关联才可以做后续的分配工作。而这一点是通过采用生产者-消费者模式，通过一个阻塞队列实现的。阻塞队列缓存任务，然后工作线程从中获取任务。</p>
<p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230407111347618.png" alt="image-20230407111347618"></p>
<h2 id="任务申请"><a href="#任务申请" class="headerlink" title="任务申请"></a>任务申请</h2><p>任务的执行有两种可能：</p>
<p>1、任务直接由新创建的线程执行。</p>
<p>2、线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。</p>
<p>第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。执行流程如下：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230407112022917.png" alt="image-20230407112022917" style="zoom: 80%;" />

<h2 id="任务拒绝"><a href="#任务拒绝" class="headerlink" title="任务拒绝"></a>任务拒绝</h2><p>任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，以保护线程池。</p>
<h1 id="Worker线程管理"><a href="#Worker线程管理" class="headerlink" title="Worker线程管理"></a>Worker线程管理</h1><p>线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。</p>
<h2 id="Worker线程"><a href="#Worker线程" class="headerlink" title="Worker线程"></a>Worker线程</h2><p>Worker这个工作线程，实现了Runnable接口，并持有一个线程thread，一个初始化的任务firstTask。thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值是非空的，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230407121025966.png" alt="image-20230407121025966"></p>
<p>这里的非核心线程创建区别于核心线程。在线程池中，核心线程一般是初始化时创建的，非核心线程是在任务提交到线程池后，如果当前线程池中的线程数还没有达到最大线程数，就会创建新的线程来执行任务。</p>
<h3 id="生命周期管理的实现"><a href="#生命周期管理的实现" class="headerlink" title="生命周期管理的实现"></a>生命周期管理的实现</h3><p>线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。</p>
<p>Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。</p>
<p>lock方法一旦获取了独占锁，表示当前线程正在执行任务中，则不应该中断线程。如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。</p>
<p>线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230407122748731.png" alt="image-20230407122748731"></p>
<h2 id="Worker线程增加"><a href="#Worker线程增加" class="headerlink" title="Worker线程增加"></a>Worker线程增加</h2><p>增加线程的执行流程如下所示：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230407123051268.png" alt="image-20230407123051268" style="zoom:67%;" />

<h2 id="Worker线程回收"><a href="#Worker线程回收" class="headerlink" title="Worker线程回收"></a>Worker线程回收</h2><p>线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。</p>
<p>Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。</p>
<h2 id="Worker线程执行任务"><a href="#Worker线程执行任务" class="headerlink" title="Worker线程执行任务"></a>Worker线程执行任务</h2><p>Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：</p>
<p>有一个while循环会不断的从阻塞队列中获取任务，如果线程池正在停止，就要保证当前线程是中断状态。然后开始执行任务，直到从阻塞队列获取任务返回为空时，销毁线程。流程图如下所示：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230407123642437.png" alt="image-20230407123642437" style="zoom: 80%;" />

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Java并发编程实战》</p>
<p>美团技术博客</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的Stream</title>
    <url>/2023/05/24/Java/Java%E7%9A%84Stream/</url>
    <content><![CDATA[<p> 需求：过滤分组一所中学里身高在 160cm 以上的男女同学</p>
<p>之前的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; stuMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;Student&gt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Student stu: studentsList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stu.getHeight() &gt; <span class="number">160</span>) &#123; <span class="comment">//如果身高大于160</span></span><br><span class="line">        <span class="keyword">if</span> (stuMap.get(stu.getSex()) == <span class="literal">null</span>) &#123; <span class="comment">//该性别还没分类</span></span><br><span class="line">            List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;(); <span class="comment">//新建该性别学生的</span></span><br><span class="line">            list.add(stu);<span class="comment">//将学生放进去列表</span></span><br><span class="line">            stuMap.put(stu.getSex(), list);<span class="comment">//将列表放到map中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//该性别分类已存在</span></span><br><span class="line">            stuMap.get(stu.getSex()).add(stu);<span class="comment">//该性别分类已存在，则直接放进去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Stream API实现：</p>
<p>串行实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; stuMap = stuList.stream().filter((Student s) -&gt; s.getHeight() &gt; <span class="number">160</span>) .collect(Collectors.groupingBy(Student ::getSex)); </span><br></pre></td></tr></table></figure>

<p>并行实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; stuMap = stuList.parallelStream().filter((Student s) -&gt; s.getHeight() &gt; <span class="number">160</span>) .collect(Collectors.groupingBy(Student ::getSex)); </span><br></pre></td></tr></table></figure>

<h1 id="Stream-如何优化遍历"><a href="#Stream-如何优化遍历" class="headerlink" title="Stream 如何优化遍历"></a>Stream 如何优化遍历</h1><p>官方将 Stream 中的操作分为两大类：中间操作（Intermediate operations）和终结操作（Terminal operations）</p>
<p>中间操作只对操作进行了记录，即只会返回一个流，不会进行计算操作，而终结操作是实现了计算操作。</p>
<p>中间操作又可以分为无状态（Stateless）与有状态（Stateful）操作，前者是指元素的处理不受之前元素的影响，后者是指该操作只有拿到所有元素之后才能继续下去。</p>
<p>终结操作又可以分为短路（Short-circuiting）与非短路（Unshort-circuiting）操作，前者是指遇到某些符合条件的元素就可以得到最终结果，后者是指必须处理完所有元素才能得到最终结果。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230524223653374.png" alt="image-20230524223653374"></p>
<p>Stream如何迭代大数据集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王老五&quot;</span>, <span class="string">&quot;李三&quot;</span>, <span class="string">&quot;刘老四&quot;</span>, <span class="string">&quot;王小二&quot;</span>, <span class="string">&quot;张四&quot;</span>, <span class="string">&quot;张五六七&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">maxLenStartWithZ</span> <span class="operator">=</span> names.stream()</span><br><span class="line">                  .filter(name -&gt; name.startsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">                  .mapToInt(String::length)</span><br><span class="line">                  .max()</span><br><span class="line">                  .toString();</span><br></pre></td></tr></table></figure>

<p>Stream 并行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王老五&quot;</span>, <span class="string">&quot;李三&quot;</span>, <span class="string">&quot;刘老四&quot;</span>, <span class="string">&quot;王小二&quot;</span>, <span class="string">&quot;张四&quot;</span>, <span class="string">&quot;张五六七&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">maxLenStartWithZ</span> <span class="operator">=</span> names.stream()</span><br><span class="line">                  .parallel()</span><br><span class="line">                  .filter(name -&gt; name.startsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">                  .mapToInt(String::length)</span><br><span class="line">                  .max()</span><br><span class="line">                  .toString();</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Java性能调优实战》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程安全</title>
    <url>/2023/03/29/Java/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="Java中的线程安全"><a href="#Java中的线程安全" class="headerlink" title="Java中的线程安全"></a>Java中的线程安全</h1><p>一个比较严格的线程安全定义：当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的</p>
<p>Java语言中的各种操作的共享数据可以分为以下五类：不可变，绝对线程安全，相对线程安全，线程兼容和线程对立。</p>
<h2 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h2><p>不可变的对象，他的线程一定是安全的。</p>
<h2 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h2><p>绝对线程安全需要满足上面提到的定义。而Java API中提到的线程安全的类，大多都是相对线程安全。比如说Vector是一个线程安全的容器，因为他的add(), get(), size()的方法都是用synchronized修饰的。尽管这样，并不意味着它永远不需要同步手段。</p>
<p>比如以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			vector.add(i);</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">removeThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                    vector.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">printThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                    System.out.println((vector.get(i)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">		removeThread.start();</span><br><span class="line">		printThread.start();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//不要同时产生过多的线程，否则会导致操作系统假死</span></span><br><span class="line">		<span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">20</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码运行之后就会报错，原因是如果一个线程在错误的时间删除一个元素，那么其他元素在获取对应下标时就会报错。虽然它的get和remove都是原子操作，但是原子操作组合原子操作并不一定是原子操作。</p>
<p>当调用vector.size()获取大小时，它确实是原子性的。但是后续循环中，vector中的元素会被删除，导致get操作获取错误的下标。</p>
<p>所以说在操作这些容器时，还是需要手动加锁。</p>
<h2 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h2><p>相对线程安全就是我们通常意义上所说的安全，它需要保证对这个对象单次的操作是线程安全的，我们在调用的时候不需要进行额外的操作，但是对于特定顺序的调用，就需要额外操作的同步手段来保证。</p>
<h2 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h2><p>线程兼容是指对象本身不是线程安全的，但是可以通过在调用端使用一些同步手段来保证线程安全。比如HashMap， ArrayList等。</p>
<h2 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h2><p>线程对立是指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。</p>
<h1 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h1><h2 id="1、互斥同步"><a href="#1、互斥同步" class="headerlink" title="1、互斥同步"></a>1、互斥同步</h2><p>互斥同步在多个线程访问共享数据时，保证共享数据在同一时刻只被一条线程使用。</p>
<p>Java中最基本的互斥同步手段就是synchronized关键字，这是一种块结构的同步语法。synchronized关键字经过Javac编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。</p>
<p>如果Java源码中的synchronized明确指定了对象参数，那就以这个对象的引用作为reference；如果没有明确指定，那将根据synchronized修饰的方法类型（如实例方法或类方法），来决定是取代码所在的对象实例还是取类型对应的Class对象来作为线程要持有的锁。</p>
<p>在执行monitorenter时，会先尝试获取锁，如果对象没有被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数加一，而在执行monitorexit时就会把锁的计数器减一。计数器为0，释放锁。如果获取锁失败，就会被阻塞，直到请求锁定的对象上面的锁被释放。</p>
<p>这也就意味着，synchronized修饰的变量，一个线程获取锁后，可以在上面加很多把锁，也不会造成死锁，而且不可被中断。</p>
<p>除了synchronized关键字以外，jdk5以后，提供了JUC包的Lock接口，可以让用于以非块结构实现互斥同步。</p>
<p>ReentrantLock是Lock接口最常见的实现，它也是可重入锁，但是与synchronized有一定的区别，主要是以下三点：</p>
<p>1、等待可中断：当持有锁的线程长时间没有释放锁时，等待这把锁的线程可以选择放弃等待，而synchronized修饰的却不可以（获取锁失败会被阻塞）。</p>
<p>2、公平锁：多个线程等待锁，会按照申请锁的顺序依次获得。ReentrantLock默认情况下是非公平锁，一旦开启公平锁，会影响性能。</p>
<p>3、绑定多个条件：是指一个ReentrantLock对象可以同时绑定多个Condition对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Condition</span> <span class="variable">c1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">c2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">c3</span> <span class="operator">=</span> lock.newCondition();</span><br></pre></td></tr></table></figure>

<p>这段代码就相当于把lock绑定了三个Condition，可以通过c1或者c2，在不同的情况下是一个线程休眠或者唤醒一个线程。而synchronized想要关联多个条件，则需要添加多个锁。</p>
<h2 id="2、非阻塞同步"><a href="#2、非阻塞同步" class="headerlink" title="2、非阻塞同步"></a>2、非阻塞同步</h2><p>互斥同步不可避免的面临线程唤醒时带来的性能开销，这种也称为阻塞同步。互斥同步可以理解为一种悲观锁，即不加锁就一定会出问题，所以无论是否出现竞争，都会加锁，这会导致用户态切换到核心态的转换、维护锁计数器和检查是否有阻塞的线程等待唤醒。</p>
<p>随着硬件发展，有了另一种方案，基于冲突检测的乐观并发策略，即不管风险，直接进行操作，如果没有其他线程竞争，则执行成功，否则就一直尝试，直到没有竞争。这种方案不需要把线程阻塞挂起，因此也成为非阻塞同步。</p>
<p>JDK5之后，java类库开始使用CAS操作。CAS指令需要有三个操作数，分别是内存位置，旧的预期值以及准备设置的新值。当该指令执行时，仅当内存位置的值符合预期值时，才会用新的值去更新内存位置的值。</p>
<p>但是CAS检查并不一定能保证该值没有被修改过，例如一个值本来是1，在执行CAS操作时，它的值被改为了2，然后又被改为了1，虽然检查时还是1，但是值已经被修改了。</p>
<p>JUC包对此做了修改，控制变量的版本来保证没有被修改过。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入理解Java虚拟机》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Jvm</tag>
        <tag>深入理解Java虚拟机</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java锁优化</title>
    <url>/2023/03/30/Java/Java%E9%94%81%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>HostSpot虚拟机在 JDK 6 中实现了大量的锁优化技术，比如说适应性自旋，锁消除，锁膨胀，轻量级锁，偏向锁等。</p>
<h1 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h1><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>由于Java线程设计的原因，把一个线程挂机或者恢复都需要由用户态切换到核心态，这些都会给Java虚拟机带来很大的压力。但是由于现在用户的cpu都是多核的，可以让多个任务并行运行，所有很多共享数据锁的持有时间是很短的，如果因为这么短的时间就让一个线程挂起再恢复，很不值当。可以让一个线程等一小会儿，但不放弃处理时间，看看持有锁的线程是否很快会释放。而等的这个过程，我们只需要让线程忙循环（自旋），这就是自旋锁。</p>
<p>自旋锁并不能代替阻塞。如果持有锁的时间很短，那么自旋锁效率就很高，如果持有很长，自旋的线程占用着cpu却没有做有用的事，导致资源浪费。所以自旋锁一般设置循环次数，如果超过还没获取到锁，就挂起。</p>
<h2 id="自适应自旋"><a href="#自适应自旋" class="headerlink" title="自适应自旋"></a>自适应自旋</h2><p>JDK6中引入了自适应自旋，这时候自旋的次数不再是固定的了，改变为由上一次获取锁的时间以及锁持有者的状态来决定的。</p>
<p>如果在同一个对象上，自旋等待刚刚获取到锁，并且持有锁的线程正在运行，那么虚拟机就会认为这次自旋也会成功，而且允许这次自旋的持续时间长一点。</p>
<p>另一方面，如果获取的较少，那么可能会直接掠过。</p>
<h1 id="消除锁"><a href="#消除锁" class="headerlink" title="消除锁"></a>消除锁</h1><p>指的是虚拟机即时编译器在运行时，对那些检测到不可能存在共享数据竞争的锁进行消除。主要判定依据来源于逃逸分析的数据支持。</p>
<p>如果一段代码，在堆上的所有数据都不会逃逸出去被其他线程访问到，那么就可以把它们当作栈上的数据对待。</p>
<p>注意，这里的加的锁可能并不是程序员自己加的，可能是调用某些方法，而这些方法内部有同步块，而虚拟机会对这些方法内部的同步块所加的锁进行消除。</p>
<p>比如如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">add</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> str1 + str2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的那段代码在执行时会被优化为如下写法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">add</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    sb.append(str1);</span><br><span class="line">    sb.append(str2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StringBuilder的append方法内有同步块，所以会导致加锁，但是经过判定不需要这把锁，就会进行消除。因为这里没有其他线程会往该对象中添加数据。</p>
<h1 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h1><p>如果加锁释放锁的动作频繁执行，比如说在一个循环中，那么会影响性能，这时候就不能按照把锁的粒度尽可能缩小的原则。此时就可以在循环前加锁，循环结束后释放锁，虽然增大了锁的粒度，但是某些场景可以提高性能。</p>
<p>像上面的那个append操作，可以在第一个append之前加锁，然后最后一次append结束释放锁，这样就避免了一直加锁，释放锁。</p>
<h1 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h1><p>这个轻量级是相对于使用操作系统互斥量来实现的传统锁相比。它并不能代替传统的重量级锁，它的设计目的是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量造成的性能消耗。</p>
<p>HotSpot虚拟机的头部分为两部分，第一部分用于存储对象自身的运行时数据，例如哈希码，GC的分代年龄等，这部分被称为Mark Word。这部分对于轻量级锁和偏向锁实现很关键。另一部分用于存储指向方法区对象类型数据的指针。</p>
<p>Mark Word这部分有两比特空间用于存储锁的标记为。对象除了未被锁定的状态外，还会有轻量级锁定，重量级锁定，GC标记，可偏向等不同的状态。</p>
<p>在代码即将进入同步块的时候，如果此同步对象没有被锁定，虚拟机会在当前<strong>线程</strong>的栈帧中建立一个<strong>锁记录</strong>（Lock Record）的空间，用于存储对象目前Mark Word的拷贝（<strong>这一步意思是在当前线程中，存储一份该对象的Mark Word的拷贝</strong>）。然后虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向锁记录的指针（<strong>将对象的Mark Word更新为指向线程的锁记录</strong>）。如果更新成功，即代表该线程拥有了该对象的锁，并且将Mark Word的锁标记位改为轻量级锁。</p>
<p>如果这次更新失败，说明至少有一个线程与当前线程竞争获取该对象的锁。此时，虚拟机会先检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明已经获取到该对象的锁，直接执行就可以了，否则说明该锁被其他线程占用了。如果出现两条以上的线程争用同一个对象，那么就要膨胀为重量级锁。</p>
<p>它的解锁过程也是CAS操作实现的。如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前Mark Word和线程中复制的那一份拷贝替换回来。如果替换成功，则同步过程就成功了，如果替换失败，则说明有其他线程尝试获取过该锁，就要在释放锁的同时，唤醒被挂起的线程。</p>
<h1 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h1><p>偏向锁的目的是消除在无竞争情况下的同步原语，进一步提高性能。轻量级锁是在无竞争情况下使用CAS操作区消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS都不需要。</p>
<p>偏向锁会偏向于第一个获取它的线程，如果接下来执行的过程中，该锁一直没有被其他线程获取，那么持有偏向锁的线程则不需要进行同步。</p>
<p>具体来说，偏向锁会在对象头中存储一个标识，用于标记是否开启偏向锁。当一个线程访问对象时，如果该对象没有被锁定，则该线程会将对象头中的标识设置为当前线程的ID，并将偏向锁标识设置为1。之后，该线程访问该对象时，会直接进入偏向锁模式，无需再次加锁，从而提高了程序的性能。</p>
<p>当其他线程访问该对象时，会发现该对象已经被标记为偏向锁，并且偏向锁标识为1，此时会检查该对象的偏向线程ID是否为当前线程的ID，如果是，则直接进入偏向模式，否则表示有竞争发生，会将偏向锁升级为轻量级锁或重量级锁。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入理解Java虚拟机》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Jvm</tag>
        <tag>锁</tag>
        <tag>深入理解Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/08/09/Java/Mybatis%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A4%8D%E6%9D%82%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Mybatis的一些复杂写法"><a href="#Mybatis的一些复杂写法" class="headerlink" title="Mybatis的一些复杂写法"></a>Mybatis的一些复杂写法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 这里拿到的是key</span><br><span class="line">&lt;foreach collection=<span class="string">&quot;columns.keys&quot;</span> item=<span class="string">&quot;key&quot;</span> separator=<span class="string">&quot;,&quot;</span> open=<span class="string">&quot;(&quot;</span> close=<span class="string">&quot;)&quot;</span>&gt;</span><br><span class="line">    #&#123;key&#125;</span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line"># 这里拿到的也是value</span><br><span class="line">&lt;foreach collection=<span class="string">&quot;columns.keys&quot;</span> item=<span class="string">&quot;key&quot;</span> separator=<span class="string">&quot;,&quot;</span> open=<span class="string">&quot;(&quot;</span> close=<span class="string">&quot;)&quot;</span>&gt;</span><br><span class="line">    #&#123;columns[$&#123;key&#125;]&#125;</span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line"># 这里拿到的是value</span><br><span class="line">&lt;foreach collection=<span class="string">&quot;columns.values&quot;</span> item=<span class="string">&quot;key&quot;</span> separator=<span class="string">&quot;,&quot;</span> open=<span class="string">&quot;(&quot;</span> close=<span class="string">&quot;)&quot;</span>&gt;</span><br><span class="line">    #&#123;key&#125;</span><br><span class="line">&lt;/foreach&gt;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>NIO优化实现原理</title>
    <url>/2023/05/29/Java/NIO%E4%BC%98%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="网络-I-x2F-O-模型优化"><a href="#网络-I-x2F-O-模型优化" class="headerlink" title="网络 I&#x2F;O 模型优化"></a>网络 I&#x2F;O 模型优化</h1><p>最开始的阻塞式 I&#x2F;O，它在每一个连接创建时，都需要一个用户线程来处理，并且在 I&#x2F;O 操作 没有就绪或结束时，线程会被挂起，进入阻塞等待状态，阻塞式 I&#x2F;O 就成为了导致性能瓶颈的 根本原因。</p>
<p>首先是一次简单的TCP数据传输：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529150511602.png" alt="image-20230529150511602" style="zoom:67%;" />

<p>首先，应用程序通过系统调用 socket 创建一个套接字，它是系统分配给应用程序的一个文件描述符；</p>
<p>其次，应用程序会通过系统调用 bind，绑定地址和端口号，给套接字命名一个名称； </p>
<p>然后，系统会调用 listen 创建一个队列用于存放客户端进来的连接； </p>
<p>最后，应用服务会通过系统调用 accept 来监听客户端的连接请求。</p>
<h2 id="1-阻塞式-I-x2F-O"><a href="#1-阻塞式-I-x2F-O" class="headerlink" title="1. 阻塞式 I&#x2F;O"></a>1. 阻塞式 I&#x2F;O</h2><p>在整个 socket 通信工作流程中，socket 的默认状态是阻塞的。也就是说，当发出一个不能立 即完成的套接字调用时，其进程将被阻塞，被系统挂起，进入睡眠状态，一直等待相应的操作 响应。从上图中，我们可以发现，可能存在的阻塞主要包括以下三种。</p>
<p><strong>connect阻塞：</strong></p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529153114099.png" alt="image-20230529153114099" style="zoom:67%;" />

<p><strong>accept阻塞：</strong></p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529153138808.png" alt="image-20230529153138808" style="zoom:67%;" />

<p><strong>read、write 阻塞：</strong></p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529153200868.png" alt="image-20230529153200868" style="zoom:67%;" />

<h2 id="2-非阻塞式-I-x2F-O"><a href="#2-非阻塞式-I-x2F-O" class="headerlink" title="2. 非阻塞式 I&#x2F;O"></a>2. 非阻塞式 I&#x2F;O</h2><p>当我们把以上操作设置为了非阻塞状态，我们需要设置一个线程对该操作进行轮询检查，这也是最传统的非阻塞 I&#x2F;O 模型。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529153340669.png" alt="image-20230529153340669" style="zoom:67%;" />

<h2 id="3-I-x2F-O-复用"><a href="#3-I-x2F-O-复用" class="headerlink" title="3. I&#x2F;O 复用"></a>3. I&#x2F;O 复用</h2><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529160244459.png" alt="image-20230529160244459" style="zoom:67%;" />

<h2 id="4-信号驱动式-I-x2F-O"><a href="#4-信号驱动式-I-x2F-O" class="headerlink" title="4. 信号驱动式 I&#x2F;O"></a>4. 信号驱动式 I&#x2F;O</h2><p>信号驱动式 I&#x2F;O 类似观察者模式，内核就是一个观察者，信号回调则是通知。用户进程发起一 个 I&#x2F;O 请求操作，会通过系统调用 sigaction 函数，给对应的套接字注册一个信号回调，此时 不阻塞用户进程，进程会继续工作。当内核数据就绪时，内核就为该进程生成一个 SIGIO 信 号，通过信号回调通知进程进行相关 I&#x2F;O 操作。</p>
<p>信号驱动式 I&#x2F;O 相比于前三种 I&#x2F;O 模式，实现了在等待数据就绪时，进程不被阻塞，主循环可以继续工作，所以性能更佳。</p>
<h2 id="5-异步-I-x2F-O"><a href="#5-异步-I-x2F-O" class="headerlink" title="5. 异步 I&#x2F;O"></a>5. 异步 I&#x2F;O</h2><p>信号驱动式 I&#x2F;O 虽然在等待数据就绪时，没有阻塞进程，但在被通知后进行的 I&#x2F;O 操作还是 阻塞的，进程会等待数据从内核空间复制到用户空间中。而异步 I&#x2F;O 则是实现了真正的非阻塞 I&#x2F;O。</p>
<p>当用户进程发起一个 I&#x2F;O 请求操作，系统会告知内核启动某个操作，并让内核在整个操作完成 后通知进程。这个操作包括等待数据就绪和数据从内核复制到用户空间。</p>
<p>linux不支持，比较少见。</p>
<p>在 NIO 服务端通信编程中，首先会创建一个 Channel，用于监听客户端连接；接着，创建多 路复用器 Selector，并将 Channel 注册到 Selector，程序会通过 Selector 来轮询注册在其 上的 Channel，当发现一个或多个 Channel 处于就绪状态时，返回就绪的监听事件，最后程 序匹配到监听事件，进行相关的 I&#x2F;O 操作。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529175854015.png" alt="image-20230529175854015" style="zoom:67%;" />

<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>零拷贝是一种避免多次内存复制的技术，用来优化读写 I&#x2F;O 操作。</p>
<p>在网络编程中，通常由 read、write 来完成一次 I&#x2F;O 读写操作。每一次 I&#x2F;O 读写操作都需要 完成四次内存拷贝，路径是 I&#x2F;O 设备 -&gt; 内核空间 -&gt; 用户空间 -&gt; 内核空间 -&gt; 其它 I&#x2F;O 设 备。</p>
<p>Linux 内核中的 mmap 函数可以代替 read、write 的 I&#x2F;O 读写操作，实现用户空间和内核空间共享一个缓存数据。mmap 将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址，不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射 到物理内存地址。这种方式避免了内核空间与用户空间的数据交换。I&#x2F;O 复用中的 epoll 函数 中就是使用了 mmap 减少了内存拷贝。</p>
<h2 id="线程模型优化"><a href="#线程模型优化" class="headerlink" title="线程模型优化"></a>线程模型优化</h2><p>NIO 是基于事件驱动模型 来实现的 I&#x2F;O 操作。Reactor 模型是同步 I&#x2F;O 事件处理的一种常见模型，其核心思想是将 I&#x2F;O 事件注册到多路复用器上，一旦有 I&#x2F;O 事件触发，多路复用器就会将事件分发到事件处理器 中，执行就绪的 I&#x2F;O 事件操作。</p>
<p>该模型有以下三个主要组件：</p>
<p>事件接收器 Acceptor：主要负责接收请求连接； </p>
<p>事件分离器 Reactor：接收请求后，会将建立的连接注册到分离器中，依赖于循环监听多路 复用器 Selector，一旦监听到事件，就会将事件 dispatch 到事件处理器； </p>
<p>事件处理器 Handlers：事件处理器主要是完成相关的事件处理，比如读写 I&#x2F;O 操作。</p>
<h3 id="1-单线程-Reactor-线程模型"><a href="#1-单线程-Reactor-线程模型" class="headerlink" title="1. 单线程 Reactor 线程模型"></a>1. 单线程 Reactor 线程模型</h3><p>最开始 NIO 是基于单线程实现的，所有的 I&#x2F;O 操作都是在一个 NIO 线程上完成。由于 NIO 是非阻塞 I&#x2F;O，理论上一个线程可以完成所有的 I&#x2F;O 操作。</p>
<p>但 NIO 其实还不算真正地实现了非阻塞 I&#x2F;O 操作，因为读写 I&#x2F;O 操作时用户进程还是处于阻 塞状态，这种方式在高负载、高并发的场景下会存在性能瓶颈，一个 NIO 线程如果同时处理 上万连接的 I&#x2F;O 操作，系统是无法支撑这种量级的请求的。</p>
<h3 id="2-多线程-Reactor-线程模型"><a href="#2-多线程-Reactor-线程模型" class="headerlink" title="2. 多线程 Reactor 线程模型"></a>2. 多线程 Reactor 线程模型</h3><p>为了解决这种单线程的 NIO 在高负载、高并发场景下的性能瓶颈，后来使用了线程池。</p>
<p>在 Tomcat 和 Netty 中都使用了一个 Acceptor 线程来监听连接请求事件，当连接成功之 后，会将建立的连接注册到多路复用器中，一旦监听到事件，将交给 Worker 线程池来负责处理。</p>
<h3 id="3-主从-Reactor-线程模型"><a href="#3-主从-Reactor-线程模型" class="headerlink" title="3. 主从 Reactor 线程模型"></a>3. 主从 Reactor 线程模型</h3><p>现在主流通信框架中的 NIO 通信框架都是基于主从 Reactor 线程模型来实现的。在这个模型 中，Acceptor 不再是一个单独的 NIO 线程，而是一个线程池。Acceptor 接收到客户端的 TCP 连接请求，建立连接之后，后续的 I&#x2F;O 操作将交给 Worker I&#x2F;O 线程。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529200317906.png" alt="image-20230529200317906" style="zoom:67%;" />

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Java性能调优实战》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>调优</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty源码简单解读</title>
    <url>/2023/10/29/Java/Netty%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p>注：仅仅是尝试看源码，锻炼一下看源码能力，理解并不一定正确。</p>
<h1 id="Netty的服务端创建"><a href="#Netty的服务端创建" class="headerlink" title="Netty的服务端创建"></a>Netty的服务端创建</h1><p>创建代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">    <span class="comment">// 接收新连接线程，创建新的连接</span></span><br><span class="line">    <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    <span class="comment">// 对应读取数据的线程，用于处理数据读取以及业务逻辑处理</span></span><br><span class="line">    <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    serverBootstrap</span><br><span class="line">        .group(boss, worker)</span><br><span class="line">        <span class="comment">// 这里是接收一个Channel的类型，然后通过反射创建一个工厂类</span></span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        <span class="comment">// 这个NioSocketChannel是Netty设计的</span></span><br><span class="line">        .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        System.out.println(s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).bind(<span class="number">8000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="group-boss-worker"><a href="#group-boss-worker" class="headerlink" title="group(boss, worker)"></a>group(boss, worker)</h2><p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerBootstrap</span> <span class="keyword">extends</span> <span class="title class_">AbstractBootstrap</span>&lt;ServerBootstrap, ServerChannel&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> EventLoopGroup childGroup;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ServerBootstrap <span class="title function_">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.group(parentGroup);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.childGroup != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;childGroup set already&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.childGroup = (EventLoopGroup)ObjectUtil.checkNotNull(childGroup, <span class="string">&quot;childGroup&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，将boss也就是parentGroup传递给了父类的<code>group</code>方法，即<code>AbstractBootstrap</code>，而将worker传递给了<code>ServerBootstrap</code> ，并将ServerBootstrap返回。</p>
<p>父类的group方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBootstrap</span>&lt;B <span class="keyword">extends</span> <span class="title class_">AbstractBootstrap</span>&lt;B, C&gt;, C <span class="keyword">extends</span> <span class="title class_">Channel</span>&gt; <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> EventLoopGroup group;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> B <span class="title function_">group</span><span class="params">(EventLoopGroup group)</span> &#123;</span><br><span class="line">        ObjectUtil.checkNotNull(group, <span class="string">&quot;group&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.group != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;group set already&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.group = group;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.self();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对于这个group方法，做的事情比较简单，将两个<code>NioEventLoopGroup</code>传递给<code>ServerBootstrap</code>，然后将赋值后的<code>ServerBootstrap</code>返回。</p>
<h2 id="channel-NioServerSocketChannel-class"><a href="#channel-NioServerSocketChannel-class" class="headerlink" title="channel(NioServerSocketChannel.class)"></a>channel(NioServerSocketChannel.class)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> B <span class="title function_">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.channelFactory((io.netty.channel.ChannelFactory)(<span class="keyword">new</span> <span class="title class_">ReflectiveChannelFactory</span>((Class)ObjectUtil.checkNotNull(channelClass, <span class="string">&quot;channelClass&quot;</span>))));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段代码涉及到一个工厂类的创建<code>new ReflectiveChannelFactory()</code>，该工厂类的创建需要接收传入的<code>channelClass</code></p>
<p>工厂类的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectiveChannelFactory</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Channel</span>&gt; <span class="keyword">implements</span> <span class="title class_">ChannelFactory</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; constructor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReflectiveChannelFactory</span><span class="params">(Class&lt;? extends T&gt; clazz)</span> &#123;</span><br><span class="line">        ObjectUtil.checkNotNull(clazz, <span class="string">&quot;clazz&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.constructor = clazz.getConstructor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Class &quot;</span> + StringUtil.simpleClassName(clazz) + <span class="string">&quot; does not have a public non-arg constructor&quot;</span>, var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是通过反射，获取了传入类的构造方法。</p>
<p>另一个方法就是<code>this.channelFactory()</code>，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> B <span class="title function_">channelFactory</span><span class="params">(io.netty.channel.ChannelFactory&lt;? extends C&gt; channelFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.channelFactory((ChannelFactory)channelFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> B <span class="title function_">channelFactory</span><span class="params">(ChannelFactory&lt;? extends C&gt; channelFactory)</span> &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(channelFactory, <span class="string">&quot;channelFactory&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.channelFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;channelFactory set already&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.channelFactory = channelFactory;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.self();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里做的事情就是将上一步创建的<code>ReflectiveChannelFactory</code>赋值给<code>AbstractBootstrap</code>的<code>ChannelFactory</code>。</p>
<p>因为在创建<code>ReflectiveChannelFactory</code>时，获取到了传入class的构造方法，就可以创建对应的对象。</p>
<h2 id="childHandler-new-ChannelInitializer"><a href="#childHandler-new-ChannelInitializer" class="headerlink" title="childHandler(new ChannelInitializer(){}"></a>childHandler(new ChannelInitializer<NioSocketChannel>(){}</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerBootstrap</span> <span class="keyword">extends</span> <span class="title class_">AbstractBootstrap</span>&lt;ServerBootstrap, ServerChannel&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ChannelHandler childHandler;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ServerBootstrap <span class="title function_">childHandler</span><span class="params">(ChannelHandler childHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.childHandler = (ChannelHandler)ObjectUtil.checkNotNull(childHandler, <span class="string">&quot;childHandler&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是一个成员属性的赋值，主要看创建<code>ChannelHandler</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ChannelInitializer</span>&lt;C <span class="keyword">extends</span> <span class="title class_">Channel</span>&gt; <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 这是一个抽象方法，必须实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(C var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 案例中重写的代码如下：</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">    nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="comment">// 重写的这个方法就是我们要做的业务逻辑处理</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">// 这个方法，客户端传递数据时应该会调用</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 案例中方法重写的代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;I&gt; <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext var1, I var2)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Netty客户端创建"><a href="#Netty客户端创建" class="headerlink" title="Netty客户端创建"></a>Netty客户端创建</h1><p>创建代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">    <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">    bootstrap.group(group)</span><br><span class="line">        .channel(NioSocketChannel.class)</span><br><span class="line">        .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8000</span>).channel();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: hello world&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就存在了第一个区别<code> ServerBootstrap</code> 和 <code>Bootstrap</code></p>
<p><code>Bootstrap</code>并没有自己的group方法，它是直接调用了父类的group，也就是说传入的group直接赋值给了<code>AbstractBootstrap</code>的<code>EventLoopGroup</code>。</p>
<p>其他的代码与服务端差不多，主要看<code>writeAndFlush</code>和<code>connect</code></p>
<h2 id="writeAndFlush"><a href="#writeAndFlush" class="headerlink" title="writeAndFlush"></a>writeAndFlush</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractChannel</span> <span class="keyword">extends</span> <span class="title class_">DefaultAttributeMap</span> <span class="keyword">implements</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line">    <span class="comment">// 默认的管道</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultChannelPipeline pipeline;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ChannelFuture <span class="title function_">writeAndFlush</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.pipeline.writeAndFlush(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultChannelPipeline</span> <span class="keyword">implements</span> <span class="title class_">ChannelPipeline</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext tail;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title function_">writeAndFlush</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.tail.writeAndFlush(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractChannelHandlerContext</span> <span class="keyword">implements</span> <span class="title class_">ChannelHandlerContext</span>, ResourceLeakHint &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> EventExecutor executor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultChannelPipeline pipeline;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ChannelFuture <span class="title function_">writeAndFlush</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.writeAndFlush(msg, <span class="built_in">this</span>.newPromise());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ChannelPromise <span class="title function_">newPromise</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(<span class="built_in">this</span>.channel(), <span class="built_in">this</span>.executor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Channel <span class="title function_">channel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.pipeline.channel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EventExecutor <span class="title function_">executor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (EventExecutor)(<span class="built_in">this</span>.executor == <span class="literal">null</span> ? <span class="built_in">this</span>.channel().eventLoop() : <span class="built_in">this</span>.executor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ChannelFuture <span class="title function_">writeAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.write(msg, <span class="literal">true</span>, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(Object msg, <span class="type">boolean</span> flush, ChannelPromise promise)</span> &#123;</span><br><span class="line">        ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里，如果promise不可用，那么就释放消息</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isNotValidPromise(promise, <span class="literal">true</span>)) &#123;</span><br><span class="line">                ReferenceCountUtil.release(msg);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException var8) &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">            <span class="keyword">throw</span> var8;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">AbstractChannelHandlerContext</span> <span class="variable">next</span> <span class="operator">=</span> <span class="built_in">this</span>.findContextOutbound(flush ? <span class="number">98304</span> : <span class="string">&#x27;耀&#x27;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> <span class="built_in">this</span>.pipeline.touch(msg, next);</span><br><span class="line">        <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">        <span class="comment">// 这里是判断当前的任务是否在循环当中</span></span><br><span class="line">        <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">                next.invokeWriteAndFlush(m, promise);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next.invokeWrite(m, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AbstractChannelHandlerContext.<span class="type">WriteTask</span> <span class="variable">task</span> <span class="operator">=</span> AbstractChannelHandlerContext.WriteTask.newInstance(next, m, promise, flush);</span><br><span class="line">            <span class="keyword">if</span> (!safeExecute(executor, task, promise, m, !flush)) &#123;</span><br><span class="line">                task.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>个人心得</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Lock和Condition</title>
    <url>/2023/05/05/Java/Lock%E5%92%8CCondition/</url>
    <content><![CDATA[<p> Java当中，Lock和Condition一起使用的时候，可以实现多条件的并发，一个最简单的例子就是阻塞队列，它的实现需要两个条件变量，一个是队列不为空，另一个是队列不能满。</p>
<p>一个简单的例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockedQueue</span>&lt;T&gt;&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="comment">// 条件变量：队列不满</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">  <span class="comment">// 条件变量：队列不空</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">enq</span><span class="params">(T x)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (队列已满) &#123;</span><br><span class="line">        <span class="comment">// 等待队列不满，这里就是阻塞线程</span></span><br><span class="line">        notFull.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 省略入队操作...</span></span><br><span class="line">      <span class="comment">// 入队后,通知可出队，这里是有元素入队后，满足条件，然后唤醒线程</span></span><br><span class="line">      notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">deq</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (队列已空) &#123;</span><br><span class="line">        <span class="comment">// 等待队列不空</span></span><br><span class="line">        notEmpty.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 省略出队操作...</span></span><br><span class="line">      <span class="comment">// 出队后，通知可入队</span></span><br><span class="line">      notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h1><p><strong>通俗点来讲就是调用方是否需要等待结果，如果需要等待结果，就是同步；如果不需要等待结果，就是异步</strong>。</p>
<p>异步实现的方法：</p>
<p>1、调用方创建一个子线程，在子线程中执行方法调用，这种调用我们称为异步调用；</p>
<p>2、方法实现的时候，创建一个新的线程执行主要逻辑，主线程直接 return，这种方法我们一般称为异步方法。</p>
<h1 id="Dubbo的异步实现逻辑"><a href="#Dubbo的异步实现逻辑" class="headerlink" title="Dubbo的异步实现逻辑"></a>Dubbo的异步实现逻辑</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建锁与条件变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">done</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="comment">// 调用方通过该方法等待结果</span></span><br><span class="line">Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (!isDone()) &#123;</span><br><span class="line">        done.await(timeout);</span><br><span class="line">        <span class="type">long</span> <span class="variable">cur</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="keyword">if</span> (isDone() || cur - start &gt; timeout) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  	lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">  	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> returnFromResponse();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RPC结果是否已经返回</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> response != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RPC结果返回时调用该方法   </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReceived</span><span class="params">(Response res)</span> &#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    response = res;</span><br><span class="line">    <span class="keyword">if</span> (done != <span class="literal">null</span>) &#123;</span><br><span class="line">      done.signal();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>StampedLock</title>
    <url>/2023/05/04/Java/StampedLock/</url>
    <content><![CDATA[<h2 id="StampedLock-支持的三种锁模式"><a href="#StampedLock-支持的三种锁模式" class="headerlink" title="StampedLock 支持的三种锁模式"></a>StampedLock 支持的三种锁模式</h2><p>StampedLock 支持三种模式，分别是：<strong>写锁</strong>、<strong>悲观读锁</strong>和<strong>乐观读</strong>。其中，写锁、悲观读锁的语义和 ReadWriteLock 的写锁、读锁的语义非常类似，<strong>允许多个线程同时获取悲观读锁，但是只允许一个线程获取写锁，写锁和悲观读锁是互斥的</strong>。</p>
<p>不同的是：StampedLock 里的写锁和悲观读锁加锁成功之后，都会返回一个 stamp；然后解锁的时候，需要传入这个 stamp。示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 获取/释放悲观读锁示意代码</span></span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.readLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//省略业务相关代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  sl.unlockRead(stamp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取/释放写锁示意代码</span></span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.writeLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//省略业务相关代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  sl.unlockWrite(stamp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>StampedLock 的性能之所以比 ReadWriteLock 还要好，其关键是 StampedLock 支持乐观读的方式。ReadWriteLock 支持多个线程同时读，但是当多个线程同时读的时候，所有的写操作会被阻塞；而 StampedLock 提供的乐观读，是<strong>允许一个线程获取写锁</strong>的，也就是说不是所有的写操作都被阻塞。一个使用乐观读的示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line">    <span class="comment">//计算到原点的距离  </span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">distanceFromOrigin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 乐观读</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.tryOptimisticRead();</span><br><span class="line">        <span class="comment">// 读入局部变量，</span></span><br><span class="line">        <span class="comment">// 读的过程数据可能被修改</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curX</span> <span class="operator">=</span> x, curY = y;</span><br><span class="line">        <span class="comment">// 判断执行读操作期间，</span></span><br><span class="line">        <span class="comment">// 是否存在写操作，如果存在，</span></span><br><span class="line">        <span class="comment">// 则sl.validate返回false</span></span><br><span class="line">        <span class="keyword">if</span> (!sl.validate(stamp))&#123;</span><br><span class="line">            <span class="comment">// 升级为悲观读锁</span></span><br><span class="line">            stamp = sl.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                curX = x;</span><br><span class="line">                curY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放悲观读锁</span></span><br><span class="line">                sl.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(</span><br><span class="line">            curX * curX + curY * curY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现尝试读取x和y，读取完后判断是否被修改了，如果被修改就升级为悲观读锁，否则直接计算。</p>
<h2 id="StampedLock-使用注意事项"><a href="#StampedLock-使用注意事项" class="headerlink" title="StampedLock 使用注意事项"></a>StampedLock 使用注意事项</h2><p><strong>StampedLock 不支持重入</strong>。StampedLock 的悲观读锁、写锁都不支持条件变量。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Synchronized的使用</title>
    <url>/2023/04/20/Java/Synchronized%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p> 考虑如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncTest</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SyncTest</span> <span class="variable">syncTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyncTest</span>();</span><br><span class="line">        <span class="type">SyncTest</span> <span class="variable">syncTest1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyncTest</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(syncTest, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(syncTest1, <span class="string">&quot;thread2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在run方法上加了synchronized，也就意味着锁住的是该对象，也就是synchronized（this），当我们实例化两个对象时，他们是互相不影响的，所以打印结果如下：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230420161141896.png" alt="image-20230420161141896" style="zoom: 80%;" />

<p>另一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt) &#123;</span><br><span class="line">      <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">      target.balance += amt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写，在转账的场景中并不能解决问题。</p>
<p>因为synchronized锁的是当前对象，它并不能锁住传进来的target，也就是说，如果此时实例化的对象是A，然后调用A.transfer(B, 100),它只能锁住A的balance，并不能锁住B的balance还会存在另一个线程修改B的balance的问题。</p>
<p>一开始看到这里有一个疑问，为什么不直接在接口中锁主呢，像如下写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JSONObject <span class="title function_">testInterface</span><span class="params">(<span class="meta">@RequestBody</span> Map&lt;String, Object&gt; map)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> crudServiceImpl.getCrudValue(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法会导致另外一个问题，也就是说我在A给B转账时，会进行加锁，导致C给D转账的时候，也无法进行。也就是说这种写法会导致锁的粒度太大，在实际场景中是无法使用的。</p>
<p>第一个优化版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target, <span class="type">int</span> amt)</span>&#123;</span><br><span class="line">    <span class="comment">// 锁定转出账户</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">      <span class="comment">// 锁定转入账户</span></span><br><span class="line">      <span class="keyword">synchronized</span>(target)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt) &#123;</span><br><span class="line">          <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">          target.balance += amt;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写可以保证this 和target都被锁住，达到我们预期地效果。但是也存在问题，如果A给B转账地同时，B也要给A转账，那么就会出现死锁。两者同时锁this，也就是对象A和对象B都被锁住，然后往下执行时，发现请求资源已经被锁，导致死锁。</p>
<p>第二个优化版本，防止死锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Allocator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; als = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次性申请所有资源</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(Object from, Object to)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (als.contains(from) || als.contains(to)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            als.add(from);</span><br><span class="line">            als.add(to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归还资源</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">(Object from, Object to)</span> &#123;</span><br><span class="line">        als.remove(from);</span><br><span class="line">        als.remove(to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// actr应该为单例</span></span><br><span class="line">    <span class="keyword">private</span> Allocator actr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转账</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">        <span class="comment">// 一次性申请转出账户和转入账户，直到成功</span></span><br><span class="line">        <span class="keyword">while</span> (!actr.apply(<span class="built_in">this</span>, target));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 锁定转出账户</span></span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 锁定转入账户</span></span><br><span class="line">                <span class="keyword">synchronized</span>(target) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">                        target.balance += amt;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            actr.free(<span class="built_in">this</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个版本中，Allocator是一个单例，也就意味着只有一个，然后在加锁之前，先判断是否可以同时获取两个对象的锁，如果可以，再进行加锁。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>上述代码都忽略了在两个线程中new 出来的对象不是同一个的问题。也就是说，transfer里传入的对象，在另一个线程中也是这两个。仅作为演示破会死锁。</p>
<p>而事实情况是，如果这段代码放在两个不同的线程中运行，线程A实例化account C和D，线程B实例化account C和D，在线程A执行transfer（C，D），在线程B执行transfer（D，C）还是有可能会发生死锁。</p>
<p>而上述代码的逻辑是建立在线程A 实例化的C和D 与线程B实例化的C和D是同一个对象。</p>
]]></content>
      <categories>
        <category>个人心得</category>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Volatile关键字</title>
    <url>/2023/03/23/Java/Volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="内存模型对volatile的特殊处理"><a href="#内存模型对volatile的特殊处理" class="headerlink" title="内存模型对volatile的特殊处理"></a>内存模型对volatile的特殊处理</h1><p>当一个变量被定义成volatile之后，它将具备两项特性：</p>
<p>特征一、保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。</p>
<p>而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。比如A修改了一个值，这个值要写回主内存，而线程B只有在A写回主内存后并且读取主内存，才会得知该值改变了。</p>
<p>volatile变量在各个线程的工作内存中是不存在一致性问题的（从物理存储的角度看，各个线程的工作内存中volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是<strong>Java里面的运算操作符并非原子操作</strong>，这导致volatile变量的运算在并发下一样是不安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">race</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">		race++;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THREADS_COUNT</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[THREADS_COUNT];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">		threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">					increase();</span><br><span class="line">				&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		threads[i].start();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 等待所有累加线程都结束</span></span><br><span class="line">	<span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>)</span><br><span class="line">		Thread.<span class="keyword">yield</span>();</span><br><span class="line">		System.out.println(race);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码开了20个线程来对race变量进行++，但是会发现每次运行都是不一样的数。volatile关键字保证了race被取到操作栈顶时是正确的，但是在执行race++操作时，由于++操作不是原子进行的。反编译后increase（）方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span>;</span><br><span class="line">Code:</span><br><span class="line">Stack=<span class="number">2</span>, Locals=<span class="number">0</span>, Args_size=<span class="number">0</span></span><br><span class="line"><span class="number">0</span>: getstatic #<span class="number">13</span>; <span class="comment">//Field race:I</span></span><br><span class="line"><span class="number">3</span>: iconst_1</span><br><span class="line"><span class="number">4</span>: iadd</span><br><span class="line"><span class="number">5</span>: putstatic #<span class="number">13</span>; <span class="comment">//Field race:I</span></span><br><span class="line"><span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">LineNumberTable:</span><br><span class="line">line <span class="number">14</span>: <span class="number">0</span></span><br><span class="line">line <span class="number">15</span>: <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>这步++有4个命令，在中途会被中断，然后其他线程会对race进行修改，而中断完之后再回来执行，就有可能把旧值写到race。</p>
<p>由于volatile关键字只能保证可见性，所以<strong>不符合</strong>以下场景中需要加锁来保证原子性：</p>
<p>​	1）运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</p>
<p>​	2）变量不需要与其他的状态变量共同参与不变约束。</p>
<p>特征二、<strong>volatile变量禁止指令重排序优化</strong>，普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。</p>
<p>使用volatile修饰的变量，在进行编译后会生成一个内存屏障（与垃圾回收那里的内存屏障不同），表示重排序时，屏障后面的指令不能出现再屏障之前。当只有一个处理器时，并不需要屏障，但是当有多个，则需要屏障来保证一致性。</p>
<p>从硬件上讲，指令重排序指处理器采用了允许将多条指令不按程序的顺序分开发送给各个相应的电路单元进行处理，并不是指可以任意排序，因为要保证运行结果与正序运行一致。</p>
<h1 id="一些其他的规定"><a href="#一些其他的规定" class="headerlink" title="一些其他的规定"></a>一些其他的规定</h1><p>1、使用volatile修饰的关键字还有一些规定：只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。线程T对变量V的use动作可以认为是和线程T对变量V的load、read动作相关联的，必须连续且一起出现。</p>
<p>这条规则要求在工作内存中，每次使用V前都必须先<strong>从主内存刷新最新的值</strong>，<strong>用于保证能看见其他线程对变量V所做的修改</strong>。</p>
<p>2、只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign动作。线程T对变量V的assign动作可以认为是和线程T对变量V的store、write动作相关联的，必须连续且一起出现。</p>
<p>这条规则要求在工作内存中，每次修改V后都必须<strong>立刻同步回主内存中</strong>，用于保证其他线程可以看到自己对变量V所做的修改。</p>
<p>3、假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动作，假定动作P是和动作F相应的对变量V的read或write动作；与此类似，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的对变量W的read或write动作。如果A先于B，那么P先于Q。</p>
<p>这条规则要求volatile修饰的变量不会被指令重排序优化，从而保证代码的执行顺序与程序的顺序相同。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>volatile关键字其实只是保证了在每个线程之间可以感知到数据的变化。使用volatile修饰的关键字，在每次使用时都会刷新，拿到最新的值。而且对该关键字修改可以直接让其他线程感知到，并不需要像普通关键字，先由线程A的工作内存写入主内存，然后线程B从主内存读取才能感知到数据的变化。另一特性就是使用volatile修饰的关键字不会受指令重排序的影响。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入理解Java虚拟机》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal</title>
    <url>/2023/05/23/Java/ThreadLocal/</url>
    <content><![CDATA[<h1 id="ThreadLocal-的使用方法"><a href="#ThreadLocal-的使用方法" class="headerlink" title="ThreadLocal 的使用方法"></a>ThreadLocal 的使用方法</h1><p>下面这个静态类 ThreadId 会为每个线程分配一个唯一的线程 Id，如果<strong>一个线程</strong>前后两次调用 ThreadId 的 get() 方法，两次 get() 方法的返回值是相同的。但如果是<strong>两个线程</strong>分别调用 ThreadId 的 get() 方法，那么两个线程看到的 get() 方法的返回值是不同的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadId</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">nextId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 定义ThreadLocal变量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; tl = ThreadLocal.withInitial(() -&gt; nextId.getAndIncrement());</span><br><span class="line">  <span class="comment">//此方法会为每个线程分配一个唯一的Id</span></span><br><span class="line">  <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tl.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个使用场景：</p>
<p>SimpleDateFormat 不是线程安全的，那如果需要在并发场景下使用它，就可以使用ThreadLocal 来解决。不同线程调用 SafeDateFormat 的 get() 方法将返回不同的 SimpleDateFormat 对象实例，由于不同线程并不共享 SimpleDateFormat，所以就像局部变量一样，是线程安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SafeDateFormat</span> &#123;</span><br><span class="line">  <span class="comment">// 定义ThreadLocal变量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; tl = ThreadLocal.withInitial(()-&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(</span><br><span class="line">      <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> DateFormat <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tl.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不同线程执行下面代码</span></span><br><span class="line"><span class="comment">// 返回的df是不同的</span></span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> SafeDateFormat.get()；</span><br></pre></td></tr></table></figure>

<h1 id="ThreadLocal-的工作原理"><a href="#ThreadLocal-的工作原理" class="headerlink" title="ThreadLocal 的工作原理"></a>ThreadLocal 的工作原理</h1><p>Java对于ThreadLocal 的实现，也有一个Map，叫做 ThreadLocalMap，不过持有 ThreadLocalMap 的不是 ThreadLocal，而是 Thread。Thread 这个类内部有一个私有属性 threadLocals，其类型就是 ThreadLocalMap，ThreadLocalMap 的 Key 是 ThreadLocal。如下图所示：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230523162923334.png" alt="image-20230523162923334" style="zoom:80%;" />

<h2 id="另一种设计方案"><a href="#另一种设计方案" class="headerlink" title="另一种设计方案"></a>另一种设计方案</h2><p>如果我们仅仅是简单的用一个Map来保存，即Map的key是线程id，value是每个线程拥有的变量V。这样会导致一个问题，那就是线程的id一直被引用，导致线程资源无法被回收。</p>
<h1 id="ThreadLocal-与内存泄露"><a href="#ThreadLocal-与内存泄露" class="headerlink" title="ThreadLocal 与内存泄露"></a>ThreadLocal 与内存泄露</h1><p>在线程池中使用 ThreadLocal 为什么可能导致内存泄露呢？原因就出在线程池中线程的存活时间太长，往往都是和程序同生共死的，这就意味着 Thread 持有的 ThreadLocalMap 一直都不会被回收，再加上 ThreadLocalMap 中的 Entry 对 ThreadLocal 是弱引用（WeakReference），所以只要 ThreadLocal 结束了自己的生命周期是可以被回收掉的。但是 Entry 中的 Value 却是被 Entry 强引用的，所以即便 Value 的生命周期结束了，Value 也是无法被回收的，从而导致内存泄露。</p>
<p>所以我们要手动释放，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService es;</span><br><span class="line">ThreadLocal tl;</span><br><span class="line">es.execute(()-&gt;&#123;</span><br><span class="line">  <span class="comment">//ThreadLocal增加变量</span></span><br><span class="line">  tl.set(obj);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 省略业务逻辑代码</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//手动清理ThreadLocal </span></span><br><span class="line">    tl.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal源码</title>
    <url>/2023/10/21/Java/ThreadLocal%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<p>以下源码是基于JDK11。</p>
<h1 id="Get以及Set"><a href="#Get以及Set" class="headerlink" title="Get以及Set"></a>Get以及Set</h1><p>一开始，一直在疑惑这个ThreadLocal到底是用来干嘛的，其实他可以用来存储一些变量，这些变量普通存储会由于被多线程访问或导致一些并发问题，用ThreadLocal存储，就会为每一个线程存储它自己的副本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这一步，它首先获取到了当前的线程，也就是说哪一个线程去调用ThreadLocal，就获取到哪一个线程。</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 这一步就是获取到线程对应的ThreadLocalMap，后文会有具体的结构</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="built_in">this</span>.getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里就是从ThreadLocalMap中获取到对应的元素</span></span><br><span class="line">        ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果之前的map为空，则调用该方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这个初始化值为null</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.initialValue();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 这里又重新判断了一次，应该是考虑到其他的线程可能在此之间已经创建了对应的map</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="built_in">this</span>.getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里判断map为空，那么就创建新的map</span></span><br><span class="line">        <span class="built_in">this</span>.createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> TerminatingThreadLocal) &#123;</span><br><span class="line">        TerminatingThreadLocal.register((TerminatingThreadLocal)<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    <span class="comment">// 这个threadLocals的类型是ThreadLocalMap</span></span><br><span class="line">    <span class="comment">// 这个创建，是为当前的线程创建一个ThreadLocalMap</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">// 这一步set的设计思路与get一致，都是获取到当前的线程之后，再进行操作。</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="built_in">this</span>.getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实中源码中可以看出，get和set操作都是先获取到当前线程，而每一个Thread中有一个变量ThreadLocalMap，然后去该变量中获取对应的元素。也就是说在每一个Thread中存储了对应的变量，这样就避免了并发访问的问题。</p>
<h1 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h1><p>ThreadLocalMap是ThreadLocal的一个内部类，ThreadLocalMap内部还有一个内部类，表示ThreadLocalMap的每一个节点。</p>
<p>首先看ThreadLocalMap的两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">    <span class="comment">// creatMap调用的构造方法就是该方法。</span></span><br><span class="line">    <span class="comment">// 这里创建该ThreadLocalMap时，需要传入ThreadLocal，其目的就是为了获取对应的hash值，然后将该元素放入对应的下标即可。</span></span><br><span class="line">    <span class="comment">// 而且要获取到该ThreadLocal的table，因为元素的值需要与ThreadLocal绑定，我们要能通过ThreadLocal来拿到对应的元素。</span></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        <span class="built_in">this</span>.table = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry[<span class="number">16</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; <span class="number">15</span>;</span><br><span class="line">        <span class="built_in">this</span>.table[i] = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry(firstKey, firstValue);</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">this</span>.setThreshold(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ThreadLocalMap</span><span class="params">(ThreadLocal.ThreadLocalMap parentMap)</span> &#123;</span><br><span class="line">        ThreadLocal.ThreadLocalMap.Entry[] parentTable = parentMap.table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> parentTable.length;</span><br><span class="line">        <span class="built_in">this</span>.setThreshold(len);</span><br><span class="line">        <span class="built_in">this</span>.table = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry[len];</span><br><span class="line">        ThreadLocal.ThreadLocalMap.Entry[] var4 = parentTable;</span><br><span class="line">        <span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> parentTable.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="number">0</span>; var6 &lt; var5; ++var6) &#123;</span><br><span class="line">            ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> var4[var6];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                ThreadLocal&lt;Object&gt; key = (ThreadLocal)e.get();</span><br><span class="line">                <span class="keyword">if</span> (key != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> key.childValue(e.value);</span><br><span class="line">                    ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry(key, value);</span><br><span class="line">                    <span class="type">int</span> h;</span><br><span class="line">                    <span class="keyword">for</span>(h = key.threadLocalHashCode &amp; len - <span class="number">1</span>; <span class="built_in">this</span>.table[h] != <span class="literal">null</span>; h = nextIndex(h, len)) 						&#123;&#125;</span><br><span class="line">                    <span class="built_in">this</span>.table[h] = c;</span><br><span class="line">                    ++<span class="built_in">this</span>.size;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ThreadLocalMap的一个静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="built_in">super</span>(k);</span><br><span class="line">            <span class="built_in">this</span>.value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的Entry，就是对应存储的具体值，比如说如下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该代码中，Entry就是一个City</span></span><br><span class="line">ThreadLocal&lt;City&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>每一个Thread有一个变量ThreadLocalMap，在创建该变量时，需要传入首个key以及value，其中key是一个ThreadLocal。</p>
<p>为什么要传入这个ThreadLocal呢？</p>
<p>我的理解是ThreadLocal要与对应的Thread绑定。换句话说，我们在使用ThreadLocal时，一般都是在多个线程中通过ThreadLocal来获取一个本该是共享的变量，而在ThreadLocal内部，它会先获取到当前线程，然后调用该线程的ThreadLocalMap来返回线程所需要的变量。所以，创建ThreadLocalMap时就需要传入一个ThreadLocal，方便后续获取值。</p>
<h2 id="Get以及Set-1"><a href="#Get以及Set-1" class="headerlink" title="Get以及Set"></a>Get以及Set</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里，是根据传入的key先获取到hash值，然后去table的对应下标获取元素，存在则直接返回，不存在则调用getEntryAfterMiss</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ThreadLocal.ThreadLocalMap.Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; <span class="built_in">this</span>.table.length - <span class="number">1</span>;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> <span class="built_in">this</span>.table[i];</span><br><span class="line">    <span class="keyword">return</span> e != <span class="literal">null</span> &amp;&amp; e.get() == key ? e : <span class="built_in">this</span>.getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里就是遍历table所有的元素（该ThreadLocalMap存储的所有元素），找是否有key匹配的，有就直接返回</span></span><br><span class="line"><span class="comment"> * 如果table中某一个值为空，则调用expungeStaleEntry方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ThreadLocal.ThreadLocalMap.Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, ThreadLocal.ThreadLocalMap.Entry e)</span> &#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = <span class="built_in">this</span>.table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length; e != <span class="literal">null</span>; e = tab[i]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = (ThreadLocal)e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.expungeStaleEntry(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法的主要目的是为了清除对应下标的元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = <span class="built_in">this</span>.table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">    --<span class="built_in">this</span>.size;</span><br><span class="line"></span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 这里是遍历该ThreadLocalMap的Entry数组，也就是看该ThreadLocalMap存储的所有元素</span></span><br><span class="line">    <span class="keyword">for</span>(i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = nextIndex(i, len)) &#123;</span><br><span class="line">       	<span class="comment">// 获取到对应的ThreadLocal</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = (ThreadLocal)e.get();</span><br><span class="line">        <span class="comment">// 这里应该是考虑对应的ThreadLocal已经被释放了</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">            --<span class="built_in">this</span>.size;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这几步操作，就是为了调整元素位置，将他们放在合适的位置，以减小tab大小</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                <span class="comment">// 这一步是循环，断开强引用</span></span><br><span class="line">                <span class="keyword">for</span>(tab[i] = <span class="literal">null</span>; tab[h] != <span class="literal">null</span>; h = nextIndex(h, len)) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = <span class="built_in">this</span>.table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = (ThreadLocal)e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++<span class="built_in">this</span>.size;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= <span class="built_in">this</span>.threshold) &#123;</span><br><span class="line">        <span class="built_in">this</span>.rehash();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value, <span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = <span class="built_in">this</span>.table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line"></span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = prevIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = prevIndex(i, len)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = (ThreadLocal)e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot) &#123;</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.cleanSomeSlots(<span class="built_in">this</span>.expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot) &#123;</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry(key, value);</span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot) &#123;</span><br><span class="line">        <span class="built_in">this</span>.cleanSomeSlots(<span class="built_in">this</span>.expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，ThreadLocalMap是用Entry[]去保存value，而Entry继承了WeakReference，查资料得知这里Entry的key是弱引用，意味着当ThreadLocal没有外部强引用时，会被GC回收，而对应的该ThreadLocal对应的value却不会被回收，若当前线程一直没有结束，会存在一条强引用链, value也会一直累加导致内存泄露。</p>
<p>而<code>expungeStaleEntry</code>方法就是为了解决上述问题。主动去清理key为空的ThreadLocal对应的value。</p>
]]></content>
      <categories>
        <category>个人心得</category>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发容器</title>
    <url>/2023/05/16/Java/java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>List 里面只有一个实现类就是 <strong>CopyOnWriteArrayList</strong>。</p>
<p>CopyOnWrite，顾名思义就是写的时候会将共享变量新复制一份出来，这样做的好处是读操作完全无锁。</p>
<p>CopyOnWriteArrayList 内部维护了一个数组，成员变量 array 就指向这个内部数组，所有的读操作都是基于 array 进行的，迭代器 Iterator 遍历的就是 array 数组。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230515224227570.png" alt="image-20230515224227570"></p>
<p>如果在遍历时，还有写入时，CopyOnWriteArrayList 会将 array 复制一份，然后在新复制处理的数组上执行增加元素的操作，执行完之后再将 array 指向这个新的数组。遍历操作一直都是基于原 array 执行，而写操作则是基于新 array 进行。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230515224431375.png" alt="image-20230515224431375" style="zoom: 80%;" />

<p>注意：CopyOnWriteArrayList 仅适用于写操作非常少的场景，而且能够容忍读写的短暂不一致。因为遍历时，写入的新元素并不能第一之间被遍历到。</p>
<p>CopyOnWriteArrayList 迭代器是只读的，不支持增删改。因为迭代器遍历的仅仅是一个快照，而对快照进行增删改是没有意义的。</p>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map 接口的两个实现是 ConcurrentHashMap 和 ConcurrentSkipListMap，它们从应用的角度来看，主要区别在于 <strong>ConcurrentHashMap 的 key 是无序的，而 ConcurrentSkipListMap 的 key 是有序的</strong>。而且他们的key和value都不能为空。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230515224643521.png" alt="image-20230515224643521" style="zoom:80%;" />

<p>ConcurrentSkipListMap 里面的 SkipList 本身就是一种数据结构，中文一般都翻译为“跳表”。</p>
<p>跳表插入、删除、查询操作平均的时间复杂度是 O(log n)，理论上和并发线程数没有关系，所以在并发度非常高的情况下，若你对 ConcurrentHashMap 的性能还不满意，可以尝试一下 ConcurrentSkipListMap。</p>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set 接口的两个实现是 CopyOnWriteArraySet 和 ConcurrentSkipListSet，使用场景可以参考前面讲述的 CopyOnWriteArrayList 和 ConcurrentSkipListMap。</p>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>队列可以从以下两个维度来分：</p>
<p>一个维度是<strong>阻塞与非阻塞</strong>，所谓阻塞指的是当队列已满时，入队操作阻塞；当队列已空时，出队操作阻塞。</p>
<p>另一个维度是<strong>单端与双端</strong>，单端指的是只能队尾入队，队首出队；而双端指的是队首队尾皆可入队出队。</p>
<p>可以将Queue分为4大类</p>
<p>1、<strong>单端阻塞队列</strong>：其实现有 ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、LinkedTransferQueue、PriorityBlockingQueue 和 DelayQueue。</p>
<p>内部一般会持有一个队列，这个队列可以是数组（其实现是 ArrayBlockingQueue）也可以是链表（其实现是 LinkedBlockingQueue）；甚至还可以不持有队列（其实现是 SynchronousQueue），此时生产者线程的入队操作必须等待消费者线程的出队操作。</p>
<p>而 LinkedTransferQueue 融合 LinkedBlockingQueue 和 SynchronousQueue 的功能，性能比 LinkedBlockingQueue 更好；PriorityBlockingQueue 支持按照优先级出队；DelayQueue 支持延时出队。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230515225105664.png" alt="image-20230515225105664" style="zoom:67%;" />

<p>2.<strong>双端阻塞队列</strong>：其实现是 LinkedBlockingDeque。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230515225129204.png" alt="image-20230515225129204" style="zoom:67%;" />

<p>3.<strong>单端非阻塞队列</strong>：其实现是 ConcurrentLinkedQueue。</p>
<p>4.<strong>双端非阻塞队列</strong>：其实现是 ConcurrentLinkedDeque。</p>
<p>在使用队列时，要注意队列是否是有界的，在使用无界队列时，要注意是否会导致OOM异常。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Java并发编程实战》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>this引用逃逸</title>
    <url>/2023/04/03/Java/this%E5%BC%95%E7%94%A8%E9%80%83%E9%80%B8/</url>
    <content><![CDATA[<h1 id="构造函数中启动线程"><a href="#构造函数中启动线程" class="headerlink" title="构造函数中启动线程"></a>构造函数中启动线程</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisEscape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThisEscape</span><span class="params">(EventSource source)</span> &#123;</span><br><span class="line">        source.registerListener(<span class="keyword">new</span> <span class="title class_">EventListener</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event e)</span> &#123;</span><br><span class="line">                doSomething();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程，此时this引用逃逸</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                doSomething();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，构造函数创建了一个匿名内部类，并将其实例化并注册到事件源对象上。此外，构造函数还创建并启动了一个新线程，该线程也会调用doSomething方法。<strong>由于在构造函数执行期间，对象还没有完全构造完成</strong>，因此在该线程中访问name字段可能会导致不可预期的结果。</p>
<h1 id="构造函数中将this传递给其他线程"><a href="#构造函数中将this传递给其他线程" class="headerlink" title="构造函数中将this传递给其他线程"></a>构造函数中将this传递给其他线程</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisEscape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThisEscape</span><span class="params">(EventSource source)</span> &#123;</span><br><span class="line">        source.registerListener(<span class="keyword">new</span> <span class="title class_">EventListener</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event e)</span> &#123;</span><br><span class="line">                doSomething();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">HelperThread</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelperThread</span>(<span class="built_in">this</span>);</span><br><span class="line">        helper.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">HelperThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> ThisEscape escape;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">HelperThread</span><span class="params">(ThisEscape escape)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.escape = escape;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            escape.doSomething();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，构造函数创建了一个HelperThread对象，并将ThisEscape对象作为参数传递给它。HelperThread对象的run方法中访问了ThisEscape对象的doSomething方法，此时ThisEscape对象可能还没有完全构造完成，因此可能导致不可预期的结果。</p>
<h1 id="构造函数中注册回调对象"><a href="#构造函数中注册回调对象" class="headerlink" title="构造函数中注册回调对象"></a>构造函数中注册回调对象</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisEscape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThisEscape</span><span class="params">()</span> &#123;</span><br><span class="line">        EventManager.getInstance().register(<span class="keyword">new</span> <span class="title class_">EventListener</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(Event e)</span> &#123;</span><br><span class="line">                doSomething();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do something&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，构造函数中将匿名内部类的实例注册到了事件管理器中。由于<strong>事件管理器可能在ThisEscape对象构造完成之前</strong>就开始调用匿名内部类实例的onEvent方法，因此可能会导致不可预期的结果。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Java并发编程实战》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java并发编程实战</tag>
      </tags>
  </entry>
  <entry>
    <title>传统网络编程与NIO编程</title>
    <url>/2023/10/26/Java/%E4%BC%A0%E7%BB%9F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="传统网络编程"><a href="#传统网络编程" class="headerlink" title="传统网络编程"></a>传统网络编程</h1><p>首先看一段最传统的Java网络编程。</p>
<p>服务端代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8000</span>);</span><br><span class="line">        <span class="comment">// 接收新连接的线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 阻塞方法获取新的连接</span></span><br><span class="line">                    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 每一个新的连接都创建一个线程，负责读取数据</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                        <span class="type">int</span> len;</span><br><span class="line">                        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">                            <span class="comment">// 按字节流读取数据</span></span><br><span class="line">                            <span class="keyword">while</span> ((len = inputStream.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, len));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).start();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 我自己运行时，这里只创建了一次连接，然后没3s发送一次数据</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8000</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 网络传输都是传输的字节</span></span><br><span class="line">                    socket.getOutputStream().write((<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot; hello world&quot;</span>).getBytes());</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，服务端启动时创建了一个线程，建立了<code>ServerSocket</code>，循环的等待客户端的连接。客户端每次连接，服务端都会创建一个新的线程去处理请求，然后读取数据。</p>
<p>这种模型在客户端数量比较小的时候是没问题的，但是如果客户端数量较多，服务端就需要创建很多的线程，线程的创建比较消耗成本，而且线程数过多时，CPU调度导致的线程切换也会影响性能。</p>
<p>主要有以下三个问题：</p>
<ol>
<li>创建太多线程，而线程是很宝贵的资源，同一时刻大量线程处于阻塞会浪费资源。</li>
<li>线程切换效率低下。</li>
<li>IO编程中，数据传输都是以字节为单位。</li>
</ol>
<p>为了解决上述问题，引入了NIO，即同步非阻塞IO。</p>
<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p>在NIO中，只会创建一个线程去进行while循环，该线程监控所有的客户端连接，而不会像传统的有多少个客户端连接就创建多少个线程去进行while循环。</p>
<p>传统的模型中，在每一时刻，只有少数线程会有数据读写需求，而没有数据需要读写的就白白浪费了CPU资源。NIO中，通过将所有的客户端连接都注册到selector上，通过检测selector上是否有数据数据需要读写，就可以达到批量读取数据的目的。</p>
<p>这样，就解决了创建太多线程浪费资源和CPU频繁切换线程导致的性能问题。而传统IO是面向字节流，读取数据后需要自己缓存，流中就不存在该数据。而NIO的读写是面向Buffer的，解决了数据只能用字节传输的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">serverSelector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">clientSelector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 对应IO编程中服务端启动</span></span><br><span class="line">                <span class="type">ServerSocketChannel</span> <span class="variable">listenerChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">                listenerChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8000</span>));</span><br><span class="line">                listenerChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                listenerChannel.register(serverSelector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 检测是否有新的连接，1指的是阻塞时间为1ms</span></span><br><span class="line">                    <span class="keyword">if</span> (serverSelector.select(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Set&lt;SelectionKey&gt; set = serverSelector.selectedKeys();</span><br><span class="line">                        Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();</span><br><span class="line">                        <span class="comment">// 遍历所有有数据的SelectionKey</span></span><br><span class="line">                        <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                            <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">                            <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="comment">// 这里就是区别，当有一个新的连接请求到来时，不再创建一个线程，而是直接注册到clientSelector</span></span><br><span class="line">                                    <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> ((ServerSocketChannel) selectionKey.channel()).accept();</span><br><span class="line">                                    clientChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                                    clientChannel.register(clientSelector, SelectionKey.OP_READ);</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    <span class="comment">// 每个客户端只注册一次就可以了</span></span><br><span class="line">                                    keyIterator.remove();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 批量轮询是否有哪些连接的数据可读，1同样为阻塞时间</span></span><br><span class="line">                    <span class="keyword">if</span> (clientSelector.select(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Set&lt;SelectionKey&gt; set = clientSelector.selectedKeys();</span><br><span class="line">                        Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();</span><br><span class="line">                        <span class="comment">// 轮询所有已经注册了的客户端，然后判断哪一个可读</span></span><br><span class="line">                        <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                            <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">                            <span class="comment">// 这里是判断可读</span></span><br><span class="line">                            <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                                    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                                    <span class="comment">// 面向buffer</span></span><br><span class="line">                                    clientChannel.read(byteBuffer);</span><br><span class="line">                                    byteBuffer.flip();</span><br><span class="line">                                    System.out.println(Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    <span class="comment">// 这里为什么移除，是否是因为每个客户端传输一次数据后，就从注册中移除</span></span><br><span class="line">                                    keyIterator.remove();</span><br><span class="line">                                    key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NIO编程的核心思路：</p>
<ol>
<li>NIO 模型中通常会有两个线程，每个线程绑定一个轮询器 selector ，在上面的例子中 serverSelector负责轮询是否有新的连接，clientSelector负责轮询连接是否有数据可读。</li>
<li>服务端监测到新的连接之后，不再创建一个新的线程，而是直接将新连接绑定到clientSelector上， 这样就不用 IO 模型中 每个连接一个while循环。</li>
<li>clientSelector被一个 while 死循环包裹着，如果在某一时刻有多条连接有数据可读，那么通过 clientSelector.select(1)方法可以轮询出来，进而批量处理。</li>
<li>数据读写面向Buffer。</li>
</ol>
<p>但是不难看出，整个编码变得极其复杂。所有，就有了Netty。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>java</category>
        <category>netty</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>一个sleep操作引起的问题</title>
    <url>/2023/04/15/Java/%E4%B8%80%E4%B8%AAsleep%E6%93%8D%E4%BD%9C%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在学习Java并发编程时，有以下demo，简单演示商品出售的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 减少t</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                t--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 减少t</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                t--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是存在并发问题的，当库存为1的时候，两个线程同时判断 t &gt; 0，然后都进入t–操作，会导致输出的值为-1。</p>
<p>但是在本地实测的时候却发现，尝试了很多次都没有出现t为负数的情况，然后将代码改成如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 减少t</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                t--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 减少t</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                t--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种情况，很容易出现t为负数的情况。</p>
<p>为什么加了sleep就很容易出现，而不加却需要尝试很多次呢？</p>
<h3 id="一个比较简单的解释"><a href="#一个比较简单的解释" class="headerlink" title="一个比较简单的解释"></a>一个比较简单的解释</h3><p>在不加sleep的情况下，由于操作只有t–，执行的特别快，所以说很难出现错误的情况，概率比较小。</p>
<p>而加了sleep之后，进入判断后会先进行sleep，sleep完再去处理t–。这样在t &#x3D; 1时，线程判断完进入while后就睡眠，另一个线程在这100ms内有很大概率也会进入相同的判断，导致结果为-1。</p>
<p>在这里加sleep可以理解为加大了判断与执行t–之间的时间，导致更多的线程会在这之间执行。</p>
<h3 id="另一种情况"><a href="#另一种情况" class="headerlink" title="另一种情况"></a>另一种情况</h3><p>如果sleep是在下面这个位置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 减少t</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                t--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + t);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 减少t</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                t--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + t);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说先执行t–，然后打印，之后再进行sleep。按照这么个顺序来执行，一个线程的判断和执行扣减操作的时间并没有被加长，却也很容易出现t为负数或者打印相同t的情况。</p>
<h3 id="从硬件考虑"><a href="#从硬件考虑" class="headerlink" title="从硬件考虑"></a>从硬件考虑</h3><p>我的电脑是8核cpu的，该程序只开了两个线程，如果当前电脑cpu资源比较充足是时，从理论上来讲，存在一种情况就是两个线程都是并行执行，并不存在竞争cpu资源的问题。</p>
<p>当并发的资源竞争没那么大时，每个线程在工作内存中所做的修改，可以很快的同步回主内存，另一个线程也可以从主内存中读取到最新的值（非volatile修饰的公共变量，虚拟机并不保证其可见性，但不代表一定是不可见的），然后再进行操作。</p>
<p>所以，当每个线程都执行的很快且并发资源竞争没那么大时（对应上面不加sleep的demo），我们可以做一个大胆一点的假设（虽然不对）：对t &gt; 0的判断和 t –操作是原子性的。也就是说，这两步执行的太快，以至于其他线程无法在中间穿插任何操作（而事实是存在穿插操作的可能），好像加了锁一样。</p>
<p>而加了sleep之后，无论在哪里加，都会导致当前的线程阻塞。而阻塞操作涉及到一个从用户态切换到核心态。因为Java的线程设计是每一个Java线程都绑定了一个内核线程，要阻塞一个线程或者唤醒都需要操作系统帮忙。这里由于内核切换带来的开销，可能会导致线程写入主内存延，也可能会导致另一个线程读取主内存的数据延迟，加大了发生问题的概率。</p>
]]></content>
      <categories>
        <category>个人心得</category>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集算法</title>
    <url>/2023/04/05/Java/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h1><p>分代收集理论建立在两个假说之上：</p>
<p>1）弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</p>
<p>2）强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</p>
<p>正是由于这两个假说，所以多款垃圾收集器都有一个设计原则：Java堆应该划分不同的区域，然后根据对象的年龄（对象熬过垃圾手机过程的次数）分配到不同的区域存储。</p>
<p>把那些朝生夕灭的对象放在一起存储，那么虚拟机只需要关注如果保留少量存活的对象即可，而不是大量的去进行标记。</p>
<p>把那些不容易被清除的对象放在一起，那么虚拟机就可以不那么频繁的去清理这部分的对象。</p>
<p>由于区域的划分，所以存在了<strong>Minor GC（指目标只是新生代的垃圾回收，也叫Young GC）</strong>，<strong>Major GC（指的是目标老年代的垃圾回收，也叫Old GC。目前只有CMS收集器有。）</strong>，<strong>Full GC（收集整个Java堆和方法区的垃圾收集）</strong>这样回收类型的划分。而且也根据不同区域对象存亡的特征，发展除了<strong>标记-复制算法</strong>，<strong>标记-清除算法</strong>，<strong>标记-整理算法</strong>。Mixed GC（混合收集）指目标是整个新生代和部分老年代的垃圾回收，目前只有G1垃圾回收有。</p>
<p>一个最基本的分代是分为新生代和老年代，在这种分代下，如果要进行一次针对新生代的垃圾收集，存在一种情况就是新生代的对象引用了老年代的对象，那么就不得不遍历整个老年代。所以引出了第三个假说：</p>
<p>3）跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</p>
<p>根据这条假说，我们可以在新生代建立一个叫做记忆集的数据结构，该结构把老年代划分为若干块，标识出老年代的哪一块内存存在跨代引用。此后发生Major GC时，只需要遍历存在跨代引用那些小块里面的对象。</p>
<h1 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h1><p>正如名字，如它的名字一样，算法分为标记和清除两个阶段。首先标记出所有需要回收的对象，标记完成后统一回收掉所有被标记的对象。也可以反过来，标记存活的，然后收集所有没有标记的。</p>
<p>存在的问题：</p>
<p>第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行<strong>大量标记和清除的动作</strong>，导致标记和清除两个过程的执行效率都随对象数量增长而降低；</p>
<p>第二个是内存空间的<strong>碎片化问题</strong>，标记、清除之后会产生大量<strong>不连续的内存碎片</strong>，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<h1 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h1><p>为了解决标记-清除算法面对大量对象效率低的问题，产生了一种半区复制算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>该算法存在的问题：</p>
<p>1、如果大多数对象都是活着的，那么意味着会有大量的对象需要复制，会浪费很多内存开销。</p>
<p>2、原来一整块内存现在只能用其中的一半了。</p>
<h2 id="Appel式回收"><a href="#Appel式回收" class="headerlink" title="Appel式回收"></a>Appel式回收</h2><p>由于标记-复制算法大多数用在针对新生代的垃圾回收，大多数对象活不过一轮收集，所以并不需要按照1：1的比例进行空间划分，对其划分进行优化后，产生了一种Appel式的回收。</p>
<p>具体做法是把<strong>新生代</strong>分为一块较大的<strong>Eden空间</strong>和<strong>两块较小的Survivor空间</strong>，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。</p>
<p>HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也就是说最多有1块Survivor没有，也就是10%。</p>
<p>Appel式回收时，如果那一块Survivor区不够用于存储还活着的对象，它会向老年区“借用”一部分区域。说白了，这些多余的对象会在分配担保机制下直接进入老年代。</p>
<h1 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h1><p>该算法主要针对老年代的回收，因为标记-复制算法要不需要浪费一半空间，要不就需要额外的空间进行担保，以防止所有对象都是存活的情况。</p>
<p>标记-整理算法的标记过程与标记-清理一样，但是标记完不是直接清除标记对象，而是把活着的对象向内存空间一端移动，然后直接清理掉边界以外的数据。具体如下图：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230405195521861.png" alt="image-20230405195521861"></p>
<h2 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h2><p>标记完后，如果移动存活的对象，移动对象并且更新这些对象的引用是一项繁重的操作，会带来性能影响。而且在移动的过程中还需要暂停用于程序，人们把暂停称为“stop the world”。</p>
<p>但是如果不移动对象，那么就会导致空间是散列开的，导致很严重的碎片化问题，就只能依赖于更复杂的内存分配器以及内存访问器来解决，譬如通过“分区空闲分配链表”来解决内存分配问题（计算机硬盘存储大文件就不要求物理连续的磁盘空间，能够在碎片化的硬盘上存储和访问就是通过硬盘分区表实现的）。</p>
<p>基于以上两点，是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。</p>
<p>从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入理解Java虚拟机》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>Jvm</tag>
        <tag>深入理解Java虚拟机</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>如何判断Java对象“已死”</title>
    <url>/2023/04/03/Java/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADJava%E5%AF%B9%E8%B1%A1%E2%80%9C%E5%B7%B2%E6%AD%BB%E2%80%9D/</url>
    <content><![CDATA[<p>JVM在进行垃圾回收前，需要判断这个对象是否还在使用，哪些是不可能再被任何途径使用的，而主要的判断方法有以下两种</p>
<h1 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h1><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p>
<p>这种方法的优点是原理比较简单，判定效率也高，但实际情况是想要用这种方法，需要做很多额外的工作，因为单靠引用计数法很难解决对象互相引用的问题。比如下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	Object instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    Object instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objA.instance = objB;</span><br><span class="line">objB.instance = objA;</span><br></pre></td></tr></table></figure>

<p>尽管他们两个都不会再被使用，但是因为他们两个互相引用着对方，导致计数器的值不为0。</p>
<p>而实际上，很少有虚拟机会采用这种方法。</p>
<h1 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h1><p>这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是<strong>从GC Roots到这个对象不可达时</strong>，则证明此对象是不可能再被使用的。</p>
<p>以下几种固定可作为GC Root的对象：</p>
<p>1、在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</p>
<p>2、在方法区中<strong>类静态属性引用的对象</strong>，譬如Java类的引用类型静态变量。</p>
<p>3、在方法区中<strong>常量引用的对象</strong>，譬如<strong>字符串常量池</strong>（String Table）里的引用。</p>
<p>4、在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</p>
<p>5、Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</p>
<p>6、所有被同步锁（synchronized关键字）持有的对象。</p>
<p>7、反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</p>
<p>除了上述内容外，还有其他对象临时性的加入，比如<strong>分代收集和局部回收（Partial GC）</strong></p>
<h1 id="一个对象的自救"><a href="#一个对象的自救" class="headerlink" title="一个对象的自救"></a>一个对象的自救</h1><p>在可达性分析算法中，被标记为不可达的对象并不一定会被清除。一个对象被清除前会经历两次标记，第一次是可达性分析算法执行后，发现该对象没有引用链到GC Roots，这时候会被第一次标记。</p>
<p>随后会进行一次筛选，看看次对象是否有必要执行finalize()方法。如果对象没有覆盖finalize()方法或者已经被调用过，则会被视为没有必要。</p>
<p>如果被视为没必要，那么该对象会被放入一个F-Queue的队列之中，之后会有一个由虚拟机创建的，地调度优先级的线程取执行他们的finalize()方法。这里虚拟机只会执行，但是不会等待执行结束。因为如果一个对象在执行时发生了死循环，那么会导致队列中其他对象无法执行，甚至导致整个系统崩溃。</p>
<p>如果对象在执行finalize方法时，只要重新与引用链上的任何一个对象建立关联即可。否则将会被虚拟机二次标记。被第二次标记的则会被清除。</p>
<h1 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h1><p>方法区的垃圾收集主要回收两部分内容：<strong>废弃的常量</strong>和<strong>不再使用的类型（这里指的是一个类的class对象）</strong>。</p>
<p>废弃常量的判定比较容易，与Java堆中对象的判定比较相似。</p>
<p>但是判断一个类型是否属于不再使用的类条件比较苛刻，需要满足以下三点：</p>
<p>1、该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</p>
<p>2、加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</p>
<p>3、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入理解Java虚拟机》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>Jvm</tag>
        <tag>深入理解Java虚拟机</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>如何实现一个完备的缓存</title>
    <url>/2023/05/08/Java/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%A4%87%E7%9A%84%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><p>1、允许多个线程同时读共享变量；</p>
<p>2、只允许一个线程写共享变量；</p>
<p>3、如果一个写线程正在执行写操作，此时禁止读线程读共享变量。</p>
<h1 id="实现一个缓存"><a href="#实现一个缓存" class="headerlink" title="实现一个缓存"></a>实现一个缓存</h1><p>我们声明一个Cache类，然后里面用HashMap来实现存储，但是它并不是线程安全的，我们采用ReadWriteLock来保证线程安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;K, V&gt; m = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">// 读锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">r</span> <span class="operator">=</span> rwl.readLock();</span><br><span class="line">    <span class="comment">// 写锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">w</span> <span class="operator">=</span> rwl.writeLock();</span><br><span class="line">    <span class="comment">// 读缓存</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> m.get(key); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123; </span><br><span class="line">            r.unlock(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写缓存</span></span><br><span class="line">    V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> m.put(key, v); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123; </span><br><span class="line">            w.unlock(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，在并发的场景下，写缓存时，可能会存在缓存的覆盖</p>
<h1 id="实现缓存的按需加载"><a href="#实现缓存的按需加载" class="headerlink" title="实现缓存的按需加载"></a>实现缓存的按需加载</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;K, V&gt; m = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">r</span> <span class="operator">=</span> rwl.readLock();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">w</span> <span class="operator">=</span> rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 读缓存</span></span><br><span class="line">        r.lock();         ①</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            v = m.get(key); ②</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            r.unlock();     ③</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 缓存中存在，返回</span></span><br><span class="line">        <span class="keyword">if</span> (v != <span class="literal">null</span>) &#123;   ④</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 缓存中不存在，查询数据库</span></span><br><span class="line">        w.lock();         ⑤</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 再次验证</span></span><br><span class="line">            <span class="comment">// 其他线程可能已经查询过数据库</span></span><br><span class="line">            v = m.get(key); ⑥</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;  ⑦</span><br><span class="line">               <span class="comment">//查询数据库</span></span><br><span class="line">               v = 省略代码无数</span><br><span class="line">               m.put(key, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="读写锁的升级与降级"><a href="#读写锁的升级与降级" class="headerlink" title="读写锁的升级与降级"></a>读写锁的升级与降级</h1><p>上面按需加载的示例代码中，在①处获取读锁，在③处释放读锁，那是否可以在②处的下面增加验证缓存并更新缓存的逻辑呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读缓存</span></span><br><span class="line"><span class="comment">// 获取读锁</span></span><br><span class="line">r.lock();         ①</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  v = m.get(key); ②</span><br><span class="line">  <span class="comment">// 没有数据，要去数据库查询</span></span><br><span class="line">  <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里升级锁是读锁没有释放，然后加了写锁</span></span><br><span class="line">    <span class="comment">// 升级为写锁</span></span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 再次验证并更新缓存</span></span><br><span class="line">      <span class="comment">// 省略详细代码</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      w.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  r.unlock();     ③</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样看上去好像是没有问题的，先是获取读锁，然后再升级为写锁，对此还有个专业的名字，叫<strong>锁的升级</strong>。可惜 ReadWriteLock 并不支持这种升级。在上面的代码示例中，读锁还没有释放，此时获取写锁，会导致写锁永久等待，最终导致相关线程都被阻塞，永远也没有机会被唤醒。</p>
<p><strong>锁的降级</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CachedData</span> &#123;</span><br><span class="line">    Object data;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> cacheValid;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">// 读锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">r</span> <span class="operator">=</span> rwl.readLock();</span><br><span class="line">    <span class="comment">// 写锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">w</span> <span class="operator">=</span> rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">processCachedData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取读锁</span></span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            <span class="comment">// 释放读锁，因为不允许读锁的升级</span></span><br><span class="line">            r.unlock();</span><br><span class="line">            <span class="comment">// 获取写锁</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 再次检查状态</span></span><br><span class="line">                <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                    data = ...</span><br><span class="line">                    cacheValid = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 释放写锁前，降级为读锁</span></span><br><span class="line">                <span class="comment">// 降级是可以的</span></span><br><span class="line">                r.lock(); ①</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放写锁</span></span><br><span class="line">                w.unlock(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此处仍然持有读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            use(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式下如何访问共享资源</title>
    <url>/2023/09/11/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8B%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<p>互斥资源指的是那种一次只可以一个系统访问的资源。</p>
<h1 id="集中式算法"><a href="#集中式算法" class="headerlink" title="集中式算法"></a>集中式算法</h1><p>该算法需要借助于一个第三方软件，或者说一个数据中心，每当有系统需要访问互斥资源时，需要先该数据中心发送请求，看是否其他的系统请求该资源。然后数据中心给系统返回是否可以访问该资源，如果同意，则系统访问互斥资源。</p>
<p>存在的问题：数据中心容易成为瓶颈，所有的系统都要请求数据中心，如果数据中心出现阻塞或者不可用，则有可能导致整个系统不可用。</p>
<h1 id="民主协商：分布式算法"><a href="#民主协商：分布式算法" class="headerlink" title="民主协商：分布式算法"></a>民主协商：分布式算法</h1><p>在该算法下，如果要访问互斥资源，则采用互相通信的形式，比如说现在有A，B，C，D四个系统，其中A想要访问某资源，它会向B，C，D三个系统发送请求，询问是否有人需要使用该资源。如果没有，则A访问该资源。假如D此时也想要访问该资源，则A，B，C会收到请求，而B，C即收到了A的请求，也受到了D的请求，由于A先到，所以会优先允许A访问资源。</p>
<p>而不同系统的请求会被放入一个队列当中，依次允许访问共享资源。</p>
<p>缺点：如果系统特别多，则访问一次资源所要发送的广播信息会消耗大量的资源，导致一定的浪费。而且部分节点可能不可用，导致一直处于等待，该问题的解决办法是忽略下线了的节点。</p>
<h1 id="轮值-CEO：令牌环算法"><a href="#轮值-CEO：令牌环算法" class="headerlink" title="轮值 CEO：令牌环算法"></a>轮值 CEO：令牌环算法</h1><p>该算法是产生一个令牌，令牌依次传递给每一个系统，拿到该令牌的系统，如果有访问共享资源的需求，则它可以访问共享资源，否则无法访问共享资源。</p>
<p>缺点：降低了系统的实时性。比如说有100个系统，系统1访问完共享资源后，其他99个系统无需访问共享资源，但令牌仍然需要转一圈才能到达系统1这里。而且令牌的传递需要忽略已经下线了的节点。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《分布式技术原理与算法解析》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机类加载机制之类加载器</title>
    <url>/2023/03/19/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<p>通过一个类的全限定名来获取描述该类的二进制字节流，实现这个动作的代码叫做<strong>类加载器</strong>。</p>
<h1 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h1><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。换句话说：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<p>这里的相等指：代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括了使用instanceof关键字做对象所属关系判定等各种情况。</p>
<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p>启动类加载器（Bootstrap Class Loader）：这个类加载器负责加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中。</p>
<p>扩展类加载器（Extension Class Loader）：它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。</p>
<p>应用程序类加载器（Application Class Loader）：由于应用程序类加载器是ClassLoader类中的getSystem-ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230319133215497.png" alt="image-20230319133215497"></p>
<p>上图中展示的各种类加载器之间的层次关系被称为类加载器的“<strong>双亲委派模型（Parents DelegationModel）</strong>”。</p>
<p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。</p>
<p><strong>双亲委派模型的工作过程是</strong>：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的<strong>启动类加载器</strong>中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p>
<p>使用双亲委派的一个好处：Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">	<span class="comment">// 首先，检查请求的类是否已经被加载过了</span></span><br><span class="line">	<span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">				c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				c = findBootstrapClassOrNull(name);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">		<span class="comment">// 如果父类加载器抛出ClassNotFoundException</span></span><br><span class="line">		<span class="comment">// 说明父类加载器无法完成加载请求</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 在父类加载器无法加载时</span></span><br><span class="line">			<span class="comment">// 再调用本身的findClass方法来进行类加载</span></span><br><span class="line">			c = findClass(name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">		resolveClass(c);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的逻辑：先检查请求加载的类型是否已经被加载过，若没有则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。假如父类加载器加载失败，抛出ClassNotFoundException异常的话，才调用自己的findClass()方法尝试进行加载。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入理解Java虚拟机》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>Jvm</tag>
        <tag>深入理解Java虚拟机</tag>
        <tag>类加载器</tag>
      </tags>
  </entry>
  <entry>
    <title>如何实现一个限流器</title>
    <url>/2023/05/06/Java/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%99%90%E6%B5%81%E5%99%A8/</url>
    <content><![CDATA[<h1 id="信号量模型"><a href="#信号量模型" class="headerlink" title="信号量模型"></a>信号量模型</h1><p>信号量模型可以简单概括为：<strong>一个计数器，一个等待队列，三个方法</strong>。</p>
<p>在信号量模型里，计数器和等待队列对外是透明的，所以只能通过信号量模型提供的三个方法来访问它们，这三个方法分别是：init()、down() 和 up()。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230506215117555.png" alt="image-20230506215117555" style="zoom:67%;" />

<ul>
<li><p>init()：设置计数器的初始值。</p>
</li>
<li><p>down()：计数器的值减 1；如果此时计数器的值小于 0，则当前线程将被阻塞，否则当前线程可以继续执行。</p>
</li>
<li><p>up()：计数器的值加 1；如果此时计数器的值小于或者等于 0，则唤醒等待队列中的一个线程，并将其从等待队列中移除。</p>
</li>
</ul>
<p>这里的 init()、down() 和 up() 三个方法都是原子性的，并且这个原子性是由信号量模型的实现方保证的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Semaphore</span> &#123;</span><br><span class="line">  <span class="comment">// 计数器</span></span><br><span class="line">  <span class="type">int</span> count;</span><br><span class="line">  <span class="comment">// 等待队列</span></span><br><span class="line">  Queue queue;</span><br><span class="line">  <span class="comment">// 初始化操作</span></span><br><span class="line">  Semaphore(<span class="type">int</span> c) &#123;</span><br><span class="line">    <span class="built_in">this</span>.count = c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">down</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.count--;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 将当前线程插入等待队列</span></span><br><span class="line">      <span class="comment">// 阻塞当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">up</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.count++;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 移除等待队列中的某个线程T</span></span><br><span class="line">      <span class="comment">// 唤醒线程T</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何使用信号量"><a href="#如何使用信号量" class="headerlink" title="如何使用信号量"></a>如何使用信号量</h2><p>信号量其实就是一个标记，可以理解为红绿灯。每次通过路口时，要先检测红绿灯，是绿灯才可以同行，否则不能通过。而上面的信号量可以理解为，每次进入这里时，要先检测以下count是否大于0，如果大于0，才可以执行，否则不能执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line"><span class="comment">//初始化信号量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//用信号量保证互斥    </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这里就相当于调用上面的down，来将count--，如果count &lt; 0,线程就会被阻塞，无法执行。</span></span><br><span class="line">    s.acquire();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 这里相当于调用up，相当于释放资源，将count++。</span></span><br><span class="line">        s.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里的acquire和release是原子性的。</p>
<h1 id="快速实现一个限流器"><a href="#快速实现一个限流器" class="headerlink" title="快速实现一个限流器"></a>快速实现一个限流器</h1><p>这里的限流器的场景是：需要一个对象池，里面有N个对象可以被重复使用。当一个线程使用了其中的对象式时，该线程释放该对象之前，其他线程不允许使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObjPool</span>&lt;T, R&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;T&gt; pool;</span><br><span class="line">    <span class="comment">// 用信号量实现限流器</span></span><br><span class="line">    <span class="keyword">final</span> Semaphore sem;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    ObjPool(<span class="type">int</span> size, T t)&#123;</span><br><span class="line">        pool = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;T&gt;()&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            pool.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        sem = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用对象池的对象，调用func</span></span><br><span class="line">    R <span class="title function_">exec</span><span class="params">(Function&lt;T,R&gt; func)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 获取信号量，相当于进入临界资源的访问</span></span><br><span class="line">        sem.acquire();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用对象池中的对象</span></span><br><span class="line">            t = pool.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> func.apply(t);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 使用完之后将对象归还</span></span><br><span class="line">            pool.add(t);</span><br><span class="line">            sem.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建对象池</span></span><br><span class="line">ObjPool&lt;Long, String&gt; pool = <span class="keyword">new</span> <span class="title class_">ObjPool</span>&lt;Long, String&gt;(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 通过对象池获取t，之后执行  </span></span><br><span class="line">pool.exec(t -&gt; &#123;</span><br><span class="line">    System.out.println(t);</span><br><span class="line">    <span class="keyword">return</span> t.toString();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>信号量可以允许多个线程同时访问临界资源，它的并发度相对于使用Lock来说要好一点。但是它无法同时唤醒多个线程去争抢锁，只能唤醒阻塞线程中的一个。</p>
<p>因为信号量模型是没有Condition的概念的，即阻塞线程被醒了直接就运行了而不会去检查此时临界条件是否已经不满足了，所以一次只能唤醒一个。即满足进去临界区域之后，就从所有阻塞的线程中选一个进去，如果选多个，这几个线程都会认为此时已经满足，并开始执行。事实是，唤醒多个之后，有一个线程开始执行后，其他的线程就不满足条件了，但由于不检查条件，他们还是会执行。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Java 并发编程实战》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务</title>
    <url>/2023/09/13/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>分布式事务的实现，一般有三种方案：</p>
<ol>
<li>基于 XA 协议的二阶段提交协议方法； </li>
<li>三阶段提交协议方法； </li>
<li>基于消息的最终一致性方法</li>
</ol>
<h1 id="基于-XA-协议的二阶段提交方法"><a href="#基于-XA-协议的二阶段提交方法" class="headerlink" title="基于 XA 协议的二阶段提交方法"></a>基于 XA 协议的二阶段提交方法</h1><p>XA是一个分布式事务协议，规定了事务管理器和资源管理器接口，可以分为两部分：<strong>事务管理器</strong>和<strong>本地资源管理器</strong>。</p>
<p>大致原理是：事务管理器作为协调者，负责各个本地资源的提交和回滚，而资源管理器就是分布式事务的参与者，通常由数据库实现。</p>
<p>基于 XA 协议的二阶段提交方法中，二阶段提交协议（The two-phase commit protocol，2PC），用于保证分布式系统中事务提交时的数据一致性，是 XA 在全局事务中用于协调多个资源的机制。</p>
<h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>投票为第一阶段，协调者会向事务的参与者发起执行操作的请求，允许他们发起提交，参与者收到请求后，会执行请求中的事务，记录日志信息但不提交，待参与者执行成功后，向协调者发送yes表示同意操作，若不成功，则发送no，表示终止。</p>
<p>当所有的参与者都返回了yes或者no信息后，才会进入提交阶段。</p>
<p>在该阶段，如果所有的参与者都发送的是yes，那么协调者将通知所有参与者提交事务，参与者收到通知后，才会完成剩下的操作。如果有一个参与者提交了no，那么所有的参与者都无法提交该事务。</p>
<p>不足：</p>
<ol>
<li>同步阻塞问题：该算法执行过程中，所有参与者未收到协调者信息的情况下，都处于事务阻塞状态，如果占用临界资源，则其他系统也无法。</li>
<li>单点故障问题：如果资源管理器发生了故障，那么整个系统就会处于停滞状态。</li>
<li>数据不一致问题：在提交阶段，如果协调者给参与者发送确认提交的信息时网络异常，会导致一部分参与者无法提交事务，而导致数据不一致。</li>
</ol>
<h2 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h2><p>三阶段提交是对二阶段提交的改进，为了防止数据不一致以及同步阻塞问题，引入了超时机制和准备阶段。如果参与者或者协调者在规定的时间内没有收到信息，则选择提交或者终止整个事务。</p>
<p>在第一阶段和第二阶段中间引入了一个准备阶段，也就是在提交阶段之前，加入了一个预 提交阶段。在预提交阶段排除一些不一致的情况，保证在最后提交之前各参与节点的状态是一致的。</p>
<p>也就是说变为了三个阶段：可以提交，预提交，和提交。</p>
<p>可以提交和之前的一样，不过多阐述。</p>
<p>而<strong>预提交</strong>是协调者根据参与者的状态来决定是否可以预提交，如果所有参与者都回复yes，协调者就会执行事务的预执行：</p>
<p>首先是发送预提交请求，然后参与者收到后，执行事务操作，并记录Undo和Redo信息记录到事务日志，之后，参与者如果执行成功，则返回ACK响应，同时开始等待最终指令。</p>
<p>到了正式提交，才是真正的提交具体的事务。</p>
<p>不管是二阶段还是三阶段提交，都无法解决性能低，包括数据出现不一致的情况。</p>
<h1 id="基于分布式消息的最终一致性方案"><a href="#基于分布式消息的最终一致性方案" class="headerlink" title="基于分布式消息的最终一致性方案"></a>基于分布式消息的最终一致性方案</h1><p>这个就是引入了一个中间件，比如消息队列，用于存储消息，比如日志或者消息可以存进来，异步的去进行执行，来达到数据最终的一致性，中间还是会有部分时间的不一致。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《分布式技术原理与算法解析》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机类加载机制之类加载时机</title>
    <url>/2023/03/17/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><p>Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作<strong>虚拟机的类加载机制</strong>。</p>
<p>在Java语言中，类型的<strong>加载、连接和初始化过程</strong>都是在程序运行期间完成的，这会导致Java语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销，但是很灵活。例如，编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类。</p>
<p>用户可以通过Java预置的或自定义类加载器，让某个本地的应用程序在运行时从网络或其他地方上加载一个二进制流作为其程序代码的一部分。</p>
<p>本文以及后续所提到的“Class文件”也并非特指某个存在于具体磁盘中的文件，而应当是一串二进制字节流，无论其以何种形式存在，包括但不限于磁盘文件、网络、数据库、内存或者动态产生等。</p>
<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历<strong>加载</strong>（Loading）、<strong>验证</strong>（Verification）、准备（Preparation）、<strong>解析</strong>（Resolution）、<strong>初始化</strong>（Initialization）、<strong>使用</strong>（Using）和<strong>卸载</strong>（Unloading）七个阶段，其中验证、准备、解析三个部分统称为<strong>连接</strong>（Linking）。如下图所示:</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230317140148379.png" alt="image-20230317140148379"></p>
<p>其中，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地<strong>开始</strong>。而解析则不一定，它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为<strong>动态绑定或晚期绑定</strong>）。</p>
<h1 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h1><p>关于在什么情况下开始类加载过程的第一个阶段“加载”，并没有约束，但是对于初始化阶段，《Java虚拟机规范》规定了<strong>有且只有</strong>6种情况必须立即进行<strong>初始化</strong>（而加载、验证、准备自然需要在此之前开始）：</p>
<p>​	1）遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：</p>
<p>​		使用<strong>new关键字实例化</strong>对象的时候。</p>
<p>​		<strong>读取或设置一个类型的静态字段</strong>（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。</p>
<p>​		<strong>调用一个类型的静态方法</strong>的时候。</p>
<p>​	2）使用java.lang.reflect包的方法对类型进行<strong>反射调用的时候</strong>，如果类型没有进行过初始化，则需要先触发其初始化。</p>
<p>​	3）当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
<p>​	4）当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p>
<p>​	5）当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</p>
<p>​	6）当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p>
<p>以上六种场景中的行为称为对一个类型进行<strong>主动引用</strong>。</p>
<h1 id="被动引用的例子"><a href="#被动引用的例子" class="headerlink" title="被动引用的例子"></a>被动引用的例子</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 被动使用类字段演示一：</span></span><br><span class="line"><span class="comment">* 通过子类引用父类的静态字段，不会导致子类初始化</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;SuperClass init!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;SubClass init!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 非主动使用类字段演示</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotInitialization</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(SubClass.value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码会打印”SuperClass init!“，并不会打印”SubClass init!”。对于静态字段，只有直接定义这个字段的才会被初始化，这里就是SuperClass，因此在子类中引用父类的静态字段，只会触发父类的初始化方法，而不会触发子类的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 被动使用类字段演示二：</span></span><br><span class="line"><span class="comment">* 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的</span></span><br><span class="line"><span class="comment">类的初始化</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstClass</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;ConstClass init!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HELLOWORLD</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 非主动使用类字段演示</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotInitialization</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码运行后，也没有输出“ConstClass init！”，这是因为虽然引用了ConstClass类的常量HELLOWORLD，但是在编译阶段通过<strong>常量传播优化</strong>，已经将常量值HELLOWORLD存储在<strong>NotInitialization类的常量池中</strong>，以后NotInitialization对常量ConstClass.HELLOWORLD的引用都会被转化为NotInitialization类对自身常量池的引用了。也就是说，实际上NotInitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class文件后就已不存在任何联系了。</p>
<p>接口的加载过程与类的加载过程稍有不同，针对接口做一些特殊的说明：</p>
<p>接口也有初始化过程，与类一致，上面的代码都是用静态语句块static{}来输出初始化信息，而接口中不能使用static{}语句块，但是编译器仍然会为接口生成“<clinit>()”类构造器，用于初始化接口中所定义的成员变量。</p>
<p><strong>接口与类真正有所区别的是</strong>前面讲述的六种“有且仅有”需要触发初始化场景中的第三种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，<strong>并不要求其父接口全部都完成了初始化</strong>，<strong>只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化</strong>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入理解Java虚拟机》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>Jvm</tag>
        <tag>深入理解Java虚拟机</tag>
        <tag>类加载机制</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机类加载机制之类加载过程</title>
    <url>/2023/03/17/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>这篇文章我们会详细了解Java虚拟机中类加载的全过程，即加载、验证、准备、解析和初始化这五个阶段所执行的具体动作。</p>
<h1 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h1><p>“加载”（Loading）阶段是整个“类加载”（Class Loading）过程中的一个阶段，在这个阶段java虚拟机要做三件事：</p>
<p>​	1）通过一个类的全限定名来获取定义此类的二进制字节流。</p>
<p>​	2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p>
<p>​	3）在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</p>
<p>针对第一件事，《Java虚拟机规范》并没有指定从哪里获取这个二进制字节流，例如可以在如下几种情况中获取：</p>
<p>​	1）从ZIP压缩包中读取，这很常见，最终成为日后<strong>JAR</strong>、EAR、WAR格式的基础。</p>
<p>​	2）从网络中获取，这种场景最典型的应用就是Web Applet。</p>
<p>​	3）运行时计算生成，这种场景使用得最多的就是动态代理技术。</p>
<p>​	4）由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件。</p>
<p>​    5）……</p>
<p>相对于类加载过程的其他阶段，非数组类型的加载阶段（准确地说，是<strong>加载阶段中获取类的二进制字节流的动作</strong>）是开发人员可控性最强的阶段。加载阶段既可以使用Java虚拟机里内置的<strong>引导类加载器</strong>来完成，也可以由<strong>用户自定义的类加载器</strong>去完成，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的findClass()或loadClass()方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。</p>
<p>对于数组类而言，情况就有所不同，<strong>数组类本身不通过类加载器创建</strong>，它是由<strong>Java虚拟机直接在内存中动态构造出来的</strong>。但数组类与类加载器仍然有很密切的关系，因为数组类的<strong>元素类型</strong>（ElementType，指的是数组<strong>去掉所有维度的类型</strong>）最终还是要靠类加载器来完成加载。创建过程遵循以下规则：</p>
<p>​	1）如果数组的<strong>组件类型</strong>（Component Type，指的是数组<strong>去掉一个维度的类型</strong>，注意和前面的元素类型区分开来）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组将被标识在加载该组件类型的类加载器的类名称空间上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用类型举例</span></span><br><span class="line"><span class="comment">// 产生一个具有10个单元的数组对象，每个单元存放的是1个String对象的引用，所有单元的初始值为默认值null，此时并未创建具体的String对象</span></span><br><span class="line">String [] example = <span class="keyword">new</span> <span class="title class_">String</span> [<span class="number">10</span>];<span class="comment">//对象引用数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本类型</span></span><br><span class="line"><span class="type">int</span> [] arr = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 在堆上为数组对象分配10个整形元素空间，每个元素初始化默认值为0；</span></span><br></pre></td></tr></table></figure>

<p>​	2）如果数组的组件类型不是引用类型（例如int[]数组的组件类型为int），Java虚拟机将会把数组标记为<strong>与引导类加载器关联</strong>。</p>
<p>​	3）数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问到。</p>
<p>加载阶段结束后，<strong>Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了</strong>。类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。</p>
<p>加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p>
<p>使用纯粹的java代码写一些访问数组外的数据，或者将一个对象转为它并未实现的类型，编译会报错，无法生成class文件，但是如果直接在修改已经编译好的class文件，则会出现上述问题，所以有必要进行验证。</p>
<p>从代码量和耗费的执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重。从整体上看，验证阶段大致上会完成下面四个阶段的检验动作：<strong>文件格式验证</strong>、<strong>元数据验证</strong>、<strong>字节码验证</strong>和<strong>符号引用验证</strong>。</p>
<p>1）文件格式验证：第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</p>
<p>2）元数据验证：第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求。</p>
<p>3）字节码验证：第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对<strong>元数据信息中的数据类型</strong>校验完毕以后，这阶段就要对<strong>类的方法体（Class文件中的Code属性）</strong>进行校验分析。如果一个类型中有方法体的字节码没有通过字节码验证，那它肯定是有问题的；但如果一个方法体通过了字节码验证，也仍然不能保证它一定就是安全的。</p>
<p>4）符号引用验证：最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段，从概念上讲，这些变量所使用的内存都应当在<strong>方法区中进行分配</strong>，但必须注意到<strong>方法区本身是一个逻辑上的区域</strong>，在JDK 7及之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在JDK 8及之后，<strong>类变量则会随着Class对象一起存放在Java堆中</strong>，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了。</p>
<p>在该阶段，进行内存分配的仅包括<strong>类变量</strong>，而<strong>不包括实例变量</strong>，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>变量value在准备阶段过后的初始值是0而不是123，因为这时尚未开始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值为123的动作要到类的初始化阶段才会被执行。</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>解析阶段是Java虚拟机将<strong>常量池内的符号引用</strong>替换为<strong>直接引用</strong>的过程。</p>
<p>符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。</p>
<p>直接引用：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</p>
<p>对同一个<strong>符号引用</strong>进行<strong>多次解析</strong>请求是很常见的事情，除invokedynamic指令以外，虚拟机实现可以对第一次解析的结果进行缓存，譬如在运行时直接引用常量池中的记录，并把常量标识为已解析状态，从而避免解析动作重复进行。无论是否解析多次，虚拟机需要保证，如果第一次成功，后续的也要成功，如果第一次失败，其他指令对该符号解析也应该收到相同的异常，哪怕这个符号后续成功加载进Java虚拟机中。</p>
<p>但是上面的规则对于invokedynamic指令并不成立。当碰到前面已经由invokedynamic指令解析的符号引用时，并不意味着这个解析对于其他invokedynamic指令同样生效。因为invokedynamic指令的目的本来就是用于动态语言支持，它对应的引用称为“<strong>动态调用点限定符</strong>”，这里“动态”的含义是指<strong>必须等到程序实际运行到这条指令时，解析动作才能进行</strong>。相对地，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有开始执行代码时就提前进行解析。</p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。</p>
<p>我们也可以从另外一种更直接的形式来表达：初始化阶段就是执行类构造器<clinit>()方法的过程。<clinit>()并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入理解Java虚拟机》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>Jvm</tag>
        <tag>深入理解Java虚拟机</tag>
        <tag>类加载机制</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁</title>
    <url>/2023/09/19/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>锁存在的意义是为了保证在多CPU，多个线程的环境中，某一个时间点上，只能由一个线程进入临界区代码，从而保证临界区操作数据的一致性。</p>
<p>进程内的锁，是操作系统直接提供的，对于同一台机器上的多进程，可以直接通过操作系统的锁来实现，只不过是协调了多个进程，需要将锁放在所有进程都可以访问的共享内存中，所有进程通过共享内存中的 锁来进行加锁和解锁。</p>
<p>但是分布式是在不同机器上，通过操作系统的锁已经无法实现。</p>
<h1 id="怎么实现分布式锁"><a href="#怎么实现分布式锁" class="headerlink" title="怎么实现分布式锁"></a>怎么实现分布式锁</h1><p>实现分布式锁，需要满足以下几个特性：</p>
<ol>
<li><p>互斥：保证不同节点、不同线程的互斥访问。</p>
</li>
<li><p>超时机制：即超时设置，防止死锁。因为锁服务和请求锁的服务分散在不同的机器上面，它们之间是通过网络来通信 的，所以我们需要用超时机制，来避免获得锁的节点故障或者网络异常，导致它持有的锁不能 归还，出现死锁的情况。</p>
<p>同时还要确保留有线程不断延长锁的时间，防止事务还没处理完，而时间到了，导致释放了锁。</p>
</li>
<li><p>完备的锁接口：比如说lock接口和trylock接口等。</p>
</li>
<li><p>可重入性：即一个节点的一个线程已经获取了锁，那么该节点持有锁的这个线程 可以再次成功获取锁。我们在加锁时，记录好当前获取锁的节点+线程组合的唯一标识，后续如果标识相同，直接返回加锁成功即可，否则按照正常流程处理。</p>
</li>
<li><p>公平性：即对于 Lock 接口获取锁失败被阻塞等待的加锁请求，在锁被释放后，如果按 先来后到的顺序，将锁颁发给等待时间最长的一个加锁请求，那么就是公平锁，否则就是非公 平锁。</p>
</li>
</ol>
<h1 id="分布式锁的挑战"><a href="#分布式锁的挑战" class="headerlink" title="分布式锁的挑战"></a>分布式锁的挑战</h1><p>分布式锁面临的挑战有：正确性、高可用和高性能。</p>
<p>首先考虑进程内的锁，如果一个线程持有锁，只要它不释放，就只有它能操作临界区的资源。同时，因为进程内锁的场景中，不会出现部分失败的情况，所以它崩溃无法释放锁时，会导致整个进程崩溃，不会出现死锁（这里不包括业务逻辑出错而导致的死锁）。</p>
<p>另一个方面，进程内锁的解锁操作是进程内部的函数调用，这个过程是同步的。只要发起加锁操作，就会成功（这个操作会成功，但是加锁不一定），解锁操作同样。</p>
<p>当存在多个进程时，加锁操作仍然是函数调用，和上边一样，但是存在一个进程获取锁后崩溃，导致无法释放锁，出现死锁。但是可以通过操作系统来判断一个进程是否存活，并查看它是否获取锁，从而解决问题。</p>
<p>但是在分布式场景下，发起获取锁的操作需要利用不可靠的网络，意味着发起获取锁的这个操作就有可能失败（这里称为获取锁的时延），而且获取锁后，该进程与服务器通信出现了问题，导致无法释放锁，造成死锁。这就需要设置一个超时时间，如果获取锁的进程超时，就自动释放锁。</p>
<p>在获取锁的时延上，如果采用超时加心跳，可能会导致服务端给客户端分发了锁，但是由于响应超时，导致客户端以为自己没有获取到锁。</p>
<p>为了解决这个问题，我们可以在生成锁的时候一并生成一个全局唯一且递增的版本号，当操作共享数据时，会检查版本号，如果出现版本号倒退的现象，则说明出了问题，拒绝该次请求即可。</p>
<h1 id="分布式锁的权衡"><a href="#分布式锁的权衡" class="headerlink" title="分布式锁的权衡"></a>分布式锁的权衡</h1><p>我们无法保证分布式锁100%的有效，而且正确性要求越高，它的性能会越低。一般来说，会在成本可接受的范围内，提供性能最好的分布式锁服务，如果性能不佳，则需要告知。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入浅出分布式技术原理》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>如何保证幂等</title>
    <url>/2023/09/14/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%B9%82%E7%AD%89/</url>
    <content><![CDATA[<p> 考虑如下问题：在一个电商系统中，如果用户下单后，在模块之间及逆行远程调用的过程中，出现了问题，给用户响应了请求超时，那么会影响到用户购买，导致损失订单。</p>
<p>但是，如果对请求超时进行重试，那么会导致用户重复下单，用户明明点击了一次，却显示购买了两次，导致一些问题。</p>
<p>这里就涉及到了一个问题，接口的幂等性，即不管执行几次，它的影响都和执行一次一样。</p>
<h1 id="如何保证Exactly-once"><a href="#如何保证Exactly-once" class="headerlink" title="如何保证Exactly-once"></a>如何保证Exactly-once</h1><p>不能保证 Exactly-once 的原因主要有两个，一个是网络出现丢包或者分区等故障，另一个是远端服务发生了故障。</p>
<p>一般来说，在分布式系统中，实现消息的 Exactly-once 传递，主要有三种方式：一种是至少一次消息传递加消息幂等性，一种是分布式快照加状态回滚，一种是整体重做。</p>
<h2 id="一次传递加幂等"><a href="#一次传递加幂等" class="headerlink" title="一次传递加幂等"></a>一次传递加幂等</h2><p>该思路比较简单，就是当处理失败后，并不给用户返回请求超时，而是进行重试，保证至少请求一次成功，然后每次请求带上一个全局的唯一id，当失败重试的时候，该id并不会发生改变，成功后，将本次请求保存在数据库中，如果第二次发现该id后，并不会执行，直接返回。</p>
<h2 id="分布式快照加回滚"><a href="#分布式快照加回滚" class="headerlink" title="分布式快照加回滚"></a>分布式快照加回滚</h2><p>分布式快照加状态回滚指的是，在整个分布式系统运行的过程中，定期对整个系统的状态做快照，在系统运行时，不论系统的哪个地方出现故障，就将整个系统回滚到上一个快照状态，然 后再重放上一个快照状态之后的情况，直到所有的消息都被正常处理。</p>
<p>但是该方式并不适合在线业务，因为对在线业务做快照很难，而且对整个系统做快照，耗费资源，而且做快照的时候会导致当前系统不可处理新的业务。</p>
<p>该方案只适合针对于像流式计算的场景。</p>
<h2 id="整体重做"><a href="#整体重做" class="headerlink" title="整体重做"></a>整体重做</h2><p>整体重做的 Exactly-once 的方式，可以看成是分布式快照加状态回滚的一种特殊情况。</p>
<h1 id="Exactly-once-的挑战"><a href="#Exactly-once-的挑战" class="headerlink" title="Exactly-once 的挑战"></a>Exactly-once 的挑战</h1><h2 id="重试面临的挑战"><a href="#重试面临的挑战" class="headerlink" title="重试面临的挑战"></a>重试面临的挑战</h2><p>当采用重试策略来保证消息最少传递一次时，我们需要限制重试的次数，来确保不会因为重试导致系统雪崩。而且重试的时间间隔也会因为重试的次数而增加。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入浅出分布式技术原理》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡</title>
    <url>/2023/09/17/%E5%88%86%E5%B8%83%E5%BC%8F/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>在分布式的环境下，单个模块往往会部署多个，当调用方通过注册发现组件获得了被调用方的网络地址时，会获得多个地址，这时候就要通过负载均衡组件来确定是调用哪一个具体的组件。</p>
<p>我们可以根据负载均衡策略是否关心请求中携带的信息，即请求是否有状态，将负载均衡策略分为无状态的负载均衡、半状态的负 载均衡和全状态的负载均衡。</p>
<h2 id="负载均衡的关键点"><a href="#负载均衡的关键点" class="headerlink" title="负载均衡的关键点"></a>负载均衡的关键点</h2><p>负载均衡需要考虑到各个实例性能差异的情况， 让每一个实例都能充分发挥它的能力，不要出现一些实例负载比较高，而另一些实例的负载却 非常低的情况，这样会造成资源浪费。所以负载均衡的第一个关键点是<strong>公平性</strong>。即要关注被调用服务组之间的公平性，不能旱的旱死，涝的涝死。</p>
<p>负载均衡需要确保外部对后端服务的请求，一定能被路由到可以提供正确服务的实例上。如果后端是有状态的，那么我们就要考虑在请求上携带状态信息，然后根据状态将请求发送到对应的路由上，所以第二个关键点是<strong>正确性</strong>，即对于有状态的服务来说，负载均 衡需要关心请求的状态，将请求调度到能处理它的后端实例上，不要出现不能处理和错误处理 的情况。</p>
<h2 id="无状态的负载均衡"><a href="#无状态的负载均衡" class="headerlink" title="无状态的负载均衡"></a>无状态的负载均衡</h2><p>无状态的负载均衡指的是所有后端实例都是对等的，不管请求发送到哪个实力上，都会得到正确的结果，所以无状态的负载均衡不需要关心请求的状态。</p>
<p>如果这些无状态的实例需要处理像存储数据这种状态，则需要将这些状态信息都交由一个中心存储负责，比如MySQL或者Redis，他们不会在本地磁盘存储任何状态信息。以下是两种具体的方案</p>
<h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>轮询的负载均衡策略非常简单，只需要将请求按顺序分配给多个实例，不用再做其他的处理。轮询在路由时，不利用请求的状态信息，属于无状态的负载均衡策略，所以它不能用于有状态 实例的负载均衡器。</p>
<h3 id="权重轮询"><a href="#权重轮询" class="headerlink" title="权重轮询"></a>权重轮询</h3><p>权重轮询的负载均衡策略是将每一个后端实例分配一个权重，分配请求的数量和实例的权重成 正比轮询。例如有两个实例 A，B，假设我们设置 A 的权重为 20，B 的权重为 80，那么负载 均衡会将 20% 的请求数量分配给 A，80 % 的请求数量分配给 B。</p>
<h2 id="半状态的负载均衡"><a href="#半状态的负载均衡" class="headerlink" title="半状态的负载均衡"></a>半状态的负载均衡</h2><p>半状态的负载均衡指的是，虽然负载均衡策略利用请求的状态信息进行路由，但是仅仅进行简单的规则处理，比如 Hash 运算加求模来路由请求，它不保证路由的正确性，这个正确性由后端实例来保证。</p>
<p>一些实例会在内存中存储一些状态数据来提升系统性能，如果一个请求被分配到错误的路由中，可以通过中心存储来读取所需要的数据。</p>
<p>半状态的负载均衡将请求按一定的策略进行路由，后端实例可以利用路 由规则来进行优化。</p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash 负载均衡策略是指将请求的状态信息，按一定的 Hash 算法固定分配到一个实例上，例 如，按请求的来源 IP 地址或者用户的 ID，将同一个来源 IP 地址或者用户 ID 的请求固定到一 个实例上。</p>
<p>存在的问题：如果机器数量发生改变，则请求和实例的分配关系则会发生变化，影响正确性。</p>
<h3 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h3><p>一致性 Hash可以解决Hash模式下的问题。</p>
<p>假设Hash环的大小为2^32，那么我们先将0~2^32均匀的分布在Hash环上，然后将所有的实例按照唯一标识来计算他们在环上的位置。</p>
<p>对于每个请求，也采用同样的方式，都是对2^32取模，然后计算位置。如果该位置没有节点，那么就顺时针往下走，知道找到第一个有节点的位置，该请求就交由该节点执行。</p>
<p>这样的好处是始终对2^32取模，不管有多少个节点变动，始终不影响结果。</p>
<h2 id="全状态的负载均衡"><a href="#全状态的负载均衡" class="headerlink" title="全状态的负载均衡"></a>全状态的负载均衡</h2><p>全状态的负载均衡是指，负载均衡策略不仅利用请求的状态信息进行路由，并且在后端实例有 状态的情况下，依然会保证路由的正确性。</p>
<p>全状态的负载均衡一般以路由服务的形式存在，在路由服务里面，都会存储后端实例 ID 和状 态信息的索引，在进行请求路由的时候，路由服务从请求的状态信息中获得索引的标识，通过 查询索引获得后端实例的 ID，然后再进行路由。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入浅出分布式技术原理》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据分区再平衡</title>
    <url>/2023/09/09/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA%E5%86%8D%E5%B9%B3%E8%A1%A1/</url>
    <content><![CDATA[<h1 id="分区再平衡"><a href="#分区再平衡" class="headerlink" title="分区再平衡"></a>分区再平衡</h1><h2 id="采用取余的坏处"><a href="#采用取余的坏处" class="headerlink" title="采用取余的坏处"></a>采用取余的坏处</h2><p>如果采用取模的话，新添加节点或者删除节点，都有可能导致分区中的数据进行移动，最简单的例子，之前有10个节点，那么分区1000计算方法为1000%10 &#x3D; 0，就在第0个分区，如果此时添加一个新的节点，变为了1000%11 &#x3D; 10，此时就要将之前存在于下标为0的节点数据重新分配到下标为10的节点，导致性能损失。</p>
<h2 id="固定分区数量"><a href="#固定分区数量" class="headerlink" title="固定分区数量"></a>固定分区数量</h2><p>改策略是指提前规定好分区有多少个，比如说提前固定分区有1000个，然后当前有10个节点，那么每个节点就存在100个分区。这样做的好处就在于，如果存在新添加的节点，那么只需要将之前节点中存在的分区划分给新节点即可，如下图所示：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230913151508491.png" alt="image-20230913151508491" style="zoom:67%;" />

<p>这样可以避免采用取余的坏处，并不需要频繁的移动每个分区的数据。</p>
<h2 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h2><p>如果之前的分区不是很合理，导致了一个分区中存在大量的数据，而其他分区几乎是空的，就可以利用到动态分区。</p>
<p>他的设计方式如下：提前设置一个阈值，当某一个分区达到该值之后，就会将该分区拆分为两个分区，如果某些分区数据特别少，那么就会将相邻的两个分区进行合并。该过程类似于B树的分裂或者合并。</p>
<p>它的一个优点是分区数量可以自适应数据的总量，但是在一个空数据库中，一开始可能只有一个分区，当道达分裂点后，后续的写入可能还是会在一个分区中进行。</p>
<h2 id="按节点比例分区"><a href="#按节点比例分区" class="headerlink" title="按节点比例分区"></a>按节点比例分区</h2><p>该分区方式中，每个节点有固定数量的分区。</p>
<p>当节点数量不变时，每个分区的大小与数据集的大小成正比，当节点数增加时，分区则会调整变得更小。</p>
<p>当一个新的节点加入分区时，随机选择固定数量的分区进行分裂，然后拿走这些分区一半的数据量。</p>
<h1 id="路由发现"><a href="#路由发现" class="headerlink" title="路由发现"></a>路由发现</h1><p>当数据被分散到多个节点上时，我们读取数据的时候，如何知道我们想要的数据在哪里，这始终是一个问题，该问题也称为服务发现。</p>
<p>解决办法有以下三种：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230913155735479.png" alt="image-20230913155735479"></p>
<p>而该过程中，可能需要一些其他的第三方软件，比如Zookeeper。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230913155838336.png" alt="image-20230913155838336"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《数据密集型系统设计》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>分布式设计</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分段</title>
    <url>/2023/04/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E6%AE%B5/</url>
    <content><![CDATA[<p> 在分段之前，操作系统会直接把进程的地址空间完整的加载到内存当中，但是栈和堆中间却有很大一块空间没有使用，如下图：</p>
<img src="C:\Users\郭俊豪\AppData\Roaming\Typora\typora-user-images\image-20230417134359838.png" alt="image-20230417134359838" style="zoom: 67%;" />

<p>但是由于进程的地址空间被加载到了内存中，那么就意味着这些虚拟的地址空间都会被分配对应的物理地址，虽然这些地址没有被该进程写入内容，但是他们已经不能再分配给其他进程使用。</p>
<p>为了解决这个问题，引入了分段的概念。有了分段的概念后，就不是给每个地址空间一个寄存器，而是让地址空间内的每个段都有自己的基址寄存器和界限寄存器。<strong>一个段是地址空间中连续的定长区域。</strong></p>
<p>这样设计，就可以把进程的单个段加载到内存中，而不是将整个地址空间都加载到内存中，这样就能确保被加载到物理内存空间中的内容都是正在使用的，或者说最小程度的浪费一些空间。</p>
<p>在经典的地址空间中，有三个逻辑不同的段：代码，栈和堆。分段之后，我们可以把这三个部分分别加载到物理内存对应的位置，如下图所示：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417141138659.png" alt="image-20230417141138659" style="zoom: 67%;" />

<p>而不需要像之前那样，必须把整个地址空间全部加载到内存当中。</p>
<h1 id="分段存在的问题"><a href="#分段存在的问题" class="headerlink" title="分段存在的问题"></a>分段存在的问题</h1><p>分段的出现会导致内存中零散的分布很多的段，如果现在有不连续的24k空间，现在有一个20k大小的段，则会导致该段进入内存失败。</p>
<p>即分段会造成一定的外部碎片。</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>这篇笔记是在学习操作系统导论时写的，该书采用的是层层递进的方式，由最初的设计，存在什么问题，一步一步解决问题，更改设计，得到一个现代的操作设计方案。所以本文中有些内容可能并非目前操作系统正确的设计。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
        <category>内存虚拟化</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>分页</title>
    <url>/2023/04/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E9%A1%B5/</url>
    <content><![CDATA[<p>因为分段采用的是将空间划分为大小不同的部分，这样的话会导致整个空间比较零碎，会给内存维护带来一定的困难。</p>
<p>为了解决这个问题，我们可以把内存空间分割成大小一样的片段，这种思想称为分页。</p>
<p>分页不是将一个进程的地址空间分割成几个不同长度的逻辑段（即代码、堆、段），而是分割成固定大小的单元，每个单元称为一页。</p>
<p>我们把物理内存看成是定长的一个分割过的槽，叫作页帧（page frame）。每个这样的页帧包含一个虚拟内存页。如下图：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230418170854468.png" alt="image-20230418170854468" style="zoom:67%;" />

<p>当分页出现以后，一个进程地址空间被引入内存就变为下图：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230418171040236.png" alt="image-20230418171040236" style="zoom:67%;" />

<p>为了记录地址空间的每个虚拟页放在物理内存中的位置，操作系统通常为每个进程保存一个数据结构，称为页表（page table）。</p>
<p>页表的主要作用是为地址空间的每个虚拟页面保存地址转换（address translation），从而让我们知道每个页在物理内存中的位置。</p>
<h1 id="页表中有什么"><a href="#页表中有什么" class="headerlink" title="页表中有什么"></a>页表中有什么</h1><p>页表中有一个有效位的标识符。该标识符用于标记对应的地址空间是否使用，如果尝试访问标记为未使用的地址空间，那么程序可能会被终止。</p>
<p>通过有效位，我们可以只对标识为已经使用了的地址空间进行分配物理内存，这样就节省了大量内存。</p>
<p>还有一个存在位，用于标识该页是在内存中还是被换出到了磁盘。</p>
<p>参考位用于标记该页是否被访问。</p>
<h1 id="分页带来的问题"><a href="#分页带来的问题" class="headerlink" title="分页带来的问题"></a>分页带来的问题</h1><p>引入分页后，我们每次想要找到具体的物理地址时，系统需要先从进程的页表中取到对应的页表项，然后才能进行具体的地址空间到物理地址的转换。</p>
<p>在分段的设计下，我们可以直接从进程的基址寄存器中找到对应的物理位置。</p>
<p>而引入分页后，我们需要先从内存中取出页表，然后在页表中去找对应的地址空间到物理地址的转换。相当于多了一次取页表的操作。</p>
<p>而且页表需要占用物理内存。</p>
<p>要注意，每一个进程都会对应一个页表。每次都要从内存中找到该进程对应的页表，然后从页表中取地址的映射。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
        <category>内存虚拟化</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>分页：快速地址转换</title>
    <url>/2023/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E9%A1%B5%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>为了解决分页带来的额外内存访问，又引入了地址转换旁路缓冲存储器，又称TLB。它是一个硬件缓存，它记录了频繁发生的虚拟地址到物理地址的转换。</p>
<p>引入该缓存后，每次需要访问内存时，硬件会先检查TLB中是否有期望的映射，如果有就直接转换。</p>
<h1 id="TLB的基本算法"><a href="#TLB的基本算法" class="headerlink" title="TLB的基本算法"></a>TLB的基本算法</h1><p>硬件会先从虚拟地址中提取页号，然后检查TLB中是否有该页号（在引入TLB之前，这里需要直接访问一次内存，去读取页表），如果有，则可以根据TLB的值，经过计算得到正确的物理地址。</p>
<p>如果没有找到，那么硬件需要去内存访问页表，然后将映射更新到TLB当中，前提是该虚拟地址有效，而且我们有权限访问。</p>
<h1 id="上下文切换时对TLB的处理"><a href="#上下文切换时对TLB的处理" class="headerlink" title="上下文切换时对TLB的处理"></a>上下文切换时对TLB的处理</h1><p>引入TLB之后，我们在发生上下文切换时，要对TLB进行特殊的处理。因为TLB记录的是某一个进程的地址空间到物理地址的转换，如果切换进程，那么当前的TLB对于另一个进程是不可用的。</p>
<p>一种解决方案：</p>
<p>在发生上下文切换时，直接清空TLB，那么就不会有进程读到错误的TLB。但是也存在问题，每个进程刚运行时，都会发生TLB未命中。</p>
<p>第二种解决方案：</p>
<p>增加一个地址空间标识符，也可以看作是进程标识符，用于标识存储的内容是那个进程的映射。这样一来，TLB可以同时缓存多个进程的地址映射。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
        <category>内存虚拟化</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>分页：较小的表</title>
    <url>/2023/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E9%A1%B5%EF%BC%9A%E8%BE%83%E5%B0%8F%E7%9A%84%E8%A1%A8/</url>
    <content><![CDATA[<p>由于一个地址空间可能会对应很多页，从而导致每一个页表比较大。而每一个进程都有一个页表，则会给内存带来很大的压力。这里就是为了解决这个问题，如何让页表变得更小。</p>
<h1 id="更大的页"><a href="#更大的页" class="headerlink" title="更大的页"></a>更大的页</h1><p>我们可以让每一个页更大，如果每一个页可以对应更多的地址空间，那么页表需要存储的映射将会变少。这也意味着每一个页表会变得更小。</p>
<p>这种解决办法会带来新的问题，如果每个页太大，则会导致每个页所分配的内存用不完，导致内部碎片。</p>
<h1 id="分页和分段混合"><a href="#分页和分段混合" class="headerlink" title="分页和分段混合"></a>分页和分段混合</h1><p>在单独采用页表时，一个进程的地址空间映射可能如下图：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230419213904915.png" alt="image-20230419213904915" style="zoom:67%;" />

<p>在上图中，一个地址空间会分为多个页，它单独对应一个页表。但是真正使用的空间却只有上图那些白色区域，而灰色区域是没有使用的，但是他们也被映射了具体的物理地址，而且这些映射还存在页表当中。</p>
<p>所以我们可以采用分段时的思想，不再将进程的整个空间分配单个页表，而是为进程的每个逻辑分段提供一个页表。</p>
<p>在上图的例子中，我们可以给代码段一个页表，给堆和栈分别一个页表。</p>
<p>在分段中，一个基址寄存器告诉我们每个段对应的物理地址，还有界限寄存器告诉我们段的大小。而在分段和分页混合的方案中，我们的基址寄存器存储的是该段的页表的物理地址。界限寄存器用于指示页表有有多少有效页。</p>
<p><strong>存在的问题</strong>：</p>
<p>如果存在一个大而稀疏的堆，那么还是要为他分配对应的物理空间，这些映射都要存储在页表当中，也会造成页表的浪费。</p>
<p>其次，这种杂合的方式会导致外部碎片产生。</p>
<h1 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h1><p>多级页表将线性页表变成了类似于树的东西。而且也是为了解决页表中存在着没有用的映射。</p>
<p>它的设计是，将页表分成页大小的单元。如果整个页的页表项都是无效的，就不为该页分配页表。为了追踪页表的页是否有效，以及有效页对应物理内存的位置，使用了一种页目录的新结构。</p>
<p>之前的页表与多级页表的对比如下图：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230419222341075.png" alt="image-20230419222341075" style="zoom:67%;" />

<p>上图左边，页表中存储了203以及204这两页对应的虚拟地址到物理地址的映射，但是这两页却没有存储任何内容。</p>
<p>而在右图，内存中存储了页目录，页目录标记了哪些页是使用过的，而此时的页表中也有多个页，我们只需要加载页表中两个页即可。这两个页存储了使用了的页的映射。</p>
<p>存在的问题：</p>
<p>如果TLB未命中，那么我们就需要从内存中访问两次，才可以找到虚拟地址到物理地址的映射。第一次用于访问页目录，从页目录中找到对应页表，第二次用于从页表中找到对应虚拟地址到物理地址的映射。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
        <category>内存虚拟化</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>地址转换</title>
    <url>/2023/04/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>地址转换：硬件对每次的内存访问进行处理，将指令的虚拟地址转换为数据实际的物理地址。</p>
<p>但是仅仅靠硬件无法解决，它只能提高效率。还需要操作系统的帮助。</p>
<p>这使得每个程序好像拥有了自己私有的内存空间，存放着自己的代码和数据。但实际上是多个程序共用内存。</p>
<h1 id="动态重定位"><a href="#动态重定位" class="headerlink" title="动态重定位"></a>动态重定位</h1><p>每个CPU需要两个硬件寄存器：基址寄存器和界限寄存器。这两个寄存器能够让我们将地址空间放在物理内存的任何位置，同时又保证程序只访问自己的地址空间。</p>
<p>采用这种硬件的地址转换方式，进程中的内存引用都是虚拟地址，而虚拟地址加上基址寄存器中的内容，可以算出来真实的物理地址，再发送给内存系统。</p>
<p>由于这个由虚拟内存转换为具体的物理内存的过程是在运行时发生的，所以又叫做动态重定位。</p>
<p>这里面的界限寄存器，就是用来保证进程只访问自己范围内的空间，如果越界，则cpu会触发异常，进程会被终止。</p>
<h1 id="操作系统要做什么"><a href="#操作系统要做什么" class="headerlink" title="操作系统要做什么"></a>操作系统要做什么</h1><p>1、进程创建时，操作系统要为进程的地址空间找到内存空间。这就需要操作系统来维护哪些空间是可用的，哪些是已经被使用了的。</p>
<p>2、当进程运行结束时，操作系统要负责回收它的内存，供其他进程使用。当进程结束时，操作系统会把这些内存放入空闲列表。</p>
<p>3、每个cpu只有一个界限寄存器和基址寄存器，但对于每个运行的程序，他们要存入的值都是不同的。所以在发生上下文切换时，操作系统需要保存当前正在运行进程的界限寄存器和基址寄存器的值，以便后续恢复该进程时使用。</p>
<p>4、操作系统需要提供异常处理。比如当一个程序要越界访问时，cpu会触发异常，而操作系统需要终止该程序。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
        <category>内存虚拟化</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>多处理器调度</title>
    <url>/2023/04/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="多处理器架构"><a href="#多处理器架构" class="headerlink" title="多处理器架构"></a>多处理器架构</h1><p>多处理器与单处理器最大的区别在于对硬件缓存的使用，以及处理器之间共享数据的方式。</p>
<p>在单CPU系统中，存在多级硬件缓存，一般会让程序执行更快。</p>
<p>假设一个程序需要从内存中加载指令并读取一个值，在它第一次读取时，需要从内存中读取，之后处理器判定在短期内很可能会再次使用这个数据，会将其放入缓存中，下一次再请求时，直接从缓存中取即可。</p>
<p>在多CPU系统中，缓存则会变得复杂。</p>
<p>假如有两个CPU，一个内存。现在有一个运行在CPU1上的程序，要去地址A读值，但是CPU1里面没有该数据的缓存，所以需要去内存中读取，读取完成后，程序要修改地址A上的值，假设改为D，它会先写入缓存中，然后再去写入内存。但是写入内存时发生了中断，中断完后此程序交由CPU2执行，但是CPU2中没有数据的缓存，就需要从内存中读，这时候就会读到旧得数据，而不是修改后得D。</p>
<p>硬件提供了这个问题得解决方案：通过监控内存得访问，硬件可以保证获得正确数据，并确保共享内存的唯一性。</p>
<h1 id="单队列调度"><a href="#单队列调度" class="headerlink" title="单队列调度"></a>单队列调度</h1><p>这种调度方式就是采用一个队列来存储任务，然后有多个cpu从中获取任务，然后执行。但是这里需要用加锁的方式来保证调度的正确性，而加锁又会带来性能上的损耗。而且可能存在一种情况，一个任务频繁的在不同的cpu上运行，导致cpu的缓存几乎不起作用。我们应该尽可能保证一个任务一直在一个cpu上处理，来尽可能多的提高缓存命中率。</p>
<p>一个cpu缓存命中率特别低的情况：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414205315810.png" alt="image-20230414205315810"></p>
<h1 id="多队列调度"><a href="#多队列调度" class="headerlink" title="多队列调度"></a>多队列调度</h1><p>这种设计下，队列与CPU是多对多的关系，我们可以让一个队列对应一个CPU。</p>
<p>这样锁的竞争就会小很多，如果每一个CPU只从固定的一个队列获取任务，甚至可以消除锁竞争。而且它的缓存亲和性比较好，一个队列里面的任务会固定在一个CPU上运行。</p>
<p>如果按照一个CPU只处理自己对应队列的任务，会存在一种情况，cpu1里的任务已经执行完了，而cpu2里的任务还没有，那么cpu2一直在忙碌 ，cpu1却在空闲，导致负载不均衡。</p>
<p>如下图：A独占cpu0，而B 和 D交替执行在cpu1上。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414205421683.png" alt="image-20230414205421683"></p>
<p>若A执行完成，则会变成如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414205507938.png" alt="image-20230414205507938"></p>
<p>解决办法：迁移。通过工作的跨cpu迁移，可以实现负载均衡。</p>
<p><strong>即cpu1可以处理cpu2对应队列中的任务。</strong></p>
<p>假如cpu1队列中一开始只有任务A，而cpu2中有任务B和D，那么在迁移的设计下，执行过程如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414205237310.png" alt="image-20230414205237310"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
        <category>CPU虚拟化</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>调度：多级反馈队列</title>
    <url>/2023/04/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h1><p>MLFQ有许多独立的队列，每个队列都有优先级，任何时刻，一个任务只能存在一个队列当中，而MLFQ总是执行优先级最高的队列中的任务。在同一个队列中的任务，采用轮转调度。而MLFQ会观察任务的行为，然后调整他们的优先级。</p>
<h1 id="尝试1：改变优先级"><a href="#尝试1：改变优先级" class="headerlink" title="尝试1：改变优先级"></a>尝试1：改变优先级</h1><p>工作进入系统时，放在优先级最高的队列当中，工作用完整个时间片后，降低其优先级，如果时间片没用完，主动放弃CPU，则优先级不进行变化。</p>
<p>按照这种方法，如果有一个很长的cpu密集型任务要执行，那么它会被慢慢降级到最低的优先级。而此时来了一个短任务，会被放在优先级最高的队列中执行，它大概率会在降到最低优先级之前处理完，这种情况下MLFQ近似于短任务优先。</p>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>这样设计，如果一个任务一直不把CPU时间片用完，那么他就一直可以处于优先级最高的队列当中，那么会导致一些用完时间片而导致降级的任务永远无法处理。</p>
<p>而且会有程序恶意放弃CPU资源而一直占用处理器，比如在时间片用完之间，执行一段I&#x2F;O操作，主动放弃CPU。</p>
<h1 id="尝试2：提升优先级"><a href="#尝试2：提升优先级" class="headerlink" title="尝试2：提升优先级"></a>尝试2：提升优先级</h1><p>一个简单的设计，经过一段时间S后，就把队列中的所有任务全部放在优先级最高的队列当中。</p>
<p>但是这个S的值设置不合适也会导致问题，太长，会导致任务饥饿，太短的话，交互性任务达不到合适的CPU时间比例。</p>
<h1 id="尝试3：更好的设计"><a href="#尝试3：更好的设计" class="headerlink" title="尝试3：更好的设计"></a>尝试3：更好的设计</h1><p>为了防止一些恶意代码在CPU时间片用完前执行一次I&#x2F;O操作来放弃处理器资源，以达到刷新时间片的目的，我们可以将时间片设计为该任务在该队列可以执行的总时间。意思就是，一个任务可以执行1s，那么无论它放弃了多少次，只要执行的总时间达到1s，他就要被降到低优先级的队列当中。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
        <category>CPU虚拟化</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>地址空间</title>
    <url>/2023/04/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h1 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h1><p>一个线程的地址空间如下图所示：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230415172631305.png" alt="image-20230415172631305"></p>
<p>这个地址空间看似是从0KB开始，但这里的0KB映射到具体的物理地址并不一定是从内存的地址0开始，它可能是物理内存的任意位置。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
        <category>内存虚拟化</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>机制：受限直接执行</title>
    <url>/2023/04/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%8F%97%E9%99%90%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<p>当我们采用时分共享或者空分共享虚化CPU时，也要考虑它带来的问题，第一个是性能问题，频繁的进行上下文切换必然会导致性能下降。第二个是控制权，如何有效的运行进程，同时保留对CPU的控制。</p>
<p>关键问题：如何高效、可控的进行虚化。</p>
<h1 id="受限直接执行"><a href="#受限直接执行" class="headerlink" title="受限直接执行"></a>受限直接执行</h1><h2 id="1、直接执行"><a href="#1、直接执行" class="headerlink" title="1、直接执行"></a>1、直接执行</h2><p>直接执行比较好理解，即直接在CPU资源上运行程序即可。</p>
<p>当程序需要运行时，直接将代码加载到内存中，然后找到入口点运行用户代码。</p>
<p>但是如果没有限制，那么会产生问题：如何保证程序不做我们不想让它做的事情，另一方面是如何停止一个进程让另一个进程运行。</p>
<h2 id="2、受限制的操作"><a href="#2、受限制的操作" class="headerlink" title="2、受限制的操作"></a>2、受限制的操作</h2><p>关键问题：如何执行受限制的操作</p>
<p>一个进程要能够执行I&#x2F;O和其他一些受限制的操作，但又不能让进程控制系统。</p>
<p>针对这个问题，引入了一个新的处理器模式：用户模式。在用户模式下运行的代码会收到限制，比如不能发出I&#x2F;O请求。</p>
<p>与之对应的是内核模式。该模式代码可以做任何操作。</p>
<p>目前硬件提供了用户程序执行<strong>系统调用</strong>的功能，即用户代码可以通过系统调用执行如创建和销毁进程，与其他进程通信等。</p>
<p>要执行系统调用，程序必须执行特殊的陷阱（trap）指令。该指令跳入内核并将特权级别提升到内核模式。但是执行该指令时需要有足够多的寄存器来存储程序目前的状态，确保程序能够正确返回。</p>
<p>很明显的一点是，发起系统调用的过程不能让程序决定跳转到内核的哪里，因为这样会导致恶意程序在内核运行。</p>
<p>解决办法是由一个陷阱表，可以理解为一个map，记录了发生某种指令时需要运行那些代码，这样当用户程序执行系统调用，就会执行对应的位置的代码，而不再由程序决定跳入内核的那个位置。</p>
<h2 id="3、在进程之间切换"><a href="#3、在进程之间切换" class="headerlink" title="3、在进程之间切换"></a>3、在进程之间切换</h2><p>一个很关键的问题，如果进程在CPU上运行，那就意味着操作系统此时没有运行，那操作系统如何拿回控制权呢？</p>
<h3 id="协作方式：等待系统调用"><a href="#协作方式：等待系统调用" class="headerlink" title="协作方式：等待系统调用"></a>协作方式：等待系统调用</h3><p>在这种方式下，运行时间过长的进程会被<strong>假定主动放弃</strong>CPU，以便操作系统决定运行其他任务。注意，这里需要程序手动的将控制权交还给操作系统。</p>
<p>但是也有恶意或者不小的代码执行一些非法操作，就会陷入操作系统，此时操作系统将再次获得CPU。</p>
<h3 id="非协作方式：操作系统进行控制"><a href="#非协作方式：操作系统进行控制" class="headerlink" title="非协作方式：操作系统进行控制"></a>非协作方式：操作系统进行控制</h3><p>这里要解决的问题：如何在没有协作的情况下获得控制权。</p>
<p>上面的那种方式，在出现非法操作时会导致进程陷入操作系统，但是如果一个进程进入无限循环，它不进行系统调用也不出错，那么操作系统就无法获得控制权。</p>
<p>这个问题的解决办法是<strong>时钟中断</strong>。</p>
<p>时钟设备可以便成为每几毫秒产生一次中断，中断发生时，正在运行的进程停止，操作系统预先配置的中断程序会运行，然后操作系统会获得CPU的控制权。然后它就可以停止当前进程，运行另外一个进程。</p>
<h3 id="保存和恢复上下文"><a href="#保存和恢复上下文" class="headerlink" title="保存和恢复上下文"></a>保存和恢复上下文</h3><p>当操作系统获得CPU时，它就要确定是继续执行当前进程还是进行切换。如果进行切换，就需要为当前正在运行的进行保存一些信息到寄存器（通用寄存器，程序计数器，当前正在运行进程的内核指针），并且恢复将要运行的进程恢复一些寄存器的值。这个过程就叫做上下文切换。</p>
<p>当发生时钟中断时，运行进程由用户寄存器隐式保存，使用该进程的内核栈。</p>
<p>当操作系统决定从A切换到B，内核寄存器被操作系统（OS）明确的保存在该进程的进程结构的内存中。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
        <category>CPU虚拟化</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象：进程</title>
    <url>/2023/04/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%8A%BD%E8%B1%A1%EF%BC%9A%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>进程就是运行中的程序。</p>
<p>一台电脑往往只有少数CPU，但是用户想要运行许多个应用，这里的关键问题：如何提供有许多CPU的假象。</p>
<p>操作系统通过虚拟化CPU来提供这假象，让一个进程只运行一个时间片，然后切换到其他进程。每个进程都运行一会儿，给用户的感觉就好像每个进程都在运行一样。</p>
<h1 id="时分共享和空分共享"><a href="#时分共享和空分共享" class="headerlink" title="时分共享和空分共享"></a>时分共享和空分共享</h1><p>时分共享是指让每个进程运行一段时间后让出处理器，让其他进程再运行一段时间，来达到虚拟化CPU的目的。</p>
<p>空分共享是指CPU资源在空间上被划分给希望使用它的进程。但这里需要注意，一旦分给一个进程，某些情况下如果它不释放空间，就不会再把这块空间分给其他进程。</p>
<h1 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h1><p>程序如何转变为进程？</p>
<p>操作系统运行程序必须先把代码和静态数据加载到内存中，加载到进程的地址空间中。如下图所示：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230412193147452.png" alt="image-20230412193147452" style="zoom: 67%;" />

<p>早期操作系统在程序运行前加载完成，而现在的是懒加载，即在程序执行期间需要的代码或者数据，才会加载到内存。</p>
<p>通过将代码和静态数据加载到内存中，然后创建和初始化栈以及执行与I&#x2F;O设置相关的工作，就只剩下最后一个任务，启动程序。</p>
<h1 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h1><p>进程有以下三种状态：</p>
<p>1、运行。说明进程正在处理器上运行，占用着资源。意味着正在执行指令。</p>
<p>2、就绪。程序已经准备好运行，但出于某种原因，操作系统不在此时运行。</p>
<p>3、阻塞。该进程在等待其他某种操作或者某个条件达成后，才可以进入就绪状态。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230412194438253.png" alt="image-20230412194438253" style="zoom:67%;" />

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
        <category>CPU虚拟化</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>空闲空间管理</title>
    <url>/2023/04/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>这一部分，书中做了一些假设：</p>
<p>1、如果请求内存，就需要指定请求内存的大小，而释放该内存则不用指定大小。</p>
<p>2、只考虑外部碎片，不考虑因分配空间稍微大于请求内存而造成的内部碎片。</p>
<p>3、内存一旦被分配给用户，那么它就不可能被重定位。即这块内存分配给用户后，除非用户调用free函数，否则无法被其他人使用。</p>
<p>4、分配程序管理的内存区域是连续的，而且还可以增大这块区域。</p>
<h1 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h1><h2 id="1、分割与合并"><a href="#1、分割与合并" class="headerlink" title="1、分割与合并"></a>1、分割与合并</h2><p>假如内存中空闲状态如下图：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417162102174.png" alt="image-20230417162102174"></p>
<p>那么它对应的空闲链表如图：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417162144075.png" alt="image-20230417162144075"></p>
<p>这也就意味着，任何长度大于10字节的分配请求都会失败。</p>
<p>如果请求分配的内存小于10字节，那么它会找到一块满足的空间区域，然后进行分割，第一块分给用户，剩下的加入空闲列表。</p>
<p>而用户在调用free时，它并不是把用户使用的那块区域直接加入，而是会看用户释放的空间左右两端是否是空闲的，如果是，则进行合并。</p>
<p>比如参考第一张图，如果用户释放中间用掉的10字节，它会变为如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417163036922.png" alt="image-20230417163036922"></p>
<p>而不是</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417163055234.png" alt="image-20230417163055234"></p>
<h2 id="2、追踪已分配空间的大小"><a href="#2、追踪已分配空间的大小" class="headerlink" title="2、追踪已分配空间的大小"></a>2、追踪已分配空间的大小</h2><p>由于在释放对应区域空间时，并不需要指出大小，这是因为在大多数分配程序都会在头块中保存一些额外的信息，头块位于内存中，就在返回的内存区域前面。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417164000218.png" alt="image-20230417164000218" style="zoom:67%;" />

<p>这里释放的时候会释放头块加具体的内存空间，那么意味着在申请内存时，申请的大小也是头块加用户指明的大小。</p>
<h1 id="内存分配的基本策略"><a href="#内存分配的基本策略" class="headerlink" title="内存分配的基本策略"></a>内存分配的基本策略</h1><p>1、最优匹配：找到和用户申请大小最接近的一块区域，分配给用户。但是他需要遍历所有的空闲列表，性能差一点。</p>
<p>2、最差匹配：找最大的空闲区域，分割并分配给用户。会导致过量碎片，而且性能不好。</p>
<p>3、首次匹配：找到第一个足够大的块，分配给用户。不需要全部遍历，但可能会导致开头的部分有很多的小块，因此，如何管理空闲列表顺序就变的比较重要。</p>
<p>一种解决办法：一种方式是基于地址排序，保持空闲块按内存地址有序，会让合并变得容易，减少内存碎片。</p>
<p>4、下次匹配：每一次都从上一次分配完成的地址开始往后遍历。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
        <category>内存虚拟化</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>进程调度：介绍</title>
    <url>/2023/04/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%9A%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>本文主要介绍一些基础的调度策略。</p>
<h1 id="调度指标"><a href="#调度指标" class="headerlink" title="调度指标"></a>调度指标</h1><p>以下算法的性能指标只考虑周转时间。</p>
<p>周转时间 &#x3D; 完成时间 - 到达时间</p>
<h1 id="先进先出（FIFO）"><a href="#先进先出（FIFO）" class="headerlink" title="先进先出（FIFO）"></a>先进先出（FIFO）</h1><p>这个算法的思路很简单，先来的先执行，并且易于实现。就好比有三个任务A，B，C，他们到来的顺序是B，A，C，那么就按照他们到来的顺序进行执行。</p>
<p>存在的问题：如果先来的任务执行了很长时间，会导致后边的任务等待很久才可以执行，这样会导致系统的周转时间变的很长。</p>
<h1 id="最短任务优先（SJF）"><a href="#最短任务优先（SJF）" class="headerlink" title="最短任务优先（SJF）"></a>最短任务优先（SJF）</h1><p>该算法会先运行短任务，然后运行次短任务，依次下去。如果任务同时到达，该算法较FIFO算法可以很好的解决平均周转时间长的问题。</p>
<p>但是如果任务不同时到达，那么执行时间长的任务比短时任务先到达，还是会导致短任务需要等待。</p>
<h1 id="最短完成时间优先（STCF）"><a href="#最短完成时间优先（STCF）" class="headerlink" title="最短完成时间优先（STCF）"></a>最短完成时间优先（STCF）</h1><p>上面两种算法都是非抢占式的。</p>
<p>而最短完成时间优先可以理解为一种抢占式的最短任务优先算法。</p>
<p>该算法下，没当有任务进入系统，会判断当前正在执行任务的剩余时间和新任务的时间，哪个短就执行哪个。</p>
<h1 id="新的性能指标"><a href="#新的性能指标" class="headerlink" title="新的性能指标"></a>新的性能指标</h1><p>从现在开始，性能不仅考虑周转时间，还要考虑响应时间。</p>
<p>响应时间 &#x3D; 首次运行 - 到达时间。</p>
<h1 id="轮转"><a href="#轮转" class="headerlink" title="轮转"></a>轮转</h1><p>在加入新的性能指标后，上述算法就会出现问题，因为会导致长任务的响应时间特别长。</p>
<p>轮转的思想是，每一个任务执行一个时间片，然后切换到队列中的下一个任务，而不是一个任务一直执行，直到完毕。</p>
<p>该算法需要考虑时间片长短的问题，太短会导致频繁切换而导致性能下降，而太长，则会导致周转时间和响应时间太长，所以需要权衡考虑。</p>
<h1 id="结合I-x2F-O"><a href="#结合I-x2F-O" class="headerlink" title="结合I&#x2F;O"></a>结合I&#x2F;O</h1><p>现在假设任务都需要进行I&#x2F;O操作，那么轮转这种设计方法就会体现出它的优势。</p>
<p>如果不进行轮转，先到来的任务占用处理器资源，然后又进行了I&#x2F;O操作，那么会导致一个任务占用处理器资源却不使用，而是进行I&#x2F;O操作，导致其他任务也无法执行，这是对处理器的浪费。</p>
<p>而轮转却能很好的解决该问题，因为任务在执行I&#x2F;O操作时，可以让出处理器，让其他任务使用。</p>
<h1 id="无法预知"><a href="#无法预知" class="headerlink" title="无法预知"></a>无法预知</h1><p>上面的讨论都是建立在操作系统知道任务需要处理多长时间，而事实情况是，执行时间是无法估计的，所以像SJF或者STCF这种算法，几乎无法实现。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
        <category>CPU虚拟化</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>超越物理内存的机制</title>
    <url>/2023/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B6%85%E8%B6%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p> 在本章之前，我们所做的假设都是将进程的所有页都可以放入内存当中，但实际情况是，物理内存无法存储这么多的页。而且，为了更大的地址空间，我们也需要更大的物理内存来存储更大的页表。</p>
<p>这里的一个解决办法就是，利用磁盘空间，也就是说将页表取出一部分，放入磁盘当中。而操作系统需要知道这些被换出的页存在于磁盘的哪个位置，以便后续将他们加载到内存当中。</p>
<h1 id="交换空间"><a href="#交换空间" class="headerlink" title="交换空间"></a>交换空间</h1><p>在磁盘上开辟一块空间，用于物理页的移入和移出，这些空间就称为交换空间。而交换空间的大小，决定了系统在某一时刻能够使用的最大内存页数。而且操作系统需要记得给定页的硬件地址。</p>
<h1 id="存在位"><a href="#存在位" class="headerlink" title="存在位"></a>存在位</h1><p>按照之前的设定，一个虚拟地址转换为物理地址，会先检查TLB（快速地址转换），如果命中，则直接从中获取到映射，速度很快。</p>
<p>如果未命中，则需要先去内存中去找页目录，然后从页目录中找到对应页表页（页表被分为了很多个页），然后从页表中找到对应的映射，之后再把它加入TLB中。</p>
<p>如果添加了交换空间，这里边就需要考虑页是否在内存中的情况，则需要多一个标记位，即存在位，用于标记该页是否在内存当中。</p>
<h1 id="页错误"><a href="#页错误" class="headerlink" title="页错误"></a>页错误</h1><p>如果访问的页不在内存当中，就会发生页错误。</p>
<p>发生页错误，可能是因为该页被换出磁盘，那么系统就需要从对应的磁盘当中去加载内存页，这也就要求操作系统需要知道被换出的页的存储位置。操作系统可以使用PTE（页表项）的某些位来存储硬盘地址。</p>
<p>当将该页加载到内存后，操作系统会更新页表，将该页标记为存在内存当中，并且更新页表项中对应位置，它之前是记录了在硬盘的地址，现在把他改为在内存中的地址。</p>
<h1 id="何时交换页"><a href="#何时交换页" class="headerlink" title="何时交换页"></a>何时交换页</h1><p>操作系统都会设置一个高水位线，也就是说并不会等到内存满了才执行换出，而是会预留一部分内存。当内存的使用情况超过高水位线时，就会从内存中清除页。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
        <category>内存虚拟化</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>AOF持久化设计</title>
    <url>/2022/11/15/Redis/AOF%E6%8C%81%E4%B9%85%E5%8C%96%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>RDB持久化会直接保存某一时刻的数据快照，而AOF持久化是直接记录Redis执行过的命令来记录数据库状态。</p>
<h3 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h3><p>AOF持久化功能可以分为命令追加，文件写入，文件同步这三个步骤。</p>
<h4 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h4><p>如果AOF功能处于开启状态，当Redis执行了一个写命令后，会将执行的写命令追加到aof_buf缓冲区末尾。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个redisServer保存了书中从前到后所展现过的所有结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 一个数组，保存着服务器中所有的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器数据库的数量</span></span><br><span class="line">    <span class="type">int</span> dbnum;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录了保存条件的数组 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparam</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改计数器</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dirty;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上一次执行保存的时间</span></span><br><span class="line">    <span class="type">time_t</span> lastsave;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// AOF缓冲区</span></span><br><span class="line">    sds aof_buf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h4><p>Redis服务器进程是一个事件循环，这个循环中<strong>文件事件</strong>负责接受客户端请求，以及发送回复命令，还有时间事件等，每个事件负责处理一部分内容。</p>
<p>在处理文件事件时可能会执行一些写命令，就会有一部分内容被追加到aof_buf缓冲区中，所以循环中每次结束事件，都会调用flushAppendOnlyFile函数，考虑是否将缓冲区中的内容追加到AOF文件当中。伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 文件处理事件，有可能将新内容追加到aof_buf缓冲区</span></span><br><span class="line">        processFileEvents();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理时间事件</span></span><br><span class="line">        processTimeEvents();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 考虑是否将缓冲区内容保存到AOF文件</span></span><br><span class="line">        flushAppendOnlyFile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>flushAppendOnlyFile怎么执行由appendfsync来配置。具体如下：</p>
<p>always：将缓冲区所有内容<strong>写入并同步</strong>到AOF文件。</p>
<p>everysec：将缓冲区所有内容写入到AOF文件，如果上次上次同步时间距离这次超过1秒，那么再次对AOF文件进行同步。这个同步操作是由一个线程专门操作的。</p>
<p>no：将内容写入AOF，但不进行同步，什么时候同步由操作系统决定。</p>
<h5 id="文件的写入与同步"><a href="#文件的写入与同步" class="headerlink" title="文件的写入与同步"></a>文件的写入与同步</h5><p>现代的操作系统为了提升效率，在文件写入时会先把数据写入缓冲区，在缓冲区写满或者超出指定时间再去写入文件。这里的写入不进行同步指的是写入到操作系统设计的写入缓冲区，但是还没有真正的写入AOF文件，等到缓冲区写满就会被真正的写入AOF文件。</p>
<h5 id="这三种策略的效率与安全性"><a href="#这三种策略的效率与安全性" class="headerlink" title="这三种策略的效率与安全性"></a>这三种策略的效率与安全性</h5><p>always：因为每次都会写入并且同步，安全性最高，即使宕机也只会丢失一个时间循环中所修改的数据。但是同步过程牵扯到写磁盘操作，所以效率比较低。</p>
<p>everysec：每隔一秒会同步一次，效率可以接受，安全性只有可能丢失1s的数据。</p>
<p>no：效率最高，因为不进行同步，如果宕机则会丢上次同步到当前所修改的所有数据。</p>
<h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>AOF重写用于缩小AOF文件，考虑一种场景，redis存了一个key为msg，值为hello world的键值对，然后对其做了数次修改，最终又回到了hello world，但是AOF文件却记录了很多条命令，这些命令其实是多余的。AOF重写就是为了去掉这些多余的命令。</p>
<h4 id="重写的实现"><a href="#重写的实现" class="headerlink" title="重写的实现"></a>重写的实现</h4><p>AOF重写是用一个新的AOF文件来代替旧的AOF文件。生成新的AOF文件并不需要对旧的AOF文件进行读取，而是根据当前数据库数据生成的。比如list集合中有2个元素，然后经过多次操作最终有5个元素。其实可以直接根据这5条记录生成命令，然后写入新的AOF文件。</p>
<p>伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">aof_rewrite</span><span class="params">(new_file_name)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建新的文件</span></span><br><span class="line">    f = create_file(new_file_name);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历数据库</span></span><br><span class="line">    <span class="keyword">for</span> db in redisServer.db &#123;</span><br><span class="line">        <span class="comment">// 为空则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (db.is_empty) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 写入select 命令，用于加载时确定数据库</span></span><br><span class="line">        f.write_command(<span class="string">&quot;select&quot;</span> + db.id);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> key in db &#123;</span><br><span class="line">            <span class="comment">// 如果过期则忽略</span></span><br><span class="line">            <span class="keyword">if</span> (key.is_expired()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 根据键类型进行重写</span></span><br><span class="line">            <span class="keyword">if</span> (key.type == String) &#123;</span><br><span class="line">                rewrite_string(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.type == List) &#123;</span><br><span class="line">                rewrite_list(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.type == Hash) &#123;</span><br><span class="line">                rewrite_hash(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.type == Set) &#123;</span><br><span class="line">                rewrite_set(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.type == SortedSet) &#123;</span><br><span class="line">                rewrite_sorted_set(key);</span><br><span class="line">            &#125; </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果键带有过期时间，则过期时间也要重写</span></span><br><span class="line">			<span class="keyword">if</span> (key.have_expire_time()) &#123;</span><br><span class="line">                rewrite_expire_time();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 写入完毕</span></span><br><span class="line">        f.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h4><p>因为AOF重写期间会执行大量的写入文件操作，所以如果用主进程去进行重写，则会造成阻塞。所以Redis将AOF重写放入子进程中。这样有两个好处，一是父进程可以继续处理请求，二是子进程带有服务器进程数据副本，使用子进程而不是子线程，可以在避免使用锁的情况下保证数据安全。</p>
<p>有一点需要注意，在执行AOF重写时，主进程还会处理请求，意味着已经写入的数据可能已经被修改。为了处理这个问题，Redis设置了一个AOF重写缓冲区，在创建子进程开始后，主进程处理的命令会同时写入<strong>AOF缓冲区</strong>和<strong>AOF重写缓冲区</strong>。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230325130958729.png" alt="image-20230325130958729"></p>
<p>在子进程重写完成后，会告知主进程，然后主进程会将AOF重写缓冲区的内容写入AOF缓冲区，这样就保证了数据一致。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis持久化</tag>
      </tags>
  </entry>
  <entry>
    <title>超越物理内存的策略</title>
    <url>/2023/04/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B6%85%E8%B6%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>当有足够的内存时，发生页错误，只需要将页加入内存即可，但是如果内存不够，就需要将内存中的一些页换出，放入磁盘中去。那么现在问题就在于，要将那些页面换出呢？</p>
<p>这些存在于内存中的页，可以看作是一个缓存，如果访问该页时，页在内存，就当作缓存命中，不在就是没命中，那么我们的目标就变为让缓存的命中率尽可能地提高。</p>
<h1 id="最优替换策略"><a href="#最优替换策略" class="headerlink" title="最优替换策略"></a>最优替换策略</h1><p>该替换策略是将最远的将来才会使用到的页替换出去，这样就能使得命中率最高，但是也很难实现，或者换种方式说，几乎无法实现。因为我们无法知道哪个页最远才会被使用，该算法只能作为一个比较使用。</p>
<h1 id="FIFO（先进先出）"><a href="#FIFO（先进先出）" class="headerlink" title="FIFO（先进先出）"></a>FIFO（先进先出）</h1><p>先进入系统的页就先被换出。优点是实现很简单。缺点是可能导致内存页命中率特别低，极端情况下还会为0。</p>
<h1 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h1><p>依靠随机数，替换出某些页。该策略实现页比较简单，但是依靠运气。</p>
<h1 id="利用历史数据：LRU"><a href="#利用历史数据：LRU" class="headerlink" title="利用历史数据：LRU"></a>利用历史数据：LRU</h1><p>该算法考虑历史使用数据，如果一个页被很频繁的使用，那么它应该是比较重要的，不应该被换出。那么那些最近最不经常使用的页，就会被换出内存。</p>
<p>这里使用了局部性原则，包括空间局部性和时间局部性。</p>
<p>面临的问题：</p>
<p>该算法要求我们，每次访问内存，都需要同步的做一些修改，来更新页面位于队列中的位置。为了记录那些页最少被访问，我们需要记录内存的引用，但是这些记录可能会导致占用大量空间。</p>
<p>如果通过硬件实现，比如给每个页设置一个时间，每次系统访问内存时，硬件去更新该时间，而需要替换出页时，扫描所有页找到最久的即可。但是页特别多的话，耗时非常高。</p>
<h1 id="近似的LRU"><a href="#近似的LRU" class="headerlink" title="近似的LRU"></a>近似的LRU</h1><p>该算法的实现需要硬件添加一个使用位。系统的每一个页都有一个存在位，该值是0或者1。每当该页被引用时，就将该位改为1。但是硬件不会将其置为0，这是由操作系统设置的。</p>
<p>该算法的实现是始终算法。即将所有的页放在一个循环队列中，时钟指针开始时指向某个页，当需要替换页时，会检查时钟指针指向的页的标记为是0还是1，如果是1就说明不适合换出，而0就将它换出。如果是1，就会找下一个页，一直到找到一个是0的为止。如果找完所有的页，还是没有0，那么就将所有的页都设置为0。</p>
<p>它的一个改进算法为，扫描到1的，不置换出该页，但是将标记位改为0，防止遍历完一遍后找不到为0的标记位。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
        <category>内存虚拟化</category>
      </categories>
      <tags>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU结构对Redis性能的影响</title>
    <url>/2023/04/05/Redis/CPU%E7%BB%93%E6%9E%84%E5%AF%B9Redis%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    <content><![CDATA[<h1 id="主流CPU架构"><a href="#主流CPU架构" class="headerlink" title="主流CPU架构"></a>主流CPU架构</h1><p>一个 CPU 处理器中一般有多个运行核心，我们把一个运行核心称为一个物理核。每个物理核都有私有的一级缓存（L1 cache）以及二级缓存（L2 cache），即其他物理核无法访问。</p>
<p>不同的物理核还会共享一个共同的三级缓存（L3 cache）</p>
<p>现在主流的 CPU 处理器中，每个物理核通常都会运行两个超线程，也叫作逻辑核。同一个物理核的逻辑核会共享使用 L1、L2 缓存。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230405110450816.png" alt="image-20230405110450816"></p>
<p>一个CPU会有多个物理核，而一个服务器上可能会有多个CPU，如下图所示：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230405110614748.png" alt="image-20230405110614748"></p>
<p>在上图的这种CPU架构中，Redis可以在不同的CPU上运行，意味着它可以现在Socket1上运行，然后被调度到Socket2上执行。</p>
<p>这里就会出现问题，如果应用程序先在一个 Socket 上运行，并且把数据保存到了内存，然后被调度到另一个 Socket 上运行，此时，应用程序再进行内存访问时，就需要访问之前 Socket 上连接的内存，这种访问属于<strong>远端内存访问</strong>。<strong>和访问 Socket 直接连接的内存相比，远端内存访问会增加应用程序的延迟。</strong></p>
<p>每一个CPU会管理一部分内存，所以存在从Socket1切换到Socket2上存在远端访问。</p>
<h1 id="CPU多核对Redis的影响"><a href="#CPU多核对Redis的影响" class="headerlink" title="CPU多核对Redis的影响"></a>CPU多核对Redis的影响</h1><p>在一个 CPU 核上运行时，应用程序需要记录自身使用的软硬件资源信息（例如栈指针、CPU 核的寄存器值等），我们把这些信息称为<strong>运行时信息</strong>。同时，应用程序访问最频繁的指令和数据还会被缓存到 L1、L2 缓存上，以便提升执行速度。</p>
<p>Redis在不同cpu之前进行切换时，另一个cpu上并没有redis之前运行时频繁访问的指令和数据，所以这些数据都需要重新从L3缓存甚至是内存中加载，Redis需要等到这些加载完才处理请求，所以会导致较高的延迟。</p>
<p>如果在 CPU 多核场景下，Redis 实例被频繁调度到不同 CPU 核上运行的话，那么，对 Redis 实例的请求处理时间影响就更大了。<strong>每调度一次，一些请求就会受到运行时信息、指令和数据重新加载过程的影响，这就会导致某些请求的延迟明显高于其他请求</strong>。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>可以把Redis实例绑定到一个CPU的一个<strong>物理核</strong>上面。</p>
<p>这里是因为同一个CPU里面会有多个物理核，而物理核的L1和L2缓存是私有的，如果在同一个CPU的不同物理核切换，也会导致一些命令需要重新加载。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis核心技术实战</tag>
      </tags>
  </entry>
  <entry>
    <title>Cluster规模对于通信的影响</title>
    <url>/2023/03/24/Redis/Cluster%E8%A7%84%E6%A8%A1%E5%AF%B9%E4%BA%8E%E9%80%9A%E4%BF%A1%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    <content><![CDATA[<h3 id="实例通信方法和对集群规模的影响"><a href="#实例通信方法和对集群规模的影响" class="headerlink" title="实例通信方法和对集群规模的影响"></a>实例通信方法和对集群规模的影响</h3><p>redis官方给出了Redis Cluster的规模上限为1000个实例，其中一个限制实例规模的因素就是<strong>实例间的通信会随着实例规模的增加而增大</strong>，因此在实例超过一定规模后，实例增加吞吐量反而会下降。</p>
<p>Redis Cluster 运行时，每个实例都会保存slot和实例的对应关系，以及自身的状态信息。为了让集群中每个实例都知道其他实例的状态，所以实例之间需要进行通信，采用的是Gossip 协议。</p>
<h4 id="Gossip-协议原理"><a href="#Gossip-协议原理" class="headerlink" title="Gossip 协议原理"></a>Gossip 协议原理</h4><p>1、每个实例之间会按照一定的频率，从集群中随机挑选一些实例，把 PING 消息发送给挑选出来的实例，用来检测这些实例是否在线，并交换彼此的状态信息。PING 消息中封装了发送消息的实例自身的状态信息、部分其它实例的状态信息，以及 Slot 映射表。</p>
<p>2、一个实例在接收到 PING 消息后，会给发送 PING 消息的实例，发送一个 PONG 消息。PONG 消息包含的内容和 PING 消息一样。</p>
<p>Gossip 协议可以保证在一段时间后，集群中的每一个实例都能获得其它所有实例的状态信息。</p>
<p>不难看出，实例间使用 Gossip 协议进行通信时，通信开销受到<strong>通信消息大小</strong>和<strong>通信频率</strong>这两方面的影响。信息越大，频率越高，影响越大。</p>
<p>Redis Cluster 的实例启动后，默认会每秒从本地的实例列表中随机选出 5 个实例，再从这 5 个实例中找出一个最久没有通信的实例，把 PING 消息发送给该实例。但是这样会导致<strong>有些实例一直没有被发送 PING 消息，导致它们维护的集群状态已经过期了</strong>。</p>
<p>为了避免这种情况，Redis Cluster 的实例会按照每 100ms 一次的频率，扫描本地的实例列表，如果发现有实例最近一次接收 PONG 消息的时间，已经大于配置项 cluster-node-timeout 的一半了（cluster-node-timeout&#x2F;2），就会立刻给该实例发送 PING 消息，更新这个实例上的集群状态信息。</p>
<p>以上频率加上每一次ping，pong所包含信息的大小，多实例的通信占用带宽可能会很多。</p>
<h3 id="如何降低实例间的通信开销"><a href="#如何降低实例间的通信开销" class="headerlink" title="如何降低实例间的通信开销"></a>如何降低实例间的通信开销</h3><p>针对以上分析，降低开销的办法一方面可以降低实例传输的大小，另一方面可以降低通信频率。</p>
<p>降低大小不可取，因为降低大小只能减少传输的字段，无法保证实例之间传输足够的信息来维持集群运行。</p>
<p>所以只能通过降低通信频率。可以修改cluster-node-timeout 这个配置项。</p>
<p>配置项 cluster-node-timeout 定义了集群实例被判断为故障的心跳超时时间，默认是 15 秒。如果 cluster-node-timeout 值比较小，那么，在大规模集群中，就会比较频繁地出现 PONG 消息接收超时的情况，从而导致实例每秒要执行 10 次“给 PONG 消息超时的实例发送 PING 消息”这个操作。</p>
<p>所以，为了避免过多的心跳消息挤占集群带宽，我们可以调大 cluster-node-timeout 值，比如说调大到 20 秒或 25 秒。这样一来， PONG 消息接收超时的情况就会有所缓解，单实例也不用频繁地每秒执行 10 次心跳发送操作了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Redis核心技术实战》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
        <category>集群</category>
      </categories>
      <tags>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的RDB持久化设计</title>
    <url>/2022/11/13/Redis/RDB%E6%8C%81%E4%B9%85%E5%8C%96%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h3 id="什么是RDB持久化"><a href="#什么是RDB持久化" class="headerlink" title="什么是RDB持久化"></a>什么是RDB持久化</h3><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。</p>
<h3 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h3><p>redis中有两个命令可以生成RDB文件，分别是SAVE命令以及BGSAVE命令。</p>
<p>SAVE命令会阻塞redis进程，直到RDB文件生成后，redis才可以继续处理请求。</p>
<p>BGSAVE命令会委派一个子进程，由子进程来创建RDB文件，然后主进程继续处理请求。</p>
<p>RDB文件的载入是在服务器启动时自行载入，没有命令。</p>
<p>注意：如果同时开启AOF和RDB这两种持久化方法，那么会优先使用AOF。</p>
<h4 id="执行BGSAVE时服务器状态"><a href="#执行BGSAVE时服务器状态" class="headerlink" title="执行BGSAVE时服务器状态"></a>执行BGSAVE时服务器状态</h4><p>在执行BGSAVE命令时，为了避免竞争，服务器在此期间收到SAVE命令和BGSAVE命令会直接拒绝。</p>
<p>而BGREWRITEAOF不能和BGSAVE命令一起执行。</p>
<p>如果此时服务器正在执行BGSAVE命令，那么他会把BGREWRITEAOF延迟到BGSAVE命令执行完在执行。如果在执行BGREWRITEAOF，那么BGSAVE命令会被拒绝。</p>
<h3 id="自动间隔设计"><a href="#自动间隔设计" class="headerlink" title="自动间隔设计"></a>自动间隔设计</h3><p>redis允许用户设置每隔一段时间执行一次BGSAVE命令。使用save命令即可。具体操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 意味着每900秒，有1次修改就执行一次BGSAVE命令。</span><br><span class="line">save 900 1</span><br></pre></td></tr></table></figure>

<h4 id="如何保存"><a href="#如何保存" class="headerlink" title="如何保存"></a>如何保存</h4><p>通过save命令所设置的值会保存在redisServer中的saveparams属性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 一个数组，保存着服务器中所有的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器数据库的数量</span></span><br><span class="line">    <span class="type">int</span> dbnum;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录了保存条件的数组 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparam</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> &#123;</span></span><br><span class="line">    <span class="comment">// 秒数</span></span><br><span class="line">    <span class="type">time_t</span> seconds;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改书</span></span><br><span class="line">    <span class="type">int</span> changes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>saveparam是一个数组，里面每一个元素都是一个saveparam的结构体，保存了上述命令设置的时间以及修改数。</p>
<p>比如执行了以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p>那么saveparams中就会如下图所示</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230324140839313.png" alt="image-20230324140839313"></p>
<h4 id="dirty计数器和lastsave"><a href="#dirty计数器和lastsave" class="headerlink" title="dirty计数器和lastsave"></a>dirty计数器和lastsave</h4><p>除了saveparams，redisServer还维护了一个dirty计数器和lastsave属性，其中dirty计数器记录了距离上一次成功执行SAVE或者BGSAVE命令后，服务器对数据库（所有的db，即db数组中每一个）进行了多少次修改（增删改），lastsave命令是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间。</p>
<p>具体结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 一个数组，保存着服务器中所有的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器数据库的数量</span></span><br><span class="line">    <span class="type">int</span> dbnum;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录了保存条件的数组 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparam</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改计数器</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dirty;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上一次执行保存的时间</span></span><br><span class="line">    <span class="type">time_t</span> lastsave;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中dirty在每次执行完SAVE或者BGSAVE后，会被置0。</p>
<h3 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h3><p>一个具体的RDB文件结构如下图所示：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230324142312205.png" alt="image-20230324142312205"></p>
<p>RBD文件开头是REDIS部分，这里保存着”REDIS”五个字符，用于标识文件是一个RDB文件。</p>
<p>db_version长度为4字节，是一个用字符串表示的整数，记录RDB文件的版本号。</p>
<p>databases部分包含着零个或多个数据库，以及各个数据库的键值对。其中，如果所有数据库都为空（db数组中的所有数据库），那么这里也为空。如果至少有一个非空，那么根据数据库保存的数据键值对数量，类型和内容不同，这里也有所不同。</p>
<p>EOF常量的长度为1，标志着RDB文件正文内容的结束。</p>
<p>check_num是一个8字节的无符号整数，保存着校验和。这个校验和是通过对前四部份内容进行计算得出的，服务器在载入RDB文件时，会根据前四部分进行计算然后以check_num进行对比，来校验是否出错。</p>
<h4 id="databases部分"><a href="#databases部分" class="headerlink" title="databases部分"></a>databases部分</h4><p>假如redisServer的db部分有2个数据库不为空，那么databases结构如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230324143315822.png" alt="image-20230324143315822"></p>
<p>每个非空数据库在RDB文件中都可以保存为SELECTDB、db_number、key_value_pairs三部分。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230324144419555.png" alt="image-20230324144419555"></p>
<p>SELECTDB常量的长度为1字节，用于当程序直到，接下来读入的是一个数据库号码。</p>
<p>db_number保存的是一个数据库号，根据号码大小不同，可以是1字节，2字节或者5字节。读到这个数据后会立即执行一个SELECT命令，进行数据库切换，以保证后续载入是正确的。</p>
<p>key_value_pairs保存了数据库中所有键值对数据，如果键值对带有过期时间，那么过期时间也会被保存。</p>
<h5 id="key-value-pairs"><a href="#key-value-pairs" class="headerlink" title="key_value_pairs"></a>key_value_pairs</h5><p>该部分保存具体的键值对，如果不带过期时间，则由TYPE，key，value三部分组成。</p>
<p>其中TYPE记录了value的类型。key总是一个字符串对象。</p>
<p>结构如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230324145255638.png" alt="image-20230324145255638"></p>
<p>带过期时间的多了一个EXPIRETIME_MS和ms属性。</p>
<p>EXPIRETIME_MS用于告知接下来读入将是一个以毫秒为单位的过期时间，ms是一个UNIX时间戳，记录着过期时间。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230324145440827.png" alt="image-20230324145440827"></p>
<p>下面介绍key_value_pairs的type不同编码所对应的value</p>
<h5 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h5><p>在服务器打开了RDB文件压缩功能的情况下，如果字符串的长度大于20字节，那么这个字符串会被压缩后保存。</p>
<p>不压缩和压缩后的结构分别如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230324150428100.png" alt="image-20230324150428100"></p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230324150437915.png" alt="image-20230324150437915"></p>
<p>压缩后的REDIS_RDB_ENC_LZF代表开启了LZF压缩算法，需要通过后边三个参数来进行解压。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230324150539948.png" alt="image-20230324150539948"></p>
<h5 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h5><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230324151159563.png" alt="image-20230324151159563"></p>
<p>list_length记录了列表的长度，即有多少个元素。后边是每个具体的元素。一个具体的结构如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230324152531691.png" alt="image-20230324152531691"></p>
<h5 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h5><p>集合对象和上面的列表对象一样。</p>
<h5 id="哈希表对象"><a href="#哈希表对象" class="headerlink" title="哈希表对象"></a>哈希表对象</h5><p>结构如下</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230324152830195.png" alt="image-20230324152830195"></p>
<p>一个具体的例子：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230324152856443.png" alt="image-20230324152856443"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis持久化</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis为什么可以支撑秒杀场景</title>
    <url>/2023/03/22/Redis/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E6%94%AF%E6%92%91%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h3 id="秒杀场景的负载特征对支撑系统的要求"><a href="#秒杀场景的负载特征对支撑系统的要求" class="headerlink" title="秒杀场景的负载特征对支撑系统的要求"></a>秒杀场景的负载特征对支撑系统的要求</h3><h4 id="特征一：瞬时并发访问很高。"><a href="#特征一：瞬时并发访问很高。" class="headerlink" title="特征一：瞬时并发访问很高。"></a>特征一：瞬时并发访问很高。</h4><p>一般的数据库每秒可以支撑千级别的并发请求，而Redis的并发处理能力达到了万级别。所以当有大量请求涌入系统，我们可以使用Redis先拦截大部分请求，避免很多请求直接发到数据库。</p>
<h4 id="特征二：读多写少，而且读操作是简单查询操作。"><a href="#特征二：读多写少，而且读操作是简单查询操作。" class="headerlink" title="特征二：读多写少，而且读操作是简单查询操作。"></a>特征二：读多写少，而且读操作是简单查询操作。</h4><p>一般的场景，需要先验证库存，然后再进行下单和商品购买，而查询库存这一操作也比较简单，适合使用Redis。</p>
<h3 id="Redis-可以在秒杀场景的哪些环节发挥作用"><a href="#Redis-可以在秒杀场景的哪些环节发挥作用" class="headerlink" title="Redis 可以在秒杀场景的哪些环节发挥作用"></a>Redis 可以在秒杀场景的哪些环节发挥作用</h3><h4 id="秒杀活动前"><a href="#秒杀活动前" class="headerlink" title="秒杀活动前"></a>秒杀活动前</h4><p>在这个阶段，用户会不断刷新商品详情页，这会导致详情页的瞬时请求量剧增。这个阶段的应对方案，一般是尽量<strong>把商品详情页的页面元素静态化，然后使用 CDN 或是浏览器把这些静态化的元素缓存起来</strong>。这样一来，秒杀前的大量请求可以直接由 CDN 或是浏览器缓存服务，不会到达服务器端了，这就减轻了服务器端的压力。</p>
<h4 id="秒杀活动开始"><a href="#秒杀活动开始" class="headerlink" title="秒杀活动开始"></a>秒杀活动开始</h4><p>简单来说这个阶段的操作有三个，库存查验、库存扣减和订单处理，其中查看库存的请求应该是最多的。所以我们可以使用Redis来保存库存数量，减少查询库存给数据库带来的压力。</p>
<p>除了查库存外，订单处理的操作可以放在后端处理。因为这时候只有少部分请求可以到达，所以压力不会太大。</p>
<p>但是扣减库存的操作最好不要放在后端。因为扣减库存放在数据库则需要维护Redis和数据库数据的一致性，会增加额外的开销。而且数据库更新比较慢，可能会导致大量请求查到旧的库存，导致超卖。所以扣减库存的操作最好放在redis中。</p>
<h4 id="秒杀结束后"><a href="#秒杀结束后" class="headerlink" title="秒杀结束后"></a>秒杀结束后</h4><p>整个阶段并发量会小很多，并不需要redis过多参与。</p>
<h3 id="Redis-的哪些特点可以支撑秒杀场景"><a href="#Redis-的哪些特点可以支撑秒杀场景" class="headerlink" title="Redis 的哪些特点可以支撑秒杀场景"></a>Redis 的哪些特点可以支撑秒杀场景</h3><h4 id="支持高并发"><a href="#支持高并发" class="headerlink" title="支持高并发"></a>支持高并发</h4><p>Redis本身就支持高并发，如果有多个秒杀商品，我们也可以使用切片集群，用不同的实例保存不同商品的库存，这样就避免，使用单个实例导致所有的秒杀请求都集中在一个实例上的问题了。</p>
<h4 id="保证库存查验和库存扣减原子性执行"><a href="#保证库存查验和库存扣减原子性执行" class="headerlink" title="保证库存查验和库存扣减原子性执行"></a>保证库存查验和库存扣减原子性执行</h4><p>针对这条要求，我们就可以使用 Redis 的原子操作或是分布式锁这两个功能特性来支撑了。</p>
<p><strong>基于原子操作支撑秒杀场景</strong></p>
<p>因为查验库存和扣减库存这两个操作要保证一起执行，<strong>一个直接的方法就是使用 Redis 的原子操作</strong>。</p>
<p>Redis原子操作有两种办法，原子命令或者Lua脚本。由于这是两个操作，无法使用一个命令，所以这里要使用lua脚本。</p>
<p><strong>基于分布式锁来支撑秒杀场景</strong></p>
<p><strong>使用分布式锁来支撑秒杀场景的具体做法是，先让客户端向 Redis 申请分布式锁，只有拿到锁的客户端才能执行库存查验和库存扣减</strong>。这样一来，大量的秒杀请求就会在争夺分布式锁时被过滤掉。而且，库存查验和扣减也不用使用原子操作了，因为多个并发客户端只有一个客户端能够拿到锁，已经保证了客户端并发访问的互斥性。</p>
<h3 id="秒杀场景其他需要注意的点"><a href="#秒杀场景其他需要注意的点" class="headerlink" title="秒杀场景其他需要注意的点"></a>秒杀场景其他需要注意的点</h3><h4 id="请求拦截和流控"><a href="#请求拦截和流控" class="headerlink" title="请求拦截和流控"></a>请求拦截和流控</h4><p>在秒杀系统的接入层，对恶意请求进行拦截，避免对系统的恶意攻击，例如使用黑名单禁止恶意 IP 进行访问。如果 Redis 实例的访问压力过大，为了避免实例崩溃，我们也需要在接入层进行限流，控制进入秒杀系统的请求数量。</p>
<h4 id="库存信息过期时间处理"><a href="#库存信息过期时间处理" class="headerlink" title="库存信息过期时间处理"></a>库存信息过期时间处理</h4><p>Redis 中保存的库存信息其实是数据库的缓存，为了避免缓存击穿问题，我们不要给库存信息设置过期时间。</p>
<h4 id="数据库订单异常处理"><a href="#数据库订单异常处理" class="headerlink" title="数据库订单异常处理"></a>数据库订单异常处理</h4><p>如果数据库没能成功处理订单，可以增加订单重试功能，保证订单最终能被成功处理。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis事件</title>
    <url>/2022/11/16/Redis/Redis%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>Redis服务器是事件驱动程序，服务器需要处理以下两类事件：</p>
<p>1、文件事件。</p>
<p>Redis服务器通过套接字与客户端或者其他Redis服务器进行连接，而文件事件就是服务器对套接字的抽象。服务器与客户端或其他服务器的通信会产生相应的文件事件，而服务器就是通过监听并处理这些事件来完成网络通信的。</p>
<p>2、时间时间。</p>
<p>Redis服务器中一些操作需要在给定时间点执行，而时间事件就是服务器对这类定时操作的抽象。</p>
<h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>文件事件处理器采用I&#x2F;O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答，读取，写入，关闭等操作时，与操作对应的文件事件就会产生，这时文件事件处理器就会根据套接字关联好的事件处理器来处理这些事件。</p>
<h3 id="文件事件处理器的构成"><a href="#文件事件处理器的构成" class="headerlink" title="文件事件处理器的构成"></a>文件事件处理器的构成</h3><p>有四个部分：</p>
<p>1、套接字</p>
<p>2、I&#x2F;O多路复用程序</p>
<p>3、文件事件分派器</p>
<p>4、事件处理器</p>
<p>具体结构如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230326145626574.png" alt="image-20230326145626574"></p>
<p>其中，I&#x2F;O多路复用程序监听多个套接字，并向文件事件分派器传递那些产生事件的套接字。尽管多个文件事件会并发出现，但是I&#x2F;O多路复用程序总是将所有产生事件的套接字放到一个队列中，然后以有序，同步，每次一个套接字的方式向文件事件分派器传送套接字。</p>
<p>文件事件分派器接受I&#x2F;O多路复用传过来的套接字，根据套接字产生的事件，传给对应的事件处理器。</p>
<h3 id="I-x2F-O多路复用的实现"><a href="#I-x2F-O多路复用的实现" class="headerlink" title="I&#x2F;O多路复用的实现"></a>I&#x2F;O多路复用的实现</h3><p>Redis的I&#x2F;O多路复用的实现是通过包装select，epoll，evport和kqueue这些I&#x2F;O多路复用函数库来实现的。</p>
<h3 id="事件的类型"><a href="#事件的类型" class="headerlink" title="事件的类型"></a>事件的类型</h3><p>I&#x2F;O多路复用程序可以监听多个套接字的AE_READABLE和AE_WRITABLE事件。</p>
<p>当套接字变得可读（客户端对套接字执行write或者close操作）或者有新的可应答套接字出现（客户端对套接字执行connect操作），套接字产生AE_READABLE事件。</p>
<p>当套接字变得可写（客户端执行read操作），套接字产生AE_WRITABLE事件。</p>
<p>如果同时产生上面这两种事件，那么会先处理AE_READABLE事件，然后才处理AE_WRITABLE事件。</p>
<h3 id="文件事件的处理器"><a href="#文件事件的处理器" class="headerlink" title="文件事件的处理器"></a>文件事件的处理器</h3><p>Redis为文件事件编写了多个处理器，这些处理器分别用于实现不同的网络通信需求。</p>
<h4 id="1、连接应答处理器"><a href="#1、连接应答处理器" class="headerlink" title="1、连接应答处理器"></a>1、连接应答处理器</h4><p>当Redis服务器进行初始化的时候，程序会将这个连接应答处理器和服务器套接字的AE_READABLE事件关联起来，当有客户端连接服务器时，套接字就会产生AE_READABLE事件，引发连接应答处理器执行。</p>
<h4 id="2、命令请求处理器"><a href="#2、命令请求处理器" class="headerlink" title="2、命令请求处理器"></a>2、命令请求处理器</h4><p>当一个客户端通过连接应答处理器成功连接到服务器后，服务器会将客户端套接字的AE_READABLE事件和命令请求处理器关联起来，当客户端向服务器发送命令请求时，就会产生AE_READABLE事件，引发命令请求处理器执行，并执行相应的套接字读入操作。</p>
<h4 id="3、命令回复处理器"><a href="#3、命令回复处理器" class="headerlink" title="3、命令回复处理器"></a>3、命令回复处理器</h4><p>当服务器有命令回复要传送给客户端时，服务器就会将客户端套接字的AE_WRITABLE事件和命令处理器关联起来，当客户端准备好接收服务器传回的命令回复时，就会产生AE_WRITABLE事件，引发相应的套接字写入操作。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230326191604556.png" alt="image-20230326191604556"></p>
<h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>redis的时间事件分为两种：</p>
<p>1、定时事件：让一段程序在指定的时间之后执行一次。</p>
<p>2、周期性事件：让一段程序每隔指定时间就执行一次。</p>
<p>一个时间事件主要由以下三部分组成：</p>
<p>id：服务器为时间事件创建的全局唯一ID（标识号）。</p>
<p>when：记录了时间事件到达时间。</p>
<p>timeProc：时间事件处理器，当时间事件到达时，服务器就会调用相应的处理器来处理事件。</p>
<p>因为存储时间事件的链表并不按照事件排序，所以说每次处理时都需要遍历整个链表，才能找到那些事件需要处理。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Redis设计与实现》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Redis设计与实现</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis主从同步与故障切换的一些问题</title>
    <url>/2023/03/19/Redis/Redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E4%B8%8E%E6%95%85%E9%9A%9C%E5%88%87%E6%8D%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="主从数据不一致"><a href="#主从数据不一致" class="headerlink" title="主从数据不一致"></a>主从数据不一致</h3><p>主从数据不一致，就是指客户端从从库中读取到的值和主库中的最新值并不一致。</p>
<p>比如主库和从库之前的数据都是20，此时一条修改命令将主库的值由20改为19，接着有一个查询走了从库，此时从库的值还是19。</p>
<p>产生原因：<strong>主从库间的命令复制是异步进行的</strong>。</p>
<p>具体来说，主库收到写命令，会发给从库，但是在写完主库后就会返回给客户端，并不会等到从库写完才返回给客户端。</p>
<p>从库命令滞后原因：</p>
<p>1、主从库间的网络可能会有传输延迟，所以从库不能及时地收到主库发送的命令，从库上执行同步命令的时间就会被延后。</p>
<p>2、从库收到命令，但此时从库因在执行其他复杂度高的命令而阻塞，无法执行同步命令。</p>
<p>解决办法：</p>
<p>1、采用更好的硬件，<strong>保证主从库间的网络连接状况良好</strong>。</p>
<p>2、监控主从复制的进度。</p>
<p>Redis 的 INFO replication 命令可以查看主库接收写命令的进度信息（master_repl_offset）和从库复制写命令的进度信息（slave_repl_offset），用 master_repl_offset 减去 slave_repl_offset，这样就能得到从库和主库间的复制进度差值了。</p>
<p>所以我们可以监视这个差值，当达到一定值，我们就不再从这个从库进行读取。</p>
<h3 id="读过期数据"><a href="#读过期数据" class="headerlink" title="读过期数据"></a>读过期数据</h3><p>产生原因：<strong>Redis 同时使用了两种策略来删除过期的数据，分别是惰性删除策略和定期删除策略</strong>。</p>
<p>惰性删除：一个数据过期并不立即删除它，当需要用到这个数据时去检查是否过期，如果过期再删除。</p>
<p>在这种策略下，如果在主库读到过期数据，那么会将其删除。如果在从库读到过期数据，在3.2版本之前，会返回过期数据，3.2版本之后，不会删除，但是会返回一个空值。</p>
<p>定期删除：Redis 每隔一段时间（默认 100ms），就会随机选出一定数量的数据，检查它们是否过期，并把其中过期的数据删除。</p>
<p>定期删除只会删除一小部分数据，如果数据量大，有些数据一直没被访问，就可能一直留存，导致读到过期数据。</p>
<p>尽管使用了3.2版本以上的Redis，还是有可能会读到过期数据，与Redis设置过期时间的命令有关。</p>
<p>Redis设置数据过期时间的命令一共有4个，可以分如下两类：</p>
<p>1、EXPIRE 和 PEXPIRE：它们给数据设置的是<strong>从命令执行时开始计算的存活时间</strong>；</p>
<p>2、EXPIREAT 和 PEXPIREAT：<strong>它们会直接把数据的过期时间设置为具体的一个时间点</strong>。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230319104238500.png" alt="image-20230319104238500"></p>
<p>针对于第一类设置过期时间的方法，当主从库进行全量同步时，如果主库收到第一类命令，它会在主库执行，然后等到全量同步结束后发给从库，然后从库执行。这样，此条数据在从库的过期时间就比主库延后了。</p>
<p>解决办法：使用第二类设置办法，避免读到过期数据。</p>
<h3 id="不合理配置项导致的服务挂掉"><a href="#不合理配置项导致的服务挂掉" class="headerlink" title="不合理配置项导致的服务挂掉"></a>不合理配置项导致的服务挂掉</h3><p><strong>1.protected-mode 配置项</strong></p>
<p>这个配置项的作用是限定哨兵实例能否被其他服务器访问。当这个配置项设置为 yes 时，哨兵实例只能在部署的服务器本地进行访问。当设置为 no 时，其他服务器也可以访问这个哨兵实例。</p>
<p>如果配置为yes，那么其他哨兵配置在其他服务器上，哨兵前就无法通信，也就无法判断主库是否故障，导致服务不可用。</p>
<p><strong>2.cluster-node-timeout 配置项</strong></p>
<p><strong>这个配置项设置了 Redis Cluster 中实例响应心跳消息的超时时间</strong>。</p>
<p>当我们在 Redis Cluster 集群中为每个实例配置了“一主一从”模式时，如果主实例发生故障，从实例会切换为主实例，受网络延迟和切换操作执行的影响，切换时间可能较长，就会导致实例的心跳超时（超出 cluster-node-timeout）。实例超时后，就会被 Redis Cluster 判断为异常。而 Redis Cluster 正常运行的条件就是，有半数以上的实例都能正常运行。</p>
<p>所以，如果执行主从切换的实例超过半数，而主从切换时间又过长的话，就可能有半数以上的实例心跳超时，从而可能导致整个集群挂掉。所以该时间最好调大一点。</p>
<h3 id="另外的一些主从同步问题"><a href="#另外的一些主从同步问题" class="headerlink" title="另外的一些主从同步问题"></a>另外的一些主从同步问题</h3><p>1、主从库设置的 maxmemory 不同，如果 slave 比 master 小，那么 <strong>slave 内存就会优先达到 maxmemroy，然后开始淘汰数据</strong>，此时主从库也会产生不一致。</p>
<p>2、如果主从同步的 client-output-buffer-limit 设置过小，并且 master 数据量很大，主从全量同步时可能会导致 buffer 溢出，溢出后主从全量同步就会失败。如果主从集群配置了哨兵，那么哨兵会让 slave 继续向 master 发起全量同步请求，然后 buffer 又溢出同步失败，如此反复，会形成复制风暴，这会浪费 master 大量的 CPU、内存、带宽资源，也会让 master 产生阻塞的风险。</p>
<h3 id="假如slave可以自动删除过期数据，是否可以保证主从库的一致性？"><a href="#假如slave可以自动删除过期数据，是否可以保证主从库的一致性？" class="headerlink" title="假如slave可以自动删除过期数据，是否可以保证主从库的一致性？"></a>假如slave可以自动删除过期数据，是否可以保证主从库的一致性？</h3><p>无法保证。考虑以下场景：</p>
<p>1、主从同步存在网络延迟。例如 master 先执行 SET key 1 10，这个 key 同步到了 slave，此时 key 在主从库都是 10s 后过期，之后这个 key 还剩 1s 过期时，master 又执行了 expire key 60，重设这个 key 的过期时间。但 expire 命令向 slave 同步时，发生了网络延迟并且超过了 1s，如果 slave 可以自动删除过期 key，那么这个 key 正好达到过期时间，就会被 slave 删除了，之后 slave 再收到 expire 命令时，执行会失败。最后的结果是这个 key 在 slave 上丢失了，主从库发生了不一致。</p>
<p>2、主从机器时钟不一致。同样 master 执行 SET key 1 10，然后把这个 key 同步到 slave，但是此时 <strong>slave 机器时钟如果发生跳跃</strong>，优先把这个 key 过期删除了，也会发生上面说的不一致问题。</p>
<p>所以 Redis 为了保证主从同步的一致性，不会让 slave 自动删除过期 key，而只在 master 删除过期 key，之后 master 会向 slave 发送一个 DEL，slave 再把这个 key 删除掉，这种方式可以解决主从网络延迟和机器时钟不一致带来的影响。</p>
<h3 id="关于-slave-read-only"><a href="#关于-slave-read-only" class="headerlink" title="关于 slave-read-only"></a>关于 slave-read-only</h3><p>slave-read-only 主要用来控制 slave 是否可写，但是否主动删除过期 key，根据 Redis 版本不同，执行逻辑也不同。</p>
<p>1、如果版本低于 Redis 4.0，slave-read-only 设置为 no，此时 slave 允许写入数据，但如果 key 设置了过期时间，那么这个 key 过期后，虽然在 slave 上查询不到了，但并不会在内存中删除，这些过期 key 会一直占着 Redis 内存无法释放。 </p>
<p>2、Redis 4.0 版本解决了上述问题，在 slave 写入带过期时间的 key，slave 会记下这些 key，并且在后台定时检测这些 key 是否已过期，过期后从内存中删除。</p>
<p>在上述两种情况下，slave都不会主动删除master上的过期key，master 带有过期时间的 key，什么时候删除由 master 自己维护，slave 不会介入。如果 slave 设置了 slave-read-only &#x3D; no，而且是 4.0+ 版本，<strong>slave 也只维护直接向自己写入的带有过期的 key</strong>，过期时只删除这些 key。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Redis核心技术实战》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
        <category>集群</category>
      </categories>
      <tags>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>如何解决Redis缓存与数据库不一致</title>
    <url>/2023/03/16/Redis/Redis%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4/</url>
    <content><![CDATA[<h4 id="1、什么是缓存一致性"><a href="#1、什么是缓存一致性" class="headerlink" title="1、什么是缓存一致性"></a>1、什么是缓存一致性</h4><p>分为两种情况，如果缓存中存在数据，那么缓存中的数据与数据库数据一致，如果缓存中没有数据 ，那么数据库中的数据就要是最新的。可能针对第二点有的人会有一些疑问，我的理解是，如果数据的修改是在缓存中进行，当缓存满后这些数据被淘汰时才写入数据库，然后清除这部分数据。如果写入数据库发生问题，而缓存又被清除，那么这里就发生了缓存不一致的问题，因为数据库中的数据不是最新的。</p>
<h4 id="2、缓存不一致的原因"><a href="#2、缓存不一致的原因" class="headerlink" title="2、缓存不一致的原因"></a>2、缓存不一致的原因</h4><p>以下几种情况会导致缓存不一致：</p>
<p>1、如果业务采用<strong>异步写回策略</strong>，即上面提到的，修改数据时只将数据在缓存中修改，并不去修改数据库，等到数据从缓存中淘汰，再写入数据库。这种策略下如果写入数据库异常，就会导致不一致。</p>
<p>2、删除数据时（不考虑并发）。假设应用<strong>先删除缓存中的数据</strong>，然后<strong>再删除数据库中</strong>的数据，此时如果缓存删除成功，然后数据库删除失败，那么下次访问，会先走缓存，缓存未命中，然后去数据库查询，但是数据库查到的是旧值，导致不一致。</p>
<p>如果是先删除数据库中的数据，再删除缓存，此时一种情况数据库删除成功，缓存删除失败，那么会导致数据库中的值是新的，而缓存中的值是旧的，而查询又先走缓存，也是不一致的情况。</p>
<p>3、考虑并发的情况。</p>
<p>​	1）、<strong>先更数据库，再更缓存，写+读并发</strong>。假如线程A删除缓存值后，还没来得及写数据库（假设遇到网络延迟或者执行被中断），线程B又读取数据，此时会遇到缓存未命中，那么线程B会去数据库进行查询，然后将数据写入缓存当中（注意，这里写入缓存的数据是旧的值）。当B写入缓存成功后，线程A删除数据库的值。虽然线程A和线程B的操作都成功了，但是此时却发生了缓存不一致的问题。</p>
<p>​	2）、<strong>先更缓存，再更数据库，写+读并发</strong>。如果线程A删除了数据库，还没来得及删除缓存，线程B进行了读取，那么线程B会直接从缓存中读取到旧的数据。这种情况下，会有短暂的数据不一致问题，因为线程A很快会删除缓存中的值，此时后续线程会发生缓存未命中，然后去数据库查询最新的值。这种情况会出现短暂的不一致，但是对业务影响不大。</p>
<p>​	3）、<strong>先更新数据库，再更新缓存，写+写并发</strong>。线程A和B同时更新一条数据，更新数据库顺序是先A后B，但是更新缓存数据因一些原因变成了先B后A，就会导致不一致。</p>
<p>​	4）、<strong>先更新缓存，再更新数据库，写+写并发</strong>。与场景3类似，更新缓存的顺序和更新数据库的顺序不一样，就会导致数据不一致。</p>
<h4 id="3、如何解决缓存不一致"><a href="#3、如何解决缓存不一致" class="headerlink" title="3、如何解决缓存不一致"></a>3、如何解决缓存不一致</h4><p>如果不考虑高并发，我们可以采用<strong>重试机制</strong>。</p>
<p>具体来说，可以把要删改的数据先存入<strong>消息队列</strong>（如rabbitmq）当中，当应用删除失败，则取队列中取出要删除的数据进行重新尝试，如果成功，则从队列中移除元素。但高并发场景下这种解决方法不行，原因下文会解释。</p>
<p>在高并发场景下，分两种情况：</p>
<p>1、如果业务设计先删除缓存，再更新数据库</p>
<p>参考上边并发情况第一条，先更数据库，再更缓存，写+读并发的情况。</p>
<p>针对这种情况，一种解决方案就是<strong>延迟双删</strong>。即让线程A在操作完数据库之后，过一小段时间再去删除一次缓存。</p>
<p>但这种情况不可避免的会导致一小段时间内，用户读到的数据是错误的。</p>
<p>2、业务设计是先删除数据库数据，再删除缓存。</p>
<p>参考上述并发情况第二条，先更缓存，再更数据库，写+读并发。</p>
<p>结合以上两种方案，其实都会出现短暂的缓存不一致，而方案一不加处理则会导致很长时间的不一致，而且延迟多久进行删除时间也不好确定，所以如果不是特别的场景，个人更倾向于采用第二种方案。</p>
<p>这种解决方案适合于那些数据不敏感的场景。</p>
<p>3、针对写+写的并发，需要采用加锁的方式，保证一个线程修改完成后，再执行第二个线程的操作。也可以将修改数据库的操作以及修改redis的操作放入一个队列当中，保证他们的执行顺序。但是使用队列可能会导致中间过程会出现部分时刻的数据不一致，但是可以保证最终的一致性。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>缓存一致性</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis哨兵</title>
    <url>/2022/11/24/Redis/Redis%E5%93%A8%E5%85%B5/</url>
    <content><![CDATA[<p>是哨兵是Redis高可用性解决方案：由一个或多个哨兵实例组成的哨兵系统可以监视一个或多个主服务器以及主服务器对应的所有从服务器。当主服务下线，哨兵会发现并发起切换，选取一个从服务器升级为主服务器。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230330141306910.png" alt="image-20230330141306910"></p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230330141319684.png" alt="image-20230330141319684"></p>
<p>如果server1下线后又重新上线，那么哨兵会让它成为新的主服务器的从服务器。</p>
<h2 id="启动并初始化哨兵"><a href="#启动并初始化哨兵" class="headerlink" title="启动并初始化哨兵"></a>启动并初始化哨兵</h2><p>哨兵其实也是一台Redis服务器，不过他比较特殊，并不处理请求，所有它的启动和初始化和普通的有所不同。它不需要加载RDB和AOF文件，</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis设计与实现</tag>
        <tag>哨兵</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis客户端</title>
    <url>/2022/11/18/Redis/Redis%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<p>Redis是典型的一对多服务器程序，一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，服务器可以处理请求并回复。</p>
<p>redis中，所有的客户端信息都保存在redisServer的clients结构体中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 一个数组，保存着服务器中所有的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器数据库的数量</span></span><br><span class="line">    <span class="type">int</span> dbnum;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录了保存条件的数组 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparam</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改计数器</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dirty;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上一次执行保存的时间</span></span><br><span class="line">    <span class="type">time_t</span> lastsave;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// AOF缓冲区</span></span><br><span class="line">    sds aof_buf;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一个链表，保存了所有客户端状态</span></span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个具体的结构如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230327142807149.png" alt="image-20230327142807149"></p>
<h2 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h2><p>客户端属性分为两类：</p>
<p>一类是比较普通的属性，一类是和特定功能相关的属性。</p>
<h3 id="套接字描述符"><a href="#套接字描述符" class="headerlink" title="套接字描述符"></a>套接字描述符</h3><p>客户端状态的fd属性记录了客户端正在使用的套接字描述符：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录客户端当前正在使用的数据库</span></span><br><span class="line">   	redisDb *db;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    </span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure>

<p>根据客户端的种类不同，fd可以为-1 或者大于-1的整数。</p>
<p>伪客户端的fd属性为-1，它处理的命令请求来源于AOF文件或者Lua脚本，而不是网络，所以这种客户端不需要套接字连接。有两个地方会用到，一个用于载入AOF文件，另一个用于执行Lua脚本中包含的Redis命令。</p>
<p>普通客户端的fd属性为大于-1的整数，普通客户端使用套接字来与服务器进行通信，服务器用fd属性来记录客户端套接字。</p>
<h3 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录客户端当前正在使用的数据库</span></span><br><span class="line">   	redisDb *db;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于标记redisClient名字</span></span><br><span class="line">    robj *name;</span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure>

<h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录客户端当前正在使用的数据库</span></span><br><span class="line">   	redisDb *db;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于标记redisClient名字</span></span><br><span class="line">    robj *name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 客户端的标志属性flags记录了客户端的角色</span></span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">    </span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure>

<h3 id="输入缓冲区"><a href="#输入缓冲区" class="headerlink" title="输入缓冲区"></a>输入缓冲区</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录客户端当前正在使用的数据库</span></span><br><span class="line">   	redisDb *db;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于标记redisClient名字</span></span><br><span class="line">    robj *name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 客户端的标志属性flags记录了客户端的角色</span></span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入缓冲区</span></span><br><span class="line">    sds querybuf;</span><br><span class="line">    </span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure>

<p>一个具体的结构如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230327215316020.png" alt="image-20230327215316020"></p>
<h3 id="命令与参数"><a href="#命令与参数" class="headerlink" title="命令与参数"></a>命令与参数</h3><p>在服务器将客户端发送的命令请求保存到客户端的querybuf中之后，服务器会将命令的内容进行解析，并将得出命令参数以及命令参数的个数，分别保存到客户端的argv和argc属性当中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录客户端当前正在使用的数据库</span></span><br><span class="line">   	redisDb *db;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于标记redisClient名字</span></span><br><span class="line">    robj *name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 客户端的标志属性flags记录了客户端的角色</span></span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入缓冲区</span></span><br><span class="line">    sds querybuf;</span><br><span class="line">    </span><br><span class="line">    robj **argv;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> argc;</span><br><span class="line">    </span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure>

<p>一个具体的例子如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230327215550229.png" alt="image-20230327215550229"></p>
<h3 id="命令的实现函数"><a href="#命令的实现函数" class="headerlink" title="命令的实现函数"></a>命令的实现函数</h3><p>当服务器从协议内容中分析得出argv和argc的属性之后，服务器会根据argv[0]的值去命令表中查看对应命令的实现。</p>
<p>一个具体的命令表如下所示：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230327220733118.png" alt="image-20230327220733118"></p>
<p>其中redisCommand结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录客户端当前正在使用的数据库</span></span><br><span class="line">   	redisDb *db;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于标记redisClient名字</span></span><br><span class="line">    robj *name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 客户端的标志属性flags记录了客户端的角色</span></span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入缓冲区</span></span><br><span class="line">    sds querybuf;</span><br><span class="line">    </span><br><span class="line">    robj **argv;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> argc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存指令具体执行过程的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">    </span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure>

<p>查找对具体的命令对应的操作之后，会把客户端状态的cmd指向该命令所对应的具体执行过程的结构体，也就是上面的redisCommand。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230327222247558.png" alt="image-20230327222247558"></p>
<h3 id="输出缓冲区"><a href="#输出缓冲区" class="headerlink" title="输出缓冲区"></a>输出缓冲区</h3><p>执行命令得到的回复会被保存在客户端状态的输出缓冲区里，每个客户端都有两个输出缓冲区，一个缓冲区的大小是固定的，另一个缓冲区的大小是可变的。</p>
<p>固定大小的缓冲区用于保存那些长度比较小的回复，比如OK，简短的字符串值，整数，错误恢复等。</p>
<p>可变大小的缓冲区用于保存那些长度比较大的回复，比如一个非常长的字符串值，一个包含很多元素的集合等。</p>
<p>客户端固定大小的缓冲区由buf和bufpos两部分组成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录客户端当前正在使用的数据库</span></span><br><span class="line">   	redisDb *db;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于标记redisClient名字</span></span><br><span class="line">    robj *name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 客户端的标志属性flags记录了客户端的角色</span></span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入缓冲区</span></span><br><span class="line">    sds querybuf;</span><br><span class="line">    </span><br><span class="line">    robj **argv;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> argc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存指令具体执行过程的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buf[REDIS_REPLY_CHUNK_BYTES];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> bufpos;</span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure>

<p>其中buf是一个字节数组，而bufpos记录了字节数组中已经使用的字节数量。</p>
<p>当buf数组的空间使用完，或者因为回复太大没办法放进去时，就会采用可变大小缓冲区。</p>
<p>可变大小缓冲区由reply链表和一个或多个字符串对象组成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录客户端当前正在使用的数据库</span></span><br><span class="line">   	redisDb *db;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于标记redisClient名字</span></span><br><span class="line">    robj *name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 客户端的标志属性flags记录了客户端的角色</span></span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入缓冲区</span></span><br><span class="line">    sds querybuf;</span><br><span class="line">    </span><br><span class="line">    robj **argv;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> argc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存指令具体执行过程的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buf[REDIS_REPLY_CHUNK_BYTES];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> bufpos;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">list</span> *reply;</span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure>

<p>通过使用链表来链接多个字符串对象，服务器可以为客户端保存一个非常长的命令回复。具体结构如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230327223418524.png" alt="image-20230327223418524"></p>
<h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>客户端还有几个其他的关键属性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录客户端当前正在使用的数据库</span></span><br><span class="line">   	redisDb *db;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于标记redisClient名字</span></span><br><span class="line">    robj *name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 客户端的标志属性flags记录了客户端的角色</span></span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输入缓冲区</span></span><br><span class="line">    sds querybuf;</span><br><span class="line">    </span><br><span class="line">    robj **argv;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> argc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存指令具体执行过程的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> buf[REDIS_REPLY_CHUNK_BYTES];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> bufpos;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">list</span> *reply;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算客户端与服务器连接了多长时间</span></span><br><span class="line">    <span class="type">time_t</span> ctime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 客户端最后一次与服务器互动的时间</span></span><br><span class="line">    <span class="type">time_t</span> lastinteraction;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录了输出缓冲区第一次到达软性限制的时间</span></span><br><span class="line">    <span class="type">time_t</span> obuf_soft_limit_reached_time;</span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure>

<p>ctime属性记录了创建客户端的时间，这个时间用于计算客户端与服务器连接了多长时间。</p>
<p>lastinteraction记录了客户端最后一次与服务器互动的时间，这个互动可以是客户端向服务器发送命令，也可以是服务器向客户端发送命令回复。</p>
<p>obuf_soft_limit_reached_time记录了输出缓冲区第一次到达软性限制的时间。</p>
<h2 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h2><h3 id="创建普通客户端"><a href="#创建普通客户端" class="headerlink" title="创建普通客户端"></a>创建普通客户端</h3><p>如果客户端是使用网络连接的普通客户端，那么客户端在使用connect连接到服务器时，服务器会在redisServer的clients属性后多链接一个客户端。如下图所示</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230328102150894.png" alt="image-20230328102150894"></p>
<h3 id="关闭普通客户端"><a href="#关闭普通客户端" class="headerlink" title="关闭普通客户端"></a>关闭普通客户端</h3><p>一个客户端可以因为多种原因被关闭：</p>
<p>如果客户端进程退出或被杀死，那么客户端与服务器之间的网络连接被关闭，造成客户端被关闭。</p>
<p>如果客户端发送带有不符合协议格式的请求命令，也会被关闭。</p>
<p>如果客户端成为了CLIENT KILL 命令的目标，也会被关闭。</p>
<p>如果用户为服务器设置了timeout属性，那么客户端的空转时间超过timeout选项设置的值，客户端也会关闭。</p>
<p>如果客户端发送的请求命令大于输入缓冲区的大小会被关闭。</p>
<p>如果要发送给客户端的命令回复大小超过了输出缓冲区的大小限制，那么这个客户端也会被关闭。</p>
<p>服务器使用两种模式来限制输出缓冲区大小：</p>
<p>1、硬性限制：如果缓冲区大小超出了硬性限制大小，客户端会被立刻关闭。</p>
<p>2、软性限制：超过软性限制大小但是没超过硬性大小，那么服务器将使用客户端状态obuf_soft_limit_reached_time属性记录客户端到达软性限制的起始时间，之后会监视这个客户端，如果超出软性限制的时间超过了服务器设定的时间，那么客户端会被关闭。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Redis设计与实现》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Redis设计与实现</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis如何解决缓存雪崩、击穿、穿透</title>
    <url>/2023/03/30/Redis/Redis%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指大量的应用请求无法在 Redis 缓存中进行处理，紧接着，应用将大量请求发送到数据库层，导致数据库层的压力激增。</p>
<h3 id="原因以及解决办法"><a href="#原因以及解决办法" class="headerlink" title="原因以及解决办法"></a>原因以及解决办法</h3><p><strong>1、缓存中有大量数据同时过期，导致大量请求无法得到处理</strong>。</p>
<p>解决方案：</p>
<p>​	1）可以避免给数据设置相同的过期时间，如果业务需要，可以给这个过期时间增加一个小的随机数，使其过期时间相差1~3分钟，这样可以避免大量的key同时过期。</p>
<p>​	2）我们还可以通过<strong>服务降级</strong>，指发生缓存雪崩时，针对不同的数据采取不同的处理方式。</p>
<p>​		当业务应用访问的是非核心数据时，<strong>暂时停止从缓存中查询这些数据</strong>，而是直接返回预定义信息、空值或是错误信息；</p>
<p>​		当业务应用访问的是核心数据时，仍然允许查询缓存，如果缓存缺失，也可以继续通过数据库读取。</p>
<p><strong>2、Redis 缓存实例发生故障宕机了</strong></p>
<p>解决方案：</p>
<p>​	1）在业务系统中实现服务熔断或请求限流机制。在发生缓存雪崩时，为了避免影响整个系统，我们可以将这部分请求不做处理，直接返回错误，以免导致整个系统崩溃。</p>
<p>​	2）提前预防。通过主从节点的方式构建 Redis 缓存高可靠集群。如果 Redis 缓存的主节点故障宕机了，从节点还可以切换成为主节点</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿是指，针对某个访问非常频繁的热点数据的请求，无法在缓存中进行处理，紧接着，访问该数据的大量请求，一下子都发送到了后端数据库，导致了数据库压力激增，会影响数据库处理其他请求。</p>
<p>发生这种情况的原因有两种，一是热点数据自动过期，应对办法就是不设过期时间。二是开发人员误删热点数据。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指要访问的数据既不在 Redis 缓存中，也不在数据库中，导致请求在访问缓存时，发生缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据。</p>
<p>两种情况：</p>
<p>1、业务层误操作：缓存中的数据和数据库中的数据被误删除了，所以缓存和数据库中都没有数据；</p>
<p>2、恶意攻击：专门访问数据库中没有的数据。</p>
<p>解决方案：</p>
<p>1、缓存空值或缺省值。</p>
<p>一旦发生缓存穿透，我们就可以针对查询的数据，在 Redis 中缓存一个空值或是和业务层协商确定的缺省值。紧接着，应用发送的后续请求再进行查询时，就可以直接从 Redis 中读取空值或缺省值，返回给业务应用了，避免了把大量请求发送给数据库处理，保持了数据库的正常运行。</p>
<p>2、使用布隆过滤器快速判断数据是否存在，避免从数据库中查询数据是否存在，减轻数据库压力。</p>
<p>布隆过滤器由一个初值都为 0 的 bit 数组和 N 个哈希函数组成，可以用来快速判断某个数据是否存在。</p>
<p>正是基于布隆过滤器的快速检测特性，我们可以在把数据写入数据库时，使用布隆过滤器做个标记。当缓存缺失后，应用查询数据库时，可以通过查询布隆过滤器快速判断数据是否存在。如果不存在，就不用再去数据库中查询了。</p>
<p>3、在请求入口的前端进行请求检测</p>
<p>缓存穿透的一个原因是有大量的恶意请求访问不存在的数据，所以，一个有效的应对方案是在请求入口前端，对业务系统接收到的请求进行合法性检测，把恶意的请求（例如请求参数不合理、请求参数是非法值、请求字段不存在）直接过滤掉，不让它们访问后端缓存和数据库。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>缓存失效</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据删除</title>
    <url>/2023/04/07/Redis/Redis%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4/</url>
    <content><![CDATA[<p>有时候，在删除了Redis中部分数据后，会发现Redis仍然占用了很多内存，这是因为当数据删除后，Redis 释放的内存空间会由内存分配器管理，并不会立即返回给操作系统。所以，操作系统仍然会记录着给 Redis 分配了大量内存。</p>
<p>但是这样会导致一个问题，这些空间可能都是碎片化的，Redis无法拿来存取数据，还占用了大量的内存空间。</p>
<h1 id="什么是内存碎片"><a href="#什么是内存碎片" class="headerlink" title="什么是内存碎片"></a>什么是内存碎片</h1><p>一个较为简单的解释，就是虽然存在空间，但是这些空间却由于零散的分布在内存的各个地方，导致无法使用。</p>
<h1 id="形成原因"><a href="#形成原因" class="headerlink" title="形成原因"></a>形成原因</h1><p>1、内因：内存分配器的分配策略</p>
<p>内存分配器一般是按固定大小来分配内存，而不是完全按照应用程序申请的内存空间大小给程序分配。比如说现在Redis需要申请20字节的空间，但是分配器可能会分配32字节，此时如果还要写入10字节的数据，就不需要在此分配空间。但是这会导致2字节的空间很难被在此利用。</p>
<p>2、外因：键值对大小不一样和删改操作</p>
<p>Redis用来存储不同的键值对，这样就需要申请不同的空间，这一点与内因相同。而修改和删除操作，就会导致空间的扩容和释放，这就会导致新的内存分配，另一方面，删除的键值对就不再需要内存空间了，此时，就会把空间释放出来，形成空闲空间。</p>
<h1 id="如何清理内存碎片"><a href="#如何清理内存碎片" class="headerlink" title="如何清理内存碎片"></a>如何清理内存碎片</h1><p>1、直接重启Redis。但是这样会带来一些问题：</p>
<ul>
<li>如果Redis中的数据没有持久化，则会丢失数据。</li>
<li>即使持久化了，重启后需要加载RDB和AOF文件进行恢复，恢复时长取决于AOF或RDB文件的大小。而且如果Redis是单机的，此时就无法对外提供服务。</li>
</ul>
<p>2、自动内存碎片清理。大致的原理是，通过对象移位的方式，把原本不连续的空间变为连续的。</p>
<p><strong>碎片清理是有代价的</strong>，操作系统需要把多份数据拷贝到新位置，把原有空间释放出来，这会带来时间开销。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Redis核心技术实战》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Redis设计与实现</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis服务器</title>
    <url>/2022/11/20/Redis/Redis%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="请求命令的执行过程"><a href="#请求命令的执行过程" class="headerlink" title="请求命令的执行过程"></a>请求命令的执行过程</h2><p>客户端给服务器发送一个命令请求的过程如下：</p>
<p>1、客户端向服务器发送命令请求</p>
<p>2、服务器接受并处理客户端请求，在数据库中进行设置操作，并产生回复。</p>
<p>3、服务器将命令回复发送给客户端</p>
<p>4、客户端收到回复命令并显示给用户。</p>
<h3 id="发送命令请求"><a href="#发送命令请求" class="headerlink" title="发送命令请求"></a>发送命令请求</h3><p>客户端输入请求后，客户端会将这个请求命令转换成协议格式，然后通过连接到服务器的套接字，将协议格式发送给服务器。</p>
<h3 id="读取命令请求"><a href="#读取命令请求" class="headerlink" title="读取命令请求"></a>读取命令请求</h3><p>读取命令时，服务器会执行一下操作：</p>
<p>1、读取协议格式的命令，将其保存到客户端状态的输入缓冲区中。</p>
<p>2、对输入缓冲区的内容进行解析，提取其中包含的命令，以及命令的个数，保存到客户端状态的argv和argc的属性当中。</p>
<p>3、调用命令执行器，执行命令。</p>
<p>具体结构如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230328152639921.png" alt="image-20230328152639921"></p>
<h3 id="命令执行器（1）：查找命令实现"><a href="#命令执行器（1）：查找命令实现" class="headerlink" title="命令执行器（1）：查找命令实现"></a>命令执行器（1）：查找命令实现</h3><p>执行器要做的第一件事就是根据客户端状态的argv[0]参数，在命令表中查找指定的命令，并将命令保存在客户端状态的cmd属性中。</p>
<p>一个命令表的结构如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230328155212121.png" alt="image-20230328155212121"></p>
<p>设置客户端状态如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230328155247458.png" alt="image-20230328155247458"></p>
<h3 id="命令执行器（2）：执行预备操作"><a href="#命令执行器（2）：执行预备操作" class="headerlink" title="命令执行器（2）：执行预备操作"></a>命令执行器（2）：执行预备操作</h3><p>到这里，服务器已经将客户端执行命令所需要的函数，参数以及参数个数都收集到了。但是在真正执行命令时，还需要一些预备操作：</p>
<p>1、检查客户端状态的cmd属性是否为null，如果为null说明输入命令错误，则不继续执行，返回错误。</p>
<p>2、根据cmd指向的redisCommand结构的arity属性，检查命令请求的参数个数是否正确，不正确直接返回。</p>
<p>3、检查客户端是否通过了身份验证。</p>
<p>4、如果服务器打开了maxmemory属性，那么会先检查服务器内存占用情况，并且在必要时进行内存回收。</p>
<p>5、如果上一次执行bgsave命令出错，并且开启了一个配置，这次命令又是一个写命令，会被直接拒绝。</p>
<p>6、如果客户端当前正在用SUBSCRIBE命令订阅频道，或者正在用PSUBSCRIBE命令订阅模式，那么服务器只会执行客户端发来的SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE四个命令，其他命令都会被服务器拒绝。<br>7、如果服务器正在进行数据载入，那么客户端发送的命令必须带有1标识(比如INFO、SHUTDOWN、PUBLISH等等)才会被服务器执行，其他命令都会被服务器拒绝。<br>8、如果服务器因为执行Lua脚本而超时并进人阻塞状态，那么服务器只会执行客户端发来的SHUTDOWN nosave命令和SCRIPT KILL命令，其他命令都会被服务器拒绝。口如果客户端正在执行事务，那么服务器只会执行客户端发来的EXEC、DISCARD、MULTI、WATCH四个命令，其他命令都会被放进事务队列中。<br>9、如果服务器打开了监视器功能，那么服务器会将要执行的命令和参数等信息发送给监视器。当完成了以上预备操作之后，服务器就可以开始真正执行命令了。</p>
<p>以上只针对单机redis，如果是集群，则还要多一点。</p>
<h3 id="命令执行器（3）：调用命令函数实现"><a href="#命令执行器（3）：调用命令函数实现" class="headerlink" title="命令执行器（3）：调用命令函数实现"></a>命令执行器（3）：调用命令函数实现</h3><p>因为命令参数，以及个数，以及要执行的命令都已经保存，所以调用时只需要给具体函数传送一个redisClient结构体即可。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230328161130267.png" alt="image-20230328161130267"></p>
<p>函数会执行具体的操作，然后将结果保存在客户端状态的输入缓冲区里面。</p>
<h3 id="将命令回复发送给客户端"><a href="#将命令回复发送给客户端" class="headerlink" title="将命令回复发送给客户端"></a>将命令回复发送给客户端</h3><p>当客户端的套接字变为可写状态时，服务器就会执行命令回复处理器，将保存到客户端输出缓冲区的命令回复发送给客户端。</p>
<h2 id="serverCron函数"><a href="#serverCron函数" class="headerlink" title="serverCron函数"></a>serverCron函数</h2><p>redis的serverCron每隔100ms就会执行一次，这个函数负责管理服务器资源，并保持服务器自身运行状态良好。</p>
<h3 id="更新服务器时间缓存"><a href="#更新服务器时间缓存" class="headerlink" title="更新服务器时间缓存"></a>更新服务器时间缓存</h3><p>因为redis很多操作都会涉及到时间，而每次获取时间都需要执行一次系统调用。为了减少系统调用的次数，服务器中的unixtime和mstime被当作时间缓存：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 一个数组，保存着服务器中所有的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器数据库的数量</span></span><br><span class="line">    <span class="type">int</span> dbnum;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录了保存条件的数组 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparam</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改计数器</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dirty;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上一次执行保存的时间</span></span><br><span class="line">    <span class="type">time_t</span> lastsave;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// AOF缓冲区</span></span><br><span class="line">    sds aof_buf;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一个链表，保存了所有客户端状态</span></span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 秒级的unix时间戳</span></span><br><span class="line">    <span class="type">time_t</span> unixtime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 毫秒级的unix时间戳</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mstime;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该函数会更新服务器的时间缓存，由于每100ms更新一次，所以并不是特别准确。</p>
<h3 id="更新LRU时钟"><a href="#更新LRU时钟" class="headerlink" title="更新LRU时钟"></a>更新LRU时钟</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 一个数组，保存着服务器中所有的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器数据库的数量</span></span><br><span class="line">    <span class="type">int</span> dbnum;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录了保存条件的数组 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparam</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改计数器</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dirty;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上一次执行保存的时间</span></span><br><span class="line">    <span class="type">time_t</span> lastsave;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// AOF缓冲区</span></span><br><span class="line">    sds aof_buf;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一个链表，保存了所有客户端状态</span></span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 秒级的unix时间戳</span></span><br><span class="line">    <span class="type">time_t</span> unixtime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 毫秒级的unix时间戳</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mstime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认每10秒更新一次时钟缓存，用于计算键的空转时间</span></span><br><span class="line">    <span class="type">unsigned</span> lruclock:<span class="number">22</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="检查持久化操作运行状态"><a href="#检查持久化操作运行状态" class="headerlink" title="检查持久化操作运行状态"></a>检查持久化操作运行状态</h3><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230328164717831.png" alt="image-20230328164717831"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Redis设计与实现》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Redis设计与实现</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis对象</title>
    <url>/2022/11/09/Redis/Redis%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="Redis中有那些对象"><a href="#Redis中有那些对象" class="headerlink" title="Redis中有那些对象"></a>Redis中有那些对象</h3><p>redis中有简单动态字符串（SDS），双端链表，字典，压缩列表，整数集合等数据结构，但是redis并没有直接采用这些数据结构来构成键值对数据库，而是基于这些数据结构创建了一个对象系统。包含了<strong>字符串对象</strong>，<strong>列表对象</strong>，<strong>哈希对象</strong>，<strong>集合对象</strong>，<strong>有序集合对象</strong>。而且redis对象系统还实现了基于<strong>引用计数器</strong>的内存回收机制，并且通过引用计数技术实现了对象共享。</p>
<p>redis中每个对象都是由一个redisObject结构表示，该结构中和保存数据有关的三个属性如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="type">unsigned</span> type;</span><br><span class="line">   	</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="type">unsigned</span> encoding;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>这个属性记录了对象的类型，该类型可以是下表中的一个。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230322183207835.png" alt="image-20230322183207835"></p>
<p>每一个数据的键，总是一个字符串对象，而值可以是上表中的任意一个。</p>
<p>在redis中，使用TYPE命令可以显示一个键对应值的type</p>
<h4 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h4><p>记录了对象所使用的编码。即记录该对象使用什么数据结构作为底层的实现。可以是下表中的任意一个。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230322183455762.png" alt="image-20230322183455762"></p>
<p>每种类型的对象至少使用了两种不同的编码，如下表所示</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230322183620698.png" alt="image-20230322183620698"></p>
<p>在redis中，使用OBJECT ENCODING命令可以查看一个键对应值对象的编码。</p>
<p>通过encoding属性设置编码，而不是固定一个对象的编码，为redis带来了极大的灵活性。因为redis可以根据不同场景选择不同的编码，以此改变底层数据结构。</p>
<h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h3><p>如果字符串对象存储的是整数，并且这个整数可以用long表示，那么整数值将保存在字符串对象结构的ptr属性里面。void* 转换为long。并将字符串编码设置为int。</p>
<p>如果字符串对象保存的是一个字符串值，并且该值长度大于32字节，那么就是用简单动态字符串保存，如果小于32，则使用embstr编码保存。</p>
<h4 id="embstr"><a href="#embstr" class="headerlink" title="embstr"></a>embstr</h4><p>embstar专门用来保存短字符串的一种优化编码。embstr和raw都是使用redisObject和sdshdr结构来表示字符串，但是raw需要两次内存分配来创建，而embstr只需要一次内存分配，并且是连续的地址。释放空间也一样，分别是1次和2次。</p>
<p>long double类型表示的浮点数也是作为字符串来保存的。</p>
<h4 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h4><p>int类型的编码和embstr在适当条件下会被转化为raw编码。而且，redis没有为embstr编写任何修改程序，我们对次做的任何修改都会使其转化为raw编码。</p>
<h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><p>列表对象的编码可以是ziplist（压缩列表）或者linkedlist（双端链表）。</p>
<p>当列表对象满足所保存的所有字符串元素都小于64字节，且数量小于512个时，采用ziplist编码，否则采用linkedlist编码。</p>
<h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h3><p>哈希对象的编码可以是ziplist或者hashtable。</p>
<p>ziplist编码的哈希对象，每当有新的值加入，程序会先将保存了键的压缩列表节点加入压缩列表的表尾，然后是将保存值的节点加入表尾。所以说，保存了键和值的节点总是挨在一起，键在前，值在后。而且先添加的键值对在表头，后添加的在表尾。</p>
<p>具体结构如下图：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230322192610777.png" alt="image-20230322192610777"></p>
<p>hashtable编码的哈希对象，使用字典作为底层实现。哈希对象每一个键值对都使用一个字典键值对来保存。</p>
<p>字典的键是一个字符串对象，保存了键值对的键。字典的每个值也是一个字符串对象，保存了键值对的值。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230322192653785.png" alt="image-20230322192653785"></p>
<p>当哈希对象的所有键值对的键以及值的长度都小于64且键值对数量小于512时，使用ziplist编码，否则使用hashtable编码。</p>
<h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><p>集合对象的编码可以是intset或者hashtable。</p>
<p>intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里。</p>
<p>具体结构如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230322194532294.png" alt="image-20230322194532294"></p>
<p>hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为null。hashtable编码如果要取值，则只用取出来键即可。</p>
<p>执行完下面语句的结构如下图</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SAD Dfruits <span class="string">&quot;apple&quot;</span> <span class="string">&quot;banana&quot;</span> <span class="string">&quot;cherry&quot;</span></span><br></pre></td></tr></table></figure>



<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230322194543206.png" alt="image-20230322194543206"></p>
<p>当集合对象保存的都是整数，且数量不超过512个时，采用intset编码，否则采用hashtable编码。</p>
<h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><p>有序集合编码可以是ziplist或者skiplist。</p>
<p>ziplist编码的有序集合对象使用压缩列表作为底层，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（number），第二个元素保存元素的分值（score）。</p>
<p>压缩列表内元素按照分值大小从小到大排序，分值较小的元素被放置在靠近表头的方向，较大的放在表尾。</p>
<p>skiplist编码的有序集合对象使用zset结构作为底层实现。一个zset包含了一个字典和一个跳跃表，具体结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    <span class="comment">// 跳跃表</span></span><br><span class="line">    zskilplist *zsl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字典</span></span><br><span class="line">    dict *dict;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p>zset结构中的zsl跳跃表按分值从小到大保存了所有的集合元素，跳跃表的每个节点保存了一个集合元素：跳跃表节点的object属性保存了元素成员，而跳跃表节点的score保存了分值。通过跳跃表可以对集合实现范围操作。</p>
<p>zset中的字典为有序集合创建了一个从成员到分值的映射，字典中的每一个键值对都保存了一个集合元素，键是元素成员，值的成员对应的分值（score）。</p>
<p>zset会同时使用跳跃表和字典保存集合元素，但这两种结构会通过指针共享相同元素的成员和分值，所以不会浪费内存。</p>
<p>为什么同时使用跳跃表和字典？</p>
<p>如果单纯使用字典，能保留在o(1)的时间复杂度内查找到某成员，但是字典是无序的，对于范围查找则效率不高，而跳跃表因为有序所欲进行范围查找很快。如果单纯使用跳跃表，那么就无法完成在o(1)的时间复杂度内查找到某成员。</p>
<p>一个具体的例子：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230322202217608.png" alt="image-20230322202217608"></p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230322202233639.png" alt="image-20230322202233639"></p>
<p>当有序集合元素数量小于128个，同时所有元素成员长度小于64字节时，使用ziplist编码，否则使用skiplist编码。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Redis设计与实现》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Redis设计与实现</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的I/O多路复用</title>
    <url>/2023/05/12/Redis/Redis%E7%9A%84I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<p>在Redis6.0之前，它的网络I&#x2F;O模型是单线程的，那么它是怎么处理多个客户端的连接的呢？这里就涉及到Redis的I&#x2F;O模型，基于多路复用的高性能 I&#x2F;O 模型。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230511204107493.png" alt="image-20230511204107493"></p>
<p>我个人对它的理解如下：</p>
<p>它的模型需要用到操作系统的epoll机制，也就是说需要内核来监控Redis建立的多个Socket，这也就是为什么Windows操作系统发挥不了Redis的最大性能，因为它只支持Select模式，不支持epoll模式。</p>
<p>Redis的一个线程只需要来处理客户端的请求，为它建立一个Socket。epoll机制允许内核一次监听多个socket，每当这些socket变得可读或者可写，就通知Redis的线程，然后Redis的线程会为对应的Socket注册对应的事件，之后将他们放入事件处理队列。这是事件在出队后，会调用对应事件绑定的函数，来处理对应的事件。</p>
<p>比如说，现在有两个客户端，这两个客户端都发起了请求，分别对应accept事件和read事件。Redis 分别对这两个事件注册 accept 和 get 回调函数。当 Linux 内核监听到有连接请求或读数据请求时，就会触发 Accept 事件和 Read 事件，此时，内核就会回调 Redis 相应的 accept 和 get 函数进行处理。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
        <category>设计</category>
      </categories>
      <tags>
        <tag>Redis设计与实现</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据库结构</title>
    <url>/2022/11/11/Redis/Redis%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="具体结构"><a href="#具体结构" class="headerlink" title="具体结构"></a>具体结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 一个数组，保存着服务器中所有的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器数据库的数量</span></span><br><span class="line">    <span class="type">int</span> dbnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录客户端当前正在使用的数据库</span></span><br><span class="line">   	redisDb *db;</span><br><span class="line">    </span><br><span class="line">&#125; redisClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    </span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p>一个具体结构如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230323111004847.png" alt="image-20230323111004847"></p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230323112244296.png"></p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230323112514862.png" alt="image-20230323112514862"></p>
<p>总的来说，就是一个redis实例，会有一个redisServer结构体，该结构体中db是一个数组，数组每一个元素代表一个数据库，每个db结构体就是一个具体的存放键值对的数据库。每一个redisClient结构体代表了一个客户端，该客户端指针会指向redisServer结构体db数组中的一个，代表使用该数据库。其中dict就是用户直接看到的数据库。</p>
<h3 id="数据库键的一些操作"><a href="#数据库键的一些操作" class="headerlink" title="数据库键的一些操作"></a>数据库键的一些操作</h3><h4 id="读写键空间时的维护操作"><a href="#读写键空间时的维护操作" class="headerlink" title="读写键空间时的维护操作"></a>读写键空间时的维护操作</h4><p>1、在读取一个键后，服务器会根据键是否命中来更新服务器键空间命中次数或者见空间不命中的次数。</p>
<p>2、在读取一个键后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算闲置时间。</p>
<p>3、如果服务器读取一个键发现已经过期，则会删除该键。</p>
<p>4、如果客户端使用watch命令监视某个键，那么服务器对被监视的键进行修改后，会标记其为脏键。</p>
<p>5、服务器每修改一个键后，都会对脏键计数器的值加1，这个计数器会触发服务器的持久化以及赋值操作。</p>
<p>6、如果服务器开启了数据库通知功能，对键进行修改后，会按配置发送给相应的数据库通知。</p>
<h4 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="headerlink" title="设置键的生存时间或过期时间"></a>设置键的生存时间或过期时间</h4><h5 id="如何保存过期时间"><a href="#如何保存过期时间" class="headerlink" title="如何保存过期时间"></a>如何保存过期时间</h5><p>redisDb结构的expires字典保存了数据库中所有键的过期时间，我们称之为过期字典。</p>
<p>过期字典的键是一个指针，指向键空间中的某个键对象。值是一个long long类型的整数，保存了过期时间。</p>
<p>具体如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230323141113896.png" alt="image-20230323141113896"></p>
<p>expires指向另外的一个字典，这个字典里面存储了每一个值的过期时间。</p>
<h5 id="如何判断键是否过期"><a href="#如何判断键是否过期" class="headerlink" title="如何判断键是否过期"></a>如何判断键是否过期</h5><p>首先看过期字典中是否含有该键，如果存在，获取过期时间，与当前时间对比做判断，如果小于当前时间，则说明过期。</p>
<h4 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h4><h5 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h5><p>在设置键过期时间的同时，创建一个定时器，让定时器在键过期时立即执行对键的删除。</p>
<p>优点：对内存友好，过期后会被立马删除。</p>
<p>缺点：对cpu不友好，如果过期键设置的太多，则定时器会占用太多的cpu资源。</p>
<h5 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h5><p>只有在用到该键时，才取检查它是否过期，过期则删除，否则返回。</p>
<p>优点：不占用cpu资源。不会影响到redis处理客户端的请求。</p>
<p>缺点：会造成内存泄漏。如果一个键过期，它如果没有被再次访问，则无法删除。</p>
<h5 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h5><p>每隔一段时间，程序就检查一次数据库，删除里面的过期键，至于检查多少以及删除多少，由算法决定。</p>
<p>该算法的好坏取决于设定，不能太频繁的去删除，导致cpu资源浪费在了检索以及删除过期数据，也不能太长时间不删除导致里面很多过期数据。</p>
<h4 id="Redis过期键删除策略"><a href="#Redis过期键删除策略" class="headerlink" title="Redis过期键删除策略"></a>Redis过期键删除策略</h4><p>redis是将惰性删除和定期删除这两种策略配合使用。</p>
<p>惰性删除就是每次读写数据库命令执行前，都会调用一个函数检查键是否过期。</p>
<p>定期删除函数每次运行时，都会抽取一定量的随机键进行检查，并删除其中过期的键。有一个全局变量current_db会记录当前检查的进度，下次定期删除时会从这里开始。当服务器中数据都被检查一边时，这个值会被设置为0。</p>
<h4 id="AOF和RDB以及复制对过期键的处理"><a href="#AOF和RDB以及复制对过期键的处理" class="headerlink" title="AOF和RDB以及复制对过期键的处理"></a>AOF和RDB以及复制对过期键的处理</h4><h5 id="生成RDB文件"><a href="#生成RDB文件" class="headerlink" title="生成RDB文件"></a>生成RDB文件</h5><p>在执行SAVE或者BGSAVE命令创建一个RDB文件时，会对数据库的键进行检查，已经过期的不会写入RDB文件。</p>
<h5 id="载入RDB文件"><a href="#载入RDB文件" class="headerlink" title="载入RDB文件"></a>载入RDB文件</h5><p>如果以主服务器的模式加载RDB文件，则会对键进行检查，过期的不会载入。</p>
<p>如果以从服务器模式运行，则会保留所有键，不论是否过期。</p>
<h5 id="AOF文件写入"><a href="#AOF文件写入" class="headerlink" title="AOF文件写入"></a>AOF文件写入</h5><p>当服务器采用AOF模式持久化，如果数据库某个键过期，但是还没被删除，则对AOF文件没有影响，但是删除时会向AOF文件中追加该记录被删除的命令。</p>
<h5 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h5><p>AOF重写的过程中会进行检查，过期键不会保留。</p>
<h5 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h5><p>当服务器运行在复制模式下，从服务对过期键删除动作由主服务器控制：</p>
<p>1、主服务器删除一个过期键后，会向所有从服务器发送一条命令，通知其删除。</p>
<p>2、从服务器在接受到读命令时，尽管碰到过期键也不会删除，而是返回。（这本书创作时对应的redis版本最高为3.0，而后续高版本的redis在某些配置下会删除从服务上的过期键，但是删除从服务器数据后并不会主动删除主服务器的过期数据）</p>
<p>3、从服务器接收到主服务命令后才会删除过期键。</p>
<p>这样设置的目的是为了保存数据的一致性。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Redis设计与实现》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Redis设计与实现</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的主从复制</title>
    <url>/2022/11/22/Redis/Redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<p>在redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制另一个服务器，被复制的服务器就是主服务器，另一个就是从服务器。</p>
<h2 id="旧版复制功能的实现"><a href="#旧版复制功能的实现" class="headerlink" title="旧版复制功能的实现"></a>旧版复制功能的实现</h2><p>旧版指的是2.8版本以前的复制，分为两个操作，同步和命令传播。</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>将从服务器的状态更新至主服务器当前所处的状态。</p>
<p>同步过程如下：</p>
<p>1、从服务器发起同步请求（发送SYNC命令）。</p>
<p>2、主服务器在后台生成RDB文件，并使用一个<strong>缓冲区</strong>记录生成RDB文件时产生的新数据。</p>
<p>3、当生成完成后，将RDB文件发送给从服务器。从服务器接收并载入RDB文件。</p>
<p>4、将缓冲区数据发送给从服务器，从服务器接收并写入。</p>
<h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>主服务器状态被修改，导致主从状态不一致，用命令传播使他们一致。</p>
<p>这个并不会像上面那样生成RDB文件，只会发送一条命令。</p>
<p>比如刚刚同步完数据，目前主从数据一致。但是主库执行了一条del命令，然后主从就不一致了，把这条del命令发给从库的行为就叫做命令传播。</p>
<h3 id="旧版的缺陷"><a href="#旧版的缺陷" class="headerlink" title="旧版的缺陷"></a>旧版的缺陷</h3><p>当第一次全量同步时，可以很好的完成该工作。但是当全量同步中途出错，导致同步结束，就会有一个问题，当从库重连后，需要重新进行全量同步，还需要生成新的RDB文件，而生成RDB文件需要占用大量的cpu资源，内存和磁盘I&#x2F;O，而且主从传输RDB文件还会占用网络带宽。所以如果中途出现意外，就需要进行新的全量同步，这样效率很低。</p>
<h2 id="新版功能的实现"><a href="#新版功能的实现" class="headerlink" title="新版功能的实现"></a>新版功能的实现</h2><p>新版的复制采用PSYNC命令来代替SYNC命令。</p>
<p>PSYNC具有完整同步和部分重同步两种，完整同步和SYNC的一致，而部分重同步在断线重连后，如果条件允许，会接着上一次的同步，或者只同步在断线期间产生的新数据。</p>
<h2 id="部分重同步实现"><a href="#部分重同步实现" class="headerlink" title="部分重同步实现"></a>部分重同步实现</h2><p>部分重同步由以下三部分构成：</p>
<p>1、主服务器的复制偏移量和从服务器的复制偏移量。</p>
<p>2、主服务器的复制挤压缓冲区。</p>
<p>3、服务器运行ID。</p>
<h3 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h3><p>执行复制时，主从服务器都会维护一个偏移量，用于记录同步的位置。该偏移量可以用来判断主从是否一致。如果一致，那么偏移量应该相等。一个具体的例子，比如主服务器的偏移量为100，三个从服务器此时的偏移量都是100，则说明主从都是一致的。此时主服务器又产生了20字节的数据需要同步，那么主服务器同步完后会在偏移量上加20，此时是120，从服务器同步成功后，也会在偏移量上加20，如果有一个从服务器同步失败，那么它的偏移量就还是100。</p>
<h3 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h3><p>在主服务器同步的过程中，它不仅会把数据发送给从服务器，也会写入复制积压缓冲区。这是一个队列，默认大小为1mb。而且写入这里边的数据都会被记录复制偏移量。</p>
<p>当从服务器断线重连后，如果复制偏移量之后的数据仍然在复制积压缓冲区中，那主服务就对从服务器进行部分重同步，如果复制偏移量之后的数据不在复制积压缓冲区中，那么就进行全量同步。</p>
<h2 id="PSYNC命令执行时可能会遇到的情况"><a href="#PSYNC命令执行时可能会遇到的情况" class="headerlink" title="PSYNC命令执行时可能会遇到的情况"></a>PSYNC命令执行时可能会遇到的情况</h2><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230329164847019.png" alt="image-20230329164847019"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Redis设计与实现》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
        <category>集群</category>
      </categories>
      <tags>
        <tag>集群</tag>
        <tag>Redis设计与实现</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis脑裂导致的数据丢失问题</title>
    <url>/2023/03/20/Redis/Redis%E8%84%91%E8%A3%82%E5%AF%BC%E8%87%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="一般的数据丢失"><a href="#一般的数据丢失" class="headerlink" title="一般的数据丢失"></a>一般的数据丢失</h3><p>在主从集群中发生数据丢失，最常见的原因就是<strong>主库的数据还没有同步到从库，结果主库发生了故障，等从库升级为主库后，未同步的数据就丢失了。</strong></p>
<p>如果是这种情况，我们可以通过比对主从库上的复制进度差值来进行判断，也就是计算 master_repl_offset 和 slave_repl_offset 的差值。</p>
<h3 id="脑裂导致的数据丢失"><a href="#脑裂导致的数据丢失" class="headerlink" title="脑裂导致的数据丢失"></a>脑裂导致的数据丢失</h3><p>所谓的脑裂，就是指在主从集群中，同时有两个主节点，它们都能接收写请求。</p>
<p>主从切换后，从库一旦升级为新主库，哨兵就会让原主库执行 slave of 命令，和新主库重新进行全量同步。而在全量同步执行的最后阶段，原主库需要清空本地的数据，加载新主库发送的 RDB 文件，这样一来，<strong>原主库在主从切换期间保存的新写数据就丢失了</strong>。</p>
<p>上述情况的发生，主要是由于误判造成的原主库假死，然后在执行主从切换的过程中，原主库还可以进行数据的处理，但是进行全量同步时这些数据并不会一起进行同步，而是会保存在缓存中，等到同步完发送，但是主从切换在执行的最后阶段会清空主库原来的数据，导致全量同步过程中新写入的数据丢失。</p>
<p>而误判的原因可能是原主库在执行cpu密集型的操作，导致无法相应哨兵的心跳检测，导致哨兵误判原主库故障。</p>
<h3 id="如何应对上述情况？"><a href="#如何应对上述情况？" class="headerlink" title="如何应对上述情况？"></a>如何应对上述情况？</h3><p>Redis 已经提供了两个配置项来限制主库的请求处理，分别是 min-slaves-to-write 和 min-slaves-max-lag。</p>
<p>min-slaves-to-write：这个配置项设置了主库能进行数据同步的最少从库数量；</p>
<p>min-slaves-max-lag：这个配置项设置了主从库间进行数据复制时，从库给主库发送 ACK 消息的最大延迟（以秒为单位）。</p>
<p>当我们把min-slaves-to-write和min-slaves-max-lag设置为N和T，意味着主库连接的从库中至少有 N 个从库和主库进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则，主库就不会再接收客户端的请求了。</p>
<p>这样设置后，假如主库假死，如果N设置为1，T设置为5，如果从库和主库进行数据复制的ACK时间超过5s，那么主库就不能够处理客户端的请求。</p>
<h3 id="上述设置是否可以避免脑裂？"><a href="#上述设置是否可以避免脑裂？" class="headerlink" title="上述设置是否可以避免脑裂？"></a>上述设置是否可以避免脑裂？</h3><p>考虑如下问题：</p>
<p>假设我们将 min-slaves-to-write 设置为 1，min-slaves-max-lag 设置为 15s，哨兵的 down-after-milliseconds 设置为 10s，哨兵主从切换需要 5s。主库因为某些原因卡住了 12s，此时，还会发生脑裂吗？主从切换完成后，数据会丢失吗？</p>
<p>主库卡住 12s，达到了哨兵设定的切换阈值，所以哨兵会触发主从切换。但哨兵切换的时间是 5s，也就是说哨兵还未切换完成，主库就会从阻塞状态中恢复回来，而且也没有触发 min-slaves-max-lag 阈值，所以主库在哨兵切换剩下的 3s 内，依旧可以接收客户端的写操作，如果这些写操作还未同步到从库，哨兵就把从库提升为主库了，那么此时也会出现脑裂的情况，之后旧主库降级为从库，重新同步新主库的数据，新主库也会发生数据丢失。</p>
<p>脑裂产生问题的本质原因是，Redis 主从集群内部没有通过共识算法，来维护多个节点数据的强一致性。它不像 Zookeeper 那样，每次写请求必须大多数节点写成功后才认为成功。当脑裂发生时，Zookeeper 主节点被孤立，此时无法写入大多数节点，写请求会直接返回失败，因此它可以保证集群数据的一致性。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>数据一致性</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis设计之基本数据结构（一）</title>
    <url>/2022/11/05/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h3 id="简单动态字符串SDS"><a href="#简单动态字符串SDS" class="headerlink" title="简单动态字符串SDS"></a>简单动态字符串SDS</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>1、保存数据库中字符串的值</p>
<p>2、AOF中的缓冲区以及客户端状态中的缓冲区</p>
<h4 id="具体结构代码"><a href="#具体结构代码" class="headerlink" title="具体结构代码"></a>具体结构代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">	<span class="comment">// 记录buf数组中已经使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于SDS所保存字符串的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为C语言的字符串在每次赋值前都需要申请空间，而且获取长度需要遍历整个字符串，所以Redis采用上述设计。</p>
<h4 id="SDS的好处"><a href="#SDS的好处" class="headerlink" title="SDS的好处"></a>SDS的好处</h4><p>1、可以在O(1)的时间复杂度之内获取到字符串的长度。</p>
<p>2、杜绝缓冲区的溢出。</p>
<p>​	SDS的API每次操作SDS时，会先检查SDS空间是否满足，如果不满足会将空间扩展至足够的大小，然后才执行实际的修改。</p>
<p>3、减少修改字符串时带来的内存分配的次数。在C语言中，每一次修改字符串都需要重新分配内存空间，而SDS采用空间预分配和惰性删除来减少分配次数</p>
<p>​	1）空间预分配：如果需要对SDS进行扩容，如果扩容后SDS的长度小于1mb，那么就会额外分配len长度的空间。比如原来10kb，扩容后30kb，小于1mb，就会多分配30kb。如果大于1mb，就会额外分配1mb。</p>
<p>​	2）惰性删除：当需要缩短字符串时，SDS并不会了立即释放多余的空间，而是使用free字段来记录这些空间，等到下一次分配时使用。同时也提供了API进行真正的释放这些空间。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>1、发布与订阅</p>
<p>2、慢查询</p>
<p>3、监视器</p>
<p>4、构建客户端输出缓冲区</p>
<h4 id="链表以及链表节点的实现"><a href="#链表以及链表节点的实现" class="headerlink" title="链表以及链表节点的实现"></a>链表以及链表节点的实现</h4><p>链表的每一个节点结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表每个节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="type">void</span> *val;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链表所包含节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup) &#123;<span class="type">void</span> *ptr;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>) &#123;<span class="type">void</span> *ptr;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="type">int</span> (*match) &#123;<span class="type">void</span> *ptr, <span class="type">void</span> * key;&#125;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Redis设计与实现》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Redis设计与实现</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis设计与实现之基本数据结构（三）</title>
    <url>/2022/11/07/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>跳跃表在大多数时间内可以与平衡树媲美，而且跳跃表的设计要比平衡树简单，所以采用跳跃表。</p>
<p>在Redis中，使用跳跃表作为有序集合的底层实现。如果一个有序集合的元素数量比较多，或者有序集合的成员是比较长的字符串时，Redis会采用跳跃表来作为有序集合的底层实现。</p>
<h4 id="具体设计"><a href="#具体设计" class="headerlink" title="具体设计"></a>具体设计</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跳跃表结构体如下</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 跳跃表的头节点以及尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skiplistNode</span> *<span class="title">head</span>, *<span class="title">tail</span>;</span></span><br><span class="line">  	</span><br><span class="line">    <span class="comment">// 跳跃表节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    </span><br><span class="line">   	<span class="comment">// 跳跃表中节点最深节点的深度</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">    </span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳跃表中每一个节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">skiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">skiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">&#125; skiplistNode;</span><br></pre></td></tr></table></figure>

<p>具体结构如下所示：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230321141729756.png" alt="image-20230321141729756"></p>
<p><strong>header</strong>：指向跳跃表的表头。</p>
<p><strong>tail</strong>：指向跳跃表的表尾。</p>
<p><strong>level</strong>：记录跳跃表内当前层数最大的那个层数。表头节点不算在内。</p>
<p>参考上面那个跳跃表，虽然有L32，但是L32没有数据。有数据的最深的的一层时L5，所以level的值为5。</p>
<p><strong>length</strong>：记录跳跃表的长度，即目前跳跃表包含节点的数量。表头节点不计算在内。</p>
<p>注意：这里表头节点不计算在内，表头节点指的是header直接指向的节点。所以除了hader直接指向的节点，另外有3个节点，所以是3.</p>
<p><strong>每一个节点，即L1,L2的构成</strong>：每一个小的节点就是skiplistNode中level数组中的一个。数组中每一个成员有一个前进指针以及跨度。前进指针用于指向<strong>尾节点方向的同一层的下一个节点</strong>。跨度指的是当前节点该层与指向下一个节点的距离，跨度越大，说明两个节点的距离越远。具体参考上图，指向线上的值就是跨度。</p>
<p><strong>backward</strong>：用于从表尾向表头遍历时使用。</p>
<p><strong>分值</strong>：在跳跃表中，数据按照各自的分值由小到大排列。</p>
<h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><p>整数集合是Redis用于保存整数值的集合抽象数据结构。它可以用来保存int16_t, int32_t, int64_t。并且保证集合中不会出现重复值。</p>
<h4 id="具体结构"><a href="#具体结构" class="headerlink" title="具体结构"></a>具体结构</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">   	<span class="type">uint32_t</span> encoding;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>其中contents数组中的元素保存具体的数据，而且从小到达排列，并且没有重复值。</p>
<p>一个具体的例子：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230321152349261.png" alt="image-20230321152349261"></p>
<h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>当我们向整数集合中添加一个元素时，如果该元素的类型比之前集合中所有元素类型都要大时，整数集合就需要升级。</p>
<p>升级的过程：</p>
<p>1）根据新元素的类型，扩展整数集合底层空间的大小，并且为新元素分配空间。</p>
<p>2）将整数集合中所有元素都转换为与新元素相同的类型。并将转换后的元素放在集合的原来位置。该过程需要与原来的顺序一致。</p>
<p>3）将新元素插入元素集合。</p>
<h4 id="升级的优点"><a href="#升级的优点" class="headerlink" title="升级的优点"></a>升级的优点</h4><p>一方面提高数据的灵活性，另一方面节约内存。</p>
<h3 id="压缩链表"><a href="#压缩链表" class="headerlink" title="压缩链表"></a>压缩链表</h3><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>一个列表只包含少量列表项，并且列表项中的每个元素要么是小整数值，要么是比较短的字符串，Redis就会使用压缩列表来作为列表键的底层实现。</p>
<h4 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h4><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230322140235259.png" alt="image-20230322140235259"></p>
<h5 id="zlbytes"><a href="#zlbytes" class="headerlink" title="zlbytes"></a>zlbytes</h5><p>该字段用于记录整个压缩列表占用的内存字节数。对压缩列表进行内存重分配，或者计算zlend的位置时使用。</p>
<h5 id="zltail"><a href="#zltail" class="headerlink" title="zltail"></a>zltail</h5><p>记录压缩列表表尾节点距离压缩列表起始地址有多少字节，通过该变量可以由表头直接到达表尾。</p>
<h5 id="zllen"><a href="#zllen" class="headerlink" title="zllen"></a>zllen</h5><p>记录了压缩列表中包含节点的数量。当这个值小于65535时，就是记录节点数量。但是大于65535，则需要遍历才能获取真证的节点数量。</p>
<h5 id="entryX"><a href="#entryX" class="headerlink" title="entryX"></a>entryX</h5><p>代表具体的节点。节点长度由保存内容决定。</p>
<h5 id="zlend"><a href="#zlend" class="headerlink" title="zlend"></a>zlend</h5><p>用于标记压缩列表的末端。</p>
<h4 id="压缩列表每个节点的构成"><a href="#压缩列表每个节点的构成" class="headerlink" title="压缩列表每个节点的构成"></a>压缩列表每个节点的构成</h4><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230322140759893.png" alt="image-20230322140759893"></p>
<h5 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h5><p>该值代表了目前节点前一个节点的大小，如果前一个节点长度小于254字节，该值的长度就是1字节，如果大于或等于254字节，那么该值的长度就是5字节。</p>
<p>记录前一个字节的大小，可以方便倒序遍历。因为知道当前节点的起始位置，又知道前一个节点的大小，就可以算出前一个节点的位置。如果需要倒序遍历，我们可以通过zltail字段的值配合首地址，直接找到末尾节点的位置，然后通过每一个节点的前一个节点大小，进行倒序的遍历。</p>
<h5 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h5><p>记录了节点的content属性所保存的数据类型以及长度。</p>
<h5 id="content"><a href="#content" class="headerlink" title="content"></a>content</h5><p>负责保存节点的值。可以是一个字节数组或者整数。</p>
<h4 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h4><p>考虑以下场景，如果有很多个连续的长度介于250-253字节的节点，因为这些节点的长度都小于254字节，所以他们的previous_entry_length属性大小都是1字节。但是现在新添加了一个节点，他的长度大于254，那么其中一个节点的previous_entry_length属性要更改为5字节，那么该节点自身的长度也就大于254，会导致它后边的节点也更新，最终导致这一连串的节点都需要重新分配内存。</p>
<p>而且删除节点时也有可能会导致这种情况。</p>
<p>实际使用中，很少会出现这种情况。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Redis设计与实现》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Redis设计与实现</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis缓冲区可能引发的问题</title>
    <url>/2023/04/04/Redis/Redis%E7%BC%93%E5%86%B2%E5%8C%BA%E5%8F%AF%E8%83%BD%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Redis缓冲区"><a href="#Redis缓冲区" class="headerlink" title="Redis缓冲区"></a>Redis缓冲区</h1><p>缓冲区的作用主要就是用一块内存空间来<strong>暂时存放命令数据</strong>，以免出现因为<strong>数据和命令的处理速度</strong>慢于<strong>发送速度</strong>而导致的数据丢失和性能问题。但缓冲区的内存空间有限，如果往里面写入数据的速度持续地大于从里面读取数据的速度，就会导致缓冲区需要越来越多的内存来暂存数据。当缓冲区占用的内存超出了设定的上限阈值时，就会出现缓冲区溢出。</p>
<p>缓冲区在 Redis 中的一个主要应用场景，就是在客户端和服务器端之间进行通信时，用来<strong>暂存客户端发送的命令数据</strong>，或者是<strong>服务器端返回给客户端的数据结果</strong>。此外，缓冲区的另一个主要应用场景，是在主从节点间进行数据同步时，用来<strong>暂存主节点接收的写命令和数据</strong>。</p>
<h1 id="客户端输入和输出缓冲区"><a href="#客户端输入和输出缓冲区" class="headerlink" title="客户端输入和输出缓冲区"></a>客户端输入和输出缓冲区</h1><p>为了避免客户端和服务端的<strong>请求发送和处理速度不匹配</strong>，服务器端给每个连接的客户端都设置了一个输入缓冲区和输出缓冲区。</p>
<p>输入缓冲区会把客户端发送过来的命令暂存起来，Redis 主线程再从输入缓冲区中读取命令，进行处理，当Redis主线程处理完数据后，会把结果写入到输出缓冲区，再通过输出缓冲区返回给客户端。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230309095753245.png" alt="image-20230309095753245"></p>
<h2 id="如何应对输入缓冲区溢出"><a href="#如何应对输入缓冲区溢出" class="headerlink" title="如何应对输入缓冲区溢出"></a>如何应对输入缓冲区溢出</h2><p>可能溢出的情况：</p>
<p>1、写入了 bigkey，比如一下子写入了多个百万级别的集合类型数据；</p>
<p>2、服务器端处理请求的速度过慢，例如，Redis 主线程出现了间歇性阻塞，无法及时处理正常发送的请求，导致客户端发送的请求在缓冲区越积越多。</p>
<p>所以对应的两个解决方案：</p>
<p>1、调大缓冲区。</p>
<p>2、从数据命令的发送和处理速度入手。</p>
<p>缓冲区的大小是Redis代码中写死的1GB，无法调整。因为太大会导致客户端占用过多内存资源而崩溃。</p>
<p>只能从发送命令入手，避免写入bigKey，以及避免Redis主线程阻塞。</p>
<h2 id="如何应对输出缓冲区溢出"><a href="#如何应对输出缓冲区溢出" class="headerlink" title="如何应对输出缓冲区溢出"></a>如何应对输出缓冲区溢出</h2><p>Redis的输出缓冲区暂存的是Redis主线程返回给客户端的数据，分两种，一种是OK或者其他的报错信息，大小固定。另外一种是大小不固定的，包含具体数据的。</p>
<p>因此，Redis 为每个客户端设置的输出缓冲区也包括两部分：一部分，是一个大小为 16KB 的固定缓冲空间，用来暂存 OK 响应和出错信息；另一部分，是一个可以动态增加的缓冲空间，用来暂存大小可变的响应结果。</p>
<p>输出缓冲区溢出的三种情况：</p>
<p>1、服务器端返回 bigkey 的大量结果；</p>
<p>2、执行了 MONITOR 命令；</p>
<p>3、缓冲区大小设置得不合理。</p>
<p>其中，MONITOR 命令是用来监测 Redis 执行的。执行这个命令之后，就会持续输出监测到的各个命令操作。而MONITOR 的输出结果会持续占用输出缓冲区，并越占越多，最后的结果就是发生溢出。</p>
<h3 id="输出缓冲区大小设置"><a href="#输出缓冲区大小设置" class="headerlink" title="输出缓冲区大小设置"></a>输出缓冲区大小设置</h3><p>和输入缓冲区不同，我们可以通过 client-output-buffer-limit 配置项，来设置缓冲区的大小，可以设置以下两个方面：</p>
<p>1、设置缓冲区大小的上限阈值；</p>
<p>2、设置输出缓冲区持续写入数据的数量上限阈值，和持续写入数据的时间的上限阈值。</p>
<p>对于和 Redis 实例进行交互的应用程序来说，主要使用两类客户端和 Redis 服务器端交互，分别是常规和 Redis 服务器端进行读写命令交互的普通客户端，以及订阅了 Redis 频道的订阅客户端。此外，在 Redis 主从集群中，主节点上也有一类客户端（从节点客户端）用来和从节点进行数据同步。</p>
<p>对于普通客户端来说，它每发送完一个请求，会等到请求结果返回后，再发送下一个请求，这种发送方式称为阻塞式发送。</p>
<p>对于订阅客户端来说，一旦订阅的 Redis 频道有消息了，服务器端都会通过输出缓冲区把消息发给客户端。所以，订阅客户端和服务器间的消息发送方式，<strong>不属于阻塞式发送</strong>。不过，如果频道消息较多的话，也会占用较多的输出缓冲区空间。</p>
<h1 id="主从集群缓冲区"><a href="#主从集群缓冲区" class="headerlink" title="主从集群缓冲区"></a>主从集群缓冲区</h1><p>主从集群间的复制包括<strong>全量复制</strong>和<strong>增量复制</strong>两种。全量复制是同步所有数据，而增量复制只会把主从库网络断连期间主库收到的命令，同步给从库。</p>
<p>在全量复制过程中，主节点在向从节点传输 RDB 文件的同时，会继续接收客户端发送的写命令请求。这些写命令就会先保存在<strong>复制缓冲区</strong>中，等 RDB 文件传输完成后，再发送给从节点去执行。主节点上会为每个从节点都维护一个复制缓冲区，来保证主从节点间的数据同步。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230309105458692.png" alt="image-20230309105458692"></p>
<p>所以，如果在全量复制时，从节点接收和加载 RDB 较慢，同时主节点接收到了大量的写命令，写命令在复制缓冲区中就会越积越多，最终导致溢出。</p>
<p>而且主节点上复制缓冲区的内存开销，会是每个从节点客户端输出缓冲区占用内存的总和。如果集群中的从节点数非常多的话，主节点的内存开销就会非常大。所以，我们还必须得控制和主节点连接的从节点个数，不要使用大规模的主从集群。</p>
<h2 id="复制积压缓冲区的溢出问题"><a href="#复制积压缓冲区的溢出问题" class="headerlink" title="复制积压缓冲区的溢出问题"></a>复制积压缓冲区的溢出问题</h2><p>复制积压缓冲区是一个大小有限的<strong>环形缓冲区</strong>。当主节点把复制积压缓冲区写满后，<strong>会覆盖缓冲区中的旧命令数据</strong>。如果从节点还没有同步这些旧命令数据，就会造成主从节点间重新开始执行全量复制。</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>主节点为每个从节点都会维护一个独立的复制缓冲区。只记录主从全量同步期间，主节点新收到的命令。</p>
<p>而复制积压缓冲区是redis2.8以后引入的，它一般配合复制偏移量一起使用，是用来进行增量同步的。整个master进程中只会存在一个，所有的slave公用。</p>
<p>在引入复制积压缓冲区后，在进行同步期间，主节点不仅会把命令写入复制缓冲区，供每一个从节点执行，也会写入复制积压缓冲区。如果从服务器断线重连，会根据偏移量去复制积压缓冲区查找缺少的数据，如果复制积压缓冲区没有对应的数据，则需要进行全量同步。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Redis核心技术与实战》</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis核心技术实战</tag>
        <tag>缓冲区</tag>
      </tags>
  </entry>
  <entry>
    <title>事务机制之Redis能否实现ACID属性</title>
    <url>/2023/03/18/Redis/%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6%E4%B9%8BRedis%E8%83%BD%E5%90%A6%E5%AE%9E%E7%8E%B0ACID%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>所谓的事务，就是指对数据进行读写的一系列操作。事务在执行时，会提供专门的属性保证，包括<strong>原子性</strong>（Atomicity）、<strong>一致性</strong>（Consistency）、<strong>隔离性</strong>（Isolation）和<strong>持久性</strong>（Durability），也就是 ACID 属性。</p>
<h3 id="事务ACID属性要求"><a href="#事务ACID属性要求" class="headerlink" title="事务ACID属性要求"></a>事务ACID属性要求</h3><p>首先来看原子性。原子性的要求很明确，就是一个事务中的多个操作必须都完成，或者都不完成。业务应用使用事务时，原子性也是最被看重的一个属性。</p>
<p>第二个属性是一致性。这个很容易理解，就是指数据库中的数据在事务执行前后是一致的。</p>
<p>第三个属性是隔离性。它要求数据库在执行一个事务时，其它操作<strong>无法存取到正在执行事务访问的数据</strong>。</p>
<p>最后一个属性是持久性。数据库执行事务后，数据的修改要被持久化保存下来。当数据库重启后，数据的值需要是被修改后的值。</p>
<h3 id="Redis如何实现事务"><a href="#Redis如何实现事务" class="headerlink" title="Redis如何实现事务"></a>Redis如何实现事务</h3><p>首先，客户端需要一个显式的命令开启事务，Redis里使用MULTI来手动开启一个事务。</p>
<p>第二步，客户端把事务中需要执行的具体操作发送给服务端。Redis接受到这些命令后会将他们都存到一个队列当中，并不会立即执行。</p>
<p>第三步向服务端发送提交事务请求，Redis使用EXEC，让数据库执行第二步的那些操作。</p>
<h3 id="Redis的事务机制能保证哪些属性？"><a href="#Redis的事务机制能保证哪些属性？" class="headerlink" title="Redis的事务机制能保证哪些属性？"></a>Redis的事务机制能保证哪些属性？</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>如果事务正常执行，MULTI 和 EXEC 配合使用，就可以保证多个操作都完成。但是如果事务执行发生错误，则需要分三种情况：</p>
<p>1、<strong>在执行 EXEC 命令前，客户端发送的操作命令本身就有错误</strong>，比如语法错误，那么在入队前会被检测出来。提交一个错误命令之后，仍然可以继续提交，但是在执行EXEC命令后，Redis会返回错误，也不会执行队列中的命令。</p>
<p>2、<strong>事务操作入队时，命令和操作的数据类型不匹配，但 Redis 实例没有检查出错误</strong>。此时在提交EXEC命令后，Redis在执行这些操作时，到达这个不匹配的命令，会报错，但是前面的正确的命令已经执行了，此种情况无法保证事务的原子性。</p>
<p>Redis没有Mysql那种回滚机制。虽然提供了DISCARD 命令，但是只能用来主动放弃事务，把暂存的命令队列清空，没有回滚效果。</p>
<p>3、<strong>在执行事务的 EXEC 命令时，Redis 实例发生了故障，导致事务执行失败</strong>。这种情况下，如果Redis开启了AOF日志，只会有部分的事务操作被记录到AOF日志中，我们需要使用 redis-check-aof 工具检查 AOF 日志文件，这个工具可以把未完成的事务操作从 AOF 文件中去除。这样一来，我们使用 AOF 恢复实例后，事务操作不会再被执行，从而保证了原子性。</p>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>事务的一致性保证会受到<strong>错误命令</strong>、<strong>实例故障</strong>的影响。所以，我们按照命令出错和实例故障的发生时机，分成三种情况来看。</p>
<p><strong>1、命令入队时就报错</strong></p>
<p>这种情况下事务就不会执行，所以可以保证一致性。</p>
<p><strong>2、命令入队时没报错，实际执行时报错</strong></p>
<p>这种情况下，正确的命令会执行，但是错误的命令并不会执行，也不会改变数据库的一致性。</p>
<p><strong>3、EXEC 命令执行时实例发生故障</strong></p>
<p>如果没有开启AOF和RDB，那么重启后就没有数据，数据是一致的。</p>
<p>如果使用了RDB，因为RDB快照不会在事务执行的时候执行，所以事务操作成功的那部分数据不会被RDB记录，所以也是一致的。</p>
<p>如果使用了AOF，事务操作还没来得及被记录到AOF当中，实例就发生了故障，那么AOF恢复的数据就是一致的。如果有部分被记录到AOF当中，我们可以使用 redis-check-aof 清除事务中已经完成的操作，数据库恢复后也是一致的。</p>
<h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><p>事务的隔离性保证，会受到和事务一起执行的并发操作的影响。而事务执行又可以分成命令入队（EXEC 命令执行前）和命令实际执行（EXEC 命令执行后）两个阶段，所以，我们就针对这两个阶段，分成两种情况来分析：</p>
<p>1、并发操作在 EXEC 命令前执行，此时，隔离性的保证要使用 WATCH 机制来实现，否则隔离性无法保证；</p>
<p>WATCH 机制的作用是，在事务执行前，<strong>监控一个或多个键的值变化情况</strong>，当事务调用 EXEC 命令执行时，WATCH 机制会先检查监控的键是否被其它客户端修改了。如果修改了，就放弃事务执行，避免事务的隔离性被破坏。然后，客户端可以再次执行事务，此时，如果没有并发修改事务数据的操作了，事务就能正常执行，隔离性也得到了保证。这里需要使用watch命令。</p>
<p>这里的情况就是，客户端A开启事务，在输入命令的过程中，客户端B修改了A涉及到的数据。</p>
<p>2、并发操作在 EXEC 命令后执行，此时，隔离性可以保证。</p>
<p>这种情况是客户端A的事务已经全部处于队列，并且Redis已经开始处理队列中的命令，此时有客户端B发送命令修改了队列中涉及到的数据。因为Redis会<strong>优先处理队列中的命令</strong>，而不会去处理客户端B的命令，所以不会破坏事务的隔离性。</p>
<h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><p>如果没有开启AOF和RDB，无法保证持久性。</p>
<p>开启了RDB，如果事务执行后，下一次RDB快照还没开始，就宕机，则无法保证持久性。</p>
<p>而AOF 模式的三种配置选项 no、everysec 和 always 都会存在数据丢失的情况，所以，事务的持久性属性也还是得不到保证。</p>
<h3 id="Pipeline-管道-的使用"><a href="#Pipeline-管道-的使用" class="headerlink" title="Pipeline(管道)的使用"></a>Pipeline(管道)的使用</h3><p>使用管道技术，可以一次性把命令全部打包发到服务端，服务端全部处理完成后返回。这么做好的好处，一是减少了来回网络 IO 次数，提高操作性能。二是一次性发送所有命令到服务端，服务端在处理过程中，是不会被别的请求打断的（Redis单线程特性，此时别的请求进不来），这本身就保证了隔离性。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Redis核心技术实战》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis设计与实现之基本数据结构（二）</title>
    <url>/2022/11/06/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><h4 id="具体结构"><a href="#具体结构" class="headerlink" title="具体结构"></a>具体结构</h4><p>字典又称符号表、关联数组或映射，是一种用于保存键值对的抽象数据结构。</p>
<p>Redis字典使用哈希表作为底层实现，一个哈希表可以有多个哈希表节点，每一个哈希表节点保存了字典中的一个键值对。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">C</span><br><span class="line"><span class="comment">// 哈希表结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值，总是等于size - 1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该哈希表已有的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">       	uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">	&#125; v;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p>Redis中的字典构造</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">C</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">	dictType *type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rehash索引</span></span><br><span class="line">    <span class="comment">// 当rehash不再进行时，值为-1</span></span><br><span class="line">    <span class="type">int</span> trehashidx;</span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*hashFunction)</span> <span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup) (<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="type">void</span> *(*valDup) (<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="type">void</span> *(*keyCompare) (<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="type">void</span> *(*keyDestructor) (<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="type">void</span> *(*valDestructor) (<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>

<p>一个字典的结构图如下所示</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230320205611832.png" alt="image-20230320205611832"></p>
<p>一个字典结构体，存储数据的是里面的ht，即一个哈希表数组，哈希表的大小为2。一个哈希表的主要内容是其中的table数组，用于存放键值对的数据结构。</p>
<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>当要将一个新的值插入数据字典时，要先根据键计算出哈希值和索引值，根据索引将新的键值对放到对应索引的位置。</p>
<p>这里计算出的索引就是dictht中table的下标，然后放入对应位置。</p>
<h4 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h4><p>Redis的哈希表使用链地址法解决键冲突（头插法）。每一个dictEntry都有一个指向下一个节点的指针，当出现冲突，就链接在后边。</p>
<h4 id="Rehash"><a href="#Rehash" class="headerlink" title="Rehash"></a>Rehash</h4><p>随着操作不断进行，哈希表保存的数据可能越来越多，也可能越来越少。为了保持哈希表的负载因子在一定范围内，当哈希表保存的键值对太多或太少时，哈希表会进行相应的扩容或者收缩。这个扩容或者收缩的过程就叫Rehash。</p>
<h5 id="Rehash过程"><a href="#Rehash过程" class="headerlink" title="Rehash过程"></a>Rehash过程</h5><p>1、首先是对ht[1]分配空间，如果是扩容操作，则大小为第一个大于ht[0].used * 2的2^n（n从0开始增大，一直到2^n大于used * 2 ）。如果是收缩，则大小为第一个大于ht[0].used的2^n。</p>
<p>2、将ht[0]上的键值对重新计算哈希值，保存在ht[1]中。</p>
<p>3、当ht[0]的全部数据都重新计算哈希值并存入ht[1]后，释放ht[0]的空间，将ht[1]设置为ht[0]，在ht[1]创建新的空白哈希表，用于下一次Rehash。</p>
<h5 id="rehash条件"><a href="#rehash条件" class="headerlink" title="rehash条件"></a>rehash条件</h5><p>1、服务器没有执行BGSAVE命令，或者BGREWRITEAOF命令，且负载因子大于1。</p>
<p>2、在执行上述两个命令，且负载因子大于5。</p>
<p>负载因子计算方法：哈希表已保存节点数 &#x2F; 哈希表大小</p>
<h4 id="渐进式Rehash"><a href="#渐进式Rehash" class="headerlink" title="渐进式Rehash"></a>渐进式Rehash</h4><p>Rehash将ht[0]所有值重计算放入ht[1]的过程并不是一次性，集中的完成的，而是分多次，渐进的完成的。</p>
<p>具体过程：</p>
<p>1、为ht[1]分配空间，让字典同时只有ht[0]和ht[1]两个哈希表。</p>
<p>2、字典中的rehashidx的值设置为0（初始值为-1），表示开始rehash。</p>
<p>3、在rehash期间，每次对字典进行增删改查时，还会顺带将 ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]上，完成后将rehashidx的值增加1。</p>
<p>4、当ht[0]都被rehash到ht[1]上时，会将rehashidx的值设置为-1，表示rehash完成。</p>
<p>注意：rehash过程中，如果需要查找，删除，更新，则会在ht[0]和ht[1]中都进行操作，找到元素在哪就在那个表操作。如果进行插入，则只会在ht[1]表中进行。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Redis设计与实现》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Redis设计与实现</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis集群方案之Codis</title>
    <url>/2023/03/21/Redis/Redis%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%E5%A6%82%E4%BD%95%E9%80%89%E5%8F%96/</url>
    <content><![CDATA[<h3 id="codis集群中包含的4个组件"><a href="#codis集群中包含的4个组件" class="headerlink" title="codis集群中包含的4个组件"></a>codis集群中包含的4个组件</h3><p>1、codis server：这是进行了二次开发的 Redis 实例，其中增加了额外的数据结构，支持数据迁移操作，主要负责处理具体的数据读写请求。</p>
<p>2、codis proxy：接收客户端请求，并把请求转发给 codis server。</p>
<p>3、Zookeeper 集群：保存集群元数据，例如数据位置信息和 codis proxy 信息。</p>
<p>4、codis dashboard 和 codis fe：共同组成了集群管理工具。其中，codis dashboard 负责执行集群管理工作，包括增删 codis server、codis proxy 和进行数据迁移。而 codis fe 负责提供 dashboard 的 Web 操作界面，便于我们直接在 Web 界面上进行集群管理。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230321095144355.png" alt="image-20230321095144355"></p>
<h3 id="Codis处理请求流程"><a href="#Codis处理请求流程" class="headerlink" title="Codis处理请求流程"></a>Codis处理请求流程</h3><p>1、首先使用codis dashboard 设置 codis server 和 codis proxy 的访问地址。</p>
<p>2、客户端与coids proxy建立连接。codis proxy本身支持Redis的RESP交互协议，所以与codis proxy建立连接与原生Redis没有区别。</p>
<p>3、coids proxy接受到请求后，会查询请求数据和coids proxy的映射关系，然后把请求转发给对应的coids server，处理完后会把结果返回给coids proxy，然后由代理（coids proxy）返回给客户端。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230321100625064.png" alt="image-20230321100625064"></p>
<h3 id="Codis关键技术原理"><a href="#Codis关键技术原理" class="headerlink" title="Codis关键技术原理"></a>Codis关键技术原理</h3><h4 id="数据如何在集群里分布"><a href="#数据如何在集群里分布" class="headerlink" title="数据如何在集群里分布"></a>数据如何在集群里分布</h4><p>在 Codis 集群中，一个数据应该保存在哪个 codis server 上，这是通过逻辑槽（Slot）映射来完成的。</p>
<p>coids集群又1024个Slot，编号0-1023，我们可以手动把这些Slot分给codis server，也可以使用dashboard进行自动分配。</p>
<p>当客户端要读写数据时，会使用 CRC32 算法计算数据 key 的哈希值，并把这个哈希值对 1024 取模。而取模后的值，则对应 Slot 的编号。此时，根据第一步分配的 Slot 和 server 对应关系，我们就可以知道数据保存在哪个 server 上了。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230321101725696.png" alt="image-20230321101725696"></p>
<p>数据 key 和 Slot 的映射关系是客户端在读写数据前直接通过 CRC32 计算得到的，而 Slot 和 codis server 的映射关系是通过分配完成的，所以就需要用一个存储系统保存下来。</p>
<p>Slot 和 codis server 的映射关系称为数据路由表（简称路由表）。我们在 codis dashboard 上分配好路由表后，dashboard 会把路由表发送给 codis proxy，同时，dashboard 也会把路由表保存在 Zookeeper 中。codis-proxy 会把路由表缓存在本地，当它接收到客户端请求后，直接查询本地的路由表，就可以完成正确的请求转发了。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230321102745604.png" alt="image-20230321102745604"></p>
<h3 id="Codis与Redis-Cluster映射区别"><a href="#Codis与Redis-Cluster映射区别" class="headerlink" title="Codis与Redis Cluster映射区别"></a>Codis与Redis Cluster映射区别</h3><p>Codis 中的路由表是我们通过 codis dashboard 分配和修改的，并被保存在 Zookeeper 集群中。一旦路由表被修改，codis dashbaord 就会把修改后的路由表发送给 codis proxy，然后proxy就可以进行转发。</p>
<p>在 Redis Cluster 中，数据路由表是通过每个实例相互间的通信传递的，最后会在每个实例上保存一份。当数据路由信息发生变化时，就需要在所有实例间通过网络消息进行传递。</p>
<h3 id="Codis如何进行扩容和数据迁移"><a href="#Codis如何进行扩容和数据迁移" class="headerlink" title="Codis如何进行扩容和数据迁移"></a>Codis如何进行扩容和数据迁移</h3><p>扩容包括增加 codis server 和增加 codis proxy。</p>
<h4 id="增加codis-server"><a href="#增加codis-server" class="headerlink" title="增加codis server"></a>增加codis server</h4><p>1、增加codis server，将他们加入集群。</p>
<p>2、把部分数据迁移到新的 server。</p>
<h5 id="数据迁移过程"><a href="#数据迁移过程" class="headerlink" title="数据迁移过程"></a>数据迁移过程</h5><p>1、在源 server 上，Codis 从要迁移的 Slot 中随机选择一个数据，发送给目的 server。</p>
<p>比如原来有server 1，2，3。现在新添加了一个4，这一步就是从1或2或3中随机选一个数据发送给4。</p>
<p>2、目的 server 确认收到数据后，会给源 server 返回确认消息。这时，源 server 会在本地将刚才迁移的数据删除。</p>
<p>3、第一步和第二步就是单个数据的迁移过程。Codis 会不断重复这个迁移过程，直到要迁移的 Slot 中的数据全部迁移完成。</p>
<h5 id="迁移种类：同步迁移和异步迁移"><a href="#迁移种类：同步迁移和异步迁移" class="headerlink" title="迁移种类：同步迁移和异步迁移"></a>迁移种类：同步迁移和异步迁移</h5><p>同步迁移：在数据从源 server 发送给目的 server 的过程中，源 server 是阻塞的，无法处理新的请求操作。这种比较简单，但是迁移过程会设计多个操作，包括数据在源 server 序列化、网络传输、在目的 server 反序列化，以及在源 server 删除，如果是一个bigKey，就会导致阻塞时间过长。</p>
<p>异步迁移：当源 server 把数据发送给目的 server 后，就可以处理其他请求操作了，不用等到目的 server 的命令执行完。目的server收到数据并反序列化保存到本地后，给源server发送一个ACK消息，这时源server删除数据。在这个过程中，目标数据被设置为只读，也就不会出现迁移完数据不一致的情况。</p>
<p>异步迁移对于bigKey采用拆分指令的方式。即对于bigKey中的每一个元素采用一条指令进行迁移，而不是把整个bigKey序列化然后迁移。避免了因序列化bigKey而导致的源server阻塞。</p>
<p>此外，当 bigkey 迁移了一部分数据后，如果 Codis 发生故障，就会导致 bigkey 的一部分元素在源 server，而另一部分元素在目的 server，这就破坏了迁移的原子性。</p>
<p>所以，Codis 会在目标 server 上，给 bigkey 的元素设置一个临时过期时间。如果迁移过程中发生故障，那么，目标 server 上的 key 会在过期后被删除，不会影响迁移的原子性。当正常完成迁移后，bigkey 元素的临时过期时间会被删除。</p>
<h4 id="增加codis-proxy"><a href="#增加codis-proxy" class="headerlink" title="增加codis proxy"></a>增加codis proxy</h4><p>启动一个新的proxy，直接使用codis dashboard加入集群即可。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230321105733398.png" alt="image-20230321105733398"></p>
<h3 id="怎么保证集群可靠性"><a href="#怎么保证集群可靠性" class="headerlink" title="怎么保证集群可靠性"></a>怎么保证集群可靠性</h3><h4 id="codis-server-的可靠性"><a href="#codis-server-的可靠性" class="headerlink" title="codis server 的可靠性"></a>codis server 的可靠性</h4><p>Codis 就使用主从集群来保证 codis server 的可靠性。简单来说就是，Codis 给每个 server 配置从库，并使用哨兵机制进行监控，当发生故障时，主从库可以进行切换，从而保证了 server 的可靠性。</p>
<p>在这种配置情况下，每个 server 就成为了一个 server group，每个 group 中是一主多从的 server。数据分布使用的 Slot，也是按照 group 的粒度进行分配的。同时，codis proxy 在转发请求时，也是按照数据所在的 Slot 和 group 的对应关系，把写请求发到相应 group 的主库，读请求发到 group 中的主库或从库上。</p>
<h4 id="codis-proxy-和-Zookeeper的可靠性"><a href="#codis-proxy-和-Zookeeper的可靠性" class="headerlink" title="codis proxy 和 Zookeeper的可靠性"></a>codis proxy 和 Zookeeper的可靠性</h4><p>proxy 上的信息源头都是来自 Zookeeper（例如路由表）。而 Zookeeper 集群使用多个实例来保存数据，只要有超过半数的 Zookeeper 实例可以正常工作， Zookeeper 集群就可以提供服务，也可以保证这些数据的可靠性。</p>
<h4 id="Codis-和-Redis-Cluster对比"><a href="#Codis-和-Redis-Cluster对比" class="headerlink" title="Codis 和 Redis Cluster对比"></a>Codis 和 Redis Cluster对比</h4><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230321112450765.png" alt="image-20230321112450765"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Redis核心技术实战》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
        <category>集群</category>
      </categories>
      <tags>
        <tag>集群</tag>
        <tag>Redis设计与实现</tag>
      </tags>
  </entry>
  <entry>
    <title>redis如何避免数据倾斜</title>
    <url>/2023/03/23/Redis/redis%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C/</url>
    <content><![CDATA[<h3 id="数据倾斜分类"><a href="#数据倾斜分类" class="headerlink" title="数据倾斜分类"></a>数据倾斜分类</h3><h4 id="数据量倾斜"><a href="#数据量倾斜" class="headerlink" title="数据量倾斜"></a>数据量倾斜</h4><p>在某些情况下，实例上的数据分布不均衡，某个实例上的数据特别多。</p>
<h5 id="造成原因"><a href="#造成原因" class="headerlink" title="造成原因"></a>造成原因</h5><p>1、bigKey</p>
<p>bigkey 的 value 值很大（String 类型），或者是 bigkey 保存了大量集合元素（集合类型），会导致这个实例的数据量增加，内存资源消耗也相应增加。bigkey 的操作一般都会造成实例 IO 线程阻塞，如果 bigkey 的访问量比较大，就会影响到这个实例上的其它请求被处理的速度。</p>
<p>在生成数据时，尽量避免把过多的数据保存在同一个键值对中，如果bigKey是一个集合，我们可以把bigKey拆分成多个小的集合类型，分散保存在不同实例。</p>
<p>2、slot分配不均衡</p>
<p>如果集群运维人员没有均衡地分配 Slot，就会有大量的数据被分配到同一个 Slot 中，而同一个 Slot 只会在一个实例上分布，这就会导致，大量数据被集中到一个实例上，造成数据倾斜。</p>
<p>比如说，集群中有5个实例，而实例1的硬件配置比较好，可能分配人员就给实例1多分配了几个Slot。但并不知道数据和Slot的对应关系，这种做法就有可能导致大量数据被映射到实例1的slot上。</p>
<p>在分配前，可以避免把过多的slot分配到一个实例上。如果已经分配了的，可以查看是否把同一个实例上分配了过多的slot，如果分配就将部分slot进行迁移。</p>
<p>3、Hash Tag</p>
<p>Hash Tag 是指加在键值对 key 中的一对花括号{}。这对括号会把 key 的一部分括起来，客户端在计算 key 的 CRC16 值时，只对 Hash Tag 花括号中的 key 内容进行计算。如果没用 Hash Tag 的话，客户端计算整个 key 的 CRC16 的值。</p>
<p>假设 key 是 user:profile:3231，我们把其中的 3231 作为 Hash Tag，此时，key 就变成了 user:profile:{3231}。当客户端计算这个 key 的 CRC16 值时，就只会计算 3231 的 CRC16 值。</p>
<p>使用 Hash Tag 的好处是，如果不同 key 的 Hash Tag 内容都是一样的，那么，这些 key 对应的数据会被映射到同一个 Slot 中，同时会被分配到同一个实例上。</p>
<p>Hash Tag主要是用在 Redis Cluster 和 Codis 中，支持事务操作和范围查询。因为 Redis Cluster 和 Codis 本身并不支持<strong>跨实例的事务操作和范围查询（多个Redis进行范围查询或者事务操作）</strong>，当业务应用有这些需求时，就只能先把这些数据读取到业务层进行事务处理，或者是逐个查询每个实例，得到范围查询的结果。我们可以使用 Hash Tag 把要执行事务操作或是范围查询的数据映射到同一个实例上，这样就能很轻松地实现事务或范围查询了。</p>
<h4 id="数据访问倾斜"><a href="#数据访问倾斜" class="headerlink" title="数据访问倾斜"></a>数据访问倾斜</h4><p>虽然每个集群实例上的数据量相差不大，但是某个实例上的数据是热点数据，被访问得非常频繁。</p>
<p>发生数据访问倾斜的根本原因，就是实例上存在热点数据。我们可以采用热点数据多副本的方法来应对。具体就是在每一个副本key中增加一个随机前缀，让它和其他副本分配到不同的slot中。<strong>热点数据多副本方法只能针对只读的热点数据</strong>。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis核心技术实战</tag>
      </tags>
  </entry>
  <entry>
    <title>Java开发分布式系统的编码技巧</title>
    <url>/2023/08/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Java%E5%BC%80%E5%8F%91%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="PageCache-调优和-Direct-IO"><a href="#PageCache-调优和-Direct-IO" class="headerlink" title="PageCache 调优和 Direct IO"></a>PageCache 调优和 Direct IO</h1><p>应用程序读取文件，会经过应用缓存、PageCache、DISK（硬盘）三层。</p>
<p>Linux内核读取到文件数据后，会把它缓存一段时间，这个文件缓存就是PageCache。它会进行适当的预读，比如用户当前只需要读取1kb的文件，但是它的算法觉得读取16k或者更多更合适，那么它就会读取16kb，加载到PageCache中，下次读取先去PageCache中查找。</p>
<p>但是以下三种情况没法使用PageCache：</p>
<ol>
<li><p>使用 FIleChannel 读写时，底层可能走 Direct IO，不走页缓存。</p>
</li>
<li><p>在内存有限或者不够用的时候，频繁换页，导致缓存命中率低。</p>
</li>
<li><p>大量随机读的场景，导致页缓存的数据无法命中。</p>
</li>
</ol>
<p>一种解决思路是：<strong>通过使用Direct IO 来模拟实现PageCahce的效果</strong>。原先PageCache的底层实现，是由操作系统实现的，比如说数据加载，缓存命中，换页，刷盘等，我们无法控制。我们可以通过自定义 Cache + Direct IO 来实现自己可控的操作。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230807102215994.png" alt="image-20230807102215994"></p>
<h1 id="FileChannel-和-mmap"><a href="#FileChannel-和-mmap" class="headerlink" title="FileChannel 和 mmap"></a>FileChannel 和 mmap</h1><p>Java 原生的 IO 主要可以分为普通 IO、FileChannel（文件通道）、mmap（内存映射）三种。</p>
<p>java.io 包中的 FileWriter 和 FileReader 属于普通 IO，java.nio 包中的 FileChannel 属于 NIO 的一种，mmap 是调用 FileChannel.map() 实例出来的一种特殊读写文件的方式，被称为内存映射。</p>
<h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h2><p><strong>FileChannel 大多数时候是和 ByteBuffer 打交道的</strong>，ByteBiffer是byte[]的一个封装类，ByteBuffer 是在应用内存中的，它和硬盘之间还隔着一层 PageCache。从使用上看，我们通过 filechannel.write 写入数据时，会将数据从应用内存写入到 PageCache，此时便认为完成了落盘操作。但实际上，操作系统最终帮我们将 PageCache 的数据自动刷到了硬盘。</p>
<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p>mmap 是一个把文件映射到内存的操作，因此可以像读写内存一样读写文件。它省去了用户空间到内核空间的数据复制过程，从而提高了读写性能。</p>
<p>从经验来看，mmap 在内存充足、数据文件较小且相对固定的场景下，性能比 FileChannel 高。<strong>但它有这样几个缺点：</strong></p>
<ol>
<li><p>使用时必须先指定好内存映射的大小，并且一次 Map 的大小限制在 1.5G 左右。</p>
</li>
<li><p>是由操作系统来刷盘的，手动刷盘时间不好掌握。</p>
</li>
<li><p>回收非常复杂，需要手动释放，并且代码和实现很复杂。</p>
</li>
</ol>
<p>在消息队列数据文件分段的场景下，因为每个段文件的大小是固定的，且大小还是可配置的，所以是可以使用 mmap 来提高性能的。</p>
<h1 id="直接内存（堆外）和堆内内存"><a href="#直接内存（堆外）和堆内内存" class="headerlink" title="直接内存（堆外）和堆内内存"></a>直接内存（堆外）和堆内内存</h1><p>堆内和堆外的堆是指 JVM 堆，堆内内存就是指 JVM 堆内部的内存空间，堆外就是指除了 JVM 堆以外的内存空间。堆内内存加上堆外内存等于总内存。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230807103548870.png" alt="image-20230807103548870" style="zoom:80%;" />

<p>如何选择堆外内存和堆内内存：</p>
<ol>
<li>当需要申请大块的内存时，堆内内存会受到限制，可以尝试分配堆外内存</li>
<li>堆外内存适用于生命周期中等或较长的对象</li>
<li>堆内内存刷盘的过程中，还需要复制一份到堆外内存，多了一步，会降低性能</li>
<li>创建堆外内存的消耗要大于创建堆内内存的消耗，所以当分配了堆外内存之后，要尽可能复用它</li>
<li>可以使用池化 + 堆外内存的组合方式，比如代码中如果需要频繁  new byte[]，就可以研究一下 ThreadLocal 和  ThreadLocal&lt;byte[]&gt; 的使用机制。</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka如何实现高性能I/O</title>
    <url>/2023/05/05/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BDI-O/</url>
    <content><![CDATA[<h1 id="使用批量消息提升服务端处理能力"><a href="#使用批量消息提升服务端处理能力" class="headerlink" title="使用批量消息提升服务端处理能力"></a>使用批量消息提升服务端处理能力</h1><p>Kafka提供了单词发送一条消息的send方法，但实际上，Kafka的客户端在实现消息发送时，采用了异步批量发送的机制。也就是说，当你调用send时，它并不会立即将消息发出去，而是放在缓存当中，到合适的时机把缓存中消息组成一批一次性发送给Broker。</p>
<p>而接收端，Kafka不会把一批消息还原成多条，而是每条消息都当作批消息来处理，在Broker整个处理流程中，这些被组合在一起的消息始终都是一个整体，不会被拆开。</p>
<h1 id="使用顺序读写提升磁盘-I-x2F-O性能"><a href="#使用顺序读写提升磁盘-I-x2F-O性能" class="headerlink" title="使用顺序读写提升磁盘 I&#x2F;O性能"></a>使用顺序读写提升磁盘 I&#x2F;O性能</h1><p>对于磁盘来说，它有一个特性，就是顺序读写的性能要远远好于随机读写。因为操作系统每次从磁盘读写数据的时候，需要先寻址，也就是先要找到数据在磁盘上的物理位置，然后再进行数据读写。所以随机读写会花费大量时间在寻址上，而顺序读写只需要找到第一个位置，接着往下写久可以了。</p>
<p>Kafka存储设计非常简单，对于每个分区，它把从Producer 收到的消息，顺序地写入对应的 log 文件中，一个文件写满了，就开启一个新的文件这样顺序写下去。消费的时候，也是从某个全局的位置开始，也就是某一个 log 文件中的某个位置开始，顺序地把消息读出来。</p>
<h1 id="利用PageCache-加速消息读写"><a href="#利用PageCache-加速消息读写" class="headerlink" title="利用PageCache 加速消息读写"></a>利用PageCache 加速消息读写</h1><p>PageCache 就是操作系统在内存中给磁盘上的文件建立的缓存。无论我们使用什么语言编写的程序，在调用系统的 API 读写文件的时候，并不会直接去读写磁盘上的文件，应用程序实际操作的都是 PageCache，也就是文件在内存中缓存的副本。</p>
<p>Kafka 在读写消息文件的时候，充分利用了 PageCache 的特性。一般来说，消息刚刚写入到服务端就会被消费，按照 LRU 的“优先清除最近最少使用的页”这种策略，读取的时候，对于这种刚刚写入的 PageCache，命中的几率会非常高。</p>
<h1 id="ZeroCopy：零拷贝技术"><a href="#ZeroCopy：零拷贝技术" class="headerlink" title="ZeroCopy：零拷贝技术"></a>ZeroCopy：零拷贝技术</h1><p>服务端处理消费的逻辑大致如下：</p>
<p>1、找到消息所在的文件，然后读入内存当中。</p>
<p>2、把消息通过网络发送给客户端。</p>
<p>这个过程中，数据实际上做了 2 次或者 3 次复制：</p>
<p>1、如果PageCache中没有，则需要将消息从文件复制到PageCache。</p>
<p>2、从PageCache读取到应用程序的内存空间中。</p>
<p>3、从应用程序复制到Socket的缓冲区。</p>
<p>而Kafka采用的是直接从PageCache复制到Socket中，这样可以省略一次复制。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《消息队列高手课》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Redis作为消息队列</title>
    <url>/2023/03/28/Redis/%E4%BD%BF%E7%94%A8Redis%E5%BD%93%E4%BD%9C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="消息队列的存取需求"><a href="#消息队列的存取需求" class="headerlink" title="消息队列的存取需求"></a>消息队列的存取需求</h2><p>在分布式系统中，当两个组件要基于消息队列进行通信，一个组件会把消息传递给消息队列，然后就去做其他的事情，另一个组件会从消息队列中读取数据，在进行处理。我们把发送消息的称为生产者，消费消息的称为消费者。</p>
<p>这样处理的好处是，如果生产者发送消息的速度很快，消费者来不及处理也没问题，可以将这些消息暂存在消息队列当中，然后消费者可以按照一定的处理速度去异步的处理这些消息，从而达到一个流量消峰的效果。</p>
<p><strong>不过，消息队列在存取消息时，必须要满足三个需求，分别是消息保序、处理重复的消息和保证消息可靠性。</strong></p>
<h2 id="消息队列对可靠性的要求"><a href="#消息队列对可靠性的要求" class="headerlink" title="消息队列对可靠性的要求"></a>消息队列对可靠性的要求</h2><h3 id="消息保序"><a href="#消息保序" class="headerlink" title="消息保序"></a>消息保序</h3><p>虽然消费者是异步处理这些消息的，但是需要按照消息的顺序进行消费。不然可能会出现错误。</p>
<p>假如现在有一个x&#x3D;3，第一个消息要把x * 2，然后第二个消息要把x + 3，如果消息正常执行，x的值最终为9，如果先执行了x + 3，那么x的值最终就会变为12。</p>
<h3 id="重复消息处理"><a href="#重复消息处理" class="headerlink" title="重复消息处理"></a>重复消息处理</h3><p>消费者从消息队列读取消息时，有时会因为网络堵塞而出现消息重传的情况。此时，消费者可能会收到多条重复的消息。对于重复的消息，消费者如果多次处理的话，就可能造成一个业务逻辑被多次执行，如果业务逻辑正好是要修改数据，那就会出现数据被多次修改的问题了。</p>
<h3 id="消息可靠性保证"><a href="#消息可靠性保证" class="headerlink" title="消息可靠性保证"></a>消息可靠性保证</h3><p>另外，消费者在处理消息的时候，还可能出现因为故障或宕机导致消息没有处理完成的情况。此时，消息队列需要能提供消息可靠性的保证，也就是说，当消费者重启后，可以重新读取消息再次进行处理，否则，就会出现消息漏处理的问题了。</p>
<h2 id="Redis消息队列的解决方案"><a href="#Redis消息队列的解决方案" class="headerlink" title="Redis消息队列的解决方案"></a>Redis消息队列的解决方案</h2><p>Redis 的 List 和 Streams 两种数据类型，就可以满足消息队列的这三个需求。</p>
<h3 id="基于-List-的消息队列解决方案"><a href="#基于-List-的消息队列解决方案" class="headerlink" title="基于 List 的消息队列解决方案"></a>基于 List 的消息队列解决方案</h3><p>具体来说，生产者可以使用 LPUSH 命令把要发送的消息依次写入 List，而消费者则可以使用 RPOP 命令，从 List 的另一端按照消息的写入顺序，依次读取消息并进行处理。</p>
<p>但是这里有一个性能问题，在生产者往 List 中写入数据时，List 并不会主动地通知消费者有新消息写入，如果消费者想要及时处理消息，就需要在程序中不停地调用 RPOP 命令（比如使用一个 while(1) 循环）。如果有新消息写入，RPOP 命令就会返回结果，否则，RPOP 命令返回空值，再继续循环。</p>
<p>所以，即使没有新消息写入 List，消费者也要不停地调用 RPOP 命令，这就会导致消费者程序的 CPU 一直消耗在执行 RPOP 命令上，带来不必要的性能损失。</p>
<p>Redis 提供了 BRPOP 命令。<strong>BRPOP 命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据</strong></p>
<p>我们在将消息插入list时，要生成一个全局唯一的id，用来作为消息是否处理的标志。</p>
<p>为了留存消息，List 类型提供了 BRPOPLPUSH 命令，这个命令的作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存。这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。</p>
<h3 id="基于-Streams-的消息队列解决方案"><a href="#基于-Streams-的消息队列解决方案" class="headerlink" title="基于 Streams 的消息队列解决方案"></a>基于 Streams 的消息队列解决方案</h3><p>Streams 是 Redis 专门为消息队列设计的数据类型，它提供了丰富的消息队列操作命令。</p>
<p>XADD：插入消息，保证有序，可以自动生成全局唯一 ID；</p>
<p>XREAD：用于读取消息，可以按 ID 读取数据；</p>
<p>XREADGROUP：按消费组形式读取消息；</p>
<p>XPENDING 和 XACK：XPENDING 命令可以用来查询每个消费组内所有消费者已读取但尚未确认的消息，而 XACK 命令用于向消息队列确认消息处理已完成。</p>
<p>list支持的操作，stream都支持，下面是stream特有的。</p>
<p>1、Streams 本身可以使用 XGROUP 创建消费组，创建消费组之后，Streams 可以使用 XREADGROUP 命令让消费组内的消费者读取消息，消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了。使用消费组的目的是让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的。</p>
<p>为了保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息，Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 XACK 命令通知 Streams“消息已经处理完成”。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Redis核心技术实战》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Redis实现分布式锁</title>
    <url>/2023/03/17/Redis/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h4 id="1、为什么要使用分布式锁"><a href="#1、为什么要使用分布式锁" class="headerlink" title="1、为什么要使用分布式锁"></a>1、为什么要使用分布式锁</h4><p>当Redis的客户端只有一个时，可以通过在客户端加锁来控制并发写操作对共享数据的修改，也可以使用原子操作。</p>
<p>但是一个Redis往往不仅连接一个客户端，当有多个客户端需要并发修改数据时，这把锁加在客户端已经不起作用了。假如有3个客户端，在客户端加锁可以保证该客户端所处理的请求在同一时间内只有一个可以修改Redis数据，但是3个客户端意味着有3把锁，会出现同一时间内有3个客户端可以修改Redis数据。</p>
<p>所以，在分布式系统中，当有多个客户端需要获取锁时，我们需要<strong>分布式锁</strong>。此时，锁是保存在一个<strong>共享存储系统中</strong>的，可以被多个客户端共享访问和获取。</p>
<h4 id="2、简单锁的设计"><a href="#2、简单锁的设计" class="headerlink" title="2、简单锁的设计"></a>2、简单锁的设计</h4><p>先看单机上的锁。</p>
<p>对锁进行简化，我们可以用一个变量来表示。变量值为0，表示没有线程获取锁，变量值为1，表示已经有线程获取到了锁。</p>
<p>平时所说的加锁，解锁，其实就是该线程去检查这个变量，如果是0，就可以获取该锁，然后把变量值改为1。如果变量值本身就是1，那么就返回获取锁失败。除此之外，我们还需要知道哪一个线程获取了锁，所以还需要一个id来标识。一个最简单的锁伪代码可以设计如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLock</span> &#123;</span><br><span class="line">    <span class="type">int</span> lock;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">acquireLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lock == <span class="number">0</span>) &#123;</span><br><span class="line">            lock = <span class="number">1</span>;</span><br><span class="line">            id = Thread.id;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">releaseLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lock == <span class="number">1</span> &amp;&amp; id = Thread.id) &#123;</span><br><span class="line">            lock = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、单Redis实例的分布式锁"><a href="#3、单Redis实例的分布式锁" class="headerlink" title="3、单Redis实例的分布式锁"></a>3、单Redis实例的分布式锁</h4><p>和单机的锁类似，分布式的锁可以用一个变量来表示。而且加锁和释放锁的逻辑也和上边类似，<strong>但是锁变量需要由一个共享存储系统来维护</strong>，只有这样，多个客户端才可以通过访问共享存储系统来访问锁变量。相应的，<strong>加锁和释放锁的操作就变成了读取、判断和设置共享存储系统中的锁变量值</strong>。</p>
<p>分布式锁的两个要求：</p>
<p>1、上述代码的逻辑需要原子的进行。例如，在判断完lock&#x3D;0进入修改lock的阶段，但是被中断，然后另一个线程此时也进入判断，lock此时还是0，就会导致两个线程都获取了锁。所以需要原子性。</p>
<p>2、共享存储系统需要保证可靠。如果不可靠，如果存储系统崩溃，会导致获取锁的客户端无法释放锁，而其他线程又一直等待锁。</p>
<p>使用Redis作为存储可以用下图表示：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230317095916845.png" alt="image-20230317095916845"></p>
<p>在上图中，客户端A和C同时请求加锁，但是Redis是使用单线程处理请求，所以即使客户端A和C同时把加锁请求发给Redis，Redis也会串行处理。首先是客户端A，他发现lock_key的value为0，说明没有客户端获取锁，所以他可以把value置为1。而客户端C来加锁时，会法师value为1，就返回加锁失败。</p>
<p>释放锁的过程，判断改锁是否是该线程加的，如果是，则可以将value设置为0，然后其他客户端就可以加锁。</p>
<p>但是加锁包含了三个操作，读取变量，判断value是否为0，以及设置value为1，我们需要保证这三个操作是原子进行的。在Redis中可以使用<strong>Redis 的单命令操作</strong>和使用 <strong>Lua 脚本</strong>。</p>
<p>Redis单命令：</p>
<p>首先是 SETNX 命令，它用于设置键值对的值。具体来说，就是这个命令在执行时会判断键值对是否存在，如果不存在，就设置键值对的值，如果存在，就不做任何设置。可以用该命令来加锁。</p>
<p>对于释放锁操作来说，我们可以在执行完业务逻辑后，使用 DEL 命令删除锁变量。</p>
<p>伪代码如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">// 加锁</span><br><span class="line">SETNX lock_key <span class="number">1</span></span><br><span class="line">// 业务逻辑</span><br><span class="line">DO THINGS</span><br><span class="line">// 释放锁</span><br><span class="line">DEL lock_key</span><br></pre></td></tr></table></figure>

<p>这样设计的两个风险：</p>
<p>1、假如某个客户端执行SETNX命令，加锁之后却在操作共享数据时发生了异常，没有执行DEL命令释放锁，导致其他客户端无法访问共享数据。针对这个问题，一个有效的解决办法是<strong>给锁变量设置一个过期时间</strong>。这样即使出了异常，也不会导致一直持有锁。</p>
<p>2、一个客户端加锁，却被另一个客户端释放了。这种情况的解决办法就是加id，用于表示该锁是哪一个客户端添加的，不是添加的客户端就无法释放锁。</p>
<p>如果使用Lua脚本，则只需要考虑逻辑即可。因为Lua脚本本身就具有原子性，伪代码如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">//释放锁 比较unique_value是否相等，避免误释放</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>其中，KEYS[1]表示 lock_key，ARGV[1]是当前客户端的唯一标识，这两个值都是我们在执行 Lua 脚本时作为参数传入的。</p>
<h4 id="4、基于多个-Redis-节点实现高可靠的分布式锁"><a href="#4、基于多个-Redis-节点实现高可靠的分布式锁" class="headerlink" title="4、基于多个 Redis 节点实现高可靠的分布式锁"></a>4、基于多个 Redis 节点实现高可靠的分布式锁</h4><p>为了避免Redis实例故障而导致锁无法工作，Redis开发者提出了分布式锁Redlock。</p>
<p>Redlock 算法的基本思路，是让客户端和多个独立的 Redis 实例<strong>依次请求加锁</strong>，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁了，否则加锁失败。这样一来，即使有单个 Redis 实例发生故障，因为锁变量在其它实例上也有保存，所以，客户端仍然可以正常地进行锁操作，锁变量并不会丢失。</p>
<p>具体执行步骤如下（假如有N个Redis实例）：</p>
<p><strong>1、获取客户端当前时间。</strong></p>
<p><strong>2、客户端按顺序依次向N个Redis实例执行加锁操作。</strong></p>
<p>这里的加锁操作和在单实例上执行的加锁操作一样，使用 SET 命令，带上 NX，EX&#x2F;PX 选项，以及带上客户端的唯一标识，并设置过期时间。</p>
<p>如果客户端在和一个 Redis 实例请求加锁时，一直到超时都没有成功，那么此时，客户端会和下一个 Redis 实例继续请求加锁。加锁操作的超时时间需要远远地小于锁的有效时间，一般也就是设置为几十毫秒。</p>
<p><strong>3、一旦客户端完成了和所有 Redis 实例的加锁操作，客户端就要计算整个加锁过程的总耗时。</strong></p>
<p>客户端只有在满足下面的这两个条件时，才能认为是加锁成功。</p>
<p>​	1）：客户端从超过半数（大于等于 N&#x2F;2+1）的 Redis 实例上成功获取到了锁；</p>
<p>​	2）：客户端获取锁的总耗时没有超过锁的有效时间。</p>
<p>在满足了这两个条件后，我们需要<strong>重新计算这把锁的有效时间</strong>，计算的结果是<strong>锁的最初有效时间减去客户端为获取锁的总耗时</strong>。如果锁的有效时间已经来不及完成共享数据的操作了，我们可以释放锁，以免出现还没完成数据操作，锁就过期了的情况。</p>
<p>在 Redlock 算法中，释放锁的操作和在单实例上释放锁的操作一样，只要执行释放锁的 Lua 脚本就可以了。</p>
<h4 id="5、Redis-分布式锁可靠性的问题"><a href="#5、Redis-分布式锁可靠性的问题" class="headerlink" title="5、Redis 分布式锁可靠性的问题"></a>5、Redis 分布式锁可靠性的问题</h4><p>使用单个 Redis 节点（只有一个master）使用分布锁，如果实例宕机，那么无法进行锁操作了。那么采用主从集群模式部署是否可以保证锁的可靠性？</p>
<p>答案是也很难保证。如果在 master 上加锁成功，此时 master 宕机，由于主从复制是异步的，加锁操作的命令还未同步到 slave，此时主从切换，新 master 节点依旧会丢失该锁，对业务来说相当于锁失效了。</p>
<h4 id="6、基于-Redis-使用分布锁的注意点"><a href="#6、基于-Redis-使用分布锁的注意点" class="headerlink" title="6、基于 Redis 使用分布锁的注意点"></a>6、基于 Redis 使用分布锁的注意点</h4><p>1、使用 SET $lock_key $unique_val EX $second NX 命令保证加锁原子性，并为锁设置过期时间 </p>
<p>2、锁的过期时间要提前评估好，要大于操作共享资源的时间</p>
<p>3、每个线程加锁时设置随机值，释放锁时判断是否和加锁设置的值一致，防止自己的锁被别人释放</p>
<p>4、释放锁时使用 Lua 脚本，保证操作的原子性</p>
<p>5、基于多个节点的 Redlock，加锁时超过半数节点操作成功，并且获取锁的耗时没有超过锁的有效时间才算加锁成功</p>
<p>6、Redlock 释放锁时，要对所有节点释放（即使某个节点加锁失败了），因为加锁时可能发生服务端加锁成功，由于网络问题，给客户端回复网络包失败的情况，所以需要把所有节点可能存的锁都释放掉</p>
<p>7、使用 Redlock 时要避免机器时钟发生跳跃，需要运维来保证，对运维有一定要求，否则可能会导致 Redlock 失效。例如共 3 个节点，线程 A 操作 2 个节点加锁成功，但其中 1 个节点机器时钟发生跳跃，锁提前过期，线程 B 正好在另外 2 个节点也加锁成功，此时 Redlock 相当于失效了（Redis 作者和分布式系统专家争论的重要点就在这）</p>
<p>8、如果为了效率，使用基于单个 Redis 节点的分布式锁即可，此方案缺点是允许锁偶尔失效，优点是简单效率高</p>
<p>9、如果是为了正确性，业务对于结果要求非常严格，建议使用 Redlock，但缺点是使用比较重，部署成本高</p>
<p>第6点参考文章：<a href="http://zhangtielei.com/posts/blog-redlock-reasoning.html">http://zhangtielei.com/posts/blog-redlock-reasoning.html</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Redis核心技术实战》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Redis</category>
        <category>集群</category>
      </categories>
      <tags>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ的设计</title>
    <url>/2023/07/24/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>下图是RabbitMQ的系统架构：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230724201809821.png" alt="image-20230724201809821"></p>
<p>RabbitMQ 由 Producer、Broker、Consumer 三个大模块组成。</p>
<p>生产者将数据发送到 Broker，Broker 接收到数据后，将数据存储到对应的 Queue 里面，消费者从不同的 Queue 消费数据。它有 Exchange、Bind、Route 这几个独有的概念。</p>
<p>Exchange 称为交换器，它是一个逻辑上的概念，用来做分发，本身不存储数据。流程上生产者先将消息发送到 Exchange，而不是发送到数据的实际存储单元 Queue 里面。然后 Exchange 会根据一定的规则将数据分发到实际的 Queue 里面存储。</p>
<p>这个分发过程就是 Route（路由），设置路由规则的过程就是 Bind（绑定）。即 Exchange 会接收客户端发送过来的 route_key，然后根据不同的路由规则，将数据发送到不同的 Queue 里面。</p>
<h1 id="协议和网络模块"><a href="#协议和网络模块" class="headerlink" title="协议和网络模块"></a>协议和网络模块</h1><p>在网络通信协议层面，RabbitMQ 数据流是基于四层 TCP 协议通信的，跑在 TCP 上的应用层协议是 AMQP。</p>
<p>RabbitMQ 的网络层有 Connectoion 和 Channel 两个概念需要注意。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230724202241340.png" alt="image-20230724202241340"></p>
<p>Connection 是指 TCP 连接，Channel 是 Connection 中的虚拟连接。两者的关系是：一个客户端和一个 Broker 之间只会建立一条 TCP 连接，就是指 Connection。Channel（虚拟连接）的概念在这个连接中定义，一个 Connection 中可以创建多个 Channel。</p>
<p><strong>客户端和服务端的实际通信都是在 Channel 维度通信的。</strong></p>
<p>RabbitMQ 服务端通过 tcp_listener 监听端口，tcp_acceptor 接收请求，rabbit_reader 处理和返回请求。本质上来看是也是一个多线程的网络模型。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230724202504119.png" alt="image-20230724202504119"></p>
<h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><p>RabbitMQ 的存储模块也包含元数据存储与消息数据存储两部分。RabbitMQ 的两类数据都是存储在 Broker 节点上的。</p>
<h2 id="元数据存储"><a href="#元数据存储" class="headerlink" title="元数据存储"></a>元数据存储</h2><p>RabbitMQ 的元数据都是存在于 Erlang 自带的分布式数据库 Mnesia 中的。即每台 Broker 都会起一个 Mnesia 进程，用来保存一份完整的元数据信息。Mnesia是一个分布式数据库，自带了多节点自动同步机制。</p>
<h2 id="消息数据存储"><a href="#消息数据存储" class="headerlink" title="消息数据存储"></a>消息数据存储</h2><p>RabbitMQ 消息数据的最小存储单元是 Queue，即消息数据是按顺序写入存储到 Queue 里面的。</p>
<p>在底层的数据存储方面，所有的 Queue 数据是存储在同一个“文件”里面的。这个“文件”是一个虚拟的概念，表示所有的 Queue 数据是存储在一起的意思。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230724202717072.png" alt="image-20230724202717072"></p>
<p>这个“文件”由队列索引（rabbit_queue_index）和消息存储（rabbitmq_msg_store）两部分组成。即在节点维度，所有 Queue 数据都是存储在 rabbit_msg_store 里面的，每个节点上只有一个 rabbit_msg_store，数据会依次顺序写入到 rabbit_msg_store 中。</p>
<p>rabbit_msg_store 是一个逻辑概念，底层的实际存储单元分为两个，msg_store_persistent 和 msg_store_transient，分别负责持久化消息和非持久化消息的存储。</p>
<p>这里所有的消息都会以追加的形式写入一个文件当中，当一个文件的大小超过了配置的最大大小，就会新开一个文件来存储。</p>
<p>队列索引负责存储、维护队列中落盘消息的信息，包括消息的存储位置、是否交付、是否 ACK 等等信息。队列索引是 Queue 维度的，每个 Queue 都有一个对应的队列索引。</p>
<p>删除消息时，不会立即删除数据，只是从 Erlang 中的 ETS 表删除指定消息的相关信息，同时更新消息对应的存储文件的相关信息。此时文件中的消息不会立即被删除，会被标记为已删除数据，直到一个文件中都是可以删除的数据时，再将这个文件删除，这个动作就是常说的延时删除。另外内核有检测机制，会检查前后两个文件中的数据是否可以合并，当符合合并规则时，会进行段文件的合并。</p>
<h1 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h1><p>当生产者和消费者连接到 Broker 进行生产消费的时候，是直接和 Broker 交互的，不需要客户端寻址。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230724203444673.png" alt="image-20230724203444673" style="zoom:80%;" />

<p>RabbitMQ 集群部署后，为了提高容灾能力，就需要在集群前面挂一层负载均衡来进行灾备。但是一个客户端拿到负载均衡ip的时候，去对应的Broker去消费数据，可能会出现该条消息并不存储于该Broker而导致消费失败。</p>
<p>为了解决这个问题，每个 Broker 上会设置有转发的功能。在实现上，每台 Broker 节点都会保存集群所有的元数据信息。当 Broker 收到请求后，根据本地缓存的元数据信息判断 Queue 是否在本机上，如果不在本机，就会将请求转发到 Queue 所在的目标节点。</p>
<p>生产端发送数据不是直接发送到 Queue，而是直接发送到 Exchange。即发送时需要指定 Exchange 和 route_key，服务端会根据这两个信息，将消息数据分发到具体的 Queue。</p>
<p>在消费端，RabbitMQ 支持 Push（推）和 Pull（拉）两种模式，如果使用了 Push 模式，Broker 会不断地推送消息给消费者（如果有消息的情况下）。推送消息的个数会受到 channel.basicQos 的限制，不能无限推送，在消费端会设置一个缓冲区来缓冲这些消息。</p>
<p>拉模式是指客户端不断地去服务端拉取消息，RabbitMQ 的拉模式只支持拉取单条消息。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入拆解消息队列 47 讲》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式队列编程优化</title>
    <url>/2023/07/06/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E5%88%86%E5%B8%83%E5%BC%8F%E9%98%9F%E5%88%97%E7%BC%96%E7%A8%8B%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="缓存优化（接收请求和处理之间）"><a href="#缓存优化（接收请求和处理之间）" class="headerlink" title="缓存优化（接收请求和处理之间）"></a>缓存优化（接收请求和处理之间）</h1><p>处于“处理－转发”模式下运行的生产者往往被设计成请求驱动型的服务，即每个请求都会触发一个处理线程，线程处理完后将结果写入分布式队列。但是如果队列不可用，那么生产者的处理线程就会产生堆积，则会导致以下两个问题：</p>
<ul>
<li>系统可用性降低。由于每个线程都需要一定的内存开销，线程过多会使系统内存耗尽，甚至可能产生雪崩效应导致最终完全不可用。</li>
<li>信息丢失。为了避免系统崩溃，一般会给请求驱动型服务设置一个处理线程池，设置最大处理线程数量。这是一种典型的降级策略，目的是为了防止系统崩溃。但是，后续的请求会因为没有处理线程而被迫阻塞，最终可能产生信息丢失。</li>
</ul>
<p>解决思路来自CAP理论，即通过降低<strong>一致性</strong>来保证<strong>可用性</strong>。具体如下：</p>
<p>生产者接收线程在收到请求之后第一时间不去处理，直接将请求缓存在内存中（牺牲一致性），而在后台启动多个处理线程从缓存中读取请求、进行处理并写入分布式队列。</p>
<p>与线程所占用的内存开销相比，大部分的请求所占内存几乎可以忽略。通过在接收请求和处理请求之间增加一层内存缓存，可以大大提高系统的处理吞吐量和可扩展性。这个方案本质上是一个内存生产者消费者模型。</p>
<h1 id="批量写入优化（处理请求和写入队列之间）"><a href="#批量写入优化（处理请求和写入队列之间）" class="headerlink" title="批量写入优化（处理请求和写入队列之间）"></a>批量写入优化（处理请求和写入队列之间）</h1><p>如果生产者请求过大，写入分布式队列则会成为瓶颈，有以下几点原因：</p>
<ul>
<li>队列自身性能不高；</li>
<li>分布式队列编程模型往往被应用在跨机房的系统里面，跨机房的网络开销往往容易成为系统瓶颈；</li>
<li>消息确认机制往往会大大降低队列的吞吐量以及响应时间。</li>
</ul>
<p>如果在<strong>处理请求和写队列之间</strong>添加一层缓存，消息写入程序批量将消息写入队列，可以大大提高系统的吞吐量。原因如下：</p>
<ul>
<li>批量写队列可以大大减少生产者和分布式队列的交互次数和消息传输量。特别是对于高吞吐小载荷的消息实体，批量写可以显著降低网络传输量；</li>
<li>对于需要确认机制的消息，确认机制往往会大大降低队列的吞吐量以及响应时间，某些高敏感的消息需要多个消息中间件代理同时确认，这近一步恶化性能。在生产者的应用层将多条消息批量组合成一个消息体，消息中间件就只需要对批量消息进行一次确认，这可能会数量级的提高消息传输性能。</li>
</ul>
<h1 id="持久化优化"><a href="#持久化优化" class="headerlink" title="持久化优化"></a>持久化优化</h1><p>添加缓存可以提高吞吐行，但是也会导致新的问题，内存数据丢失。对于敏感数据，要考虑以下问题：</p>
<ul>
<li>如果内存中存在未处理完的请求，而某些原因导致生产者服务宕机，内存数据就会丢失而可能无法恢复；</li>
<li>如果分布式队列长时间不可用，随着请求数量的不断增加，最终系统内存可能会耗尽而崩溃，内存的消息也可能丢失。</li>
</ul>
<p>所以缓存中的数据要定时持久化到磁盘中。主要有两种 ：</p>
<ul>
<li>定期触发，即每隔一段时间进行一次持久化；</li>
<li>定量触发，即每当缓存中的请求数量达到一定阈值后进行持久化。</li>
</ul>
<p>是否需要持久化优化，以及持久化策略应该由请求数据的敏感度、请求量、持久化性能等因素共同决定。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《美团博客》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>如何避免单线程的Redis阻塞</title>
    <url>/2023/03/26/Redis/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84Redis%E9%98%BB%E5%A1%9E/</url>
    <content><![CDATA[<h2 id="Redis有哪些阻塞点"><a href="#Redis有哪些阻塞点" class="headerlink" title="Redis有哪些阻塞点"></a>Redis有哪些阻塞点</h2><p><strong>客户端</strong>：网络 IO，键值对增删改查操作，数据库操作；</p>
<p><strong>磁盘</strong>：生成 RDB 快照，记录 AOF 日志，AOF 日志重写；</p>
<p><strong>主从节点</strong>：主库生成、传输 RDB 文件，从库接收 RDB 文件、清空数据库、加载 RDB 文件；</p>
<p><strong>切片集群实例</strong>：向其他实例传输哈希槽信息，数据迁移。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230304101219130.png" alt="image-20230304101219130"></p>
<h3 id="一、和客户端交互时的阻塞点"><a href="#一、和客户端交互时的阻塞点" class="headerlink" title="一、和客户端交互时的阻塞点"></a>一、和客户端交互时的阻塞点</h3><p>Redis采用多路复用I&#x2F;O机制，避免了主线程一直处在等待网络连接或请求到来的状态，所以与客户端的网路通信不会是阻塞点。</p>
<h4 id="1、查询时的阻塞"><a href="#1、查询时的阻塞" class="headerlink" title="1、查询时的阻塞"></a>1、查询时的阻塞</h4><p>而Reddis中涉及到集合的操作，复杂度通常为O(N)，例如集合元素全量查询操作 HGETALL、SMEMBERS，以及集合的聚合统计操作，例如求交、并和差集。这些操作可以作为 Redis 的<strong>第一个阻塞点：集合全量查询和聚合操作</strong>。</p>
<h4 id="2、删除时的阻塞"><a href="#2、删除时的阻塞" class="headerlink" title="2、删除时的阻塞"></a>2、删除时的阻塞</h4><p>删除操作的本质是要释放键值对占用的内存空间，释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，<strong>操作系统需要把释放掉的内存块插入一个空闲内存块的链表</strong>，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会阻塞当前释放内存的应用程序，所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞。</p>
<p>典型的操作，删出bigKey。</p>
<h4 id="3、清空数据库阻塞"><a href="#3、清空数据库阻塞" class="headerlink" title="3、清空数据库阻塞"></a>3、清空数据库阻塞</h4><p>在 Redis 的数据库级别操作中，清空数据库（例如 FLUSHDB 和 FLUSHALL 操作）必然也是一个潜在的阻塞风险，因为它涉及到删除和释放所有的键值对。</p>
<h3 id="二、和磁盘交互时的阻塞点"><a href="#二、和磁盘交互时的阻塞点" class="headerlink" title="二、和磁盘交互时的阻塞点"></a>二、和磁盘交互时的阻塞点</h3><p>虽然redis的设计已经考虑到磁盘IO会带来阻塞，设计时采用子进程方式生成RDB快照文件，以及执行AOF日志重写操作，这两个操作由子进程负责执行，慢速的磁盘 IO 就不会阻塞主线程了。</p>
<p>但是，Redis 直接记录 AOF 日志时，会根据不同的写回策略对数据做落盘保存。一个同步写磁盘的操作的耗时大约是 1～2ms，如果有大量的写操作需要记录在 AOF 日志中，并同步写回的话，就会阻塞主线程了。这就得到了 Redis 的<strong>第四个阻塞点了：AOF 日志同步写</strong>。</p>
<h3 id="三、主从节点交互时的阻塞点"><a href="#三、主从节点交互时的阻塞点" class="headerlink" title="三、主从节点交互时的阻塞点"></a>三、主从节点交互时的阻塞点</h3><p>在主从集群中，主库需要生成 RDB 文件，并传输给从库。主库在复制的过程中，创建和传输 RDB 文件都是由子进程来完成的，不会阻塞主线程。但是，对于从库来说，它在接收了 RDB 文件后，需要使用 FLUSHDB 命令清空当前数据库，这就正好撞上了刚才我们分析的<strong>第三个阻塞点。</strong></p>
<p>此外，从库在清空当前数据库后，还需要把 RDB 文件加载到内存，这个过程的快慢和 RDB 文件的大小密切相关，RDB 文件越大，加载过程越慢，所以，<strong>加载 RDB 文件就成为了 Redis 的第五个阻塞点</strong>。</p>
<h3 id="四、切片集群实例交互时的阻塞点"><a href="#四、切片集群实例交互时的阻塞点" class="headerlink" title="四、切片集群实例交互时的阻塞点"></a>四、切片集群实例交互时的阻塞点</h3><p>当我们部署 Redis 切片集群时，每个 Redis 实例上分配的哈希槽信息需要在不同实例间进行传递，同时，当需要进行负载均衡或者有实例增删时，数据会在不同的实例间进行迁移。不过，哈希槽的信息量不大，而数据迁移是渐进式执行的，所以，一般来说，这两类操作对 Redis 主线程的阻塞风险不大。</p>
<p>不过，如果使用了 Redis Cluster 方案，而且同时正好迁移的是 bigkey 的话，就会造成主线程的阻塞，因为 Redis Cluster 使用了同步迁移。</p>
<h2 id="上述哪些阻塞点可以异步执行？"><a href="#上述哪些阻塞点可以异步执行？" class="headerlink" title="上述哪些阻塞点可以异步执行？"></a>上述哪些阻塞点可以异步执行？</h2><p>首先，异步执行的要求：如果一个操作能被异步执行，就意味着，它并不是 Redis 主线程的关键路径上的操作。我再解释下关键路径上的操作是啥。这就是说，客户端把请求发送给 Redis 后，等着 Redis 返回数据结果的操作。</p>
<p>对于 Redis 来说，<strong>读操作是典型的关键路径操作</strong>，所以对于<strong>集合全量查询和聚合操作</strong>不能进行异步操作。</p>
<p>删除操作并不需要给客户端返回具体的数据结果，所以不算是关键路径操作。而上述bigKey删除以及清空数据库都属于删除操作，并不在关键路径上。因此，我们可以使用后台子线程来异步执行删除操作。</p>
<p>而对于AOF日志同步写来说，虽然需要保证落盘，这个操作需要实例等待，但是并不需要返回结果，所以可以用子进程来完成。</p>
<p>从库加载RDB这个操作，主库想要对客户端提供数据存取服务，就必须要RDB文件全部加载，所以这个操作也数据关键路径的操作，不能用子进程来完成。</p>
<h2 id="异步的子线程机制"><a href="#异步的子线程机制" class="headerlink" title="异步的子线程机制"></a>异步的子线程机制</h2><p>Redis 主线程启动后，会使用操作系统提供的 pthread_create 函数创建 3 个子线程，分别由它们负责 AOF 日志写操作、键值对删除以及文件关闭的异步执行。</p>
<p>主线程通过一个链表形式的任务队列和子线程进行交互。当收到键值对删除和清空数据库的操作时，主线程会把这个操作封装成一个任务，放入到任务队列中，然后给客户端返回一个完成信息，表明删除已经完成。</p>
<p>但实际上，这个时候删除还没有执行，等到后台子线程从任务队列中读取任务后，才开始实际删除键值对，并释放相应的内存空间。因此，我们把这种异步删除也称为惰性删除（lazy free）。此时，删除或清空操作不会阻塞主线程，这就避免了对主线程的性能影响。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230304111048551.png" alt="image-20230304111048551"></p>
<h2 id="有关lazy-free的一些细节"><a href="#有关lazy-free的一些细节" class="headerlink" title="有关lazy-free的一些细节"></a>有关lazy-free的一些细节</h2><p>1、lazy-free是4.0新增的功能，但是默认是关闭的，需要手动开启。</p>
<p>2、手动开启lazy-free时，有4个选项可以控制，分别对应不同场景下，要不要开启异步释放内存机制： </p>
<p>​	a) lazyfree-lazy-expire：key在过期删除时尝试<strong>异步释放内存</strong> </p>
<p>​	b) lazyfree-lazy-eviction：内存达到maxmemory并设置了淘汰策略时尝试异步释放内存 </p>
<p>​	c) lazyfree-lazy-server-del：执行RENAME&#x2F;MOVE等命令或需要覆盖一个key时，删除旧key尝试异步释放内存 </p>
<p>​	d) replica-lazy-flush：主从全量同步，从库清空数据库时异步释放内存 </p>
<p>3、即使开启了lazy-free，如果直接使用DEL命令还是会同步删除key，只有使用UNLINK命令才会可能异步删除key。 </p>
<p>4、这也是最关键的一点，上面提到开启lazy-free的场景，除了replica-lazy-flush之外，其他情况都只是<strong>可能</strong>去异步释放key的内存，并不是每次必定异步释放内存的。 </p>
<p>开启lazy-free后，Redis在释放一个key的内存时，首先会评估代价，如果释放内存的代价很小，那么就直接在主线程中操作了，没必要放到异步线程中执行（不同线程传递数据也会有性能消耗）。 </p>
<h3 id="什么情况才会真正异步释放内存？"><a href="#什么情况才会真正异步释放内存？" class="headerlink" title="什么情况才会真正异步释放内存？"></a>什么情况才会真正异步释放内存？</h3><p>这和key的类型、编码方式、元素数量都有关系（详细可参考源码中的lazyfreeGetFreeEffort函数）： </p>
<p>a) 当Hash&#x2F;Set底层采用哈希表存储（非ziplist&#x2F;int编码存储）时，并且元素数量超过64个 </p>
<p>b) 当ZSet底层采用跳表存储（非ziplist编码存储）时，并且元素数量超过64个 </p>
<p>c) 当List链表节点数量超过64个（注意，不是元素数量，而是链表节点的数量，List的实现是在每个节点包含了若干个元素的数据，这些元素采用ziplist存储） </p>
<p>只有以上这些情况，在删除key释放内存时，才会真正放到异步线程中执行，其他情况一律还是在主线程操作。 </p>
<p>也就是说String（不管内存占用多大）、List（少量元素）、Set（int编码存储）、Hash&#x2F;ZSet（ziplist编码存储）这些情况下的key在释放内存时，依旧在主线程中操作。 可见，即使开启了lazy-free，String类型的bigkey，在删除时依旧有阻塞主线程的风险。</p>
<p>所以，即便Redis提供了lazy-free，尽量不要在Redis中存储bigkey。 个人理解Redis在设计评估释放内存的代价时，不是看key的内存占用有多少，而是关注释放内存时的工作量有多大。从上面分析基本能看出，如果需要释放的内存是连续的，Redis作者认为释放内存的代价比较低，就放在主线程做。如果释放的内存不连续（大量指针类型的数据），这个代价就比较高，所以才会放在异步线程中去执行。</p>
<p><strong>Redis 6.0又提供一个选项：lazyfree-lazy-user-del。打开这个选项后，使用DEL和UNLINK就没有区别了。</strong></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>主流消息队列的网络模型</title>
    <url>/2023/07/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E4%B8%BB%E6%B5%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Kafka-网络模型"><a href="#Kafka-网络模型" class="headerlink" title="Kafka 网络模型"></a>Kafka 网络模型</h1><p>Kafka 的网络层没有用 Netty 作为底层的通信库，而是直接采用 Java NIO 实现网络通信。在网络模型中，也是参照 Reactor 多线程模型，采用多线程、多 Selector 的设计。</p>
<p>Processor 线程和 Handler 线程之间通过 RequestChannel 传递数据，RequestChannel 中包含一个 RequestQueue 队列和多个 ResponseQueues 队列。每个 Processor 线程对应一个 ResponseQueue。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717213627999.png" alt="image-20230717213627999"></p>
<p>具体流程上：</p>
<ul>
<li><p>一个 Acceptor 接收客户端建立连接的请求，创建 Socket 连接并分配给 Processor 处理。</p>
</li>
<li><p>Processor 线程把读取到的请求存入 RequestQueue 中，Handler 线程从 RequestQueue 队列中取出请求进行处理。</p>
</li>
<li><p>Handler 线程处理请求产生的响应，会存放到 Processor 对应的 ResponseQueue 中，Processor 线程从其对应的 ResponseQueue 中取出响应信息，并返回给客户端。</p>
</li>
</ul>
<h1 id="RocketMQ-网络模型"><a href="#RocketMQ-网络模型" class="headerlink" title="RocketMQ 网络模型"></a>RocketMQ 网络模型</h1><p>RocketMQ 采用 Netty 组件作为底层通信库，遵循 Reactor 多线程模型，同时又在 Reactor 模型上做了一些扩展和优化。</p>
<p>所以它的网络模型是 Netty 的网络模型，Netty 底层采用的是主从 Reactor 多线程模型，模型的原理逻辑跟前面讲到的主从 Reactor 多线程模型是一样的。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717213829623.png" alt="image-20230717213829623"></p>
<p>具体流程上：</p>
<ul>
<li><p>一个 Reactor 主线程负责监听 TCP 网络连接请求，建立好连接，创建 SocketChannel，并注册到 Selector 上。RocketMQ 的源码中会自动根据 OS 的类型选择 NIO 和 Epoll，也可以通过参数配置，监听真正的网络数据。</p>
</li>
<li><p>接收到网络数据后，会把数据传递给 Reactor 线程池处理。</p>
</li>
<li><p>真正执行业务逻辑之前，会进行 SSL 验证、编解码、空闲检查、网络连接管理，这些工作在 Worker 线程池处理（defaultEventExecutorGroup）。</p>
</li>
<li><p>处理业务操作，放在业务 Processor 线程池中执行。</p>
</li>
</ul>
<h1 id="NIO-编程和-RPC-框架"><a href="#NIO-编程和-RPC-框架" class="headerlink" title="NIO 编程和 RPC 框架"></a>NIO 编程和 RPC 框架</h1><p>因为 RPC 调用的是一个远端对象，调用者和被调用者处于不同的节点上，想完成调用，必须实现 4 个能力。</p>
<ul>
<li><p><strong>网络传输协议</strong>：远端调用底层需要经过网络传输，所以需要选择网络通信协议，比如 TCP。</p>
</li>
<li><p><strong>应用通信协议</strong>：网络传输需要设计好应用层的通信协议，比如 HTTP2 或自定义协议。</p>
</li>
<li><p><strong>服务发现</strong>：调用的是远端对象，需要可以定位到调用的服务器地址以及调用的具体方法。</p>
</li>
<li><p><strong>序列化和反序列化：</strong>网络传输的是二进制数据，因此 RPC 框架需要自带序列化和反序列化的能力。</p>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入拆解消息队列 47 讲》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>如何保证消息仅被消费一次</title>
    <url>/2023/05/05/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%BB%85%E8%A2%AB%E6%B6%88%E8%B4%B9%E4%B8%80%E6%AC%A1/</url>
    <content><![CDATA[<p>首先，如果要确保每个消息只被消费一次，那么就要确保每一个消息都正常到达了消费端，即不能出现消息丢失。</p>
<p>以下三个地方会造成消息丢失：</p>
<p>1、消息从生产者写入到消息队列的过程；</p>
<p>2、消息在消息队列中的存储场景；</p>
<p>3、消息被消费者消费的过程。</p>
<h1 id="1、在消息生产的过程中丢失消息"><a href="#1、在消息生产的过程中丢失消息" class="headerlink" title="1、在消息生产的过程中丢失消息"></a>1、在消息生产的过程中丢失消息</h1><p>生产者一般是独立部署的应用程序，而消息队列一般也是独立部署。那么生产者的消息发往消息队列需要通过网络，这就有可能丢失。这里的一个比较好的解决办法就是重试，即重新发送消息。</p>
<p>但是重试则会导致消息重复，比如第一条消息因为在网络中拥堵，导致超过时延，生产设判断消息丢失，重新发送消息。但是过段时间重新发送的消息和之前的消息都到达了消息队列，那么这条消息就重复了。</p>
<h1 id="2、在消息队列中丢失消息"><a href="#2、在消息队列中丢失消息" class="headerlink" title="2、在消息队列中丢失消息"></a>2、在消息队列中丢失消息</h1><p>拿Kafka来说，消息一般是存储在本地磁盘，而为了减少刷盘次数，消息会先写入Page Cache（操作系统提供的缓存）中，然后找合适时间刷盘。</p>
<p>这样设计，好处在于减少I&#x2F;O，但是如果在未刷盘时，服务器掉电，就会导致在Page Cache中的数据丢失。</p>
<p>这里的解决办法有，调整刷盘时机，即过一段时间，或者一定量消息强行刷盘，但是会影响性能。另一种方法，部署Kafka集群，通过多个数据备份，防止丢数据。</p>
<h1 id="3、在消费的过程中存在消息丢失的可能"><a href="#3、在消费的过程中存在消息丢失的可能" class="headerlink" title="3、在消费的过程中存在消息丢失的可能"></a>3、在消费的过程中存在消息丢失的可能</h1><p>在这里，消费端接收消息有可能失败，而正确接受完消息后，在处理的过程中也可能失败。所以这里需要注意，消费端一定要等到处理消息的逻辑执行完后，再给消息队列返回。</p>
<h1 id="如何保证消息只被消费一次"><a href="#如何保证消息只被消费一次" class="headerlink" title="如何保证消息只被消费一次"></a>如何保证消息只被消费一次</h1><h2 id="1、保证幂等性"><a href="#1、保证幂等性" class="headerlink" title="1、保证幂等性"></a>1、保证幂等性</h2><p>幂等性指的是不论执行多少次，最终的结果都是一致的。</p>
<p>比如说下面语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update table set a = 1 where id = 2;</span><br></pre></td></tr></table></figure>

<p>这条语句不论执行多少次，结果都不会变（不考虑其他语句穿插），也就是说不论执行多少次，都不会影响最终结果的正确性。</p>
<p>这样就保证了消息重复时，虽然被执行了多次，但是不影响最终结果的正确性。</p>
<h2 id="2、在生产、消费过程中增加消息幂等性的保证"><a href="#2、在生产、消费过程中增加消息幂等性的保证" class="headerlink" title="2、在生产、消费过程中增加消息幂等性的保证"></a>2、在生产、消费过程中增加消息幂等性的保证</h2><p>生产者这边，可以通过给每一个消息增加一个全局唯一的id，这样消息队列接收到重复的id时，就知道消息是重复的，丢弃即可。</p>
<p>在消费端，可以通过给每一个消息一个全局id，如果消费完该消息，就将id存储起来，每次消费前查看是否已经消费该id，以此来确保每条消息只被消费一次。</p>
<p>另外一种做法就是通过增加一个类似于乐观锁的版本号，每次消费时，就把版本号增加。这样的话，第二次消费该消息时，就会发现版本号对不上，就会放弃消费该消息。</p>
<p>类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update table set a = 1 , controler_version = controler_version + 1 where control_version = 1</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《消息队列高手课》</p>
<p>《高并发系统设计40问》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>如何处理消息积压</title>
    <url>/2023/05/03/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E7%A7%AF%E5%8E%8B/</url>
    <content><![CDATA[<h1 id="优化性能来避免消息积压"><a href="#优化性能来避免消息积压" class="headerlink" title="优化性能来避免消息积压"></a>优化性能来避免消息积压</h1><p>在使用消息队列时，我们主要考虑消息的发送方和接收方这两部分的处理，而不需要关注消息队列的处理能力，因为业务逻辑往往复杂于消息队列的处理，而且这两者并不是一个量级。</p>
<p>所以，对于消息队列的性能优化，我们更关注的是，<strong>在消息的收发两端，我们的业务代码怎么和消息队列配合，达到一个最佳的性能</strong>。</p>
<h2 id="1-发送端性能优化"><a href="#1-发送端性能优化" class="headerlink" title="1. 发送端性能优化"></a><strong>1.</strong> 发送端性能优化</h2><p>发送端可能存在发送速率没有设置好，从而导致消息处理太慢。这里的一个解决办法就是并发的进行消息发送，或者说批量的进行发送，都可以提高发送端的性能。</p>
<h2 id="2-消费端性能优化"><a href="#2-消费端性能优化" class="headerlink" title="2. 消费端性能优化"></a>2. 消费端性能优化</h2><p>当消费端的处理能力长时间低于发送端的发送能力时，就会导致消息积压。会导致两种结果，消息队列填满，无法对外服务，或者消息丢失，这都是比较严重的事故。</p>
<p>消费端的优化，除了优化业务逻辑外，还可以水平扩容，增加消费端的并发数来提升总体的消费性能。特别需要注意的一点是，<strong>在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的。</strong>如果 Consumer 的实例数量超过分区数量，这样的扩容实际上是没有效果的。因为对于消费者来说，在每个分区上实际上只能支持单线程消费。</p>
<h1 id="消息积压了该如何处理"><a href="#消息积压了该如何处理" class="headerlink" title="消息积压了该如何处理"></a>消息积压了该如何处理</h1><p>这里需要注意一种情况，如果通过监控系统发现消息的发送方和处理方的速度都没什么变化，但还是出现了消息积压，就要考虑是否是一个消息处理失败，被反复执行，导致后续的消息无法处理。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《消息队列高手课》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>如何实现高性能延时消息</title>
    <url>/2023/09/06/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF/</url>
    <content><![CDATA[<h1 id="延时消息使用场景"><a href="#延时消息使用场景" class="headerlink" title="延时消息使用场景"></a>延时消息使用场景</h1><p>需要某些事件在特定的时间点上触发时，就需要用到延时消息。</p>
<h1 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h1><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230906104126430.png" alt="image-20230906104126430"></p>
<p>延时消息可以通过定时扫描来实现，但是资源浪费太多。</p>
<p>如果使用消息队列，可以理解为生产者生产一条消息，但是并不会被消费者看到，当到达固定的时间点后，消费者才能够看到并且消费消息。所以从技术上来看，消息队列实现延时消息主要包含<strong>数据存储、如何让消息可见、定时机制、主动推送</strong>四个部分。</p>
<p>以下主要介绍<strong>消息可见</strong>和<strong>定时机制</strong>。</p>
<h2 id="如何让消息可见"><a href="#如何让消息可见" class="headerlink" title="如何让消息可见"></a>如何让消息可见</h2><p>让消息从不可见变为可见的思路：先将数据写入到临时存储，然后根据一定机制在数据到期后让消费端可以看到该消息。</p>
<p>临时存储大多有以下三种选择：</p>
<ol>
<li><p>单独设计的数据结构</p>
</li>
<li><p>独立的 Topic</p>
</li>
<li><p>本地的某个存储引擎（如 RocksDB、Mnesia 等）</p>
</li>
</ol>
<p>延时到期后，消费者如何得知该消息可以消费，有以下两种实现：</p>
<ol>
<li>定时检测写入</li>
<li>消费时判断是否可见</li>
</ol>
<p>定时检测写入：指的是先将消息写入某个地方，同时有独立的线程去判断数据是否到期，如果到期则将数据写入真正的存储当中。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230906104734666.png" alt="image-20230906104734666"></p>
<p>消费时判断数据是否可见：是指每次消费时判断是否有到期的延时消息，如果有则从第三方存储中拉取，供消费者消费。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230906104931264.png" alt="image-20230906104931264"></p>
<p>实际上，大多采用第一种方案。因为每次消费时都去判断一下是否有消息可见，则会对性能造成一定的影响。</p>
<h2 id="定时机制的实现"><a href="#定时机制的实现" class="headerlink" title="定时机制的实现"></a>定时机制的实现</h2><p>定时机制的核心：随着时间的推移，拿出到期的延时消息进行处理。从技术上看，定时机制可以拆解为<strong>定时器</strong>和<strong>延时消息定位处理</strong>两部分。</p>
<p>定时器就是按照时间推进，说白了就是记录一下时间。</p>
<p>延时消息定位是指随着定时器的推进，在每个时间刻度可以高效定位，获取到该时刻需要处理的延时消息。</p>
<h1 id="延时消息的技术方案"><a href="#延时消息的技术方案" class="headerlink" title="延时消息的技术方案"></a>延时消息的技术方案</h1><p>延时消息的实现主要有基于轮询检测机制的实现和基于时间轮机制的实现两种方案。</p>
<h2 id="基于轮询检测机制的实现"><a href="#基于轮询检测机制的实现" class="headerlink" title="基于轮询检测机制的实现"></a>基于轮询检测机制的实现</h2><p>核心思路：将消息写入到独立的存储当中，利用类似于while + sleep的定时器，来推进时间，通过独立线程检测数据是否到期，然后取出到期数据，存入正式存储。</p>
<p>我们可以将独立存储根据时间划分，大致结构如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230906110914110.png" alt="image-20230906110914110"></p>
<p>这样可以减小每个队列的长度。而每个队列采用什么结构，则可以根据实际的应用场景决定。</p>
<h2 id="基于时间轮机制的实现"><a href="#基于时间轮机制的实现" class="headerlink" title="基于时间轮机制的实现"></a>基于时间轮机制的实现</h2><p>核心思路：将延时消息写入到独立的存储中，然后通过构建多级时间轮，在每个时间刻度上挂载需要处理的延时消息的索引列表。再依赖时间轮的推进，获取到需要处理的延时消息列表，进行后续的处理。</p>
<p>时间轮是一个很成熟的算法，分为<strong>单级时间轮</strong>和<strong>多级时间轮</strong>，具体结构如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230906111154935.png" alt="image-20230906111154935"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入拆解消息队列 47 讲》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>如何利用事务消息实现分布式事务</title>
    <url>/2023/05/01/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="什么是分布式事务？"><a href="#什么是分布式事务？" class="headerlink" title="什么是分布式事务？"></a>什么是分布式事务？</h1><p>首先事务是要保证我们对一系列数据进行一些操作，这些操作要么都成功，要么都失败。一个严格意义的事务实现，应该具有 4 个属性：原子性、一致性、隔离性、持久性。</p>
<p>但是，对于分布式系统来说，严格的实现 ACID 这四个特性几乎是不可能的。一般会采用一些“妥协”的方案，比如说顺序一致性或者最终一致性。</p>
<h1 id="消息队列是如何实现分布式事务的？"><a href="#消息队列是如何实现分布式事务的？" class="headerlink" title="消息队列是如何实现分布式事务的？"></a>消息队列是如何实现分布式事务的？</h1><p>一个订单和购物车的模型如下图：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230501183227849.png" alt="image-20230501183227849"></p>
<p>这里的半消息，并不是只发送数据信息的一半，而是说发送全部的数据，但是在事务提交之前，消费者是无法看到这条数据的。</p>
<p>这里，发送半消息后，就可以继续执行创建订单，如果订单创建成功，则提交事务，那么消费者，也就是购物车模块可以看到这条消息，然后从购物车删除对应订单的物品。如果订单创建失败，则消费者无法看到消息，也就不会导致创建订单失败，但是购物车删除物品这种情况。</p>
<p>但是还存在一个问题：如果提交事务消息失败时，还是会存在一定的问题，针对这个问题，Kafka 和 RocketMQ给出了不同的解决办法。Kafka 的解决方案比较简单粗暴，直接抛出异常，让用户自行处理。我们可以在业务代码中反复重试提交，直到提交成功，或者删除之前创建的订单进行补偿。RocketMQ 则给出了另外一种解决方案。</p>
<h1 id="RocketMQ-中的分布式事务实现"><a href="#RocketMQ-中的分布式事务实现" class="headerlink" title="RocketMQ 中的分布式事务实现"></a>RocketMQ 中的分布式事务实现</h1><p>在 RocketMQ 中的事务实现中，增加了事务反查的机制来解决事务消息提交失败的问题。如果 Producer 也就是订单系统，在提交或者回滚事务消息时发生网络异常，RocketMQ 的 Broker 没有收到提交或者回滚的请求，Broker 会定期去 Producer 上反查这个事务对应的本地事务的状态，然后根据反查结果决定提交或者回滚这个事务。</p>
<p>为了支撑这个事务反查机制，我们的业务代码需要实现一个反查本地事务状态的接口，告知 RocketMQ 本地事务是成功还是失败。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230501184354506.png" alt="image-20230501184354506" style="zoom:67%;" />

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《消息队列高手课》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>并发场景下的幂等问题--分布式锁详解</title>
    <url>/2023/07/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%B9%82%E7%AD%89%E9%97%AE%E9%A2%98-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>业务流程：</p>
<p>1）用户选择实人认证后会在服务端初始化一条记录；<br>2）用户在钉钉移动端按照指示完成人脸比对；<br>3）比对完成后访问服务端修改数据库状态。</p>
<p>问题现象：数据库一个人有两条认证记录。</p>
<p>原因：并发导致了不幂等。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/640" alt="图片"></p>
<p>如果依赖的组件天然幂等，比如说数据库唯一键的约束，那么不需要做太多的处理，否则，可以采用以下方法来保证幂等。</p>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>如何实现一个分布式锁？</p>
<h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>分布式系统中常见有两个问题：</p>
<p>1）单点故障问题，即当持有锁的应用发生单点故障时，锁将被长期无效占有；</p>
<p>2）网络超时问题，即当客户端发生网络超时但实际上锁成功时，我们无法再次正确的获取锁。</p>
<p>要解决问题1，一个简单的方案是引入过期时间（lease time），对锁的持有将是有时效的，当应用发生单点故障时，被其持有的锁可以自动释放。</p>
<p>要解决问题2，一个简单的方案是支持可重入，我们为每个获取锁的客户端都配置一个不会重复的身份标识（通常是UUID），上锁成功后锁将带有该客户端的身份标识。当实际上锁成功而客户端超时重试时，我们可以判断锁已被该客户端持有而返回成功。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MdbDistributeLock</span> <span class="keyword">implements</span> <span class="title class_">DistributeLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的命名空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> namespace;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁对应的缓存key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lockName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的唯一标识，保证可重入，以应对put成功，但是返回超时的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lockId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否持有锁。true：是</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> locked;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TairManager tairManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MdbDistributeLock</span><span class="params">(TairManager tairManager, <span class="type">int</span> namespace, String lockCacheKey)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.tairManager = tairManager;</span><br><span class="line">        <span class="built_in">this</span>.namespace = namespace;</span><br><span class="line">        <span class="built_in">this</span>.lockName = lockCacheKey;</span><br><span class="line">        <span class="built_in">this</span>.lockId = UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取锁状态</span></span><br><span class="line">            Result&lt;DataEntry&gt; getResult = <span class="literal">null</span>;</span><br><span class="line">            <span class="type">ResultCode</span> <span class="variable">getResultCode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>; cnt &lt; DEFAULT_RETRY_TIMES; cnt++) &#123;</span><br><span class="line">                getResult = tairManager.get(namespace, lockName);</span><br><span class="line">                getResultCode = getResult == <span class="literal">null</span> ? <span class="literal">null</span> : getResult.getRc();</span><br><span class="line">                <span class="keyword">if</span> (noNeedRetry(getResultCode)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重入，已持有锁，返回成功</span></span><br><span class="line">            <span class="keyword">if</span> (ResultCode.SUCCESS.equals(getResultCode)</span><br><span class="line">                &amp;&amp; getResult.getValue() != <span class="literal">null</span> &amp;&amp; lockId.equals(getResult.getValue().getValue())) &#123;</span><br><span class="line">                locked = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不可获取锁，返回失败</span></span><br><span class="line">            <span class="keyword">if</span> (!ResultCode.DATANOTEXSITS.equals(getResultCode)) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;tryLock fail code=&#123;&#125; lock=&#123;&#125; traceId=&#123;&#125;&quot;</span>, getResultCode, <span class="built_in">this</span>, EagleEye.getTraceId());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//尝试获取锁</span></span><br><span class="line">            <span class="type">ResultCode</span> <span class="variable">putResultCode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>; cnt &lt; DEFAULT_RETRY_TIMES; cnt++) &#123;</span><br><span class="line">                putResultCode = tairManager.put(namespace, lockName, lockId, MDB_CACHE_VERSION,</span><br><span class="line">                    DEFAULT_EXPIRE_TIME_SEC);</span><br><span class="line">                <span class="keyword">if</span> (noNeedRetry(putResultCode)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!ResultCode.SUCCESS.equals(putResultCode)) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;tryLock fail code=&#123;&#125; lock=&#123;&#125; traceId=&#123;&#125;&quot;</span>, getResultCode, <span class="built_in">this</span>, EagleEye.getTraceId());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            locked = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;DistributedLock.tryLock fail lock=&#123;&#125;&quot;</span>, <span class="built_in">this</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!locked) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ResultCode</span> <span class="variable">resultCode</span> <span class="operator">=</span> tairManager.invalid(namespace, lockName);</span><br><span class="line">        <span class="keyword">if</span> (!resultCode.isSuccess()) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;DistributedLock.unlock fail lock=&#123;&#125; resultCode=&#123;&#125; traceId=&#123;&#125;&quot;</span>, <span class="built_in">this</span>, resultCode,</span><br><span class="line">                EagleEye.getTraceId());</span><br><span class="line">        &#125;</span><br><span class="line">        locked = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否需要重试</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultCode 缓存的返回码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true：不用重试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">noNeedRetry</span><span class="params">(ResultCode resultCode)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> resultCode != <span class="literal">null</span> &amp;&amp; !ResultCode.CONNERROR.equals(resultCode) &amp;&amp; !ResultCode.TIMEOUT.equals(</span><br><span class="line">            resultCode) &amp;&amp; !ResultCode.UNKNOW.equals(resultCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分布式锁工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MdbDistributeLockFactory</span> <span class="keyword">implements</span> <span class="title class_">DistributeLockFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存的命名空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> namespace;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> MultiClusterTairManager mtairManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DistributeLock <span class="title function_">getLock</span><span class="params">(String lockName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MdbDistributeLock</span>(mtairManager, namespace, lockName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分布式锁的一般使用方式如下：</p>
<ul>
<li>初始化分布式锁的工厂</li>
<li>利用工厂生成一个分布式锁实例</li>
<li>使用该分布式实例上锁和解锁操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTryLock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化工厂</span></span><br><span class="line">    <span class="type">MdbDistributeLockFactory</span> <span class="variable">mdbDistributeLockFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MdbDistributeLockFactory</span>();</span><br><span class="line">    mdbDistributeLockFactory.setNamespace(<span class="number">603</span>);</span><br><span class="line">    mdbDistributeLockFactory.setMtairManager(<span class="keyword">new</span> <span class="title class_">MultiClusterTairManager</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得锁</span></span><br><span class="line">    <span class="type">DistributeLock</span> <span class="variable">lock</span> <span class="operator">=</span> mdbDistributeLockFactory.getLock(<span class="string">&quot;TestLock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上锁解锁操作</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="keyword">if</span> (!locked) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do something </span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样实现简单，但是也存在问题：释放锁的时候只是简单的将缓存中的key失效，所以存在错误释放他人已持有锁问题。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKg8iaeq9DENh4Ow1NmjvfqmapX7ERkKOhIS0Rz8ibzwVWxH4j8tJ7gGkytBrhvEW3Vns3hPfviboWwg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>设想一种情况，当占有锁的Client 1在释放锁之前，锁就已经到期了，Client 2将获取锁，此时锁被Client 2持有，但是Client 1可能会错误的将其释放。只要锁的租期设置的足够长，该问题出现几率就足够小。</p>
<p>一个更优秀的方案，我们给每个锁都设置一个身份标识，在释放锁的时候，1）首先查询锁是否是自己的，2）如果是自己的则释放锁。</p>
<p>受限于实现方式，步骤1和步骤2不是原子操作，在步骤1和步骤2之间，如果锁到期被其他客户端获取，此时也会错误的释放他人的锁。</p>
<h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>借助Redis的Lua脚本，可以完美的解决存在错误释放他人已持有锁问题的。</p>
<p>当我们想要获取锁时，我们可以执行如下方法：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">SET resource_name my_random_value NX PX <span class="number">30000</span></span><br></pre></td></tr></table></figure>

<p>当我们想要释放锁时，我们可以执行如下的Lua脚本</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h2><p>在方案一和方案二的讨论过程中，有一个问题被我们反复提及：锁的自动释放。</p>
<p>他的好处以及坏处如下：</p>
<p>1）一方面它很好的解决了持有锁的客户端单点故障的问题</p>
<p>2）另一方面，如果锁提前释放，就会出现锁的错误持有状态</p>
<p>这个时候，我们可以引入Watch Dog自动续租机制，参考以下Redisson是如何实现的。</p>
<p>在上锁成功后，Redisson会调用renewExpiration()方法开启一个Watch Dog线程，为锁自动续期。每过1&#x2F;3时间续一次，成功则继续下一次续期，失败取消续期操作。</p>
<p>以下是Redisson的续期操作，Redisson也是使用Lua脚本进行锁续租的：1）判断锁是否存在；2）如果存在则重置过期时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager().newTimeout(timeout -&gt; &#123;</span><br><span class="line">        <span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">        <span class="keyword">if</span> (ent == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">        <span class="keyword">if</span> (threadId == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">        future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getRawName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                EXPIRATION_RENEWAL_MAP.remove(getEntryName());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                <span class="comment">// reschedule itself</span></span><br><span class="line">                renewExpiration();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cancelExpirationRenewal(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title function_">renewExpirationAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">                          <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;return 0;&quot;</span>,</span><br><span class="line">                          Collections.singletonList(getRawName()),</span><br><span class="line">                          internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h2><p>借助Redisson的自动续期机制，我们无需再担心锁的自动释放。但是讨论到这里，我还是不得不面对一个问题：分布式锁本身不是一个分布式应用。当Redis服务器故障无法正常工作时，整个分布式锁也就无法提供服务。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《阿里博客》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实践之公平有界阻塞队列实现（下）</title>
    <url>/2023/07/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%85%AC%E5%B9%B3%E6%9C%89%E7%95%8C%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="4、状态追踪解除竞争"><a href="#4、状态追踪解除竞争" class="headerlink" title="4、状态追踪解除竞争"></a>4、状态追踪解除竞争</h1><p>此处可以通过状态追踪，解除读与读之间和写与写之间的竞争问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FairnessBoundedBlockingQueue</span> <span class="keyword">implements</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头指针，empty: head.next == tail == null</span></span><br><span class="line">    <span class="keyword">protected</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾指针</span></span><br><span class="line">    <span class="keyword">protected</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canPollCount, head</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">pollLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canPollCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> waitPollCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canOfferCount, tail</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">offerLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canOfferCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> waitOfferCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FairnessBoundedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.canPollCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.canOfferCount = capacity;</span><br><span class="line">        <span class="built_in">this</span>.waitPollCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.waitOfferCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，通过返回值标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            <span class="keyword">while</span>(canOfferCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                waitOfferCount++;</span><br><span class="line">                offerLock.wait();</span><br><span class="line">                waitOfferCount--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(obj);</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            canOfferCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            ++canPollCount;</span><br><span class="line">            <span class="keyword">if</span> (waitPollCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pollLock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，阻塞等待</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            <span class="keyword">while</span>(canPollCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                waitPollCount++;</span><br><span class="line">                pollLock.wait();</span><br><span class="line">                waitPollCount--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = head.next.value;</span><br><span class="line">            head.next.value = <span class="literal">null</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            canPollCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            canOfferCount++;</span><br><span class="line">            <span class="keyword">if</span> (waitOfferCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                offerLock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        Node next;</span><br><span class="line">        Node(Object obj) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = obj;</span><br><span class="line">            next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上</p>
<ol>
<li>通过 waitOfferCount 和 waitPollCount 的状态追踪解决 读写内部的竞争问题；</li>
<li>当队列变更时，根据追踪的状态，决定是否派发消息，触发线程阻塞状态解除；</li>
</ol>
<p>但，上述的实现在某些场景下会运行失败，面临活性问题，考虑</p>
<p>情况一：</p>
<ol>
<li>初始状态队列为空 线程 A 执行出队动作，被阻塞在 pollLock , 此时 waitPollCount&#x3D;&#x3D;1；</li>
<li>此时线程 A 在执行 wait 时被中断，抛出异常， waitPollCount&#x3D;&#x3D;1 并未被重置；</li>
<li>阻塞队列为空，但 waitPollCount&#x3D;&#x3D;1 类状态异常；</li>
</ol>
<p>情况二：</p>
<ol>
<li>初始状态队列为空 线程 A B 执行出队动作，被阻塞在 pollLock , 此时 waitPollCount&#x3D;&#x3D;2；</li>
<li>线程 C 执行入队动作，可以立即执行，执行完成后，触发 pollLock 解除一个线程等待 notify；</li>
<li><strong>触发的线程在 JVM 实现中是随机的</strong>，假设线程 A 被解除阻塞；</li>
<li>假设线程 A 在阻塞过程中已被中断，阻塞解除后 JVM 检查 interrupted 状态，抛出 InterruptedException 异常；（线程A在阻塞时被中断，那么它的状态是interrupted，但是还处在被阻塞状态，此时去唤醒该线程，则会报错，而此次唤醒操作则丢失。线程A等中断结束后还会进入阻塞状态。）</li>
<li>此时队列中有一个元素，但线程 A 仍阻塞在 pollLock 中，且一直阻塞下去；</li>
</ol>
<p>以上为解除阻塞消息丢失的例子，问题的根源在与异常处理。</p>
<h1 id="5、解决异常问题"><a href="#5、解决异常问题" class="headerlink" title="5、解决异常问题"></a>5、解决异常问题</h1><p>解决线程中断退出的问题，线程校验中断状态的场景</p>
<ol>
<li>JVM 通常只会在有限的几个场景检测线程的中断状态， wait, Thread.join, Thread.sleep；</li>
<li>JVM 在检测到线程中断状态 Thread.interrupted() 后，会清除中断标志，抛出 InterruptedException；</li>
<li>通常为了保证线程对中断及时响应， run 方法中需要自主检测中断标志，中断线程，特别是对中断比较敏感需要保持类的不变式的场景；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FairnessBoundedBlockingQueue</span> <span class="keyword">implements</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头指针，empty: head.next == tail == null</span></span><br><span class="line">    <span class="keyword">protected</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾指针</span></span><br><span class="line">    <span class="keyword">protected</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canPollCount, head, waitPollCount</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">pollLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canPollCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> waitPollCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canOfferCount, tail, waitOfferCount</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">offerLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canOfferCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> waitOfferCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FairnessBoundedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.canPollCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.canOfferCount = capacity;</span><br><span class="line">        <span class="built_in">this</span>.waitPollCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.waitOfferCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，通过返回值标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>(); <span class="comment">// 线程已中断，直接退出即可，防止中断线程竞争锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            <span class="keyword">while</span>(canOfferCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                waitOfferCount++;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    offerLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 触发其他线程</span></span><br><span class="line">                    offerLock.notify();</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    waitOfferCount--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(obj);</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            canOfferCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            ++canPollCount;</span><br><span class="line">            <span class="keyword">if</span> (waitPollCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pollLock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，阻塞等待</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            <span class="keyword">while</span>(canPollCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                waitPollCount++;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    pollLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    pollLock.notify();</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    waitPollCount--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = head.next.value;</span><br><span class="line">            head.next.value = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// ignore head;</span></span><br><span class="line">            head = head.next;</span><br><span class="line">            canPollCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            canOfferCount++;</span><br><span class="line">            <span class="keyword">if</span> (waitOfferCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                offerLock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 Node 的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上</p>
<ol>
<li>当等待线程中断退出时，捕获中断异常，通过 pollLock.notify 和 offerLock.notify 转发消息；</li>
<li>通过在 finally 中恢复状态追踪变量；</li>
</ol>
<p>通过状态变量追踪可以解决读与读之间和写与写之间的锁竞争问题。</p>
<h1 id="6、解决公平性"><a href="#6、解决公平性" class="headerlink" title="6、解决公平性"></a>6、解决公平性</h1><p>公平性的问题的解决需要将状态变量的追踪转换为：<strong>请求监视器追踪</strong>。</p>
<ol>
<li>每个请求对应一个监视器；</li>
<li>通过内部维护一个 FIFO 队列，实现公平性；</li>
<li>在队列状态变更时，释放队列中的监视器；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> needToWait;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">    needToWait = calculateNeedToWait();</span><br><span class="line">    <span class="keyword">if</span> (needToWait) &#123;</span><br><span class="line">        enqueue(monitor); <span class="comment">// 请求对应的monitor</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needToWait) &#123;</span><br><span class="line">    monitor.doWait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意</p>
<ol>
<li>monitor.doWait() 需要在 this 的卫式语句之外，因为如果在内部， monitor.doWait 并不会释放 this锁；</li>
<li>calculateNeedToWait() 需要在 this 的守卫之内完成，避免同步问题；</li>
<li>需要考虑中断异常的问题；</li>
</ol>
<p>基于以上的逻辑抽象，实现公平队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略接口定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FairnessBoundedBlockingQueue</span> <span class="keyword">implements</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头指针，empty: head.next == tail == null</span></span><br><span class="line">    <span class="keyword">protected</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾指针</span></span><br><span class="line">    <span class="keyword">protected</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canPollCount, head, pollQueue</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">pollLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canPollCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canOfferCount, tail, offerQueue</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">offerLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canOfferCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">WaitQueue</span> <span class="variable">pollQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitQueue</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">WaitQueue</span> <span class="variable">offerQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FairnessBoundedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.canOfferCount = capacity;</span><br><span class="line">        <span class="built_in">this</span>.canPollCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，通过返回值标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>(); <span class="comment">// 线程已中断，直接退出即可，防止中断线程竞争锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">WaitNode</span> <span class="variable">wait</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            <span class="comment">// 在有阻塞请求或者队列为空时，阻塞等待</span></span><br><span class="line">            <span class="keyword">if</span> (canOfferCount &lt;= <span class="number">0</span> || !offerQueue.isEmpty()) &#123;</span><br><span class="line">                wait = <span class="keyword">new</span> <span class="title class_">WaitNode</span>();</span><br><span class="line">                offerQueue.enq(wait);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// continue.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (wait != <span class="literal">null</span>) &#123;</span><br><span class="line">                wait.doWait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            offerQueue.doNotify();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保此时线程状态正常，以下不会校验中断</span></span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(obj);</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            canOfferCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            ++canPollCount;</span><br><span class="line">            pollQueue.doNotify();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，阻塞等待</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">WaitNode</span> <span class="variable">wait</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            <span class="comment">// 在有阻塞请求或者队列为空时，阻塞等待</span></span><br><span class="line">            <span class="keyword">if</span> (canPollCount &lt;= <span class="number">0</span> || !pollQueue.isEmpty()) &#123;</span><br><span class="line">                wait = <span class="keyword">new</span> <span class="title class_">WaitNode</span>();</span><br><span class="line">                pollQueue.enq(wait);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (wait != <span class="literal">null</span>) &#123;</span><br><span class="line">                wait.doWait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 传递消息</span></span><br><span class="line">            pollQueue.doNotify();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下不会检测线程中断状态</span></span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            result = head.next.value;</span><br><span class="line">            head.next.value = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// ignore head;</span></span><br><span class="line">            head = head.next;</span><br><span class="line">            canPollCount--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            canOfferCount++;</span><br><span class="line">            offerQueue.doNotify();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WaitQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">        WaitNode head;</span><br><span class="line">        WaitNode tail;</span><br><span class="line"></span><br><span class="line">        WaitQueue() &#123;</span><br><span class="line">            head = <span class="keyword">new</span> <span class="title class_">WaitNode</span>();</span><br><span class="line">            tail = head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doNotify</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">                <span class="type">WaitNode</span> <span class="variable">node</span> <span class="operator">=</span> deq();</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.doNotify()) &#123;</span><br><span class="line">                    <span class="comment">// 此处确保NOTIFY成功</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// ignore, and retry.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> head.next == <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">enq</span><span class="params">(WaitNode node)</span> &#123;</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> WaitNode <span class="title function_">deq</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">WaitNode</span> <span class="variable">res</span> <span class="operator">=</span> head.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                tail = head; <span class="comment">// 为空，迁移tail节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WaitNode</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> released;</span><br><span class="line">        WaitNode next;</span><br><span class="line">        WaitNode() &#123;</span><br><span class="line">            released = <span class="literal">false</span>;</span><br><span class="line">            next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doWait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!released) &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125;             </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!released) &#123;</span><br><span class="line">                    released = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果是NOTIFY之后收到中断的信号，不能抛出异常；需要做RELAY处理</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">doNotify</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!released) &#123;</span><br><span class="line">                released = <span class="literal">true</span>;</span><br><span class="line">                notify();</span><br><span class="line">                <span class="comment">// 明确释放了一个线程，返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有释放新的线程，返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 Node 的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上</p>
<ol>
<li>核心是替换状态追踪变量为同步节点， WaitNode；</li>
<li>WaitNode 通过简单的同步队列组织实现 FIFO 协议，每个线程等待各自的 WaitNode 监视器；</li>
<li>WaitNode 内部维持 released 状态，标识线程阻塞状态是否被释放，主要是为了处理中断的问题；</li>
<li>WaitQueue 本身是全同步的，由于已解决了读写竞争已经读写内部竞争的问题， WaitQueue 同步并不会造成问题；</li>
<li>WaitQueue 是无界队列，是一个潜在的问题；但由于其只做同步的追踪，而且追踪的通常是线程，通常并不是问题；</li>
<li>最终的公平有界队列实现，无论是入队还是出队，首先卫式语句判定是否需要入队等待，如果入队等待，通过公平性协议等待;<br>当信号释放时，借助读写锁同步更新队列；最后同样借助读写锁，触发队列更新消息；</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《阿里技术博客》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>消息中间件单例服务优化</title>
    <url>/2023/07/09/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8D%95%E4%BE%8B%E6%9C%8D%E5%8A%A1%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>几乎所有串行化理论真正解决的问题只有一个：性能。 所以，在性能允许的前提下，对于消费者角色，建议采用单实例部署。通过单实例部署，有序性、串行化、完整性和一致性问题自动获得了解决。另外，单实例部署的消费者拥有全部所需信息，它可以在频次控制上采取很多优化策略。</p>
<p>单实例部署并非没有代价，它意味着系统可用性的降低，解决可用性问题的最直接的思路就是冗余（Redundancy）。最常用的冗余方案是Master-slave架构，不过大部分的Master-slave架构都是Active&#x2F;active模式，即主从服务器都提供服务。</p>
<p>大部分基于负载均衡设计的Master-slave集群中，主服务器和从服务器同时提供相同的服务。这显然不满足单例服务优化需求。有序性和串行化需要Active&#x2F;passive架构，即在某一时刻只有主实例提供服务，其他的从服务等待主实例失效。这是典型的领导人选举架构，即只有获得领导权的实例才能充当实际消费者，其他实例都在等待下一次选举。采用领导人选举的Active&#x2F;passive架构可以大大缓解纯粹的单实例部署所带来的可用性问题。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《美团博客》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程实践之公平有界阻塞队列实现（上）</title>
    <url>/2023/07/12/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%85%AC%E5%B9%B3%E6%9C%89%E7%95%8C%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="1、基础版本"><a href="#1、基础版本" class="headerlink" title="1、基础版本"></a>1、基础版本</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span>;</span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">poll</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FairnessBoundedBlockingQueue</span> <span class="keyword">implements</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="comment">// 当前大小</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头指针，empty: head.next == tail == null</span></span><br><span class="line">    <span class="keyword">protected</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾指针</span></span><br><span class="line">    <span class="keyword">protected</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FairnessBoundedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = head;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，通过返回值标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; capacity) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(obj);</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，head.next == null；返回空元素</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> head.next.value;</span><br><span class="line">            head.next.value = <span class="literal">null</span>;</span><br><span class="line">            head = head.next; <span class="comment">// 丢弃头结点</span></span><br><span class="line">            --size;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        Node next;</span><br><span class="line">        Node(Object obj) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = obj;</span><br><span class="line">            next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>定义支持队列的两个基础接口， poll 和 offer；</li>
<li>队列的实现，采用经典实现；</li>
<li>考虑在队列空的情况下， poll 返回为空，非阻塞；</li>
<li>队列在满的情况下， offer 返回 false ，入队不成功，无异常；</li>
</ol>
<h1 id="2、并发版本"><a href="#2、并发版本" class="headerlink" title="2、并发版本"></a>2、并发版本</h1><p>如果在并发场景下，上述的实现面临一些问题，同时未实现给定的一些需求。通过添加 synchronized ，保证并发条件下的线程安全问题。注意此处做同步的原因是为了保证类的不变式。</p>
<p>以上，简单粗暴的加 synchronized 可以解决问题，但会引入新的问题：系统活性问题（此问题下文会解决）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoundedBlockingQueue</span> <span class="keyword">implements</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前大小</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头指针，empty: head.next == tail == null</span></span><br><span class="line">    <span class="keyword">protected</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾指针</span></span><br><span class="line">    <span class="keyword">protected</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BoundedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = head;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，通过返回值标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; capacity) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(obj);</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，head.next == null；返回空元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> head.next.value;</span><br><span class="line">            head.next.value = <span class="literal">null</span>;</span><br><span class="line">            head = head.next; <span class="comment">// 丢弃头结点</span></span><br><span class="line">            --size;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        BoundedBlockingQueue.Node next;</span><br><span class="line">        Node(Object obj) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = obj;</span><br><span class="line">            next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，简单加 synchronized 同步是无法实现阻塞等待；即</p>
<ol>
<li>如果队列为空，那么出队的动作还是会立即返回，返回为空；</li>
<li>如果队列已满，那么入队动作还是会立即返回，返回操作不成功；</li>
</ol>
<h2 id="卫式方法"><a href="#卫式方法" class="headerlink" title="卫式方法"></a>卫式方法</h2><p>阻塞等待，可以通过简单的卫式方法来实现，此问题本质上可以抽象为：</p>
<ol>
<li>任何一个方法都需要在满足一定条件下才可以执行；</li>
<li>执行方法前需要首先校验不变式，然后执行变更；</li>
<li>在执行完成后，校验是否满足后验不变式；</li>
</ol>
<p>代码逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 当前线程</span></span><br><span class="line"><span class="keyword">synchronized</span> Object <span class="title function_">action</span><span class="params">(Object arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(!condition) &#123;</span><br><span class="line">        wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前置条件，不变式</span></span><br><span class="line">    checkPreCondition();</span><br><span class="line">    doAction();</span><br><span class="line">    <span class="comment">// 后置条件，不变式</span></span><br><span class="line">    checkPostCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他线程</span></span><br><span class="line"><span class="keyword">synchronized</span> Object <span class="title function_">notifyAction</span><span class="params">(Object arg)</span> &#123;</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意：</p>
<ol>
<li>通常会采用 notifyAll 发送通知，而非 notify ；因为如果当前线程收到 notify 通知后被中断，那么系统将一直等待下去。</li>
<li>如果使用了 notifyAll 那么卫式语句必须放在 while 循环中；因为线程唤醒后，执行条件已经不满足，虽然当前线程持有互斥锁。</li>
<li>卫式条件的所有变量，有任何变更都需要发送 notifyAll 不然面临系统活性问题。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FairnessBoundedBlockingQueue</span> <span class="keyword">implements</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="comment">// 当前大小</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头指针，empty: head.next == tail == null</span></span><br><span class="line">    <span class="keyword">protected</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾指针</span></span><br><span class="line">    <span class="keyword">protected</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FairnessBoundedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = head;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，通过返回值标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        size&gt;=capacity &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(obj);</span><br><span class="line">        tail.next = node;</span><br><span class="line">        tail = node;</span><br><span class="line">        ++size;</span><br><span class="line">        notifyAll(); <span class="comment">// 可以出队</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，阻塞等待</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> head.next.value;</span><br><span class="line">        head.next.value = <span class="literal">null</span>;</span><br><span class="line">        head = head.next; <span class="comment">// 丢弃头结点</span></span><br><span class="line">        --size;</span><br><span class="line">        notifyAll(); <span class="comment">// 可以入队</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 Node 的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上，实现了阻塞等待，但也引入了更大的性能问题</p>
<ol>
<li>入队和出队动作阻塞等待同一把锁，恶性竞争；（这里不管入队还是出队操作的都是同一个队列，入队还是出队都操作了size，所以不能同时进行）</li>
<li>当队列变更时，所有阻塞线程被唤醒，大量的线程上下文切换，竞争同步锁，最终可能只有一个线程能执行；</li>
</ol>
<p>需要注意的点：</p>
<ol>
<li>阻塞等待 wait 会抛出中断异常。关于异常的问题下文会处理；</li>
<li>接口需要支持抛出中断异常；</li>
<li>队里变更需要 notifyAll 避免线程中断或异常，丢失消息；</li>
</ol>
<h1 id="3、锁拆分优化"><a href="#3、锁拆分优化" class="headerlink" title="3、锁拆分优化"></a>3、锁拆分优化</h1><p>以上第一个问题，可以通过锁拆分来解决，即：定义两把锁，读锁和写锁；读写分离。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 省略接口定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FairnessBoundedBlockingQueue</span> <span class="keyword">implements</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头指针，empty: head.next == tail == null</span></span><br><span class="line">    <span class="keyword">protected</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾指针</span></span><br><span class="line">    <span class="keyword">protected</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canPollCount, head</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">pollLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canPollCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canOfferCount, tail</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">offerLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canOfferCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FairnessBoundedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.canPollCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.canOfferCount = capacity;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，通过返回值标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            <span class="keyword">while</span>(canOfferCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                offerLock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(obj);</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            canOfferCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            ++canPollCount;</span><br><span class="line">            pollLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，阻塞等待</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            <span class="keyword">while</span>(canPollCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                pollLock.wait();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = head.next.value;</span><br><span class="line">            head.next.value = <span class="literal">null</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            canPollCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            canOfferCount++;</span><br><span class="line">            offerLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 Node 定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上</p>
<ol>
<li>定义了两把锁， pollLock 和 offerLock 拆分出队和入队竞争；</li>
<li>入队锁同步的变量为：callOfferCount 和 tail；</li>
<li>出队锁同步的变量为：canPollCount 和 head；</li>
<li>出队的动作：首先拿到 pollLock 卫式等待后，完成出队动作；然后拿到 offerLock 发送通知，解除入队的等待线程。</li>
<li>入队的动作：首先拿到 offerLock 卫式等待后，完成入队的动作；然后拿到 pollLock 发送通知，解除出队的等待线程。</li>
</ol>
<p>以上实现</p>
<ol>
<li>确保通过入队锁和出队锁，分别保证入队和出队的原子性；</li>
<li>出队动作，通过特别的实现，确保出队只会变更 head ，避免获取 offerLock；</li>
<li>通过 offerLock.notifyAll 和 pollLock.notifyAll 解决读写竞争的问题；</li>
</ol>
<p>问题：当有多个入队线程等待时，一次出队的动作会触发所有入队线程竞争，大量的线程上下文切换，最终只有一个线程能执行。<br>即，还有 <strong>读与读</strong> 和 <strong>写与写</strong> 之间的竞争问题。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《阿里技术博客》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>消息模型：主题和队列区别</title>
    <url>/2023/04/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%BB%E9%A2%98%E5%92%8C%E9%98%9F%E5%88%97%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><strong>早期的消息队列，就是按照“队列”的数据结构来设计的。</strong>我们一起看下这个图，生产者（Producer）发消息就是入队操作，消费者（Consumer）收消息就是出队也就是删除操作，服务端存放消息的容器自然就称为“队列”。</p>
<p>以下是最初的一种消息模型：队列模型</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230428145326054.png" alt="image-20230428145326054" style="zoom:67%;" />

<p>这种模型中，消费者之间是竞争关系，每个消息只能被一个消费者消费。</p>
<p>但是如果想要一个消息被多个消费者消费，比如说对于一个订单消息，风控系统，分析系统，支付系统都需要得到该订单的信息，那么采用这种模型的话就需要为每一个消费者创建一个队列，但是这样做就需要提前知道有多少个消费者，违背了解耦。</p>
<p>为了解决这个问题，演化出了另外一种消息模型：“<strong>发布 - 订阅模型（Publish-Subscribe Pattern）</strong>”。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230428145647672.png" alt="image-20230428145647672" style="zoom:67%;" />

<p>以上两种模型的区别就是，<strong>一份消息数据能不能被消费多次的问题。</strong></p>
<h1 id="RabbitMQ-的消息模型"><a href="#RabbitMQ-的消息模型" class="headerlink" title="RabbitMQ 的消息模型"></a>RabbitMQ 的消息模型</h1><p>rabbitmq采用队列模型，它用了一个交换机来解决多个消费者消费同一条消息的问题。</p>
<p>生产者不关心消息发送给哪个消费者，它只需要发送给交换机，由交换机决定发送给哪个消费者。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230428145907388.png" alt="image-20230428145907388" style="zoom:67%;" />

<h1 id="RocketMQ-的消息模型"><a href="#RocketMQ-的消息模型" class="headerlink" title="RocketMQ 的消息模型"></a>RocketMQ 的消息模型</h1><p>RocketMQ 使用的消息模型是标准的发布 - 订阅模型。但是它也有队列的概念。</p>
<p>几乎所有的消息队列都采用<strong>请求-确认机制</strong>，即生产者将消息发送给服务端，服务端收到并写入队列后，会给生产者发送确认响应。而消费端，消费者收到消息并处理完后，也会给服务端发送消息，服务端在收到确认消息后，才会判定消息被消费成功。上面两种，如果没收到确认消息，会重试。</p>
<p>但是这样也存在一个问题，即还没收到一个消息的确认信息时，只能等待，而不能去执行第二条消息，这样是为了保证消息的顺序性。</p>
<p>为了解决这个问题，RocketMQ引入了队列的概念。</p>
<p><strong>每个主题包含多个队列，通过多个队列来实现多实例并行生产和消费。</strong>RocketMQ 只在队列上保证消息的有序性，主题层面是无法保证消息的严格顺序的。</p>
<p>RocketMQ 中，订阅者的概念是通过消费组（Consumer Group）来体现的。每个消费组都消费主题中一份完整的消息，不同消费组之间消费进度彼此不受影响，也就是说，一条消息被 Consumer Group1 消费过，也会再给 Consumer Group2 消费。</p>
<p>一个消费组中的消费者是竞争关系，一条消息只会被消费组中的一个消费者消费。</p>
<p>由于每一条消息需要被多个消费组消费，所以消费完的消息并不会立即被删除，这就需要 RocketMQ 为每个消费组在每个队列上维护一个消费位置（Consumer Offset），这个位置之前的消息都被消费过，之后的消息都没有被消费过，每成功消费一条消息，消费位置就加一。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230428150934219.png" alt="image-20230428150934219"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《消息队列高手课》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列中如何设计高性能的网络模块</title>
    <url>/2023/07/17/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>消息队列是需要满足高吞吐、高可靠、低延时，并支持多语言访问的基础软件，网络模块最需要解决的是<strong>性能</strong>、<strong>稳定性、开发成本</strong>三个问题。</p>
<h1 id="网络模块的性能瓶颈分析"><a href="#网络模块的性能瓶颈分析" class="headerlink" title="网络模块的性能瓶颈分析"></a>网络模块的性能瓶颈分析</h1><p>消息队列的访问链路图如下：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717205443205.png" alt="image-20230717205443205" style="zoom: 80%;" />

<p>对于<strong>单个请求</strong>来说，请求流程是：客户端构建请求，发送给服务端，服务端收到后交由业务线程处理，业务线程处理完后返回给客户端。</p>
<p>该流程性能消耗有三个点：</p>
<ul>
<li><strong>编解码的速度</strong>。即序列化与反序列化的速度。</li>
<li><strong>网络延迟</strong>。这点几乎无法优化，与网络传输有关。</li>
<li><strong>服务端 &#x2F; 客户端网络模块的处理速度</strong>。发送 &#x2F; 接收请求包后，包是否能及时被处理。</li>
</ul>
<p>对于<strong>并发请求</strong>来说，在单个请求维度的问题的基础上，还需要处理高并发、高 QPS、高流量等场景带来的性能问题。主要包含三个方面。</p>
<ul>
<li><strong>高效的连接管理</strong>：当客户端和服务端之间的 TCP 连接数很多，如何高效处理、管理连接。</li>
<li><strong>快速处理高并发请求</strong>：当客户端和服务端之间的 QPS 很高，如何快速处理（接收、返回）请求。</li>
<li><strong>大流量场景</strong>：当客户端和服务端之间的流量很高，如何快速吞吐（读、写）数据。</li>
</ul>
<p>大流量场景分为两类，单个请求包大，但是并发小，单个请求包小，但是并发大。</p>
<p>第一种的瓶颈主要在于数据拷贝、垃圾回收、CPU 占用等方面，主要依赖语言层面的编码技巧来解决。</p>
<p>我们这里主要看第二种。</p>
<h1 id="高性能网络模块的设计实现"><a href="#高性能网络模块的设计实现" class="headerlink" title="高性能网络模块的设计实现"></a>高性能网络模块的设计实现</h1><p>从技术上来看，高性能网络模块的设计可以分为如何<strong>高效管理大量的 TCP 连接</strong>、如何<strong>快速处理高并发的请求</strong>、如何<strong>提高稳定性和降低开发成本</strong>等三个方面。</p>
<h2 id="基于多路复用技术管理-TCP-连接"><a href="#基于多路复用技术管理-TCP-连接" class="headerlink" title="基于多路复用技术管理 TCP 连接"></a>基于多路复用技术管理 TCP 连接</h2><p>从技术原理来看，高效处理大量 TCP 连接，在消息队列中主要有<strong>单条 TCP 连接的复用</strong>和<strong>多路复用</strong>两种技术思路。</p>
<h3 id="1-单条-TCP-连接的复用"><a href="#1-单条-TCP-连接的复用" class="headerlink" title="1. 单条 TCP 连接的复用"></a>1. 单条 TCP 连接的复用</h3><p>如下图，在一条真实的 TCP 连接中，创建信道（channel，可以理解为虚拟连接）的概念。通过编程手段，我们把信道当做一条 TCP 连接使用，做到 TCP 连接的复用，避免创建大量 TCP 连接导致系统资源消耗过多。</p>
<p>缺点是在协议设计和编码实现的时候有额外开发工作量，而且近年随着异步 IO、IO 多路复用技术的发展，这种方案有点多余。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717210315458.png" alt="image-20230717210315458" style="zoom:67%;" />

<h3 id="2-IO-多路复用技术"><a href="#2-IO-多路复用技术" class="headerlink" title="2. IO 多路复用技术"></a>2. IO 多路复用技术</h3><p>IO 多路复用技术，是指通过把多个 IO 的阻塞复用到同一个 selector 的阻塞上，让系统在单线程的情况下可以同时处理多个客户端请求。最大的优势是系统开销小，系统不需要创建额外的进程或者线程，降低了维护的工作量，也节省了资源。</p>
<p>目前支持 IO 多路复用的系统调用有 Select、Poll、Epoll 等，Java NIO 库底层就是基于 Epoll 机制实现的。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717210436640.png" alt="image-20230717210436640" style="zoom:80%;" />

<p>即使用了这两种技术，<strong>单机能处理的连接数还是有上限的</strong>。</p>
<p>第一个上限是操作系统的 FD 上限，如果连接数超过了 FD 的数量，连接会创建失败。</p>
<p>第二个限制是系统资源的限制，主要是 CPU 和内存。频繁创建、删除或者创建过多连接会消耗大量的物理资源，导致系统负载过高。</p>
<h2 id="基于-Reactor-模型处理高并发请求"><a href="#基于-Reactor-模型处理高并发请求" class="headerlink" title="基于 Reactor 模型处理高并发请求"></a>基于 Reactor 模型处理高并发请求</h2><p><strong>对于单个请求来说</strong>，最快的处理方式就是客户端直接发出请求，服务端接收到包后，直接丢给后面的业务线程处理，当业务线程处理成功后，直接返回给客户端。但存在以下两个问题：</p>
<ul>
<li><p>如何第一时间拿到包交给后端的业务逻辑处理？</p>
</li>
<li><p>当业务逻辑处理完成后，如何立即拿到返回值返回给客户端？</p>
</li>
</ul>
<p>最直观的思路是阻塞等待模型，不断轮询等待请求拿到包，业务逻辑处理完后返回给客户端。但是阻塞等待模型是穿行机制，下一个请求需要等到上一个请求处理完才能处理，效率低。</p>
<p>所以，单个请求，最合理的方式就是<strong>异步的事件驱动模型</strong>，可以通过 Epoll 和异步编程来解决。</p>
<p><strong>在高并发的情况下</strong>会有很多连接、请求需要处理，核心思路就是并行、多线程处理，需要用到Reactor模型。</p>
<p>Reactor 模型是一种处理并发服务请求的事件设计模式，当主流程收到请求后，通过多路分离处理的方式，把请求分发给相应的请求处理器处理。</p>
<p>如下图所示，Reactor 模式包含 Reactor、Acceptor、Handler 三个角色。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717211239869.png" alt="image-20230717211239869" style="zoom: 80%;" />

<ul>
<li>Reactor：负责监听和分配事件。收到事件后分派给对应的 Handler 处理，事件包括连接建立就绪、读就绪、写就绪等。</li>
<li>Acceptor：负责处理客户端新连接。Reactor 接收到客户端的连接事件后，会转发给 Acceptor，Acceptor 接收客户端的连接，然后创建对应的 Handler，并向 Reactor 注册此 Handler。</li>
<li>Handler：请求处理器，负责业务逻辑的处理，即业务处理线程。</li>
</ul>
<p><strong>从技术上看，Reactor 模型一般有三种实现模式。</strong></p>
<ul>
<li>单 Reactor 单线程模型（单 Reactor 单线程）</li>
<li>单 Reactor 多线程模型 （单 Reactor 多线程）</li>
<li>主从 Reactor 多线程模型 (多 Reactor 多线程)</li>
</ul>
<h3 id="1、单-Reactor-单线程模型"><a href="#1、单-Reactor-单线程模型" class="headerlink" title="1、单 Reactor 单线程模型"></a>1、单 Reactor 单线程模型</h3><p>特点是 Reactor 和 Handler 都是单线程的串行处理。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717212026725.png" alt="image-20230717212026725" style="zoom:80%;" />

<p>优点是所有处理逻辑放在单线程中实现，没有上下文切换、线程竞争、进程通信等问题。缺点是在性能与可靠性方面存在比较严重的问题。</p>
<p>性能上，因为是单线程处理，无法充分利用 CPU 资源，并且业务逻辑 Handler 的处理是同步的，容易造成阻塞，出现性能瓶颈。<strong>所以单</strong> <strong>Reactor</strong> <strong>单进程模型不适用于计算密集型的场景，只适用于业务处理非常快速的场景</strong>。</p>
<h3 id="2、单-Reactor-多线程模型"><a href="#2、单-Reactor-多线程模型" class="headerlink" title="2、单 Reactor 多线程模型"></a>2、单 Reactor 多线程模型</h3><p>业务逻辑处理 Handler 变成了多线程，也就是说，获取到 IO 读写事件之后，业务逻辑是一批线程在处理。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717212143234.png" alt="image-20230717212143234"></p>
<p>优点是 Handler 收到响应后通过 send 把响应结果返回给客户端，降低 Reactor 的性能开销，提升整个应用的吞吐。而且 Handler 使用多线程模式，可以充分利用 CPU 的性能，提高了业务逻辑的处理速度。</p>
<p>缺点是 Handler 使用多线程模式，带来了多线程竞争资源的开销，同时涉及共享数据的互斥和保护机制，实现比较复杂。另外，单个 Reactor 承担所有事件的监听、分发和响应，对于高并发场景，容易造成性能瓶颈。</p>
<h3 id="3、主从-Reactor-多线程模型"><a href="#3、主从-Reactor-多线程模型" class="headerlink" title="3、主从 Reactor 多线程模型"></a>3、主从 Reactor 多线程模型</h3><p>该模型让 Reactor 也变为了多线程。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717212515159.png" alt="image-20230717212515159"  />

<p>这种方案，优点是 Reactor 的主线程和子线程分工明确，主线程只负责接收新连接，子线程负责完成后续的业务处理。主线程接收到主线程的连接后，只需要交由后续业务处理即可，不需要关注主线程，可以直接在子线程把处理结果返回给客户端。</p>
<p>缺点是Acceptor 是一个单线程，如果挂了，如何处理客户端新连接是一个风险点。</p>
<p>优化后，将Acceptor改为多线程</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717212849187.png" alt="image-20230717212849187"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入拆解消息队列 47 讲》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>消息中间件选型标准</title>
    <url>/2023/07/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%80%89%E5%9E%8B%E6%A0%87%E5%87%86/</url>
    <content><![CDATA[<h1 id="中间件的功能"><a href="#中间件的功能" class="headerlink" title="中间件的功能"></a>中间件的功能</h1><p>典型的消息中间件主要包含如下几个功能： </p>
<ul>
<li><p>消息接收 </p>
</li>
<li><p>消息分发 </p>
</li>
<li><p>消息存储 </p>
</li>
<li><p>消息读取</p>
</li>
</ul>
<h1 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h1><p>抽象的消息中间件模型包含如下几个角色：</p>
<ol>
<li>发送者和接收者客户端（Sender&#x2F;Receiver Client）；</li>
<li>代理服务器（Broker Server），它们是与客户端代码直接交互的服务端代码；</li>
<li>消息交换机（Exchanger），接收到的消息一般需要通过消息交换机（Exchanger）分发到具体的消息队列中；</li>
<li>消息队列，一般是一块内存数据结构或持久化数据。</li>
</ol>
<p>如下图所示：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230709105627284.png" alt="image-20230709105627284"></p>
<h1 id="选型标准"><a href="#选型标准" class="headerlink" title="选型标准"></a>选型标准</h1><p>大致有以下几点</p>
<h2 id="1、性能"><a href="#1、性能" class="headerlink" title="1、性能"></a>1、性能</h2><p>性能主要有两个方面需要考虑：吞吐量（Throughput）和响应时间（Latency）。 不同的消息队列中间件的吞吐量和响应时间相差甚远，对于同一种中间件，不同的配置方式也会影响性能。</p>
<p>配置主要有以下几种：</p>
<ul>
<li>是否需要确认机制，即写入队列后，或从队列读取后，是否需要进行确认。确认机制对响应时间的影响往往很大。</li>
<li>能否批处理，即消息能否批量读取或者写入。批量操作可以大大减少应用程序与消息中间件的交互次数和消息传递量，大大提高吞吐量。</li>
<li>能否进行分区（Partition）。将某一主题消息队列进行分区，同一主题消息可以有多台机器并行处理。这不仅仅能影响消息中间件的吞吐量，还决定着消息中间件是否具备良好的可伸缩性（Scalability）。</li>
<li>是否需要进行持久化。将消息进行持久化往往会同时影响吞吐量和响应时间。</li>
</ul>
<h2 id="2、可靠性"><a href="#2、可靠性" class="headerlink" title="2、可靠性"></a>2、可靠性</h2><p>可靠性主要包含：可用性、持久化、确认机制等。高可用性的消息中间件应该具备如下特征：</p>
<ul>
<li>消息中间件代理服务器（Broker）具有主从备份。即当一台代理服务宕机之后，备用服务器能接管相关的服务。</li>
<li>消息中间件中缓存的消息是否有备份、并持久化。高可用、高一致性以及网络分裂不可兼得，大部分中间件在面临网络分裂情况下都很难保证高可用和一致性，而且可用性和一致性之间也不可兼得。</li>
</ul>
<p>高可靠的消息中间件应该确保从发送者接收到的消息不会丢失。中间件代理服务器的宕机并不是小概率事件，所以大部分消息中间件都提供持久化，将消息写入磁盘中。但仍有两个问题需要考虑：</p>
<ul>
<li>磁盘损坏问题。长时间来看，磁盘出问题的概率仍然存在。</li>
<li>性能问题。与操作内存相比，磁盘I&#x2F;O的操作性能要慢几个数量级。频繁持久化不仅会增加响应时间，也会降低吞吐量。</li>
</ul>
<p>解决方案：多机确认，定期持久化。即消息被缓存在多台机器的内存中，只有每台机器都确认收到消息，才跟发送者确认（很多消息中间件都会提供相应的配置选项，让用户设置最少需要多少台机器接收到消息）。</p>
<p>确认机制本质上是通讯的握手机制（Handshaking）。如果没有该机制，消息在传输过程中丢失将不会被发现。当然如果没有接收到消息中间件确认完成的指令，应用程序需要决定如何处理。典型的做法有两个： </p>
<ol>
<li>多次重试。 </li>
<li>暂存到本地磁盘或其它持久化媒介。</li>
</ol>
<h2 id="3、投递策略（Delivery-policies）"><a href="#3、投递策略（Delivery-policies）" class="headerlink" title="3、投递策略（Delivery policies）"></a>3、投递策略（Delivery policies）</h2><p>投递策略指的是一个消息会被发送几次。主要包含三种策略：</p>
<ol>
<li>最多一次（At most Once ）</li>
<li>最少一次（At least Once）</li>
<li>仅有一次（Exactly Once）。</li>
</ol>
<p>在实际应用中，只考虑消息中间件的投递策略并不能保证业务的投递策略，因为接收者在确认收到消息和处理完消息并持久化之间存在一个时间窗口。</p>
<p>例如，即使消息中间件保证仅有一次（Exactly Once），如果接收者先确认消息，在持久化之前宕机，则该消息并未被处理。从应用的角度，这就是最多一次（At most Once）。反之，接收者先处理消息并完成持久化，但在确认之前宕机，消息就要被再次发送，这就是最少一次（At least Once）。</p>
<h1 id="面临的挑战"><a href="#面临的挑战" class="headerlink" title="面临的挑战"></a>面临的挑战</h1><p>消费者是分布式队列编程中真正的数据处理方，数据处理方最常见的挑战包括：有序性、串行化（Serializability）、频次控制、完整性和一致性等。</p>
<h2 id="1、有序性"><a href="#1、有序性" class="headerlink" title="1、有序性"></a>1、有序性</h2><p>如下图，假定分布式队列保证请求严格有序，请求ri2和ri1都是针对同一数据记录的不同状态，ri2的状态比ri1的状态新。T1、T2、T3和T4代表各个操作发生的时间，并且 T1 &lt; T2 &lt; T3 &lt; T4（”&lt;“代表早于）。</p>
<p>采用多消费者架构，这两条记录被两个消费者（Consumer1和Consumer2）处理后更新到数据库里面。Consumer1虽然先读取ri1但是却后写入数据库，这就导致，新的状态被老的状态覆盖，所以多消费者不保证数据的有序性。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230709111658723.png" alt="image-20230709111658723"></p>
<h2 id="2、串行化"><a href="#2、串行化" class="headerlink" title="2、串行化"></a>2、串行化</h2><p>很多场景下，串行化是数据处理的一个基本需求，这是保证数据完整性、可恢复性、事务原子性等的基础。对于分布式队列编程架构，要在在多台消费者实现串行化非常复杂。</p>
<h2 id="3、频次控制"><a href="#3、频次控制" class="headerlink" title="3、频次控制"></a>3、频次控制</h2><p>有时候，消费者的消费频次需要被控制，可能的原因包括：</p>
<ul>
<li>费用问题。如果每次消费所引起的操作都需要收费，而同一个请求消息在队列中保存多份，不进行频次控制，就会导致无谓的浪费。 </li>
<li>性能问题。每次消费可能会引起对其他服务的调用，被调用服务希望对调用量有所控制，对同一个请求消息的多次访问就需要有所控制。</li>
</ul>
<h2 id="4、完整性和一致性"><a href="#4、完整性和一致性" class="headerlink" title="4、完整性和一致性"></a>4、完整性和一致性</h2><p>完整性和一致性是所有多线程和多进程的代码都面临的问题。在多线程或者多进程的系统中考虑完整性和一致性往往会大大地增加代码的复杂度和系统出错的概率。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《美团博客》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列问题答疑</title>
    <url>/2023/05/03/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%97%AE%E9%A2%98%E7%AD%94%E7%96%91/</url>
    <content><![CDATA[<h1 id="网关如何接收服务端的秒杀结果"><a href="#网关如何接收服务端的秒杀结果" class="headerlink" title="网关如何接收服务端的秒杀结果"></a>网关如何接收服务端的秒杀结果</h1><p>这里只是一个很简单的例子，省去了很多的细节，不同的系统也有不同的设计，思路仅供参考。</p>
<p>网关在收到 APP 的秒杀请求后，直接给消息队列发消息。如果发送消息失败，可以直接给 APP 返回秒杀失败结果，成功发送消息之后，线程就阻塞等待秒杀结果。这里不会无限等待，会设置一个超时事件。等待结束之后，去存放秒杀结果的 Map 中查询是否有返回的秒杀结果，如果有就构建Response，给 APP 返回秒杀结果，如果没有，按秒杀失败处理。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230503160946737.png" alt="image-20230503160946737"></p>
<h1 id="RocketMQ-和-Kafka-的消息模型"><a href="#RocketMQ-和-Kafka-的消息模型" class="headerlink" title="RocketMQ 和 Kafka 的消息模型"></a>RocketMQ 和 Kafka 的消息模型</h1><p>现在，假如有一个主题 MyTopic，我们为主题创建 5 个队列，分布到 2 个 Broker 中。有三个生产者Produer0，Produer1 和Producer2。</p>
<p>这三个生产者与2个Broker可以随便对应，也就是说可以轮询发消息，或者说一个生产者的消息全部发送到一个Broker中。</p>
<p>至于消费端，有消费组、消费者和队列这几个概念。</p>
<p>每个消费组就是一份订阅，它要消费主题 MyTopic 下，所有队列的全部消息。这里要注意，消费了的消息并不会从队列中删除，只是从队列中读取了消息。</p>
<p>多个消费组在消费同一个主题时，消费组之间是互不影响的。比如我们有 2 个消费组：G0和 G1。G0 消费了哪些消息，G1 是不知道的，也不用知道。G0 消费过的消息，G1 还可以消费。即使 G0 积压了很多消息，对 G1 来说也没有任何影响。</p>
<p>而一个消费组中可以包含多个消费者的实例。比如说消费组G1，包含了 2 个消费者 C0 和 C1。这里有一个原则，即同一个消费组里面，每个队列只能被一个消费者实例占用。我们可以让消费者 C0 消费 Q0，Q1 和 Q2，C1 消费Q3 和 Q4，如果 C0 宕机了，会触发重新分配，这时候 C1 同时消费全部 5 个队列。</p>
<p>队列占用只是针对消费组内部来说的，对于其他的消费组来说是没有影响的。比如队列 Q2 被消费组 G1 的消费者 C1 占用了，对于消费组 G2 来说，是完全没有影响的，G2 也可以分配它的消费者来占用和消费队列 Q2。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230503162810577.png" alt="image-20230503162810577"></p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230503162822904.png" alt="image-20230503162822904"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列分布式限流方案</title>
    <url>/2023/09/01/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%88%86%E5%B8%83%E5%BC%8F%E9%99%90%E6%B5%81%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="限流分类"><a href="#限流分类" class="headerlink" title="限流分类"></a>限流分类</h1><p>1、单机限流</p>
<p>限制每一台broker的流量，如下图所示：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230901201114249.png" alt="image-20230901201114249"></p>
<p>2、全局限流</p>
<p>限制所有broker的流量和，这种方案往往需要一个第三方的平台来统计目前所有Broker的总流量，如下图所示：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230901201158231.png" alt="image-20230901201158231"></p>
<h1 id="对什么限流"><a href="#对什么限流" class="headerlink" title="对什么限流"></a>对什么限流</h1><p>主要对流量、连接数、请求数三类资源进行限流。</p>
<p><strong>流量限制</strong>指对生产、消费的流量限制。</p>
<p><strong>连接数限制</strong>指对客户端连接到服务端的 TCP 连接数量进行限制。因为 TCP 连接的建立和关闭需要消耗 CPU、内存等资源，限制是为了保护服务端不会因为连接数太多，耗尽资源，导致服务不可用，主要从一下三个方面：</p>
<ul>
<li><p>服务端单机可承载的最大连接数限制。</p>
</li>
<li><p>客户端单个 IP 可建立的连接数。</p>
</li>
<li><p>单个集群可建立的总链接数。</p>
</li>
</ul>
<p><strong>请求数限制</strong>指对单个接口的访问频次进行限制，来保护集群自身的可用性。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列如何保证存储的高性能</title>
    <url>/2023/07/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AD%98%E5%82%A8%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<p>存储模块的优化主要是基于以下四点：</p>
<ul>
<li>内存读写的效率高于硬盘读写</li>
<li>批量读写的效率高于单条读写</li>
<li>顺序读写的效率高于随机读写</li>
<li>数据复制次数越多，效率越低</li>
</ul>
<h1 id="提升写入操作的性能"><a href="#提升写入操作的性能" class="headerlink" title="提升写入操作的性能"></a>提升写入操作的性能</h1><p>数据需要先写入内存，然后才会落盘，所以写入操作的性能优化就要从内存和磁盘入手。写入性能的提高主要有缓存写、批量写、顺序写三个思路。</p>
<h2 id="1-缓存写和批量写"><a href="#1-缓存写和批量写" class="headerlink" title="1. 缓存写和批量写"></a>1. 缓存写和批量写</h2><p>物理硬件的写入速度如下图：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719104418089.png" alt="image-20230719104418089"></p>
<p>所以，写入优化的主要思路之一是：<strong>将数据写入到速度更快的内存中，等积攒了一批数据，再批量刷到硬盘中。</strong></p>
<p>平时可以看到的一种说法，数据先写入 PageCache，再批量刷到硬盘，就是这种思路。PageCache 指操作系统的页缓存，简单理解就是内存，通过缓存读写数据可以避免直接对硬盘进行操作，从而提高性能。</p>
<p>把缓存数据刷回到硬盘，一般有“按照空间占用比例”、“时间周期扫描”和“手动强制刷新”三种策略。操作系统内核提供了前两种处理策略，不需要应用程序感知。</p>
<p><strong>按空间占用比例刷新</strong>是指当系统内存中的“脏”数据大于某个阈值时会将数据刷新到硬盘。操作系统提供了两个配置项：</p>
<ul>
<li><p>“脏”数据在内存中的占比（dirty_background_ratio）</p>
</li>
<li><p>“脏”数据的绝对的字节数（dirty_background_bytes）</p>
</li>
</ul>
<p><strong>按时间周期刷新</strong>是指根据配置好的时间，周期性刷新数据到硬盘。主要通过脏页存活时间（dirty_expire_seconds) 和刷新周期（dirty_writeback_centisecs）两个参数来配置。</p>
<p>两个配置默认都是 1&#x2F;100，也就说时间间隔为每秒 100 次，根据刷新周期的配置周期性执行刷新，刷新会检查脏页的存活时间是否超过配置的最大存活时间，如果是则刷入硬盘。</p>
<p>同时，操作系统也提供了第三种方法<strong>程序手动强制刷新</strong>，你可以通过系统提供的 sync()&#x2F;msync()&#x2F;fsync() 调用来强制刷新缓存。</p>
<p>消息队列一般会同时提供：是否同步刷盘、刷盘的时间周期、刷盘的空间比例三个配置项，让业务根据需要调整自己的刷新策略。从性能的角度看，异步刷新肯定是性能最高的，同步刷新是可靠性最高的。</p>
<h2 id="2-随机写和顺序写"><a href="#2-随机写和顺序写" class="headerlink" title="2. 随机写和顺序写"></a>2. 随机写和顺序写</h2><p>首先，随机写和顺序写都是针对硬盘的，是整个操作系统和硬盘的关系，而不是单文件和硬盘的关系。搞清楚这一点，就需要考虑<strong>单文件顺序写入硬盘</strong>和<strong>多文件顺序写入硬盘</strong>，从硬盘角度看，他们都是顺序的吗？</p>
<p>单文件顺序写入硬盘很简单，硬盘控制器只需在连续的存储区域写入数据，对硬盘来讲，数据就是顺序写入的。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719105647355.png" alt="image-20230719105647355" style="zoom: 80%;" />

<p>多文件顺序写入硬盘，系统中有很多文件同时写入，这个时候从硬盘的视角看，你会发现操作系统同时对多个不同的存储区域进行操作，硬盘控制器需要同时控制多个数据的写入，所以从硬盘的角度是随机写的。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719105709022.png" alt="image-20230719105709022"></p>
<p>所以，在消息队列中，实现随机写和顺序写的核心就是<strong>数据存储结构的设计</strong>。</p>
<p>在上一篇博客中写过，数据存储结构设计有两个思路：每个 Partition&#x2F;Queue 单独一个存储文件，每台节点上所有 Partition&#x2F;Queue 的数据都存储在同一个文件。</p>
<p>第一种方案，对单个文件来说读和写都是顺序的，性能最高，但当文件很多且都有读写，在硬盘层面就会退化为随机读写，性能会下降很多。</p>
<p>第二种方案，因为只有一个文件，不存在文件过多的情况，写入层面一直都会是顺序的，性能一直很高。所以为了提高写的性能，可以采用第二种方案。</p>
<h1 id="提升写入操作的可靠性"><a href="#提升写入操作的可靠性" class="headerlink" title="提升写入操作的可靠性"></a>提升写入操作的可靠性</h1><p>因为数据是先写入内存，然后刷到磁盘，那么没刷之前就有丢失的风险。</p>
<p>为了提高数据可靠性，在消息队列的存储模块中，一般会通过三种处理手段：同步刷盘、WAL 预写日志、多副本备份，进一步提升数据的可靠性。</p>
<h2 id="1-同步刷盘"><a href="#1-同步刷盘" class="headerlink" title="1. 同步刷盘"></a>1. 同步刷盘</h2><p>同步刷盘指每条数据都同步刷盘，等于回到了直接写硬盘的逻辑，一般通过写入数据后调用 force() 操作来完成数据刷盘。这种办法相当于省略了内存那一步，直接写入磁盘，效率比较低。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719110348072.png" alt="image-20230719110348072" style="zoom: 80%;" />

<h2 id="2-WAL"><a href="#2-WAL" class="headerlink" title="2. WAL"></a>2. WAL</h2><p>WAL（预写日志）指在写数据之前先写日志，当出现数据丢失时通过日志来恢复数据，避免数据丢失。但是WAL 日志需要写入持久存储，业务数据也要写入缓存，多了一步，性能会不会降低呢？</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719110506254.png" alt="image-20230719110506254" style="zoom:80%;" />

<p>从理论来看，WAL 机制肯定会比直接写入缓存中的性能低。但我们实际落地的时候往往可以通过一些手段来优化，降低影响，达到性能要求。</p>
<p>在消息队列中，消息的量很大，我们不可能采用性能很高的存储设备，但是日志的量比较小，而且可顺序存储。所以<strong>在实际落地中，我们可以采取 WAL 日志盘和实际数据盘分离的策略，提升 WAL 日志的写入速度</strong>。</p>
<p>具体就是让 WAL 数据盘是高性能、低容量的数据盘，存储消息的数据盘是性能较低、容量较大的数据盘，如果出现数据异常，就通过 WAL 日志进行数据恢复。</p>
<h2 id="3-多副本的备份"><a href="#3-多副本的备份" class="headerlink" title="3. 多副本的备份"></a>3. 多副本的备份</h2><p>多副本的备份就是将数据拷贝到多台节点，每台节点都写入到内存中，从而完成数据的可靠性存储。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719111128096.png" alt="image-20230719111128096" style="zoom:80%;" />

<p>好处是可以在分布式存储的基础上做优化，通过多台缓存的手段来降低数据丢失的概率。但是如果所有节点在同一时刻重启，数据还是有可能丢失的，无法保证百分百的数据高可靠。</p>
<p>从消息队列业界的存储方案来看，方案一所有产品都会支持，方案二和方案三一般会选一种支持，Kakfa、RabbitMQ、RocketMQ 用的是第三种，Pulsar 用的是第二种。</p>
<h1 id="提升读取操作的性能"><a href="#提升读取操作的性能" class="headerlink" title="提升读取操作的性能"></a>提升读取操作的性能</h1><p>提高读取的性能主要有读热数据、顺序读、批量读、零拷贝四个思路。</p>
<h2 id="1-冷读和热读"><a href="#1-冷读和热读" class="headerlink" title="1. 冷读和热读"></a>1. 冷读和热读</h2><p>热读是指消息数据本身还在缓存中，读取数据是从内存中获取，此时性能最高，不需要经过硬盘。冷读是指消息数据刷到硬盘中了，并且数据已经被换页换出缓存了，此时读取数据需要从硬盘读取。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719111256980.png" alt="image-20230719111256980" style="zoom: 80%;" />

<p>理想情况，肯定全部是热读最好，因为性能最高。但是在代码层面，我们是无法控制冷读或热读的，只能通过配置更大的内存，尽量保证缓存中保留更多的数据，从而提高热读的概率。</p>
<h2 id="2-顺序读、随机读、批量读"><a href="#2-顺序读、随机读、批量读" class="headerlink" title="2. 顺序读、随机读、批量读"></a>2. 顺序读、随机读、批量读</h2><p>为了实现大吞吐，在消费的时候服务端都会支持批量读的能力。为了能尽快返回数据给客户端，服务端都会实现数据的预读机制。在读取数据的时候，也读取客户下一步可能会用的数据，预先加载到内存中，以便更快返回数据。</p>
<p>数据的预读分为两种：硬盘层面预读、应用程序的预读。</p>
<p>硬盘层面的预读，是在连续的地址空间中读取数据。<strong>但具体实现，我们在程序中无法控制，这和数据目录存储结构设计有关。</strong></p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719111635117.png" alt="image-20230719111635117"></p>
<p>上图是两种数据存储结构的设计，第一种由于每个分区一个文件，读取一个分区时数据都是连续的，预读很方便，只要在硬盘上读取连续的数据块即可。而第二种设计方案，需要根据分区的索引，在具体存储文件的不同位置进行读取，预读有很大的随机成分，效率不如第一种。</p>
<h2 id="3-零拷贝原理和使用方式"><a href="#3-零拷贝原理和使用方式" class="headerlink" title="3. 零拷贝原理和使用方式"></a>3. 零拷贝原理和使用方式</h2><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719111938059.png" alt="image-20230719111938059" style="zoom:67%;" />

<p>如上图所示，在正常读取数据的过程中，数据要经过五步，硬盘 -&gt; ReadBuffer -&gt; 应用程序 -&gt; SocketBuffer -&gt; 网卡设备，四次复制。因为数据在复制过程耗费资源和时间，会降低性能，所以优化流程最重要的是减少数据复制的次数和资源损耗。</p>
<p>零拷贝指的是数据在<strong>内核空间</strong>和<strong>用户空间</strong>之间的拷贝次数，即图中的第 2 步和第 3 步。</p>
<p>如果只有 1 和 4 两步，没有执行 2 和 3 的话，那么内核空间和用户空间之间的拷贝次数就是零，“零拷贝”的零指的是这个次数“零”，因此是零拷贝。</p>
<p><strong>主要思路是通过减少数据复制次数、减少上下文（内核态和用户态）切换次数、通过 DMA（直接内存）代替 CPU 完成数据读写，来解决复制和资源损耗的问题。</strong></p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719112126032.png" alt="image-20230719112126032" style="zoom:80%;" />

<p>红色的线即为零拷贝优化后的结果。</p>
<p>优化后，数据链路赋值变为了硬盘 -&gt; ReadBuffer -&gt; 网卡设备，从4次变为了2次，而且减少用户态和核心态的切换，并且使用DMA来搬运数据，释放了CPU。</p>
<p>零拷贝主要用于在消费的时候提升性能，具体有两种实现方式：<strong>mmap+write 和 sendfile</strong>。</p>
<p>mmap 是一种内存映射文件的方法，把文件或者其他对象映射到进程的地址空间，修改内存文件也会同步修改，这样就减少了一次数据拷贝。所以，我们不需要把数据拷贝到用户空间，修改后再回写到内核空间。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719112520577.png" alt="image-20230719112520577" style="zoom:80%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 正常的“读取数据并发送”流程是通过 read + write 完成的</span><br><span class="line">read(file, tmp_buf, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br><span class="line"></span><br><span class="line"># 而操作系统层面的 read()，系统在调用的过程中，会把内核缓冲区的数据拷贝到用户的缓冲区里，为了减少这一步开销，我们可以用 mmap() # 替换 read() 系统调用函数。</span><br><span class="line">buf = mmap(file, len);</span><br><span class="line">write(sockfd, buf, len);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Java NIO 包的 FileChannel 的 map 方法</span></span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">fc</span> <span class="operator">=</span> f.getChannel();</span><br><span class="line"><span class="type">MappedByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> fc.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<p>在 Java 中也可以使用零拷贝技术，主要是在 NIO FileChannel 类中。</p>
<ul>
<li><p>transferTo() 方法：可以将数据从 FileChannel 直接传输到另外一个 Channel。</p>
</li>
<li><p>transferFrom() 方法：可以将数据从 Channel 传输到 FileChannel。</p>
</li>
</ul>
<h1 id="通过硬件和系统优化提升性能"><a href="#通过硬件和系统优化提升性能" class="headerlink" title="通过硬件和系统优化提升性能"></a>通过硬件和系统优化提升性能</h1><p>从硬件和系统优化提升性能的角度，主要可以通过提升硬件配置（如内存或硬盘）、配置多盘读写、配置硬盘阵列三个手段来提高集群的性能。</p>
<h2 id="1-提升硬件配置"><a href="#1-提升硬件配置" class="headerlink" title="1. 提升硬件配置"></a>1. 提升硬件配置</h2><h2 id="2-配置多盘读写"><a href="#2-配置多盘读写" class="headerlink" title="2. 配置多盘读写"></a>2. 配置多盘读写</h2><p>这种方案要内核支持这个机制，在部署的时候进行相关配置才能生效。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719112927310.png" alt="image-20230719112927310" style="zoom:80%;" />

<p>一般实现思路是在消息队列的内核支持多目录读写的能力，将不同的文件或者不同的数据段调度存放在不同硬盘设备对应的挂载目录中。此时在数据的写入和读取的过程中，就可以同时利用到多块盘的吞吐和存储。</p>
<h2 id="3-配置-RAID-和-LVM-硬盘阵列"><a href="#3-配置-RAID-和-LVM-硬盘阵列" class="headerlink" title="3. 配置 RAID 和 LVM 硬盘阵列"></a>3. 配置 RAID 和 LVM 硬盘阵列</h2><p>多目录读写的问题是多块盘之间无法共享 IO 能力和存储空间，当遇到数据倾斜时，在单机层面会出现性能和容量瓶颈。Linux 提供了 RAID 硬盘阵列和 LVM 逻辑卷管理两种方式，通过串联多块盘的读写能力和容量，提升硬盘的性能和吞吐能力。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719113032364.png" alt="image-20230719113032364" style="zoom:80%;" />

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入拆解消息队列 47 讲》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列存储之功能实现</title>
    <url>/2023/07/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%98%E5%82%A8%E4%B9%8B%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>存储模块的主流程是数据的写入、存储、读取、过期，因为消息队列本质是做一个缓冲，它的持久化在一定时间或者数据被消费后需要删除。</p>
<p>消息队列中的数据一般分为<strong>元数据和消息数据</strong>。元数据是指 Topic、Group、User、ACL、Config 等集群维度的资源数据信息，消息数据指客户端写入的用户的业务数据。</p>
<h1 id="元数据信息的存储"><a href="#元数据信息的存储" class="headerlink" title="元数据信息的存储"></a>元数据信息的存储</h1><p>元数据信息的特点是数据量比较小，不会经常读写，但是需要保证数据的强一致和高可靠，不允许出现数据的丢失。同时，元数据信息一般需要通知到所有的 Broker 节点，Broker 会根据元数据信息执行具体的逻辑。比如创建 Topic 并生成元数据后，就需要通知对应的 Broker 执行创建分区、创建目录等操作。</p>
<p>所以元数据信息的存储，一般有两个思路：</p>
<ul>
<li><p>基于第三方组件来实现元数据的存储。</p>
</li>
<li><p>在集群内部实现元数据的存储。</p>
</li>
</ul>
<p><strong>基于第三方组件来实现元数据的存储是目前业界的主流选择。</strong>比如 Kakfa 和 Pulsar 的元数据存储在 ZooKeeper 中，RocketMQ 存储在 NameServer 中。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230718110010031.png" alt="image-20230718110010031"></p>
<p>优点是集成方便，而且第三方软件已经保证了一致性，高性能等需求，可以降低开发成本。</p>
<p>但也有缺点。引入第三方组件会增加系统部署和运维的复杂度，而且第三方组件自身的稳定性问题会增加系统风险，第三方组件和多台 Broker 之间可能会出现数据信息不一致的情况，导致读写异常。</p>
<h1 id="消息数据的存储"><a href="#消息数据的存储" class="headerlink" title="消息数据的存储"></a>消息数据的存储</h1><p>消息队列的存储主要是指消息数据的存储，分为存储结构、数据分段、数据存储格式、数据清理四个部分。</p>
<h2 id="数据存储结构设计"><a href="#数据存储结构设计" class="headerlink" title="数据存储结构设计"></a>数据存储结构设计</h2><p>在消息队列中，跟存储有关的主要是 Topic 和分区两个维度。用户可以将数据写入 Topic 或直接写入到分区。</p>
<p>如果写入 Topic，数据也是分发到多个分区去存储的。所以从实际数据存储的角度来看，<strong>Topic 和 Group 不承担数据存储功能，承担的是逻辑组织的功能，实际的数据存储是在在分区维度完成的</strong>。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230718110640501.png" alt="image-20230718110640501"></p>
<p>而数据的罗盘也有两种思路：</p>
<ol>
<li>每个分区单独一个存储“文件”。</li>
<li>每个节点上所有分区的数据都存储在同一个“文件”。</li>
</ol>
<p>这里的“文件”是一个虚指，即表示所有分区的数据是存储在一起，还是每个分区的数据分开存储的意思。</p>
<h3 id="第一种思路"><a href="#第一种思路" class="headerlink" title="第一种思路"></a>第一种思路</h3><p>每个分区的数据对应一个文件去存储，在实现上每个分区的数据是顺序写入到同一个磁盘文件中，数据是连续的，所以读写性能上效率最高。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230718112210221.png" alt="image-20230718112210221"></p>
<p>但如果分区太多，会占用太多的系统 FD 资源，极端情况下有可能把节点的 FD 资源耗完，并且硬盘层面会出现大量的随机写情况，导致写入的性能下降很多，另外管理起来也相对复杂。（fd是是<strong>内核为了高效管理这些已经被打开的文件所创建的一种索引</strong>，如果太多分区，相当于很多个文件在同时读写，虽然每个分区内文件是顺序读写的，但是分区之间并不是顺序，而是随机的，所以会导致磁盘层面大量的随机读写）</p>
<p>具体的磁盘组织结构：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230718111845083.png" alt="image-20230718111845083"></p>
<h3 id="第二种思路"><a href="#第二种思路" class="headerlink" title="第二种思路"></a>第二种思路</h3><p>每个节点上所有分区的数据都存储在同一个文件中，这种方案需要为每个分区维护一个对应的索引文件，索引文件里会记录每条消息在 File 里面的位置信息，以便快速定位到具体的消息内容。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230718112137877.png" alt="image-20230718112137877"></p>
<p>因为<strong>所有文件都在一份文件上，管理简单，也不会占用过多的系统 FD 资源，单机上的数据写入都是顺序的，写入的性能会很高</strong>。</p>
<p>缺点是同一个分区的数据一般会在文件中的不同位置，或者不同的文件段中，无法利用到顺序读的优势，读取的性能会受到影响。</p>
<h2 id="消息数据的分段实现"><a href="#消息数据的分段实现" class="headerlink" title="消息数据的分段实现"></a>消息数据的分段实现</h2><p>数据分段的规则一般是根据大小来进行的，比如默认 1G 一个文件，同时会支持配置项调整分段数据的大小。从技术上来看，当数据段到达了规定的大小后，就会新创建一个新文件来保存数据。</p>
<p>如果进行了分段，消息数据可能分布在不同的文件中。所以我们在读取数据的时候，需要先定位消息数据在哪个文件中。为了满足这个需求，技术上一般有根据<strong>偏移量定位</strong>或根据<strong>索引定位</strong>两种思路。</p>
<h3 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h3><p>根据偏移量（Offset）来定位消息在哪个分段文件中，是指通过记录每个数据段文件的起始偏移量、中止偏移量、消息的偏移量信息，来快速定位消息在哪个文件。</p>
<p>当消息数据存储时，通常会用一个自增的数值型数据（比如 Long）来表示这条数据在分区或 commitlog 中的位置，这个值就是消息的偏移量。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230718112847872.png" alt="image-20230718112847872" style="zoom:80%;" />

<p>在实际的编码过程中，记录文件的起始偏移量一般有两种思路：单独记录每个数据段的起始和结束偏移量，在文件名称中携带起始偏移量信息。因为数据是顺序存储的，每个文件记录了本文件的起始偏移量，那么下一个文件的起始偏移量就是上一个文件的结束偏移量。</p>
<h3 id="索引定位"><a href="#索引定位" class="headerlink" title="索引定位"></a>索引定位</h3><p>如果用索引定位，会直接存储消息对应的文件信息，而不是通过偏移量来定位到具体文件。</p>
<p>具体是通过维护一个单独的索引文件，记录消息在哪个文件和文件的哪个位置。读取消息的时候，先根据消息 ID 找到存储的信息，然后找到对应的文件和位置，读取数据。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><strong>这两种方案所面临的场景不一样。</strong></p>
<p>根据偏移量定位数据，通常用在每个分区各自存储一份文件的场景；根据索引定位数据，通常用在所有分区的数据存储在同一份文件的场景。</p>
<p>因为在前一种场景，每一份数据都属于同一个分区，那么通过位点来二分查找数据的效率是最高的。</p>
<p>第二种场景，这一份数据属于多个不同分区，则通过二分查找来查找数据效率很低，用哈希查找效率是最高的。</p>
<h2 id="消息数据存储格式"><a href="#消息数据存储格式" class="headerlink" title="消息数据存储格式"></a>消息数据存储格式</h2><p>消息数据存储格式一般包含消息写入文件的格式和消息内容的格式两个方面。</p>
<p><strong>消息写入文件的格式指消息是以什么格式写入到文件中的</strong>，比如 JSON 字符串或二进制。从性能和空间冗余的角度来看，消息队列中的数据基本都是以二进制的格式写入到文件的。</p>
<p><strong>消息内容的格式是指写入到文件中的数据都包含哪些信息。</strong>对于一个成熟的消息队列来说，消息内容格式不仅关系功能维度的扩展，还牵涉性能维度的优化。</p>
<h2 id="消息数据清理机制"><a href="#消息数据清理机制" class="headerlink" title="消息数据清理机制"></a>消息数据清理机制</h2><p>消息队列的数据过期机制一般有手动删除和自动删除两种形式，从实现上看主要有三种思路。</p>
<ul>
<li>消费完成执行 ACK 删除数据</li>
<li>根据时间和保留大小删除</li>
<li>ACK 机制和过期机制相结合</li>
</ul>
<h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><p><strong>消费完成执行 ACK 删除数据，技术上的实现思路一般是</strong>：当客户端成功消费数据后，回调服务端的 ACK 接口，告诉服务端数据已经消费成功，服务端就会标记删除该行数据，以确保消息不会被重复消费。ACK 的请求一般会有单条消息 ACK 和批量消息 ACK 两种形式。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230718113808956.png" alt="image-20230718113808956" style="zoom: 80%;" />

<p>因为消息队列的 ACK 一般是顺序的，如果前一条消息无法被正确处理并 ACK，就无法消费下一条数据，导致消费卡住。此时就需要死信队列的功能，把这条数据先写入到死信队列，等待后续的处理。然后 ACK 这条消息，确保消费正确进行。</p>
<p>这个方案，优点是不会出现重复消费，一条消息只会被消费一次。缺点是 ACK 成功后消息被删除，无法满足需要消息重放的场景。</p>
<h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><p><strong>根据时间和保留大小删除指消息在被消费后不会被删除，只会通过提交消费位点的形式标记消费进度。</strong></p>
<p>实现思路一般是服务端提供偏移量提交的接口，当客户端消费成功数据后，客户端会回调偏移量提交接口，告诉服务端这个偏移量的数据已经消费成功了，让服务端把偏移量记录起来。然后服务端会根据消息保留的策略，比如保留时间或保留大小来清理数据。一般通过一个常驻的异步线程来清理数据。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230718114135696.png" alt="image-20230718114135696" style="zoom:67%;" />

<p>这个方案，一条消息可以重复消费多次。不管有没有被成功消费，消息都会根据配置的时间规则或大小规则进行删除。优点是消息可以多次重放，适用于需要多次进行重放的场景。缺点是在某些情况下（比如客户端使用不当）会出现大量的重复消费。</p>
<h3 id="方案3"><a href="#方案3" class="headerlink" title="方案3"></a>方案3</h3><p>我们结合前两个方案，就有了 <strong>ACK 机制和过期机制相结合的方案</strong>。实现核心逻辑跟方案二很像，但保留了 ACK 的概念，不过 ACK 是相对于 Group 概念的。</p>
<p>当消息完成后，在 Group 维度 ACK 消息，此时消息不会被删除，只是这个 Group 也不会再重复消费到这个消息，而新的 Group 可以重新消费订阅这些数据。所以在 Group 维度避免了重复消费的情况，也可以允许重复订阅。（说白了，一条消息在一个Group消费后会发送一个ACK确认，然后此Group就不会再消费该消息了，但是其他的Group还是可以重复的消费该消息，如果超过时间，则该消息被删除，其他Group也无法订阅）</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230718114619550.png" alt="image-20230718114619550" style="zoom:67%;" />

<p>我们知道消息数据是顺序存储在文件中的，会有很多分段数据，一个文件可能会有很多行数据。</p>
<p>那么在 ACK 或者数据删除的时候，一个文件中可能既存在可删除数据，也存在不可删除数据。</p>
<p>如果我们每次都立即删除数据，需要不断执行“读取文件、找到记录、删除记录、写入文件”的过程，即使批量操作，降低频率，还是得不断地重复这个过程，会导致性能明显下降。</p>
<p>当前主流的思路都是<strong>延时删除，以段数据为单位清理</strong>，降低频繁修改文件内容和频繁随机读写文件的操作。</p>
<p>只有该段里面的数据都允许删除后，才会把数据删除。而删除该段数据中的某条数据时，会先对数据进行标记删除，比如在内存或 Backlog 文件中记录待删除数据，然后在消费的时候感知这个标记，这样就不会重复消费这些数据。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/1090617-20190626173042073-147043337.jpg" alt="img"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入拆解消息队列 47 讲》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>消费客户端的SDK（下）</title>
    <url>/2023/07/22/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E8%B4%B9%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84SDK%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<p>这里介绍上篇剩下的三部分，也就是消费分组（订阅）、消费确认、消费失败处理。</p>
<h1 id="消费分组"><a href="#消费分组" class="headerlink" title="消费分组"></a>消费分组</h1><p>消费分组是用来组织消费者、分区、消费进度关系的逻辑概念。</p>
<p>在没有消费分组直接消费 Topic 的场景下，如果希望不重复消费 Topic 中的数据，那么就<strong>需要有一个标识来标识当前的消费情况，比如记录进度。</strong>这个唯一标识就是消费分组。</p>
<p>消费分组主要有管理消费者和分区的对应关系、保存消费者的消费进度、实现消息可重复被消费三类功能。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230722104248529.png" alt="image-20230722104248529" style="zoom:80%;" />

<p>因为 Topic 不存储真实数据，分区才存储消息数据，所以就需要解决消费者和分区的分配关系，即<strong>哪个分区被哪个消费者消费，这个分配的过程就叫做消费重平衡（Rebalance）</strong>。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230722104350416.png" alt="image-20230722104350416" style="zoom:80%;" />

<p>由上图可以看出，当新增一个消费分组时，为了使得消费平衡，就需要重新分配消费关系。</p>
<h2 id="协调者"><a href="#协调者" class="headerlink" title="协调者"></a>协调者</h2><p>如果要对消费者和分区进行分配，肯定需要有一个模块拥有消费分组、所有的消费者、分区信息三部分信息，这个模块我们一般命名为<strong>协调者。</strong>协调者主要的工作就是执行消费重平衡，并记录消费分组的消费进度。</p>
<p>分区分配的操作可以在协调者内部或者消费者上完成。这两种，一种是协调者获得所有的信息，然后进行分配，分配完同步给其他的消费者。一种是一个消费者获取所有其他消费者和分区的信息，进行分配操作，之后同步给其他消费者。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230722105108840.png" alt="image-20230722105108840" style="zoom:80%;" />

<h2 id="消费分区分配策略"><a href="#消费分区分配策略" class="headerlink" title="消费分区分配策略"></a>消费分区分配策略</h2><p>分区分配策略的制定一般遵循以下三个原则：</p>
<ol>
<li>各个分区的数据能均匀地分配给每个消费者，保证所有消费者的负载最大概率是均衡的。</li>
<li>在每次重新分配的时候，尽量减少分区和消费者之间的关系变动，这样有助于加快重新分配的速度，并且保持数据处理的连续性，降低处理切换成本。</li>
<li>可以允许灵活地根据业务特性制定分配关系</li>
</ol>
<p>所有消息队列的默认策略都是相对通用的，一般都会包含有轮询、粘性、自定义三种类型的策略。</p>
<p><strong>轮询</strong>就是指用轮询的方式将分区分配给各个消费者，保证每个消费者的分区数量是尽量相同的，从而保证消费者的负载最大概率上是均衡的。但是这种方案可能导致几个流量较高的分区分给了同一个消费者，为了解决这个问题，在随机的基础上，将 Topic 的不同分区尽量打散到不同的消费者，从而保证整体消费者之间的分区是均衡的（即同一个topic下的不同partition分给不同的消费者）。</p>
<p><strong>粘性</strong>是指尽量减少分区分配关系的变动，进而减少重平衡所耗费的时间和资源损耗。即当有新的分区加入，或者老的分区挂掉，在重新分配时，应尽可能减少变动。</p>
<p>自定义就是提供接口，用户自己实现。</p>
<h1 id="消费确认"><a href="#消费确认" class="headerlink" title="消费确认"></a>消费确认</h1><p>当消息被消费时，就必须进行消费确认，即告诉服务端这条消息已经被消费了，也就是常说的ACK。</p>
<p>一般情况下，消息确认分为确认后删除数据和确认后保存消费进度数据两种形式。</p>
<p><strong>确认后删除数据</strong>是指集群的每条消息只能被消费一次，只要数据被消费成功，就会回调服务端的 ACK 接口，服务端就会执行数据删除操作。这种方案不利于回溯，所以用的不多。</p>
<p><strong>消费成功保存消费进度</strong>是指当消费数据成功后，调用服务端的消费进度接口来保存消费进度。这种方式一般都是配合消费分组一起用的，服务端从消费分组维度来保存进度数据。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230722110620707.png" alt="image-20230722110620707"></p>
<p>为了保证消息的回溯和多次消费，一般都采用这种方案。<strong>数据的删除交由数据过期策略去执行。</strong></p>
<p>保存消费进度一般分为服务端保存和客户端自定义保存两种实现机制。</p>
<p><strong>服务端保存</strong>是指服务端提供一个接口用于保存数据，客户端调用即可。服务端一般会通过内置的 Topic 或者文件来持久保存该数据。</p>
<p>在提交位点信息的时候，底层一般支持自动提交和手动提交两种实现。</p>
<ul>
<li><strong>自动提交</strong>一般是根据时间批次或数据消费到客户端后就自动提交，提交过程客户无感知。</li>
<li><strong>手动提交</strong>是指业务根据自己的处理情况，手动提交进度信息，以避免业务处理异常导致的数据丢失。</li>
</ul>
<p>优缺点如下：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230722111121025.png" alt="image-20230722111121025" style="zoom:80%;" />

<p><strong>客户端自定义保存</strong>是指当消费完成后，客户端自己管理保存消费进度。</p>
<h1 id="消费失败处理"><a href="#消费失败处理" class="headerlink" title="消费失败处理"></a>消费失败处理</h1><p>一个完整的消费流程包括消费数据、本地业务处理、消费进度提交三部分，那么从消费失败的角度来看，就应该分为从服务端拉取数据失败、本地业务数据处理失败、提交位点信息失败三种情况。</p>
<p><strong>从服务端拉取数据失败</strong>，和客户端的错误逻辑处理是一致的，根据可重试错误和不可重试错误的分类，进行重复消费或者向上抛错。</p>
<p><strong>本地业务数据处理失败</strong>，如果是偶尔失败，那么在业务层做好重试处理逻辑，配合手动提交消费进度的操作即可解决。如果是一直失败，即使重试多次也无法被解决，此时如果一直重试，就会出现消费卡住的情况，这就需要配合死信队列的功能，将无法被处理的数据投递到死信队列中，从而保存异常数据并保证消费进度不阻塞。</p>
<p><strong>提交位点信息失败</strong>，其处理方法通常是一直重试，重复提交，如果持续失败就向上抛错。因为如果提交进度失败，即使再从服务端拉取数据，还是会拉到同一批数据，出现重复消费的问题。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入拆解消息队列 47 讲》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>消费客户端的SDK（上）</title>
    <url>/2023/07/21/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E8%B4%B9%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84SDK%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<p>从实现来看，消费相关功能包括<strong>消费模型</strong>、<strong>分区消费模式</strong>、<strong>消费分组（订阅）</strong>、<strong>消费确认</strong>、<strong>消费失败处理</strong>五个部分。</p>
<p>这里只涉及到前两个部分。</p>
<h1 id="消费模型的选择"><a href="#消费模型的选择" class="headerlink" title="消费模型的选择"></a>消费模型的选择</h1><p>为了满足不同场景的业务需求，从实现机制上来看，主流消息队列一般支持 Pull、Push、Pop 三种消费模型。</p>
<h2 id="Pull-模型"><a href="#Pull-模型" class="headerlink" title="Pull 模型"></a>Pull 模型</h2><p>Pull（拉）模型是指客户端通过不断轮询的方式向服务端拉取数据。它是消息队列中使用最广泛和最基本的模型，主流的消息队列都支持这个模型。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230721105121747.png" alt="image-20230721105121747"></p>
<p>它的好处是客户端根据自身的处理速度去拉取数据，不会对客户端和服务端造成额外的风险和负载压力。缺点是可能会出现大量无效返回的 Pull 调用（服务端没有数据可以拉去时），另外消费及时性不够。</p>
<p>为了提高性能，Pull是可以指定一次拉去多少条数据，然后传递给服务端，即批量拉取。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230721105516142.png" alt="image-20230721105516142" style="zoom:80%;" />

<p>如上图，如果Topic1的数据已经被消费完，但是客户端还是不断的发请求拉数据，那么就会导致资源的浪费。</p>
<p>为了解决这个问题，一般服务端会协助处理，有如下两个思路：</p>
<h3 id="1-服务端-hold-住请求"><a href="#1-服务端-hold-住请求" class="headerlink" title="1. 服务端 hold 住请求"></a>1. 服务端 hold 住请求</h3><p>当客户端根据策略拉取数据时，如果没有足够的数据，就先在服务端等一段时间，等有数据后一起返回给客户端。</p>
<p>好处是可以尽可能提高吞吐率，而且不会有太多的空请求。</p>
<p>缺点是如果长时间没有消息，则会导致消费者请求超时，而且如果数据长时间不够，则会提高消费时延。</p>
<h3 id="2-服务端有数据的时候通知客户端"><a href="#2-服务端有数据的时候通知客户端" class="headerlink" title="2. 服务端有数据的时候通知客户端"></a>2. 服务端有数据的时候通知客户端</h3><p>当服务端不 hold 住请求，立刻返回空数据，客户端收到空数据时则不再发起请求，会等待服务端的通知。当服务端有数据的时候，再主动通知客户端来拉取。</p>
<p>这种方案的好处是可以及时通知客户端来拉取数据，从而降低消费延时。</p>
<p>缺点是因为客户端和服务端一般是半双工的通信，此时服务端是不能主动向客户端发送消息的。</p>
<p>所以在 Pull 模型中，比较合适的方案是客户端告诉服务端：<strong>最多需要多少数据、最少需要多少数据、未达到最小数据时可以等多久</strong>三个信息。然后服务端首先判断是否有足够的数据，有的话就立即返回，否则就根据客户端设置的等待时长 hold 住请求，如果超时，无论是否有数据，都会直接给客户端返回当前的结果。</p>
<h2 id="Push-模型"><a href="#Push-模型" class="headerlink" title="Push 模型"></a>Push 模型</h2><p>Push（推）模型是为了解决消费及时性而提出来的。这个模型的本意是指当服务端有数据时会主动推给客户端，让数据的消费更加及时。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230721110037813.png" alt="image-20230721110037813" style="zoom:80%;" />

<p>在实际的 Push 模型的实现上，一般有 Broker 内置 Push 功能、Broker 外独立实现 Push 功能的组件、在客户端实现伪 Push 功能三种思路。</p>
<p><strong>第一种，Broker内置Push功能是指在 Broker 中内置标准的 Push的能力，由服务端向客户端主动推送数据。</strong></p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230721110202222.png" alt="image-20230721110202222" style="zoom:80%;" />

<p>优点：Broker 自带 Push 能力，无需重复开发和部署。Broker 内部可以感知到数据堆积情况，可以保证消息被及时消费。</p>
<p>缺点：当消费者很多时，内核需要主动维护很多与第三方的长连接，并且需要处理各种客户端异常，推送数据，异常处理等比较耗费系统资源，可能会导致Broker不稳定。</p>
<p><strong>第二种，Broker 外独立实现 Push 功能的组件是指独立于 Broker 提供一个专门实现推模型的组件。</strong></p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230721110409783.png" alt="image-20230721110409783" style="zoom:80%;" />

<p>好处是将push组件独立了出来，可以保证Broker的稳定。</p>
<p>缺点是需要先pull拉去数据，然后再push，会存在较高的时延。</p>
<p><strong>第三种，在客户端实现伪 Push 功能是指在客户端内部维护内存队列，SDK 底层通过 Pull 模型从服务端拉取数据存储到客户端的内存队列中。</strong>然后通过回调的方式，触发用户设置的回调函数，将数据推送给应用程序，在使用体验上看就是 Push 的效果。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230721110735383.png" alt="image-20230721110735383" style="zoom: 80%;" />

<p>这种方案的好处在于通过客户端底层的封装，从用户体验看是 Push 模型的效果，解决用户代码层面的不断轮询问题。</p>
<p>缺点是底层依旧是 Pull 模型，还是得通过不断轮询的方式去服务端拉取数据，就会遇到 Pull 模型遇到的问题。</p>
<p>因为 Push 模型需要先分配分区和消费者的关系，客户端就需要感知分区分配、分区均衡等操作，从而在客户端就需要实现比较重的逻辑。并且当客户端和订阅的分区数较多时，容易出现需要很长的重平衡时间的情况。此时为了解决这个问题，业界提出了 Pop 模型。</p>
<h2 id="Pop-模型"><a href="#Pop-模型" class="headerlink" title="Pop 模型"></a>Pop 模型</h2><p>Pop 模型想解决的是客户端实现较重，重平衡会暂停消费并且可能时间较长，从而出现消费倾斜的问题。</p>
<p>它的思路是客户端不需要感知到分区，直接通过 Pop 模型提供的 get 接口去获取到数据，消费成功后 ACK 数据。就跟我们发起 HTTP 请求去服务端拉取数据一样，不感知服务端的数据分布情况，只需要拉到数据。</p>
<p>这种方案的好处是简化了消费模型，同时服务端可以感知到消费的堆积情况，可以根据堆积情况返回那些分区的数据给客户端，这样也简化了消息数据的分配策略。</p>
<p>从实现上来看，它将分区分配的工作移到了服务端，在服务端完成了消费者的分区分配、进度管理，然后暴露出了新的 Pop 和 ACK 接口。客户端调用 Pop 接口去拿取数据，消费成功后调用 ACK 去确认数据。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230721112049239.png" alt="image-20230721112049239" style="zoom:80%;" />

<h1 id="分区消费模式的设计"><a href="#分区消费模式的设计" class="headerlink" title="分区消费模式的设计"></a>分区消费模式的设计</h1><p>消息队列的数据是在 Partition&#x2F;Queue 维度承载的。所以消费过程中一个重要的工作就是消费者和分区的消费模式问题，即分区的数据能不能被多个消费者并发消费，一条数据能不能被所有消费者消费到，分区的数据能不能被顺序消费等等。</p>
<p>从技术上看，在数据的消费模式上主要有<strong>独占消费</strong>、<strong>共享消费</strong>、<strong>广播消费</strong>、<strong>灾备消费</strong>四个思路。</p>
<h2 id="独占消费"><a href="#独占消费" class="headerlink" title="独占消费"></a>独占消费</h2><p><strong>独占消费是指一个分区在同一个时间只能被一个消费者消费。</strong>在消费者启动时，会分配消费者和分区之间的消费关系。当消费者数量和分区数量都没有变化的情况下，两者之间的分配关系不会变动。</p>
<p>如果消费者数量大于分区数量，则会有消费者被空置；</p>
<p>反之，如果分区数量大于消费者数量，一个消费者则可以同时消费多个分区。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230721112545785.png" alt="image-20230721112545785" style="zoom:80%;" />

<p>独占消费的好处是可以保证分区维度的消费是有序的。缺点是当数据出现倾斜、单个消费者出现性能问题或 hang 住时，会导致有些分区堆积严重。</p>
<h2 id="共享消费"><a href="#共享消费" class="headerlink" title="共享消费"></a>共享消费</h2><p><strong>共享消费是指单个分区的数据可以同时被多个消费者消费。</strong>即分区的数据会依次投递给不同的消费者，一条数据只会投递给一个消费者。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230721112658334.png" alt="image-20230721112658334" style="zoom:80%;" />

<p>这种方式的好处是，可以避免单个消费者的性能和稳定性问题导致分区的数据堆积。缺点是无法保证数据的顺序消费。这种模式一般用在对数据的有序性无要求的场景，比如日志。</p>
<h2 id="广播消费"><a href="#广播消费" class="headerlink" title="广播消费"></a>广播消费</h2><p><strong>广播消费是指一条数据要能够被多个消费者消费到。</strong>即分区中的一条数据可以投递给所有的消费者，这种方式是需要广播消费的场景。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230721112908668.png" alt="image-20230721112908668"></p>
<p>实现广播消费一般有内核实现广播消费的模型、使用不同的消费分组消费和指定分区消费三种技术思路。</p>
<ol>
<li>内核实现广播消费的模型，指在 Broker 内核中的消息投递流程实现广播消费模式，即 Broker 投递消息时，可以将一条消息吐给不同的消费者，从而实现广播消费。</li>
<li>使用不同的消费分组对数据进行消费，指通过创建不同的消费者组消费同一个 Topic 或分区，不同的消费分组管理自己的消费进度，消费到同一条消息，从而实现广播消费的效果。</li>
<li>指定分区消费，是指每个消费者指定分区进行消费，在本地记录消费位点，从而实现不同消费者消费同一条数据，达到广播消费的效果。</li>
</ol>
<p>优缺点如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230721113216520.png" alt="image-20230721113216520"></p>
<h2 id="灾备消费"><a href="#灾备消费" class="headerlink" title="灾备消费"></a>灾备消费</h2><p><strong>灾备消费是独占消费的升级版，在保持独占消费可以支持顺序消费的基础上，同时加入灾备的消费者****。</strong>当消费者出现问题的时候，灾备消费者加入工作，继续保持独占顺序消费。</p>
<p>好处是既能保持独占顺序消费，又能保证容灾能力。缺点是无法解决消费倾斜的性能问题，另外还需要准备一个消费者来做灾备，使用成本较高。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入拆解消息队列 47 讲》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式下如何排查慢请求</title>
    <url>/2023/05/17/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8B%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E6%85%A2%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<p>在引入了注册中心后，微服务项目的架构会变成下图：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514175352625.png" alt="image-20230514175352625"></p>
<p>但是，如果此时有一个请求的响应速度比较慢，而这个请求调用了多个RPC服务，该如何去排查呢？</p>
<h1 id="一体化架构中的慢请求排查如何做"><a href="#一体化架构中的慢请求排查如何做" class="headerlink" title="一体化架构中的慢请求排查如何做"></a>一体化架构中的慢请求排查如何做</h1><p>最简单的办法，就是像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">processA();</span><br><span class="line"><span class="comment">// 打印A步骤的耗时</span></span><br><span class="line">Logs.info(<span class="string">&quot;process A cost &quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line">processB();</span><br><span class="line"><span class="comment">// 打印B步骤的耗时</span></span><br><span class="line">Logs.info(<span class="string">&quot;process B cost &quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line">processC();</span><br><span class="line"><span class="comment">// 打印C步骤的耗时</span></span><br><span class="line">Logs.info(<span class="string">&quot;process C cost &quot;</span> + (System.currentTimeMillis() - start));</span><br></pre></td></tr></table></figure>

<p>但是这样会有一个问题，如果多个用户同时下单，那么日志的打印是穿插进行的，无法判断。</p>
<p>一个简单的解决办法是，给每个请求每一行日志加一个id，用于区分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">requestId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">ThreadLocal&lt;String&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> requestId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; <span class="comment">//requestId存储在线程上下文中</span></span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">processA();</span><br><span class="line">Logs.info(<span class="string">&quot;rid : &quot;</span> + tl.get() + <span class="string">&quot;, process A cost &quot;</span> + (System.currentTimeMillis() - start)); <span class="comment">// 日志中增加requestId</span></span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line">processB();</span><br><span class="line">Logs.info(<span class="string">&quot;rid : &quot;</span> + tl.get() + <span class="string">&quot;, process B cost &quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line">processC();</span><br><span class="line">Logs.info(<span class="string">&quot;rid : &quot;</span> + tl.get() + <span class="string">&quot;, process C cost &quot;</span> + (System.currentTimeMillis() - start));</span><br></pre></td></tr></table></figure>

<h1 id="利用切面编程"><a href="#利用切面编程" class="headerlink" title="利用切面编程"></a>利用切面编程</h1><p>一般来说，切面分为两类：</p>
<ul>
<li><p>一类是静态代理，典型的代表是 AspectJ，它的特点是在编译期做切面代码注入；</p>
</li>
<li><p>另一类是动态代理，典型的代表是 Spring AOP，它的特点是在运行期做切面代码注入</p>
</li>
</ul>
<p>区别：</p>
<p>静态代理是在编译期插入代码，增加了编译的时间，给你的直观感觉就是启动的时间变长了，但是一旦在编译期插入代码完毕之后在运行期就基本对于性能没有影响。</p>
<p>而动态代理不会去修改生成的 Class 文件，而是会在运行期生成一个代理对象，这个代理对象对源对象做了字节码增强，来完成切面所要执行的操作。由于在运行期需要生成代理对象，所以动态代理的性能要比静态代理要差。</p>
<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><p>为了避免打印过多的日志，我们可以根据id进行采样，比如说只打印id % 10 &#x3D;&#x3D; 0的，这样就只统计局部的 也可以实现需求。</p>
<p>但是还有一个问题，如果这样的话，拿到一个id我们并不知道它是属于哪个服务器的，我们还需要去服务器查询。解决办法就是将日志通过消息队列插入Elasticsearch，这样搜索也比较简单。如下图：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514183317870.png" alt="image-20230514183317870"></p>
<h1 id="如何来做分布式-Trace"><a href="#如何来做分布式-Trace" class="headerlink" title="如何来做分布式 Trace"></a>如何来做分布式 Trace</h1><p>采用traceId + spanId</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514184244939.png" alt="image-20230514184244939"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>高并发系统设计</category>
        <category>微服务架构</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>生产者的SDK需要哪些设计</title>
    <url>/2023/07/20/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E7%94%9F%E4%BA%A7%E8%80%85%E7%9A%84SDK%E9%9C%80%E8%A6%81%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>生产模块包含<strong>客户端基础功能和生产相关功能</strong>两部分，如下图：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230720144646902.png" alt="image-20230720144646902"></p>
<p>基础功能是蓝色部分，生产功能是黄色部分。</p>
<h1 id="客户端基础功能"><a href="#客户端基础功能" class="headerlink" title="客户端基础功能"></a>客户端基础功能</h1><h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p>客户端和服务端之间基本都是创建 TCP 长连接进行通信的，为了避免连接数膨胀，每个客户端实例和每台 Broker 只会维护一条 TCP 连接。</p>
<p>分为两种：</p>
<ul>
<li><strong>初始化创建连接</strong>，指在实例初始化时就创建到各个 Broker 的 TCP 连接，等待数据发送。这种可能会导致连接空跑，会消耗一定的资源。</li>
<li><strong>使用时创建链接</strong>，指在实例初始化时不建立连接，当需要发送数据时再建立。可能出现连接冷启动，会增加一点本次请求的耗时。</li>
</ul>
<h2 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h2><p>消息队列一般都是基于 TCP 协议通信的，所以客户端和服务端之间的心跳检测机制的实现，一般有基于 TCP 的 KeepAlive 保活机制和应用层主动探测两种形式。</p>
<p><strong>基于 TCP 的 KeepAlive 保活机制</strong>是 TCP&#x2F;IP 协议层内置的功能，需要手动打开，优点是简单，缺点是需要Server主动发出检测包，当客户端出现故障而Server没有发包时，可能会出现不可用的TCP连接占用服务器资源。</p>
<p><strong>应用层主动探测</strong>一般是 Client 向 Server 发起的，探测流程一般是客户端定时发送保活心跳，当服务端连续几次没收到请求，就断开连接。可以降低服务端压力。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>从请求的角度，有些错误是重试可以恢复的，比如连接断开、Leader 切换、发送偶尔超时、服务端某些异常等；有些错误是不可恢复的，比如 Topic&#x2F; 分区不存在、服务端 Broker 不存在、集群和 Broker 长时间无响应等。</p>
<p>所以，在客户端的处理中也会将错误分为可重试错误和不可重试错误两类。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230720145133022.png" alt="image-20230720145133022"></p>
<p>可重试指的是那些因为网络波动，Leader切换等异常，重试之后有可能解决的错误，不可重试的错误就是不管如何重试都无法恢复的异常。</p>
<h2 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h2><p>重试策略一般会支持重试次数和退避时间的概念。当消息失败，超过设置的退避时间后，会继续重试，当超过重试次数后，就会抛弃消息或者将消息投递到配置好的重试队列中。</p>
<p>退避策略影响的是重试的成功率，因为网络抖动正常是 ms 级，某些异常可能会抖动十几秒。此时，如果退避策略设置得太短，在退避策略和重试次数用完后，可能消息还没生产成功；如果退避时间设置太长，可能导致客户端发送堵塞消息堆积。</p>
<h1 id="生产相关功能"><a href="#生产相关功能" class="headerlink" title="生产相关功能"></a>生产相关功能</h1><h2 id="客户端寻址机制"><a href="#客户端寻址机制" class="headerlink" title="客户端寻址机制"></a>客户端寻址机制</h2><p>消息队列作为一个分布式系统，分区会分布在集群的不同节点上。那么客户端给服务端发送数据时，要发给哪台节点呢？</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230720145523867.png" alt="image-20230720145523867" style="zoom:80%;" />

<p>一种思路是：手动指定目标 Broker 的 IP，就是说在生产者写数据到 Broker 的时候，在代码里面手动指定分区对应的对端的 Broker 地址，然后将数据写到目标 Broker。</p>
<p>为了解决查找分区在Broker上的对应关系，业界提出了 Metadata（元数据）寻址机制和服务端内部转发两个思路。</p>
<h3 id="1-Metadata（元数据）寻址机制"><a href="#1-Metadata（元数据）寻址机制" class="headerlink" title="1. Metadata（元数据）寻址机制"></a>1. Metadata（元数据）寻址机制</h3><p>服务端会提供一个获取全量的 Metadata 的接口，客户端在启动时，首先通过接口拿到集群所有的元数据信息，本地缓存这部分数据信息。然后，客户端发送数据的时候，会根据元数据信息的内容，得到服务端的地址是什么，要发送的分区在哪台节点上。最后根据这两部分信息，将数据发送到服务端。</p>
<p>简而言之，通过接口查到对应的数据，下次请求时带上就可以了。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230720150122612.png" alt="image-20230720150122612"></p>
<p>消息队列的元数据是指 Topic、分区、Group、节点、配置等集群维度的信息。比如 Topic 有几个分区，分区的 Leader 和 Follower 在哪些节点上，节点的 IP 和端口是什么，有哪些 Group 等等。</p>
<h3 id="2-服务端内部转发机制"><a href="#2-服务端内部转发机制" class="headerlink" title="2. 服务端内部转发机制"></a>2. 服务端内部转发机制</h3><p>另外一种服务端内部转发机制，客户端不需要经过寻址的过程，写入的时候是随机把数据写入到服务端任意一台 Broker。</p>
<p>具体思路是服务端的每一台 Broker 会缓存所有节点的元数据信息，生产者将数据发送给 Broker 后，Broker 如果判断分区不在当前节点上，会找到这个分区在哪个节点上，然后把数据转发到目标节点。</p>
<p>简单来说就是随便发到任意一个Broker中，然后他们之间有类似路由信息，Broker之间再进行转发。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230720150320170.png" alt="image-20230720150320170"></p>
<h2 id="生产分区分配策略"><a href="#生产分区分配策略" class="headerlink" title="生产分区分配策略"></a>生产分区分配策略</h2><p>数据可以直接写入分区或者写入 Topic。写入 Topic 时，最终数据还是要写入到某个分区。这个数据选择写入到哪个分区的过程，就是生产数据的分区分配过程。过程中的分配策略就是生产分区分配策略。</p>
<p>一般情况下，消息队列默认支持轮询、按 Key Hash、手动指定、自定义分区分配策略四种分区分配策略。</p>
<h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p><strong>轮询</strong>是所有消息队列的默认选项。消息通过轮询的方式依次写入到各个分区中，这样可以保证每个分区的数据量是一样的，不会出现分区数据倾斜。</p>
<p>但是如果我们需要保证数据的写入是有序的，轮询就满足不了。因为在消费模型中，每个分区的消费是独立的，如果数据顺序依次写入多个分区，在消费的时候就无法保持顺序。所以为了保证数据有序，就需要保证 Topic 只有一个分区。这是另外两种分配策略的思路。</p>
<h3 id="按-Key-Hash"><a href="#按-Key-Hash" class="headerlink" title="按 Key Hash"></a>按 Key Hash</h3><p><strong>按 Key Hash</strong> 是指根据消息的 Key 算出一个 Hash 值，然后跟 Topic 的分区数取余数，算出一个分区号，将数据写入到这个分区中。</p>
<p>这种方案的好处是可以根据 Key 来保证数据的分区有序。比如某个用户的访问轨迹，以客户的 AppID 为 Key，按 Key Hash 存储，就可以确保客户维度的数据分区有序。（因为key是一样的，所以该用户的所有消息会被分到一个分区当中）</p>
<p>缺点是分区数量不能变化，变化后 Hash 值就会变，导致消息乱序。并且因为每个 Key 的数据量不一样，容易导致数据倾斜。</p>
<h3 id="手动指定"><a href="#手动指定" class="headerlink" title="手动指定"></a>手动指定</h3><p>在生产数据的时候，手动指定数据写入哪个分区。</p>
<h3 id="自定义分区分配策略"><a href="#自定义分区分配策略" class="headerlink" title="自定义分区分配策略"></a>自定义分区分配策略</h3><p>用户实现消息队列提供的接口，自定义分区策略。</p>
<h2 id="批量语义"><a href="#批量语义" class="headerlink" title="批量语义"></a>批量语义</h2><p>客户端支持批量写入数据的前提是，需要在协议层支持批量的语义。否则就只能在业务中自定义将多条消息组成一条消息。</p>
<p>批量发送的实现思路一般是在客户端内存中维护一个队列，数据写入的时候，先将其写到这个内存队列，然后通过某个策略从内存队列读取数据，发送到服务端。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230720150820416.png" alt="image-20230720150820416"></p>
<h2 id="数据发送方式"><a href="#数据发送方式" class="headerlink" title="数据发送方式"></a>数据发送方式</h2><p>消息队列一般也会提供同步发送、异步发送、发送即忘三种形式。</p>
<p>同步异步好理解，不再过多阐述。</p>
<p>发送即忘指消息发送后不关心请求返回的结果，立即发送下一条。这种方式因为不用关心发送结果，发送性能会提升很多。缺点是当数据发送失败时无法感知，可能有数据丢失的情况。</p>
<h1 id="集群管控操作"><a href="#集群管控操作" class="headerlink" title="集群管控操作"></a>集群管控操作</h1><p>集群管控操作一般是用来完成资源的创建、查询、修改、删除等集群管理动作。资源包括主题、分区、配置、消费分组等等。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入拆解消息队列 47 讲》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Api网关</title>
    <url>/2023/05/16/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Api%E7%BD%91%E5%85%B3/</url>
    <content><![CDATA[<h1 id="API-网关起到的作用"><a href="#API-网关起到的作用" class="headerlink" title="API 网关起到的作用"></a>API 网关起到的作用</h1><p>API 网关可以分为两类：<strong>一类叫做入口网关，一类叫做出口网关。</strong></p>
<h2 id="入口网关"><a href="#入口网关" class="headerlink" title="入口网关"></a>入口网关</h2><p>入口网关部署在负载均衡服务器和应用服务器之间，<strong>主要有几方面的作用。</strong></p>
<p>1、它提供客户端一个统一的接入地址，API 网关可以将用户的请求动态路由到不同的业务服务上，并且做一些必要的协议转换工作。这里有一点需要注意，<strong>你部署的微服务对外暴露的协议可能不同</strong>，有些可能是RPC，有些可能是Http，这些细节都可以在网关中处理。</p>
<p>2、另一方面，在 API 网关中，我们可以植入一些服务治理的策略，比如服务的熔断、降级、流量控制和分流等等。</p>
<p>3、客户端的认证和授权的实现，也可以放在 API 网关中。</p>
<p>4、另外，API 网关还可以做一些与黑白名单相关的事情，比如针对设备 ID、用户 IP、用户 ID 等维度的黑白名单。</p>
<p>5、最后，在 API 网关中也可以做一些日志记录的事情。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230516142313124.png" alt="image-20230516142313124" style="zoom:67%;" />

<h2 id="出口网关"><a href="#出口网关" class="headerlink" title="出口网关"></a>出口网关</h2><p>我们在系统开发中，会依赖很多外部的第三方系统，典型的例子：第三方账户登录、使用第三方工具支付等等。我们可以在应用服务器和第三方系统之间，部署出口网关，在出口网关中，对调用外部的 API 做统一的认证、授权、审计以及访问控制。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230516142531792.png" alt="image-20230516142531792" style="zoom:67%;" />

<h1 id="网关实现"><a href="#网关实现" class="headerlink" title="网关实现"></a>网关实现</h1><p>在实现网关时，需要注意一点：为了提升网关对于请求的并行处理能力，我们一般会使用线程池来并行的执行请求。</p>
<p>但是这样设计也同样会带来一些问题：假如一个服务出现问题导致响应过慢，那么调用该服务的模块也会被阻塞，其他服务也会级联受到影响，导致无法线程池中的线程无法释放，对整个系统造成影响。</p>
<p>因此，我们需要针对不同的服务做线程隔离或者保护。<strong>有两种思路：</strong></p>
<ul>
<li>如果你后端的服务拆分得不多，可以针对不同的服务，采用不同的线程池，这样一个服务的故障就不会影响到其他服务；</li>
<li>在线程池内部可以针对不同的服务甚至不同的接口做线程的保护。比如说，线程池的最大线程数是 1000，那么可以给每个服务设置一个最多可以使用的配额。</li>
</ul>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230516151544806.png" alt="image-20230516151544806"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>高并发系统设计</category>
        <category>微服务架构</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>如何提高服务调用速度</title>
    <url>/2023/05/11/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E9%80%9F%E5%BA%A6/</url>
    <content><![CDATA[<p>假如电商系统的 QPS 已经达到了每秒 2 万次，在做了服务化拆分之后，由于我们把业务逻辑都拆分到了单独部署的服务中，那么假设你在完成一次完整的请求时需要调用 4～5 次服务，计算下来，RPC 服务需要承载大概每秒 10 万次的请求。</p>
<p>所以RPC框架的选型要：</p>
<p>1、选择合适的网络模型，有针对性地调整网络参数优化网络传输性能；</p>
<p>2、选择合适的序列化方式，以提升封包、解包的性能。</p>
<h1 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h1><p>RPC指的是通过网络调用另一台计算机上部署服务的技术。而 RPC 框架就封装了网络调用的细节，让你像调用本地服务一样调用远程部署的服务。</p>
<h1 id="在引入RPC框架后会出现的问题"><a href="#在引入RPC框架后会出现的问题" class="headerlink" title="在引入RPC框架后会出现的问题"></a>在引入RPC框架后会出现的问题</h1><p>假设一个电商系统的商品详情页面需要商品数据、评论数据还有店铺数据。如果是一体化的项目，只需要从商品库、评论库和店铺库获取数据就可以了，不考虑缓存的情况下有三次网络请求。</p>
<p>但是如果独立出商品服务、评论服务和店铺服务之后，那么就需要分别调用这三个服务，而这三个服务又会分别调用各自的数据库，这就是六次网络请求。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230511184337555.png" alt="image-20230511184337555"></p>
<p>想要优化RPC调用，那么就要了解RPC调用的步骤都有哪些：</p>
<ul>
<li>客户端首先会将调用的类名、方法名、参数名、参数值等信息，序列化成二进制流；</li>
<li>然后客户端将二进制流通过网络发送给服务端；</li>
<li>服务端接收到二进制流之后将它反序列化，得到需要调用的类名、方法名、参数名和参数值，再通过动态代理的方式调用对应的方法得到返回值；</li>
<li>服务端将返回值序列化，再通过网络发送给客户端；</li>
<li>客户端对结果反序列化之后，就可以得到调用的结果了。</li>
</ul>
<p>如下图：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230511184610250.png" alt="image-20230511184610250"></p>
<p>不难看出，想要优化RPC调用，需要从<strong>网络传输和序列化</strong>入手。</p>
<h2 id="如何提升网络传输性能"><a href="#如何提升网络传输性能" class="headerlink" title="如何提升网络传输性能"></a>如何提升网络传输性能</h2><p>在网络传输优化中，首先要做的是选择一种高性能的 I&#x2F;O 模型，即我们处理I&#x2F;O的方式。而单次I&#x2F;O请求会分为两个节点。</p>
<p><strong>首先，I&#x2F;O 会经历一个等待资源的阶段，</strong>比方说，等待网络传输数据可用。这里有两种处理方式：</p>
<ul>
<li><p>阻塞。指的是在数据不可用时 I&#x2F;O 请求一直阻塞，直到数据返回；</p>
</li>
<li><p>非阻塞。指的是数据不可用时 I&#x2F;O 请求立即返回，直到被通知资源可用为止。</p>
</li>
</ul>
<p><strong>然后是使用资源的阶段，</strong>比如说从网络上接收到数据，并且拷贝到应用程序的缓冲区里面。也有两种处理方式：</p>
<ul>
<li><p>同步处理。指的是 I&#x2F;O 请求在读取或者写入数据时会阻塞，直到读取或者写入数据完成；</p>
</li>
<li><p>异步处理。指的是 I&#x2F;O 请求在读取或者写入数据时立即返回，当操作系统处理完成 I&#x2F;O 请求并且将数据拷贝到用户提供的缓冲区后，再通知应用 I&#x2F;O 请求执行完成。</p>
</li>
</ul>
<p>将这两个阶段的四种处理方式做一些排列组合，再做一些补充，就得到了我们常见的五种 I&#x2F;O 模型：</p>
<ul>
<li><p>同步阻塞 I&#x2F;O；</p>
</li>
<li><p>同步非阻塞 I&#x2F;O；</p>
</li>
<li><p>同步多路 I&#x2F;O 复用；</p>
</li>
<li><p>信号驱动 I&#x2F;O；</p>
</li>
<li><p>异步 I&#x2F;O。</p>
</li>
</ul>
<h2 id="选择合适的序列化方式"><a href="#选择合适的序列化方式" class="headerlink" title="选择合适的序列化方式"></a>选择合适的序列化方式</h2><p><strong>在对网络数据传输完成调优之后，另外一个需要关注的点就是数据的序列化和反序列化。</strong></p>
<p>这里要考虑序列化和反序列化的速度，以及序列化完成后的大小，因为要在网络上传输。</p>
<p>可以有以下几种方案：</p>
<ul>
<li>JSON，性能要求不高可以选</li>
<li><strong>Thrift</strong> 是 Facebook 开源的高性能的序列化协议</li>
<li><strong>Protobuf</strong> 是谷歌开源的序列化协议。</li>
</ul>
<p>如果性能要求比较高，Thrift 或者 Protobuf 都可以。</p>
<p>一些存储的场景下，比如说缓存中存储的数据占用空间较大，那么你可以考虑使用 Protobuf。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>高并发系统设计</category>
        <category>微服务架构</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式场景下的CAP理论</title>
    <url>/2023/09/21/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84CAP%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h1><p>CAP理论是关于数据一致性（ C：Consistency ）、服务可用性（ A：Availability ）、分区容错性（ P：Partition-tolerance ）。</p>
<p>CAP 理论告诉我们，一个分布式系统不可能同时满足数据一致性、服务可用性和分区容错性 这三个基本需求，最多只能同时满足其中的两个。</p>
<h1 id="一致性（-C-）"><a href="#一致性（-C-）" class="headerlink" title="一致性（ C ）"></a>一致性（ C ）</h1><p>这里的一致性是指强一致性，又叫线性一致性，它要求多节点组成的分布式系统，能像单节点一样运作，如果一个写操作返回成功，那么之后的读请求都必须读到这个新数据；如果返回失败，那么所有的读操作都不能读到这个数据。</p>
<p>一致性中除了强一致性之外，还有其他的一致性级别，比如序列一致性（ Sequential Consistency ）和最终一致性（ Eventual Consistency ）等。</p>
<h1 id="可用性（-A-）"><a href="#可用性（-A-）" class="headerlink" title="可用性（ A ）"></a>可用性（ A ）</h1><p>可用性指的是要求系统提供的服务必须处于 100% 可用的状态，对于用 户的每一个操作请求，系统总能够在有限的时间内返回结果。</p>
<h1 id="分区容错性（-P-）"><a href="#分区容错性（-P-）" class="headerlink" title="分区容错性（ P ）"></a>分区容错性（ P ）</h1><p>分区指的是在整个分布式系统中，因为网络原因，系统被分隔成多个单独的部分，这里，不同系统之间在正常情况下应该是一个整体，因为网络原因不能通信才会被划分为不同的分区。在现实的分布式系统中，我们面对的就是一个不可靠的网络和有一定概率宕机的设备，这两个 因素都会导致分区出现，因此在分布式系统实现中，分区容错性 P 是一个必须项。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入浅出分布式技术原理》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>如何提高系统性能</title>
    <url>/2023/04/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<h1 id="性能的度量指标"><a href="#性能的度量指标" class="headerlink" title="性能的度量指标"></a>性能的度量指标</h1><p>1、平均值</p>
<p>平均值是把这段时间所有请求的响应时间数据相加，再除以总请求数。但是它存在一定的问题，可能这段时间有10000个请求，只有100个响应时间为100ms，其他都是1s，这样算下来平均值不太大，但是系统是有问题的。</p>
<p>2、最大值</p>
<p>即找到一段时间请求的响应时间的最大值。但是又过于敏感，如果只有一个请求响应是100ms，那么最大值就是100。</p>
<p>3、分位值</p>
<p>分位值有很多种，比如 90 分位、95 分位、75 分位。以 90 分位为例，我们把这段时间请求的响应时间从小到大排序，假如一共有 100 个请求，那么排在第 90 位的响应时间就是 90 分位值。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424200201337.png" alt="image-20230424200201337"></p>
<h1 id="高并发下的性能优化"><a href="#高并发下的性能优化" class="headerlink" title="高并发下的性能优化"></a>高并发下的性能优化</h1><p>加入说现在的系统中只有一个处理核心，执行的响应时间都在10ms以内，我们该如何优化呢？</p>
<h2 id="1-提高系统的处理核心数"><a href="#1-提高系统的处理核心数" class="headerlink" title="1. 提高系统的处理核心数"></a>1. 提高系统的处理核心数</h2><p>当提高了系统的处理核心数，那么我们就可以开更多的线程来同时处理请求。那么系统的吞吐量会变得大一点。但是并不意味着无限制的增加处理核心数可以一直的提高性能。随着并发进程数的增加，并行的任务对于系统资源的争抢也会愈发严重。在某一个临界点上继续增加并发进程数，反而会造成系统性能的下降。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424201739627.png" alt="image-20230424201739627" style="zoom: 67%;" />

<h2 id="2、减少单次任务响应时间"><a href="#2、减少单次任务响应时间" class="headerlink" title="2、减少单次任务响应时间"></a>2、减少单次任务响应时间</h2><p>想要减少任务的响应时间，首先要看你的系统是 CPU 密集型还是 IO 密集型的。不同类型的系统性能优化方式不尽相同。</p>
<p>CPU 密集型系统中，需要处理大量的 CPU 运算，那么选用更高效的算法或者减少运算次数就是这类系统重要的优化手段。</p>
<p>IO 密集型系统指的是系统的大部分操作是在等待 IO 完成，这里 IO 指的是磁盘 IO 和网络 IO。我们熟知的系统大部分都属于 IO 密集型，比如数据库系统、缓存系统、Web 系统。</p>
<p>比方说，如果是数据库访问慢，那么就要看是不是有锁表的情况、是不是有全表扫描、索引加的是否合适、是否有 JOIN 操作、需不需要加缓存，等等；如果是网络的问题，就要看网络的参数是否有优化的空间，抓包来看是否有大量的超时重传，网卡是否有大量丢包等。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《高并发系统设计40问》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>高并发系统设计</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>如何正确的选择缓存读写策略</title>
    <url>/2023/04/30/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%80%89%E6%8B%A9%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="Cache-Aside（旁路缓存）策略"><a href="#Cache-Aside（旁路缓存）策略" class="headerlink" title="Cache Aside（旁路缓存）策略"></a>Cache Aside（旁路缓存）策略</h1><p>读策略为：</p>
<ul>
<li>从缓存中读取数据，命中则直接返回</li>
<li>缓存未命中，则从数据库查询，然后写入缓存，并返回给用户</li>
</ul>
<p>写策略为：</p>
<ul>
<li>更新数据库中的数据</li>
<li>删除缓存的数据</li>
</ul>
<p>先删除缓存再删数据或者先删数据库再删除缓存都会导致一定的问题，分析比较简单，不做具体说明。</p>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>如果新注册了一个用户，然后立刻发起了查询（此时缓存无法命中），如果查询走的是从库，而且存在一定的时延，那么会有可能查询不到个人信息。</p>
<p>解决办法就是在特定的场景下，我们可以修改后将修改的信息写入缓存当中，而不是删除。</p>
<p>而且该策略对于频繁的修改会导致缓存中的数据被频繁的清理，造成缓存命中率低。</p>
<p>两种解决办法：</p>
<ol>
<li><p>一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；</p>
</li>
<li><p>另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务的影响也是可以接受。</p>
</li>
</ol>
<h1 id="Read-x2F-Write-Through（读穿-x2F-写穿）策略"><a href="#Read-x2F-Write-Through（读穿-x2F-写穿）策略" class="headerlink" title="Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略"></a>Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略</h1><p>这个策略的核心原则是用户只与缓存打交道，由缓存和数据库通信，写入或者读取数据。</p>
<p><strong>Write Through 的策略</strong>是这样的：先查询要写入的数据在缓存中是否已经存在，如果已经存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，如果缓存中数据不存在，我们把这种情况叫做“Write Miss（写失效）”。</p>
<p>如果发生写失效，则解决办法有以下两种：</p>
<ul>
<li>Write Allocate（按写分配）：写入缓存相应位置，再由缓存组件同步更新到数据库中；</li>
<li>No-write allocate（不按写分配）：不写入缓存中，而是直接更新到数据库中。</li>
</ul>
<p><strong>Read Through 策略</strong>就简单一些，它的步骤是这样的：先查询缓存中数据是否存在，如果存在则直接返回，如果不存在，则由缓存组件负责从数据库中同步加载数据。</p>
<h1 id="Write-Back（写回）策略"><a href="#Write-Back（写回）策略" class="headerlink" title="Write Back（写回）策略"></a>Write Back（写回）策略</h1><p>这个策略的核心思想是在写入数据时只写入缓存，并且把缓存块儿标记为“脏”的。而脏块儿只有被再次使用时才会将其中的数据写入到后端存储中。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230430194034299.png" alt="image-20230430194034299" style="zoom:67%;" />

<p><strong>如果使用 Write Back 策略的话，读的策略也有一些变化了。</strong></p>
<p>我们在读取缓存时如果发现缓存命中则直接返回缓存数据。</p>
<p>如果缓存不命中则寻找一个可用的缓存块儿，如果这个缓存块儿是“脏”的，就把缓存块儿中之前的数据写入到后端存储中，并且从后端存储加载数据到缓存块儿。</p>
<p>如果不是脏的，则由缓存组件将后端存储中的数据加载到缓存中，最后我们将缓存设置为不是脏的，返回数据就好了。</p>
<p>这个策略一般不直接在生产环境中使用，往往是计算机结构中使用，比如说操作系统层面的 Page Cache，日志的异步刷盘，消息队列中消息的异步写入磁盘等。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《高并发系统设计》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>高并发系统设计</category>
        <category>缓存篇</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>服务熔断</title>
    <url>/2023/09/25/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/</url>
    <content><![CDATA[<h1 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h1><p>熔断机制：当服务之间发起调用的时候，如果被调用方返回的 指定错误码的比例超过一定的阈值，那么后续的请求将不会真正发起，而是由调用方直接返回错误。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230925125355151.png" alt="image-20230925125355151" style="zoom:67%;" />

<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230925125408532.png" alt="image-20230925125408532"></p>
<p>首先是闭合状态，此时可以处理请求，但是需要一个计数器，来统计调用失败的次数，如果失败的次数达到阈值，则将状态改为闭合。</p>
<p>在闭合状态下，可以直接拒绝后续的请求，也可以对请求做一个降级（后续介绍）。此时会启动一个超时计时器，当计时器超时后，会转变为半打开状态。</p>
<p>在半打开状态下，允许一定数量的请求发往被调用的服务，如果这些调用正常，则就可以认为被调用服务已经恢复正常，此时熔断器切换为闭合状态，同时重置计数器。如果仍有部分调用失败的情况，则认为被调用方仍然没有恢复，熔断器会切换到断开状态，然后重置计数器。半打开状态是为了防止恢复中的服务被大量请求再次打垮的情况。</p>
<h2 id="熔断的关键点"><a href="#熔断的关键点" class="headerlink" title="熔断的关键点"></a>熔断的关键点</h2><p>有以下五个关键点：粒度控制、错误类型、存活与过载的区别、重试和熔断的关系和熔断机制的适应范围。</p>
<h3 id="粒度控制"><a href="#粒度控制" class="headerlink" title="粒度控制"></a>粒度控制</h3><p>该问题是指我们想将监控资源过载的粒度控制在一个什么样的范围内，这个范围可以由<strong>服务、实例和接口</strong>这三个维度的组合来得到。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230925130518335.png" alt="image-20230925130518335" style="zoom: 80%;" />

<p>建议使用基于实例接口的熔断，这样的粒度最小，假如说一个实例有10个接口，只有一个接口请求超时，那么熔断该接口即可，其他接口仍然可以提供服务，将熔断的错误率讲到最低。</p>
<h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><p>由于熔断机制是用来消除系统过载的，所以，我们需要识别出与系统过载相关的错误，来进行 熔断处理，一般来说，主要有下面两个错误类型。</p>
<ol>
<li>系统被动对外表现出来的过载错误，一般来说，如果一个接口过载了，那么它的响应时间就会变长，熔断器捕获到的错误类型就是“响应超时”之类的超时错误。</li>
<li>系统主动对外表现出来的过载错误，对于这种情况，一般是请求的流量触发了限流等机制返回的错误码，这个是我们在程序开发过程中主动设计的。</li>
</ol>
<h3 id="过载与存活的区别"><a href="#过载与存活的区别" class="headerlink" title="过载与存活的区别"></a>过载与存活的区别</h3><p>熔断机制关心系统是否过载，最好的判断方式为利用队列中的平均等待时间来计算服务的负载。不利用服务的处理时间是为了考虑下游任务的处理时间，有时可能是因为下游处理太慢而导致的当前服务处理时间较长。</p>
<p>在熔断场景中，我们对过载判断进行了简化，直接通过接口请求的结果进行判断，如果发生请求错误，并且错误为超时或者限流等错误的比例超过一定的阈值，我们就可以认为系统过载，然后进行熔断。</p>
<p>而存活一般是指机器或者服务是否存活，对于机器是否存活，一般是通过定期 ping 机器的 IP ，如果超过一定时间不能 ping 通，则认为该机器不存活了。</p>
<h3 id="熔断与重试的关系"><a href="#熔断与重试的关系" class="headerlink" title="熔断与重试的关系"></a>熔断与重试的关系</h3><p>熔断和重试都会对服务之间的调用请求进行额外的处理，不同的是，重试是指我们认为该次调用失败是因为系统临时错误导致的，所以重发一次请求。而熔断是指我们已经认为系统过载了，为了保证系统不发生雪崩，为了使接口快速处理，而直接返回失败。</p>
<h3 id="熔断机制的适应范围"><a href="#熔断机制的适应范围" class="headerlink" title="熔断机制的适应范围"></a>熔断机制的适应范围</h3><p>只要是过载问题的场景， 我们都可以考虑利用熔断机制来解决，不论是分布式系统中服务之间的调用，还是服务与数据 库之间等其他场景的调用</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入浅出分布式技术原理》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务后系统要如何改造</title>
    <url>/2023/05/10/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%90%8E%E7%B3%BB%E7%BB%9F%E8%A6%81%E5%A6%82%E4%BD%95%E6%94%B9%E9%80%A0/</url>
    <content><![CDATA[<p> 微服务化后，一个项目的架构图如下所示：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230510222409851.png" alt="image-20230510222409851" style="zoom: 80%;" />

<h1 id="微服务拆分的原则"><a href="#微服务拆分的原则" class="headerlink" title="微服务拆分的原则"></a>微服务拆分的原则</h1><p>单体化的项目就像一个大的蜘蛛网，不同模块交织在一起，调用比较复杂，一个问题出bug可能会导致连锁的问题。所以要对架构进行拆分。而进行拆分则需要遵循以下原则：</p>
<h2 id="1、做到单一服务内部功能的高内聚和低耦合"><a href="#1、做到单一服务内部功能的高内聚和低耦合" class="headerlink" title="1、做到单一服务内部功能的高内聚和低耦合"></a>1、做到单一服务内部功能的高内聚和低耦合</h2><p>也就是说每个服务只完成自己职责之内的任务，对于不是自己职责的功能交给其它服务来完成。</p>
<h2 id="2、需要关注服务拆分的粒度，先粗略拆分再逐渐细化"><a href="#2、需要关注服务拆分的粒度，先粗略拆分再逐渐细化" class="headerlink" title="2、需要关注服务拆分的粒度，先粗略拆分再逐渐细化"></a>2、需要关注服务拆分的粒度，先粗略拆分再逐渐细化</h2><p>拆分初期可以把服务粒度拆得粗一些，后面随着团队对于业务和微服务理解的加深，再考虑把服务粒度细化。</p>
<h2 id="3、拆分的过程，要尽量避免影响产品的日常功能迭代"><a href="#3、拆分的过程，要尽量避免影响产品的日常功能迭代" class="headerlink" title="3、拆分的过程，要尽量避免影响产品的日常功能迭代"></a>3、拆分的过程，要尽量避免影响产品的日常功能迭代</h2><p>要一边做产品功能迭代，一边完成服务化拆分。拆分只能在现有一体化系统的基础上不断剥离业务独立部署，<strong>剥离的顺序你可以参考以下几点：</strong></p>
<ol>
<li><p>优先剥离比较独立的边界服务（比如短信服务、地理位置服务），从非核心的服务出发减少拆分对现有业务的影响</p>
</li>
<li><p>当两个服务存在依赖关系时优先拆分被依赖的服务。比如内容服务依赖于用户服务获取用户的基本信息，那么如果先把内容服务拆分出来，内容服务就会依赖于一体化架构中的用户模块，这样还是无法保证内容服务的快速部署能力。</p>
</li>
</ol>
<h2 id="4、服务接口的定义要具备可扩展性"><a href="#4、服务接口的定义要具备可扩展性" class="headerlink" title="4、服务接口的定义要具备可扩展性"></a>4、服务接口的定义要具备可扩展性</h2><p>服务拆分之后，由于服务是以独立进程的方式部署，所以服务之间通信就不再是进程内部的方法调用而是跨进程的网络通信了。在这种通信模型下服务接口的定义要具备可扩展性，否则在服务变更时会造成意想不到的错误。</p>
<h1 id="微服务化带来的问题和解决思路"><a href="#微服务化带来的问题和解决思路" class="headerlink" title="微服务化带来的问题和解决思路"></a>微服务化带来的问题和解决思路</h1><p>微服务会引入一定的复杂度：</p>
<p>1、服务接口调用不再是同一进程内的方法调用，而是跨进程的网络调用，这会增加时延，同时接口调用方需要知道服务部署在哪些机器的哪个端口上，这些信息需要存储在一个分布式一致性的存储中，<strong>于是就需要引入服务注册中心</strong>。</p>
<p>2、多个服务之间有着错综复杂的依赖关系。一个服务会依赖多个其它服务也会被多个服务所依赖，那么一旦被依赖的服务的性能出现问题产生大量的慢请求，就会导致依赖服务的工作线程池中的线程被占满，依赖的服务也会出现性能问题，有可能会导致整个服务崩溃。</p>
<p>为了避免发生这种情况，我们需要引入服务治理体系针对出问题的服务采用熔断、降级、限流、超时控制的方法，使问题被限制在单一服务中，保护服务网络中的其它服务不受影响。</p>
<p>3、服务拆分到多个进程后，一条请求的调用链路上涉及多个服务，那么一旦这个请求的响应时间增长或者是出现错误，我们就很难知道是哪一个服务出现的问题。</p>
<p>另外，整体系统一旦出现故障，很可能外在的表现是所有服务在同一时间都出现了问题，你在问题定位时很难确认哪一个服务是源头，<strong>这就需要引入分布式追踪工具，以及更细致的服务端监控报表。</strong></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>高并发系统设计</category>
        <category>微服务架构</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>注册中心</title>
    <url>/2023/05/13/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<p> 当一个项目拆分成微服务之后，接口之间的调用就需要跨网络来完成，这时候就需要知道另外一个接口的ip地址以及端口号，如果把这些内容全部在代码里面写死，那么如果ip发生变动，就需要重启服务，还需要修改代码。注册中心的诞生就解决了这个问题。</p>
<p>注册中心的基本功能有两点：</p>
<ul>
<li><p>一是提供了服务地址的存储；</p>
</li>
<li><p>二是当存储内容发生变化时，可以将变更的内容推送给客户端。</p>
</li>
</ul>
<p>使用了注册中心组件之后，RPC 的通信过程就变成了下面这个样子：</p>
<ul>
<li><p>客户端会与注册中心建立连接，并且告诉注册中心，它对哪一组服务感兴趣；</p>
</li>
<li><p>服务端向注册中心注册服务后，注册中心会将最新的服务注册信息通知给客户端；</p>
</li>
<li><p>客户端拿到服务端的地址之后就可以向服务端发起调用请求了。</p>
</li>
</ul>
<h1 id="服务状态管理如何来做"><a href="#服务状态管理如何来做" class="headerlink" title="服务状态管理如何来做"></a>服务状态管理如何来做</h1><p>服务的上线和下线是由服务端主动向注册中心注册和取消注册来实现的，这在正常的流程中是没有问题的。<strong>可是，如果某一个服务端意外故障，</strong>比如说机器掉电，网络不通等情况，服务端就没有办法向注册中心通信，将自己从服务列表中删除，就会导致客户端请求一个无法响应的服务。</p>
<h2 id="主动探测"><a href="#主动探测" class="headerlink" title="主动探测"></a>主动探测</h2><p>你的 RPC 服务要打开一个端口，然后由注册中心每隔一段时间（比如 30 秒）探测这些端口是否可用，如果可用就认为服务仍然是正常的，否则就可以认为服务不可用，那么注册中心就可以把服务从列表里面删除了。</p>
<p>这样做的如果服务比较多的话，成本就会比较的高。</p>
<h2 id="心跳模式"><a href="#心跳模式" class="headerlink" title="心跳模式"></a>心跳模式</h2><p>注册中心为每一个连接上来的 RPC 服务节点记录最近续约的时间，RPC 服务节点在启动注册到注册中心后，就按照一定的时间间隔（比如 30 秒），向注册中心发送心跳包。注册中心在接收到心跳包之后，会更新这个节点的最近续约时间。然后，注册中心会启动一个定时器定期检测当前时间和节点最近续约时间的差值，如果达到一个阈值（比如说 90 秒），那么认为这个服务节点不可用。</p>
<h2 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h2><p>要避免注册中心因为监测不到心跳而摘除所有的服务，要设置一定的警报，如果摘除超过一定比例的服务后，要发起警告。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>高并发系统设计</category>
        <category>微服务架构</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>服务治理</title>
    <url>/2023/10/06/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/</url>
    <content><![CDATA[<h1 id="服务治理手段"><a href="#服务治理手段" class="headerlink" title="服务治理手段"></a>服务治理手段</h1><p>服务的调用涉及到注册中心，服务调用的发起方和提供方三者，这三者中任意两个的通信都是通过网络，那么不论是网络出现问题，还是说这三者中任意一个出现问题，此次调用都会失败。所以就需要服务治理。</p>
<h2 id="节点管理"><a href="#节点管理" class="headerlink" title="节点管理"></a>节点管理</h2><p>该部分可以分为两点。</p>
<ol>
<li>注册中心主动摘除机制。这种机制要求服务提供者定时向注册中心汇报心跳，当两次汇报中间的时间超过规定时间后，就认为服务提供者出现问题，进行摘除，然后把最近的可用服务列表推送给服务消费者。</li>
<li>服务消费者摘除机制。上述机制可能因为网络问题导致一个正常的服务被摘除，最坏情况所有服务都正常，但是全被摘除。一个更合理的摘除办法就是让服务的调用者去执行。即服务调用者调用失败时，就从本地缓存的可用服务列表中去移除该服务，而不进行实际的摘除。</li>
</ol>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>这里边有几个算法：</p>
<ol>
<li>随机算法</li>
<li>轮询算法</li>
<li>最少活跃调用算法</li>
<li>一致性Hash算法</li>
</ol>
<h2 id="服务路由"><a href="#服务路由" class="headerlink" title="服务路由"></a>服务路由</h2><p>对于服务消费者而言，在内存中的可用服务节点列表中选择哪个节点不仅由负载均衡算法决定，还由路由规则确定。而指定路由规则的主要原因有以下两点：</p>
<ol>
<li>服务功能做了变更，需要灰度发布，根据这部分人的使用反馈来决定是否全量发布时，就可以做一些路由规则的限制，比如说使用尾号限制，让特定比例的人群才会访问到新发布的服务节点。</li>
<li>部分规模比较大的公司，为了业务高可用，会将业务部署在不止一个IDC中，这时候不同IDC之间访问要跨IDC，而距离比较远时延迟就会比较大。所以一次服务调用尽可能选择同一个IDC内部的节点，减少网络开销，提高性能。</li>
</ol>
<p>路由的配置规则一般有<strong>静态配置</strong>和<strong>动态配置</strong>。其中静态配置是防止在每一个服务本地的，服务上线后规则不发生改变。而动态配置一般都是放在注册中心，需要修改时改动注册中心的内容即可。</p>
<h2 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h2><p>对于服务调用失败的情况，需要有手段自动恢复，来保证调用成功。常用手段有以下几种：</p>
<ol>
<li>失败自动切换。顾名思义，调用失败了后就从最近的可用服务列表中选一个进行重试，可以限制重试次数，但是这种操作要求服务的调用操作是<strong>幂等</strong>的。</li>
<li>失败通知。服务调用失败后，不再进行重试，而是根据失败返回的信息而决定后续的操作。</li>
<li>失败缓存。服务调用失败后，并不立即进行重试，而是隔一段时间后再进行重试。</li>
<li>快速失败。调用失败后就不管了。</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《从0开始学微服务》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据该如何迁移</title>
    <url>/2023/05/07/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%95%B0%E6%8D%AE%E8%AF%A5%E5%A6%82%E4%BD%95%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<p> 数据迁移需要满足以下几点：</p>
<ul>
<li>迁移的过程中，要保证新数据可以写入</li>
<li>迁移后，新旧数据库数据要一致</li>
<li>迁移过程中可以回滚</li>
</ul>
<p>下面给出几个具体的迁移方案。</p>
<h1 id="“双写”方案"><a href="#“双写”方案" class="headerlink" title="“双写”方案"></a>“双写”方案</h1><p>1、将新的库配置为源库的从库用来同步数据</p>
<p>2、改造业务代码，在数据写入的时候不仅要写入旧库也要写入新库。同时要保证在写入新库失败的数据被单独记录，以便后续添加。</p>
<p>3、校验数据了，这里只抽取部分数据。</p>
<p>4、将流量切换到新库，最好采用灰度的方式，即先切10%的流量过去，然后50%，慢慢加到100。</p>
<p>5、如果有问题，要将流量切回之前的库。</p>
<p>6、如果没有问题，将双写改为只写新库。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230507163056086.png" alt="image-20230507163056086" style="zoom:67%;" />

<h1 id="级联同步方案"><a href="#级联同步方案" class="headerlink" title="级联同步方案"></a>级联同步方案</h1><p>1、先将新库配置为旧库的从库，用作数据同步</p>
<p>2、再将一个备库配置为新库的从库，用作数据的备份</p>
<p>3、等到三个库的写入一致后，将数据库的读流量切换到新库</p>
<p>4、然后暂停应用的写入，将业务的写入流量切换到新库</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230507163310998.png" alt="image-20230507163310998" style="zoom:67%;" />

<p>但是这里的一个缺点是，切换时要暂停应用的使用，所以要选择低峰期来执行。</p>
<h1 id="数据迁移时如何预热缓存"><a href="#数据迁移时如何预热缓存" class="headerlink" title="数据迁移时如何预热缓存"></a>数据迁移时如何预热缓存</h1><p>上述的两种方案也可以在迁移缓存时使用，但是需要注意，直接在新的服务上加一个空的缓存，有可能会导致数据库宕机，<strong>所以，缓存迁移的重点是保持缓存的热度。</strong></p>
<h2 id="使用副本组预热缓存"><a href="#使用副本组预热缓存" class="headerlink" title="使用副本组预热缓存"></a>使用副本组预热缓存</h2><p>一般的数据写入流程是写入 Master、Slave 和所有的副本组，而在读取数据的时候，会先读副本组的数据，如果读取不到再到 Master 和 Slave 里面加载数据，再写入到副本组中。</p>
<p>这样，我们可以直接在云上部署一个副本组，如果查不到就去旧的机房去查询缓存，然后写入副本组。当副本组数据足够多时，缓存的迁移也就完成了。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230507171235231.png" alt="image-20230507171235231" style="zoom: 80%;" />

<p>不过这里要注意，存在跨网络的调用，可能接口的速度会受到影响。</p>
<h2 id="改造副本组方案预热缓存"><a href="#改造副本组方案预热缓存" class="headerlink" title="改造副本组方案预热缓存"></a>改造副本组方案预热缓存</h2><p>1、在云上部署多组缓存的副本组，自建机房在接收到写入请求时，会优先写入自建机房的缓存节点，异步写入云上部署的缓存节点；</p>
<p>2、在处理自建机房的读请求时，会指定一定的流量（比如 10%）优先走云上的缓存节点，这样虽然也会走专线穿透回自建机房的缓存节点，但是流量是可控的；</p>
<p>3、当云上缓存节点的命中率达到 90% 以上时，就可以在云上部署应用服务器，让云上的应用服务器完全走云上的缓存节点就可以了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《高并发系统设计》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>高并发系统设计</category>
        <category>缓存篇</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡</title>
    <url>/2023/05/15/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<h1 id="负载均衡服务器的种类"><a href="#负载均衡服务器的种类" class="headerlink" title="负载均衡服务器的种类"></a>负载均衡服务器的种类</h1><p><strong>负载均衡的含义是：</strong>将负载（访问的请求）“均衡”地分配到多个处理节点上。这样可以减少单个处理节点的请求量，提升整体系统的性能。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230515172635623.png" alt="image-20230515172635623" style="zoom:67%;" />

<p>在项目的架构中，我们一般会同时部署 LVS 和 Nginx 来做 HTTP 应用服务的负载均衡。也就是说，在入口处部署 LVS 将流量分发到多个 Nginx 服务器上，再由 Nginx 服务器分发到应用服务器上。</p>
<p>不过这两个负载均衡服务适用于普通的 Web 服务，对于微服务架构来说，它们是不合适的。</p>
<p>因为微服务架构中的服务节点存储在注册中心里，使用 LVS 就很难和注册中心交互获取全量的服务节点列表。另外，一般微服务架构中，使用的是 RPC 协议而不是 HTTP 协议，所以 Nginx 也不能满足要求。</p>
<p><strong>所以，我们会使用另一类的负载均衡服务，客户端负载均衡服务，也就是把负载均衡的服务内嵌在 RPC 客户端中。</strong></p>
<p>这类服务一般会结合注册中心来使用，注册中心提供服务节点的完整列表，客户端拿到列表之后使用负载均衡服务的策略选取一个合适的节点，然后将请求发到这个节点上。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230515194359296.png" alt="image-20230515194359296"></p>
<h2 id="常见的负载均衡策略有哪些"><a href="#常见的负载均衡策略有哪些" class="headerlink" title="常见的负载均衡策略有哪些"></a>常见的负载均衡策略有哪些</h2><ul>
<li><p>一类是静态策略，也就是说负载均衡服务器在选择服务节点时，不会参考后端服务的实际运行的状态；</p>
</li>
<li><p>一类是动态策略，也就是说负载均衡服务器会依据后端服务的一些负载特性，来决定要选择哪一个服务节点。</p>
</li>
</ul>
<p>静态的又有以下几种策略：</p>
<ul>
<li><strong>轮询的策略</strong>：如果服务器性能不一样，则不能很好的发挥作用</li>
<li><strong>带有权重的轮询策略</strong></li>
</ul>
<p>动态策略：</p>
<ul>
<li>Dubbo 提供的 LeastAcive 策略，就是优先选择活跃连接数最少的服务；</li>
<li>Spring Cloud 全家桶中的 Ribbon 提供了 WeightedResponseTimeRule 是使用响应时间给每个服务节点计算一个权重，然后依据这个权重，来给调用方分配服务节点。</li>
</ul>
<p><strong>这些策略的思考点</strong>是从调用方的角度出发，选择负载最小、资源最空闲的服务来调用，以期望能得到更高的服务调用性能</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>高并发系统设计</category>
        <category>微服务架构</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存如何做到高可用</title>
    <url>/2023/05/01/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<p> 分布式缓存的高可用方案有以下三类：</p>
<p>1、<strong>客户端方案</strong>：在客户端配置多个缓存的节点，通过缓存写入和读取算法策略来实现分布式，从而提高缓存的可用性。</p>
<p>2、<strong>中间代理层方案</strong>：在应用代码和缓存节点之间增加代理层，客户端所有的写入和读取的请求都通过代理层，而代理层中会内置高可用策略，帮助提升缓存系统的高可用。</p>
<p>3、<strong>服务端方案</strong>：Redis 2.4 版本后提出的 Redis Sentinel 。</p>
<h1 id="客户端方案"><a href="#客户端方案" class="headerlink" title="客户端方案"></a>客户端方案</h1><p>在该方案中，需要注意缓存的读写。写需要将数据分片，而读可以用多组缓存做容错，提升系统的可用性。</p>
<h2 id="缓存数据分片"><a href="#缓存数据分片" class="headerlink" title="缓存数据分片"></a>缓存数据分片</h2><p>当单一机器无法存储所有的数据时，我们就需要将缓存分配到不同的机器上，每个节点上存储部分数据。</p>
<p><strong>一般来讲，分片算法常见的就是 Hash 分片算法和一致性 Hash 分片算法两种。</strong></p>
<h3 id="1、Hash分片"><a href="#1、Hash分片" class="headerlink" title="1、Hash分片"></a>1、Hash分片</h3><p>Hash分片就是对key做哈希计算，然后对总的缓存节点取余。该算法优点是简单，缺点是当增加或者减少分片节点数量时，计算的方式也要发生变化。该方案适合缓存命中率下降不敏感的业务。</p>
<h3 id="2、一致性Hash"><a href="#2、一致性Hash" class="headerlink" title="2、一致性Hash"></a>2、一致性Hash</h3><p><strong>一致性 Hash 算法可以很好地解决增加和删减节点时，命中率下降的问题</strong>。</p>
<p>该算法中，我们将整个Hash值空间组织成一个虚拟的圆环，然后将每一个分片节点的ip或者主机名做hash后放在该圆环上。当需要确定某一个key在哪个节点上时，先对key做hash，确定在换上的位置（注意，这一步做完hash后，不一定会直接落到某一个节点的下标处，所以需要顺时针往下走），然后往下走，找到第一个是节点的位置，就将数据存储在该节点中。</p>
<p>在该算法中，删除节点会导致节点上的数据漂移到下一个节点上，对于hash命中率并不会造成特别大的影响。</p>
<p>存在的问题：</p>
<p>1、缓存节点在圆环上分布不均匀，会造成部分节点压力很大，而且当一个节点失效，会将数据全部转移到下一个节点。</p>
<p>2、一致性 Hash 算法的脏数据问题。</p>
<p>针对于第一个问题，在某个节点出问题时，要将节点平均分配到其他的几个节点上，而不能将它全部移交到下一个节点上。</p>
<p>对于第二个问题，如果节点3中有一个数据，现在要修改该数据，但是节点3此时无法连接，那么修改操作就会发生到节点4，那么当节点3恢复后，客户端就会从节点3中读取到脏数据。解决办法就是增加过期时间。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《高并发系统设计》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>高并发系统设计</category>
        <category>缓存篇</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>远程调用</title>
    <url>/2023/10/08/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h1 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h1><p>本地调用通常指的是，进程内函数之间的相互调用；而远程调用，是进程间函数的相互调用，是进程间通信 IPC（Inter-Process Communication）的一种方式。</p>
<p>根据进程是否部署在一台机器上，远程调用可以分为以下两类：</p>
<ol>
<li><strong>本地过程调用（Local Procedure Call，LPC）</strong>，是指运行在同一台机器上的进程之间 的互相通信，即在多进程操作系统中，运行的不同进程之间可以通过 LPC 进行函数调 用。</li>
<li><strong>远程过程调用（Remote Procedure Call，RPC）</strong>，是指不同机器中运行的进程之间的 相互通信，某一机器上运行的进程在不知道底层通信细节的情况下，就像访问本地服务 一样，去调用远程机器上的服务。</li>
</ol>
<h2 id="远程调用的原理"><a href="#远程调用的原理" class="headerlink" title="远程调用的原理"></a>远程调用的原理</h2><p>在B&#x2F;S ( Browser&#x2F;Server，浏览器 &#x2F; 服务器) 架构中，被调用方（服务器）会有一个开放的接口，然后调用方（用户）会通过Browser使用这个接口，来间接的调用相应的服务。</p>
<p>但是，B&#x2F;S 架构是基于 HTTP 协议实现的，每次调用接口时，都需要先进行 HTTP 请求，比较的耗时，不适合分布式中的远程调用。更为常用的是 <strong>远程过程调用 RPC(Remote Procedure Call)</strong> 和 **远程方法调用 RMI(Remote Method Invocation)**。</p>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>简单地说，RPC 就是调用方采用参数传递的方式，通过调用本机器上的一个函数或方法， 去执行远程机器上的函数或方法（可以统称为服务），并返回结果。在整个过程中，RPC 会隐藏具体的通信细节。一个支付流程的网络调用如下图所示：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231012092420486.png" alt="image-20231012092420486" style="zoom:80%;" />

<p>其中，Stub 是用于转换 RPC 过程中在订单系统和支付系统所在机器之间传递的参数。说白了，客户端的Stub用于封装参数，而服务端的Stub就是为了将收到的封装后的参数解析出来。</p>
<p>不难看出，机器 A 上的 Pay(Order)、 Client Stub 和网络调用之间的交互属于本地调用，机器 B 上的 Pay(Order)、Server Stub 和网络调用之间的交互也属于本地调用。而机器 A 和机器 B 之间的远程调用的核心是，发生在机器 A 上的网络调用和机器 B 上的网络调用。</p>
<p>RPC的目的是，将第 2 到第 8 步的几个过程封装起来，让用户看不到这些细节。 从用户的角度看，订单系统的进程只是做了一次普通的本地调用，然后就得到了结果。</p>
<p>订单系统进程并不需要知道底层是如何传输的，在用户眼里，远程过程调用和调用一次本地服务没什么不同。这就是 RPC 的核心。</p>
<h4 id="RPC与本地调用的区别"><a href="#RPC与本地调用的区别" class="headerlink" title="RPC与本地调用的区别"></a>RPC与本地调用的区别</h4><p>第一个区别是<strong>调用 ID 和函数的映射</strong>。在本地调用中，进程内可共享内存地址空间，因此程序可直接通过函数名来调用函数。函数名的本质是一个函数指针，可以看作函数在内存中的地址。而在远程调用中，只通过函数名却不行，因为不同进程的地址空间不一样，所以必须通过一个调用ID来标识，在远程调用时要附上ID。</p>
<p>调用方首先通过映射表，先找到调用函数的ID，传给被调用方。被调用方拿到ID后，通过ID找到具体被调用的函数。</p>
<p>第二个区别是，<strong>序列化和反序列化</strong>。在本地调用中，进程之间共享内存等，因此我们只需要把参数压到栈里，然后进程自己去栈 里读取就行。但是在 RPC 中，两个进程分布在不同的机器上，使用的是不同机器的内存， 因此不可能通过内存来传递参数。</p>
<p>而网络协议传输的内容是二进制流，无法直接传输参数的类型，因此这就需要调用方把参数 先转成一个二进制流，传到被调用方后，被调用方再把二进制流转换成自己能读取的格式。 这个过程，就叫作序列化和反序列化。</p>
<p>第三个区别是，<strong>网络传输协议</strong>。序列化和反序列化解决了调用方和被调用方之间的数据传输 格式问题，但要想序列化后的数据能在网络中顺利传输，还需要有相应的网络协议，比如 TCP、UDP 等，因此就需要有一个底层通信层。而大部分的RPC框架，采用的都是TCP协议。</p>
<h3 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h3><p>RMI 是一个基于 Java 环境的应用编程接口，能够让本地 Java 虚拟机上运行的对象，像调用本地对象一样调用远程 Java 虚拟机上的对象。RMI可以说是RPC的一种具体形式，原理与RPC基本一致，不同的是RMI 是基于对象的，充分利用了面向对象的思想去实现整个过程，其本质就是一种基于对象的 RPC 实现。</p>
<p>RMI 与 PRC 最大的不同在于调用方式和返回结果的形式，RMI 通 过对象作为远程接口来进行远程方法的调用，返回的结果也是对象形式，可以是 Java 对象 类型，也可以是基本数据类型。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《分布式技术原理与算法实战》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>降级</title>
    <url>/2023/09/27/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%99%8D%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h1><p>上面的熔断，是为了在系统过载时不发生雪崩，限流是为了流量较大时，系统不发生过载。但是这两者都不会区分该服务是核心业务还是非核心业务。而降级，则是为了减少或者停掉一些非核心业务，来确保核心业务收到的影响最小。</p>
<h2 id="为什么需要降级"><a href="#为什么需要降级" class="headerlink" title="为什么需要降级"></a>为什么需要降级</h2><ol>
<li>降级机制能从全局角度对资源进行调配，通过牺牲非核心服务来保障核心服务的稳定性。降级是主动停掉一些非核心业务，而限流则是被动的将一些请求拒绝。</li>
<li>降级可以提高系统的用户体验性和可用性。在一些场景中，如果正常调用出现了非业务层错误后，我们可以不返回错误，而是执行接口的B计划，进行降级，虽然可能和正常流程不太一样，但是比直接返回错误要好。</li>
</ol>
<h2 id="如何实现降级"><a href="#如何实现降级" class="headerlink" title="如何实现降级"></a>如何实现降级</h2><h3 id="手动降级"><a href="#手动降级" class="headerlink" title="手动降级"></a>手动降级</h3><p>手动降级是指在分布式系统中提前设置好降级开关，然后通过类似配置中心的集中式降级平 台，来管理降级开关的配置信息，在系统需要降级的时候，通过降级平台手动启动降级开关， 对系统进行降级处理。</p>
<p>该方案需要注意的是，往往服务有成千上百个，如果全部手动操作，则很麻烦。一个解决办法是：通过对降级分级，利用服务的等级信息和业务信息进行批量降级，比如一次直接把p1,p2,p3的服务全部降级。</p>
<h3 id="自动降级"><a href="#自动降级" class="headerlink" title="自动降级"></a>自动降级</h3><p>自动降级是指在分布式系统中，当系统的某些指标或者接口调用出现错误时，直接启动降级逻辑。一个降级的例子如下：</p>
<p>我们在网关中调用鉴权服务进行鉴权，每一 个调用鉴权服务的鉴权接口，需要执行如下的两个校验逻辑，不论哪一个失败，都会导致鉴权失败。</p>
<ol>
<li>校验 Token 是否合法。</li>
<li>校验 UID 是否被管理员封禁。</li>
</ol>
<p>在这个情况下，我们可以将 Token 设计为可以自校验的，在鉴权服务出现故障的时候，则启动降级逻辑，直接在网关中校验 Token 是否合法，如果合法就返回鉴权成功。</p>
<h2 id="降级机制的关键问题"><a href="#降级机制的关键问题" class="headerlink" title="降级机制的关键问题"></a>降级机制的关键问题</h2><p>一般来 说，我们使用降级都是在系统已经出现过载的场景下，这时我们需要考虑，降级的配置信息是 否能正常下发。并且，降级通常会与熔断和限流一起出现，我们应该如何处理它们三者之间的关系。</p>
<h3 id="配置信息下发的问题"><a href="#配置信息下发的问题" class="headerlink" title="配置信息下发的问题"></a>配置信息下发的问题</h3><p>对于熔断和限流来说，其阈值相关的配置信息在系统正常运行的时候，就已经下发到实例上了，所以在系统出现故障的时候，这些配置信息会直接生效。但是对于手动降级，我们需要在系统出问题时，通过降级平台下发配置来启动降级。</p>
<p>针对于配置无法正常下发的情况，我们可以考虑，由服务直接暴露出修改降级配置的 HTTP 接口，在必要的时候，可以手动通过 HTTP 接口，来启动服务的降级逻辑。</p>
<h3 id="熔断、限流和降级之间的关系"><a href="#熔断、限流和降级之间的关系" class="headerlink" title="熔断、限流和降级之间的关系"></a>熔断、限流和降级之间的关系</h3><p>首先，因为熔断机制是系统稳定性保障的最后一道防线，并且它是自适应的，所以我们应该在系统全局默认启用；</p>
<p>其次，限流是用来保障被限流服务稳定性的，一般在系统的核心链路和核心服务上，默认启用限流机制；</p>
<p>最后，降级是通过牺牲被降级的接口或者服务，来保障其他的接口和服务正常运行的，可以通过降级直接停用非核心服务，然后对于核心接口和服务，在必要的时候，可以提供一个“ B 计划”。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入浅出分布式技术原理》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发系统的通用设计方案</title>
    <url>/2023/04/22/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%80%9A%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>高并发系统的通用设计：</p>
<p>Scale-out（横向扩展）：采用分布式部署的方式把流量分流开，让每个服务器都承担一部分并发和流量。</p>
<p>缓存：使用缓存来提高系统的性能，就好比用“拓宽河道”的方式抵抗高并发大流量的冲击。</p>
<p>异步：在某些场景下，未处理完成之前我们可以让请求先返回，在数据准备好之后再通知请求方，这样可以在单位时间内处理更多的请求。</p>
<h1 id="Scale-out"><a href="#Scale-out" class="headerlink" title="Scale-out"></a>Scale-out</h1><p>这里牵扯到一个横向扩展（Scale-out）与纵向扩展（Scale-up）。其中纵向扩展是不断的提高单个cpu的处理能力，来处理更多的请求。而横向扩展则是指利用多个cpu资源来并行处理，来处理更多请求。</p>
<p>一般来说，在项目初期，我们可以采用纵向扩展，当单机无法承受时，再使用横向扩展。</p>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>我们的数据都是存储在磁盘上的，而磁盘的读取速度特别的慢，会给处理请求带来很大的压力。所以产生了缓存。在现代的设计中，从操作系统到浏览器，从数据库到消息队列都可以看到缓存的影子。</p>
<p>由于缓存是基于内存读写的，所以速度要比磁盘读取快很多。如果能够能快的读写数据，那么每个请求的处理时间都会变短，那么就会提高系统的并发度。</p>
<h1 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h1><p>异步处理相对应的就是同步。</p>
<p>同步是指调用一个方法，需要等到该方法返回之后，才可以继续执行后续的操作。这种情况下，如果调用的方法响应时间太长的话，会导致后续的业务阻塞。</p>
<p>异步处理是指调用方法后，并不需要等待方法处理完，可以直接执行后续的请求。比如说，我们可以将请求放入队列当中，然后响应用户一个信息，等处理完结果后，再给用户反馈一下，这样可以处理更多的请求。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230422182314880.png" alt="image-20230422182314880"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《高并发系统设计40问》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>高并发系统设计</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>享元模式（下）</title>
    <url>/2023/06/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="享元模式在-Java-Integer-中的应用"><a href="#享元模式在-Java-Integer-中的应用" class="headerlink" title="享元模式在 Java Integer 中的应用"></a>享元模式在 Java Integer 中的应用</h1><h2 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h2><p>Java中的基本数据类型对应的有包装器类型，他们之前存在着自动装箱和拆箱的过程。</p>
<p>所谓的自动装箱，就是自动将基本数据类型转换为包装器类型。所谓的自动拆箱，也就是自 动将包装器类型转化为基本数据类型。具体的代码示例如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">56</span>; <span class="comment">//自动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; <span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure>

<p>数值 56 是基本数据类型 int，当赋值给包装器类型（Integer）变量的时候，触发自动装箱 操作，创建一个 Integer 类型的对象，并且赋值给变量 i。其底层相当于执行了下面这条语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">59</span>；底层执行了：<span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">59</span>);</span><br></pre></td></tr></table></figure>

<p>反过来，当把包装器类型的变量 i，赋值给基本数据类型变量 j 的时候，触发自动拆箱操 作，将 i 中的数据取出，赋值给 j。其底层相当于执行了下面这条语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; 底层执行了：<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i.intValue();</span><br></pre></td></tr></table></figure>

<h2 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">123</span>, <span class="number">23</span>); <span class="comment">// id=123, age=23</span></span><br></pre></td></tr></table></figure>

<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230616110300848.png" alt="image-20230616110300848" style="zoom:67%;" />

<p>当我们通过“&#x3D;&#x3D;”来判定两个对象是否相等的时候，实际上是在判断两个局部变量存储的 地址是否相同，换句话说，是在判断两个局部变量是否指向相同的对象。</p>
<h2 id="一个具体的例子"><a href="#一个具体的例子" class="headerlink" title="一个具体的例子"></a>一个具体的例子</h2><p>看下面的代码，它的结果是什么样的？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">56</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">56</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">129</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">129</span>;</span><br><span class="line">System.out.println(i1 == i2);</span><br><span class="line">System.out.println(i3 == i4);</span><br></pre></td></tr></table></figure>

<p>前 4 行赋值语句都会触发自动装箱操作，也就是会创建 Integer 对象并且赋值给 i1、i2、 i3、i4 这四个变量。i1、i2 尽管存储的数值相同，都是 56，但是指向不同的 Integer 对象，所以通过“&#x3D;&#x3D;”来判定是否相同的时候，会返回 false，同理第二个也是false。这样对吗？</p>
<p>答案并非是两个 false，而是一个 true，一个 false。</p>
<p>实际上，这正是因为 Integer 用到了享元模式来复用对象，才 导致了这样的运行结果。当我们通过自动装箱，也就是调用 valueOf() 来创建 Integer 对象的时候，<strong>如果要创建的 Integer 对象的值在 -128 到 127 之间，会从 IntegerCache 类中 直接返回</strong>，否则才调用 new 方法创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 56 处于 -128 和 127 之间，i1 和 i2 会指向相同 的享元对象，所以 i1&#x3D;&#x3D;i2 返回 true。而 129 大于 127，并不会被缓存，每次都会创建一 个全新的对象，也就是说，i3 和 i4 指向不同的 Integer 对象，所以 i3&#x3D;&#x3D;i4 返回 false。</p>
<p>在平时开发中，优先使用后两种创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>第一种创建方式并不会使用到 IntegerCache，而后面两种创建方法可以利用 IntegerCache 缓存，返回共享的对象，以达到节省内存的目的。</p>
<h1 id="享元模式在-Java-String-中的应用"><a href="#享元模式在-Java-String-中的应用" class="headerlink" title="享元模式在 Java String 中的应用"></a>享元模式在 Java String 中的应用</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line">System.out.println(s1 == s3);</span><br></pre></td></tr></table></figure>

<p>上面代码的运行结果是：一个 true，一个 false。String 类 利用享元模式来复用相同的字符串常量，JVM 会专门开辟 一块存储区来存储字符串常量，这块存储区叫作“字符串常量池”。</p>
<p>不过，String 类的享元模式的设计，跟 Integer 类稍微有些不同。Integer 类中要共享的对 象，是在类加载的时候，就集中一次性创建好的。但是，对于字符串来说，我们没法事先知 道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的 时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需 要再重新创建了。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式的双重锁检查</title>
    <url>/2023/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8F%8C%E9%87%8D%E9%94%81%E6%A3%80%E6%9F%A5/</url>
    <content><![CDATA[<h1 id="一般的单例模式"><a href="#一般的单例模式" class="headerlink" title="一般的单例模式"></a>一般的单例模式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            uniqueSingleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在多线程情况下，可能会导致多个实例：</p>
<table>
<thead>
<tr>
<th><strong>Time</strong></th>
<th>Thread A</th>
<th>Thread B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>检查到<code>uniqueSingleton</code>为空</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>检查到<code>uniqueSingleton</code>为空</td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>初始化对象A</td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>返回对象A</td>
</tr>
<tr>
<td>T5</td>
<td>初始化对象B</td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td>返回对象B</td>
<td></td>
</tr>
</tbody></table>
<p>这种场景，就会创建两次对象。</p>
<h1 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h1><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            uniqueSingleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法也存在问题，加锁的粒度太大了，只有在创建对象时才需要加锁，后续获取对象时并不需要加锁。</p>
<h1 id="双重锁检查"><a href="#双重锁检查" class="headerlink" title="双重锁检查"></a>双重锁检查</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">                    <span class="comment">// 可能存在问题</span></span><br><span class="line">                    uniqueSingleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写，顺序就变成下面这样：</p>
<ol>
<li>先判断对象是否存在，不存在则加锁。</li>
<li>加完锁之后再次判断对象是否存在。</li>
<li>不存在则创建。</li>
</ol>
<p>双重加锁是因为如果多个线程同时通过了第一次判断，那么这几个线程中会有一个线程加锁成功，然后创建对象，后续线程在获取锁之后，就不用再继续创建对象。</p>
<h2 id="存在的隐患"><a href="#存在的隐患" class="headerlink" title="存在的隐患"></a>存在的隐患</h2><p>在实例化一个对象时，可以分为以下步骤：</p>
<ol>
<li>分配内存空间</li>
<li>初始化对象</li>
<li>将对象指向刚分配的内存空间</li>
</ol>
<p>但是编译器在为了执行速度，可能会进行<strong>指令重排序</strong>，那么顺序就有可能如下：</p>
<ol>
<li>分配内存空间</li>
<li>将对象指向刚分配的内存空间</li>
<li>初始化对象</li>
</ol>
<p>现在考虑如下场景：</p>
<table>
<thead>
<tr>
<th><strong>Time</strong></th>
<th>Thread A</th>
<th>Thread B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>检查到<code>uniqueSingleton</code>为空</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td>获取锁</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td>第二次检查<code>uniqueSingleton</code>为空</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td>为<code>uniqueSingleton</code>分配空间</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td>将<code>uniqueSingleton</code>指向内存空间</td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>检查到<code>uniqueSingleton</code>不为空</td>
</tr>
<tr>
<td>T7</td>
<td></td>
<td>访问<code>uniqueSingleton</code>（此时对象还未完成初始化）</td>
</tr>
<tr>
<td>T8</td>
<td>初始化将<code>uniqueSingleton</code></td>
<td></td>
</tr>
</tbody></table>
<p>这种情况下，线程B就访问到了一个还未初始化完成的对象。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>使用<code>volatile</code>关键字禁止指令重排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">                    uniqueSingleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>享元模式（上）</title>
    <url>/2023/06/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。</p>
<p>具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我 们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这 样可以减少内存中对象的数量，起到节省内存的目的。</p>
<h1 id="享元模式的两个应用场景"><a href="#享元模式的两个应用场景" class="headerlink" title="享元模式的两个应用场景"></a>享元模式的两个应用场景</h1><p>1、在象棋游戏中，每一句的棋子都是一样的，当有多个玩家时，不同玩家之间只是象棋的位置不同，那么我们就可以将一些基础的属性抽出来，供多个人使用，节省了内存。</p>
<p>2、文本编辑器中，每一个字体都可以单独的设置格式。对于字体格式，我们可以将它设计成享元，让不同的文字共享使用。</p>
<h1 id="享元模式-vs-单例、缓存、对象池"><a href="#享元模式-vs-单例、缓存、对象池" class="headerlink" title="享元模式 vs 单例、缓存、对象池"></a>享元模式 vs 单例、缓存、对象池</h1><h2 id="享元模式跟单例的区别"><a href="#享元模式跟单例的区别" class="headerlink" title="享元模式跟单例的区别"></a>享元模式跟单例的区别</h2><p>在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每 个对象被多处代码引用共享。实际上，享元模式有点类似于之前讲到的单例的变体：多例</p>
<p>应用享元模式是为了对象复用，节省内存，而应用单例模式是为 了限制对象的个数。</p>
<h2 id="享元模式跟缓存的区别"><a href="#享元模式跟缓存的区别" class="headerlink" title="享元模式跟缓存的区别"></a>享元模式跟缓存的区别</h2><p>在享元模式的实现中，我们通过工厂类来“缓存”已经创建好的对象。这里的“缓存”实际 上是“存储”的意思，跟我们平时所说的“数据库缓存”“CPU 缓存”“MemCache 缓 存”是两回事。我们平时所讲的缓存，主要是为了提高访问效率，而非复用。</p>
<h2 id="享元模式跟对象池的区别"><a href="#享元模式跟对象池的区别" class="headerlink" title="享元模式跟对象池的区别"></a>享元模式跟对象池的区别</h2><p>为了避免频繁地进行对象创 建和释放导致内存碎片，我们可以预先申请一片连续的内存空间，也就是这里说的对象池。每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放 回到对象池中以供后续复用，而非直接释放掉。</p>
<p><strong>池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库池中 取一个连接，不需要重新创建）</strong>。在任意时刻，每一个对象、连接、线程，并不会被多处使 用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。</p>
<p>享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享 的，<strong>主要目的是节省空间。</strong></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式（上）</title>
    <url>/2023/06/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<p>单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p>
<h1 id="案例1：处理资源访问冲突"><a href="#案例1：处理资源访问冲突" class="headerlink" title="案例1：处理资源访问冲突"></a>案例1：处理资源访问冲突</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class="line">        writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>); <span class="comment">//true表示追加写入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        writer.write(mesasge);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Logger类的应用示例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">        logger.log(username + <span class="string">&quot; logined!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(OrderVo order)</span> &#123;</span><br><span class="line">        <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">        logger.log(<span class="string">&quot;Created an order: &quot;</span> + order.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的例子可以看出，我们在两个controller中创建了两个Logger对象，在多线程环境下，如果两个 Servlet 线程同时分别执行 login() 和 create() 两个函数，同时写入日志文件，则可能会导致日志互相覆盖的情况。</p>
<h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><h3 id="1、加锁"><a href="#1、加锁" class="headerlink" title="1、加锁"></a>1、加锁</h3><p>我们可以给Logger对象加一把类级别的锁，同一时刻只有一个线程可以访问Logger对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class="line">        writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>); <span class="comment">//true表示追加写入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Logger.class) &#123; <span class="comment">// 类级别的锁</span></span><br><span class="line">            writer.write(mesasge);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，分布式锁以及并发队列也可以解决这个问题。</p>
<h3 id="2、单例模式"><a href="#2、单例模式" class="headerlink" title="2、单例模式"></a>2、单例模式</h3><p>我们将 Logger 设计成一个单例类，程序中只允许创建一个 Logger 对象，所有的线程共享 使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线 程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Logger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class="line">        writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>); <span class="comment">//true表示追加写入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        writer.write(mesasge);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Logger类的应用示例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">        Logger.getInstance().log(username + <span class="string">&quot; logined!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(OrderVo order)</span> &#123;</span><br><span class="line">        <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">        Logger.getInstance().log(<span class="string">&quot;Created a order: &quot;</span> + order.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="案例2：表示全局唯一类"><a href="#案例2：表示全局唯一类" class="headerlink" title="案例2：表示全局唯一类"></a>案例2：表示全局唯一类</h1><p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类，比如配置信息类，全局唯一id的生成器类等。</p>
<p>此处省略代码。</p>
<h1 id="如何实现一个单例？"><a href="#如何实现一个单例？" class="headerlink" title="如何实现一个单例？"></a>如何实现一个单例？</h1><p>实现单例需要关注以下几个点：</p>
<ul>
<li>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；</li>
<li>考虑对象创建时的线程安全问题；</li>
<li>考虑是否支持延迟加载；</li>
<li>考虑 getInstance() 性能是否高（是否加锁）。</li>
</ul>
<h2 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1. 饿汉式"></a>1. 饿汉式</h2><p>饿汉式的实现方式比较简单。在类加载的时候，instance 静态实例就已经创建并初始化好 了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加 载（在真正用到 IdGenerator 的时候，再创建实例）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">IdGenerator</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdGenerator</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2. 懒汉式"></a>2. 懒汉式</h2><p>懒汉式相对于饿汉式的优势是支持延迟加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IdGenerator instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">IdGenerator</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点也很明显，我们加了锁，导致并发度之有1，即串行操作，如果频繁的被用到，则会影响性能。</p>
<h2 id="3-双重检测"><a href="#3-双重检测" class="headerlink" title="3. 双重检测"></a>3. 双重检测</h2><p>该方法既支持延迟 加载、又支持高并发的单例实现方式。该方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再 进入到加锁逻辑中了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IdGenerator instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(IdGenerator.class) &#123; <span class="comment">// 此处为类级别的锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">IdGenerator</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种实现在低版本的jdk中，会因指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才 行。</p>
<p>但是在高版本的jdk不存在这个问题。</p>
<h2 id="4-静态内部类"><a href="#4-静态内部类" class="headerlink" title="4. 静态内部类"></a>4. 静态内部类</h2><p>它有点 类似饿汉式，但又能做到了延迟加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">IdGenerator</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdGenerator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会 被加载，这个时候才会创建 instance。insance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2023/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>代理模式在不改变原始类 （或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。</p>
<p>为了将框架代码和业务代码解耦，代理模式就派上用场了。代理类 UserControllerProxy 和原始类 UserController 实现相同的接口 IUserController。UserController 类只负责业 务功能。代理类 UserControllerProxy 负责在业务代码执行前后附加其他逻辑代码，并通 过委托的方式调用原始类来执行业务代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserController</span> &#123;</span><br><span class="line">    UserVo <span class="title function_">login</span><span class="params">(String telephone, String password)</span>;</span><br><span class="line">    UserVo <span class="title function_">register</span><span class="params">(String telephone, String password)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里只写业务逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> <span class="keyword">implements</span> <span class="title class_">IUserController</span> &#123;</span><br><span class="line">    <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserVo <span class="title function_">login</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">        <span class="comment">//...省略login逻辑...</span></span><br><span class="line">        <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserVo <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">        <span class="comment">//...省略register逻辑...</span></span><br><span class="line">        <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理类使用UserController，然后添加一些其他的逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserControllerProxy</span> <span class="keyword">implements</span> <span class="title class_">IUserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line">    <span class="keyword">private</span> UserController userController;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserControllerProxy</span><span class="params">(UserController userController)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userController = userController;</span><br><span class="line">        <span class="built_in">this</span>.metricsCollector = <span class="keyword">new</span> <span class="title class_">MetricsCollector</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserVo <span class="title function_">login</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 委托</span></span><br><span class="line">        <span class="type">UserVo</span> <span class="variable">userVo</span> <span class="operator">=</span> userController.login(telephone, password);</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">        <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;login&quot;</span>, responseTime, startTimes);</span><br><span class="line">        metricsCollector.recordRequest(requestInfo);</span><br><span class="line">        <span class="keyword">return</span> userVo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserVo <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">UserVo</span> <span class="variable">userVo</span> <span class="operator">=</span> userController.register(telephone, password);</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">        <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;register&quot;</span>, responseTime, startTimes);</span><br><span class="line">        metricsCollector.recordRequest(requestInfo);</span><br><span class="line">        <span class="keyword">return</span> userVo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//UserControllerProxy使用举例</span></span><br><span class="line"><span class="comment">//因为原始类和代理类实现相同的接口，是基于接口而非实现编程</span></span><br><span class="line"><span class="comment">//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码</span></span><br><span class="line"><span class="type">IUserController</span> <span class="variable">userController</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserControllerProxy</span>(<span class="keyword">new</span> <span class="title class_">UserController</span>())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是上面这种需要原始类是一个接口，如果原始类并不是我们开发的，比如说原始类是框架中的一个类，改怎么办？</p>
<p>对于这种外部类的扩展，我们一般都是采用继承的方式。我们让代理类继承 原始类，然后扩展附加功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserControllerProxy</span> <span class="keyword">extends</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserControllerProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.metricsCollector = <span class="keyword">new</span> <span class="title class_">MetricsCollector</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> UserVo <span class="title function_">login</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">UserVo</span> <span class="variable">userVo</span> <span class="operator">=</span> <span class="built_in">super</span>.login(telephone, password);</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">        <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;login&quot;</span>, responseTime, startTimes);</span><br><span class="line">        metricsCollector.recordRequest(requestInfo);</span><br><span class="line">        <span class="keyword">return</span> userVo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> UserVo <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">UserVo</span> <span class="variable">userVo</span> <span class="operator">=</span> <span class="built_in">super</span>.register(telephone, password);</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">        <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;register&quot;</span>, responseTime, startTimes);</span><br><span class="line">        metricsCollector.recordRequest(requestInfo);</span><br><span class="line">        <span class="keyword">return</span> userVo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//UserControllerProxy使用举例</span></span><br><span class="line"><span class="type">UserController</span> <span class="variable">userController</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserControllerProxy</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="动态代理的原理解析"><a href="#动态代理的原理解析" class="headerlink" title="动态代理的原理解析"></a>动态代理的原理解析</h1><p>上面的写法，每多一个代理类，就需要重新创建一个新的类，这样会导致比较繁琐。</p>
<p>我们可以使用动态代理，就是不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MetricsCollectorProxy</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MetricsCollectorProxy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.metricsCollector = <span class="keyword">new</span> <span class="title class_">MetricsCollector</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">createProxy</span><span class="params">(Object proxiedObject)</span> &#123;</span><br><span class="line">    Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();</span><br><span class="line">    <span class="type">DynamicProxyHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicProxyHandler</span>(proxiedObject);</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object proxiedObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicProxyHandler</span><span class="params">(Object proxiedObject)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.proxiedObject = proxiedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(proxiedObject, args);</span><br><span class="line">      <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">      <span class="type">String</span> <span class="variable">apiName</span> <span class="operator">=</span> proxiedObject.getClass().getName() + <span class="string">&quot;:&quot;</span> + method.getName();</span><br><span class="line">      <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(apiName, responseTime, startTimestamp);</span><br><span class="line">      metricsCollector.recordRequest(requestInfo);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MetricsCollectorProxy使用举例</span></span><br><span class="line"><span class="type">MetricsCollectorProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MetricsCollectorProxy</span>();</span><br><span class="line"><span class="type">IUserController</span> <span class="variable">userController</span> <span class="operator">=</span> (IUserController) proxy.createProxy(<span class="keyword">new</span> <span class="title class_">UserController</span>());</span><br></pre></td></tr></table></figure>

<p>Spring AOP 底层的实现原理就是基于动态代理。</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h2 id="1-业务系统的非功能性需求开发"><a href="#1-业务系统的非功能性需求开发" class="headerlink" title="1. 业务系统的非功能性需求开发"></a>1. 业务系统的非功能性需求开发</h2><p>在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类中统一处理。</p>
<h2 id="2-代理模式在-RPC、缓存中的应用"><a href="#2-代理模式在-RPC、缓存中的应用" class="headerlink" title="2. 代理模式在 RPC、缓存中的应用"></a>2. 代理模式在 RPC、缓存中的应用</h2><p>实际上，RPC 框架也可以看作一种代理模式，GoF 的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式（下）</title>
    <url>/2023/06/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="如何理解单例模式中的唯一性"><a href="#如何理解单例模式中的唯一性" class="headerlink" title="如何理解单例模式中的唯一性"></a>如何理解单例模式中的唯一性</h1><p>这个唯一性指的是进程内只允许创建一个对象。</p>
<h1 id="如何实现线程唯一的单例"><a href="#如何实现线程唯一的单例" class="headerlink" title="如何实现线程唯一的单例"></a>如何实现线程唯一的单例</h1><p>“进程唯一”指的是进程内唯一，进程间不唯一。“线程唯一”指的是线程内唯 一，线程间可以不唯一。</p>
<p>我们通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以 做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本 身提供了 ThreadLocal 工具类，可以更加轻松地实现线程唯一单例。不过，ThreadLocal 底层实现原理也是基于下面代码中所示的 HashMap。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Long, IdGenerator&gt; instances</span><br><span class="line">        = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">currentThreadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        instances.putIfAbsent(currentThreadId, <span class="keyword">new</span> <span class="title class_">IdGenerator</span>());</span><br><span class="line">        <span class="keyword">return</span> instances.get(currentThreadId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="如何实现集群环境下的单例"><a href="#如何实现集群环境下的单例" class="headerlink" title="如何实现集群环境下的单例"></a>如何实现集群环境下的单例</h1><p>集群相当于多个进程构成的 一个集合，“集群唯一”就相当于是进程内唯一、进程间也唯一。也就是说，不同的进程间 共享同一个对象，不能创建同一个类的多个对象。</p>
<p>具体来说，我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在 使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对 象，然后再使用，使用完成之后还需要再存储回外部共享存储区。</p>
<p>为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对 象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内 存中删除，并且释放对对象的加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IdGenerator instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SharedObjectStorage</span> <span class="variable">storage</span> <span class="operator">=</span> FileSharedObjectStorage();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DistributedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DistributedLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            instance = storage.load(IdGenerator.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> synchroinzed <span class="keyword">void</span> <span class="title function_">freeInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        storage.save(<span class="built_in">this</span>, IdGeneator.class);</span><br><span class="line">        instance = <span class="literal">null</span>; <span class="comment">//释放对象</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// IdGenerator使用举例</span></span><br><span class="line"><span class="type">IdGenerator</span> <span class="variable">idGeneator</span> <span class="operator">=</span> IdGenerator.getInstance();</span><br><span class="line"><span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> idGenerator.getId();</span><br><span class="line">IdGenerator.freeInstance();</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式（中）</title>
    <url>/2023/06/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
    <content><![CDATA[<h1 id="单例存在的问题"><a href="#单例存在的问题" class="headerlink" title="单例存在的问题"></a>单例存在的问题</h1><p>我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息 类、连接池类、ID 生成器类，但 是，这种使用方法有点类似硬编码（hard code），会带来诸多问题。</p>
<h2 id="1、对-OOP-特性的支持不友好"><a href="#1、对-OOP-特性的支持不友好" class="headerlink" title="1、对 OOP 特性的支持不友好"></a>1、对 OOP 特性的支持不友好</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(...)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> IdGenerator.getInstance().getId();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(...)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> IdGenerator.getInstance().getId();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种涉及违背了基于接口而非实现的设计原则，如果未来某一天，我们希望针对不同的业务采用不同的 ID 生成算法。 比如，订单 ID 和用户 ID 采用不同的 ID 生成器来生成。为了应对这个需求变化，我们需要修改所有用到 IdGenerator 类的地方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(...)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> IdGenerator.getInstance().getId();</span><br><span class="line">        <span class="comment">// 需要将上面一行代码，替换为下面一行代码</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> OrderIdGenerator.getIntance().getId();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(...)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> IdGenerator.getInstance().getId();</span><br><span class="line">        <span class="comment">// 需要将上面一行代码，替换为下面一行代码</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> UserIdGenerator.getIntance().getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，单例对继承、多态特性的支持也不友好。</p>
<h2 id="2、单例会隐藏类之间的依赖关系"><a href="#2、单例会隐藏类之间的依赖关系" class="headerlink" title="2、单例会隐藏类之间的依赖关系"></a>2、单例会隐藏类之间的依赖关系</h2><p>通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能 很容易识别出来。但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用 就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。</p>
<h2 id="3、单例对代码的扩展性不友好"><a href="#3、单例对代码的扩展性不友好" class="headerlink" title="3、单例对代码的扩展性不友好"></a>3、单例对代码的扩展性不友好</h2><p>比如，在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据 库连接资源的消耗。所以，我们把数据库连接池类设计成了单例类。</p>
<p>但之后我们发现，系统 中有些 SQL 语句运行得非常慢。这些 SQL 语句在执行的时候，长时间占用数据库连接资源，导致其他 SQL 请求无法响应。为了解决这个问题，我们希望将慢 SQL 与其他 SQL 隔 离开来执行。</p>
<p>为了实现这样的目的，我们可以在系统中创建两个数据库连接池，慢 SQL 独 享一个数据库连接池，其他 SQL 独享另外一个数据库连接池，这样就能避免慢 SQL 影响到 其他 SQL 的执行。</p>
<h2 id="4、单例对代码的可测试性不友好"><a href="#4、单例对代码的可测试性不友好" class="headerlink" title="4、单例对代码的可测试性不友好"></a>4、单例对代码的可测试性不友好</h2><p>如果单例类依赖比较重的外部资源，比如 DB， 我们在写单元测试的时候，希望能通过 mock 的方式将它替换掉。而单例类这种硬编码式 的使用方式，导致无法实现 mock 替换。</p>
<p>而且单例往往可以理解为一个全局唯一的变量，在编写单元测试时，需要注意不同测试用例之间修改了单例的值，对测试结果的影响。</p>
<h2 id="5、单例不支持有参数的构造函数"><a href="#5、单例不支持有参数的构造函数" class="headerlink" title="5、单例不支持有参数的构造函数"></a>5、单例不支持有参数的构造函数</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2023/06/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="原型模式的原理与应用"><a href="#原型模式的原理与应用" class="headerlink" title="原型模式的原理与应用"></a>原型模式的原理与应用</h1><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同）， 在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新 对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式 （Prototype Design Pattern），简称原型模式。</p>
<h2 id="什么是对象成本创建比较大"><a href="#什么是对象成本创建比较大" class="headerlink" title="什么是对象成本创建比较大"></a>什么是对象成本创建比较大</h2><p>如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需 要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利 用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执 行这些耗时的操作。</p>
<h1 id="原型模式的实现方式：深拷贝和浅拷贝"><a href="#原型模式的实现方式：深拷贝和浅拷贝" class="headerlink" title="原型模式的实现方式：深拷贝和浅拷贝"></a>原型模式的实现方式：深拷贝和浅拷贝</h1><p>散列表索引中，每个结点存储的 key 是搜索关 键词，value 是 SearchWord 对象的内存地址。SearchWord 对象本身存储在散列表之外 的内存空间中。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230612154147518.png" alt="image-20230612154147518" style="zoom:67%;" />

<p>浅拷贝和深拷贝的区别在于，<strong>浅拷贝只会复制图中的索引（散列表），不会复制数据 （SearchWord 对象）本身</strong>。相反，<strong>深拷贝不仅仅会复制索引，还会复制数据本身</strong>。浅拷 贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据 （SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230612154246807.png" alt="image-20230612154246807"></p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230612154256726.png" alt="image-20230612154256726"></p>
<p>在 Java 语言中，Object 类的 clone() 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对 象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存 地址，不会递归地拷贝引用对象本身。</p>
<h1 id="两个深拷贝demo"><a href="#两个深拷贝demo" class="headerlink" title="两个深拷贝demo"></a>两个深拷贝demo</h1><p>递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对 象只包含基本数据类型数据，没有引用对象为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastUpdateTime</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Deep copy</span></span><br><span class="line">        HashMap&lt;String, SearchWord&gt; newKeywords = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) &#123;</span><br><span class="line">            <span class="type">SearchWord</span> <span class="variable">searchWord</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            <span class="type">SearchWord</span> <span class="variable">newSearchWord</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchWord</span>(</span><br><span class="line">                searchWord.getKeyword(), searchWord.getCount(), searchWord.getLast());</span><br><span class="line">            newKeywords.put(e.getKey(), newSearchWord);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class="line">        List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class="line">        <span class="type">long</span> <span class="variable">maxNewUpdatedTime</span> <span class="operator">=</span> lastUpdateTime;</span><br><span class="line">        <span class="keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class="line">            <span class="keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class="line">                maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class="line">                <span class="type">SearchWord</span> <span class="variable">oldSearchWord</span> <span class="operator">=</span> newKeywords.get(searchWord.getKeyword());</span><br><span class="line">                oldSearchWord.setCount(searchWord.getCount());</span><br><span class="line">                oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastUpdateTime = maxNewUpdatedTime;</span><br><span class="line">        currentKeywords = newKeywords;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> List&lt;SearchWord&gt; <span class="title function_">getSearchWords</span><span class="params">(<span class="type">long</span> lastUpdateTime)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>demo2先将对象序列化，然后再反序列化成新的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">deepCopy</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">bo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bo);</span><br><span class="line">    oo.writeObject(object);</span><br><span class="line">    <span class="type">ByteArrayInputStream</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bo.toByteArray());</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">oi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bi);</span><br><span class="line">    <span class="keyword">return</span> oi.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/2023/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不 同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等 （附加控制）功能。</p>
<p>一些编程语言不支持传递函数，但是我们将函数封装在对象中，然后传递对象，就可以达到同样的效果。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘录模式</title>
    <url>/2023/06/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>备忘录模式，也叫快照（Snapshot）模式，在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外 保存这个状态，以便之后恢复对象为先前的状态。</p>
<p>这个模式包含两部分：一部分是，存储副本以便后期恢复。另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。</p>
<p>一个demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputText</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringBuilder</span> <span class="variable">text</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getText</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> text.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        text.append(input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Snapshot <span class="title function_">createSnapshot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Snapshot</span>(text.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreSnapshot</span><span class="params">(Snapshot snapshot)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.text.replace(<span class="number">0</span>, <span class="built_in">this</span>.text.length(), snapshot.getText());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Snapshot</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Snapshot</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getText</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnapshotHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Snapshot&gt; snapshots = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> Snapshot <span class="title function_">popSnapshot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> snapshots.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushSnapshot</span><span class="params">(Snapshot snapshot)</span> &#123;</span><br><span class="line">        snapshots.push(snapshot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InputText</span> <span class="variable">inputText</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputText</span>();</span><br><span class="line">        <span class="type">SnapshotHolder</span> <span class="variable">snapshotsHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SnapshotHolder</span>();</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="keyword">if</span> (input.equals(<span class="string">&quot;:list&quot;</span>)) &#123;</span><br><span class="line">                System.out.println(inputText.toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input.equals(<span class="string">&quot;:undo&quot;</span>)) &#123;</span><br><span class="line">                <span class="type">Snapshot</span> <span class="variable">snapshot</span> <span class="operator">=</span> snapshotsHolder.popSnapshot();</span><br><span class="line">                inputText.restoreSnapshot(snapshot);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                snapshotsHolder.pushSnapshot(inputText.createSnapshot());</span><br><span class="line">                inputText.append(input);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式（下）</title>
    <url>/2023/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<p>这篇文章主要涉及的内容是依赖注入框架，或者叫依赖注入容器，简称DI容器。</p>
<h1 id="工厂模式和-DI-容器的区别"><a href="#工厂模式和-DI-容器的区别" class="headerlink" title="工厂模式和 DI 容器的区别"></a>工厂模式和 DI 容器的区别</h1><p>DI 容器底层最基本的设计思路就是<strong>基于工厂模式</strong>的。DI 容器相当于一个大的工厂 类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪 些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。</p>
<p>一个工厂类只负责某个对象或者某一组相关类的创建，而DI容器负责的是整个应用中所有类对象的创建。</p>
<h1 id="DI-容器的核心功能"><a href="#DI-容器的核心功能" class="headerlink" title="DI 容器的核心功能"></a>DI 容器的核心功能</h1><p>一般有三个：配置解析、对象创建和对象生命周期管理。</p>
<h2 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h2><p>工厂类要创建哪个对象都是写死的，属于事先定义好的，但是DI容器并不知道应用会创建哪个对象，与不可能全部写死。</p>
<p>我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对 应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。</p>
<p>DI容器通过解析这些配置文件，来得知具体创建哪些对象。</p>
<h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，我们只需要将所有类对象的创建都放到 一个工厂类中完成就可以了，比如 BeansFactory。</p>
<p>而通过反射，我们可以保证BeansFactory中的代码并不会根据创建对象的增加而增多，不管是创建一个对象还是十个对象， BeansFactory 工厂类代码都是一样的。</p>
<h2 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式（上）</title>
    <url>/2023/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<p>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。其中抽象工厂是最复杂得一个，在本篇文章中，之介绍简单工厂和抽象工厂。</p>
<h1 id="简单工厂（Simple-Factory）"><a href="#简单工厂（Simple-Factory）" class="headerlink" title="简单工厂（Simple Factory）"></a>简单工厂（Simple Factory）</h1><p>如下代码，我们根据配置文件的后缀（json、xml、yaml、properties），选择不 同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的 配置解析成内存对象 RuleConfig。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigSource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> RuleConfig <span class="title function_">load</span><span class="params">(String ruleConfigFilePath)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ruleConfigFileExtension</span> <span class="operator">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class="line">        <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParser</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParser</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParser</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidRuleConfigException</span>(</span><br><span class="line">                <span class="string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">configText</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">        <span class="type">RuleConfig</span> <span class="variable">ruleConfig</span> <span class="operator">=</span> parser.parse(configText);</span><br><span class="line">        <span class="keyword">return</span> ruleConfig;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getFileExtension</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单工厂模式的第一种实现"><a href="#简单工厂模式的第一种实现" class="headerlink" title="简单工厂模式的第一种实现"></a>简单工厂模式的第一种实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigSource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> RuleConfig <span class="title function_">load</span><span class="params">(String ruleConfigFilePath)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ruleConfigFileExtension</span> <span class="operator">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class="line">        <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> RuleConfigParserFactory.createParser(ruleConfigFileExtension);</span><br><span class="line">        <span class="keyword">if</span> (parser == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidRuleConfigException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">configText</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">        <span class="type">RuleConfig</span> <span class="variable">ruleConfig</span> <span class="operator">=</span> parser.parse(configText);</span><br><span class="line">        <span class="keyword">return</span> ruleConfig;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getFileExtension</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体的工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigParserFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">(String configFormat)</span> &#123;</span><br><span class="line">        <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParser</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParser</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParser</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单工厂模式的第二种实现"><a href="#简单工厂模式的第二种实现" class="headerlink" title="简单工厂模式的第二种实现"></a>简单工厂模式的第二种实现</h2><p>第一种实现下，我们每次调用 RuleConfigParserFactory 的 createParser() 的时 候，都要创建一个新的 parser。</p>
<p>如果 parser 可以复用，为了节省内存和对象创建 的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我 们从缓存中取出 parser 对象直接使用，也就是下面这种实现。</p>
<p>这种实现是为了对象的复用，也就是说单例模式和简单工厂结合起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigParserFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, RuleConfigParser&gt; cachedParsers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        cachedParsers.put(<span class="string">&quot;json&quot;</span>, <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>());</span><br><span class="line">        cachedParsers.put(<span class="string">&quot;xml&quot;</span>, <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParser</span>());</span><br><span class="line">        cachedParsers.put(<span class="string">&quot;yaml&quot;</span>, <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParser</span>());</span><br><span class="line">        cachedParsers.put(<span class="string">&quot;properties&quot;</span>, <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParser</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">(String configFormat)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (configFormat == <span class="literal">null</span> || configFormat.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//返回null还是IllegalArgumentException全凭你自己说了算</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> cachedParsers.get(configFormat.toLowerCase());</span><br><span class="line">        <span class="keyword">return</span> parser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h1><p>上面的if分支还不算太多，可以接收。但是如果我们非要把if分支去了，就可以利用多态，按照下面这种方法重构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRuleConfigParserFactory</span> &#123;</span><br><span class="line">    IRuleConfigParser <span class="title function_">createParser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IRuleConfigParserFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XmlRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IRuleConfigParserFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YamlRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IRuleConfigParserFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IRuleConfigParserFact</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParser</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是工厂方法模式的典型代码实现。这样当我们新增一种 parser 的时候，只需 要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，工厂方法模 式比起简单工厂模式更加符合开闭原则。</p>
<p>但这种写法并没有解决问题，反到让设计更加复杂。</p>
<p>解决办法：我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。</p>
<p>其中，RuleConfigParserFactoryMap 类是创建工厂对象的工厂类，getParserFactory() 返回的是缓存好的单例工厂对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigSource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> RuleConfig <span class="title function_">load</span><span class="params">(String ruleConfigFilePath)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ruleConfigFileExtension</span> <span class="operator">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class="line"></span><br><span class="line">        <span class="type">IRuleConfigParserFactory</span> <span class="variable">parserFactory</span> <span class="operator">=</span> RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);</span><br><span class="line">        <span class="keyword">if</span> (parserFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidRuleConfigException</span>(ruleConfigFilePath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> parserFactory.createParser();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">configText</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">        <span class="type">RuleConfig</span> <span class="variable">ruleConfig</span> <span class="operator">=</span> parser.parse(configText);</span><br><span class="line">        <span class="keyword">return</span> ruleConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getFileExtension</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为工厂类只包含方法，不包含成员变量，完全可以复用，</span></span><br><span class="line"><span class="comment">//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigParserFactoryMap</span> &#123; <span class="comment">//工厂的工厂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        cachedFactories.put(<span class="string">&quot;json&quot;</span>, <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParserFactory</span>());</span><br><span class="line">        cachedFactories.put(<span class="string">&quot;xml&quot;</span>, <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParserFactory</span>());</span><br><span class="line">        cachedFactories.put(<span class="string">&quot;yaml&quot;</span>, <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParserFactory</span>());</span><br><span class="line">        cachedFactories.put(<span class="string">&quot;properties&quot;</span>, <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParserFactory</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParserFactory <span class="title function_">getParserFactory</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span> || type.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">IRuleConfigParserFactory</span> <span class="variable">parserFactory</span> <span class="operator">=</span> cachedFactories.get(type.toLowerCase());</span><br><span class="line">        <span class="keyword">return</span> parserFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们需要添加新的规则配置解析器的时候，我们只需要创建新的 parser 类和 parser factory 类，并且在 RuleConfigParserFactoryMap 类中，将新的 parser factory 对象添加到 cachedFactories 中即可。</p>
<h1 id="怎么选择使用哪个"><a href="#怎么选择使用哪个" class="headerlink" title="怎么选择使用哪个"></a>怎么选择使用哪个</h1><p>当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，推荐使用<strong>工厂方法模式</strong>，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。</p>
<p>除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>模板方法（上）</title>
    <url>/2023/06/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<h1 id="模板模式的原理与实现"><a href="#模板模式的原理与实现" class="headerlink" title="模板模式的原理与实现"></a>模板模式的原理与实现</h1><p>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类 中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些 步骤。</p>
<p>一个具体的例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        method1();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        method2();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass1</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass2</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">AbstractClass</span> <span class="variable">demo</span> <span class="operator">=</span> ConcreteClass1();</span><br><span class="line">demo.templateMethod();</span><br></pre></td></tr></table></figure>

<h1 id="模板模式作用一：复用"><a href="#模板模式作用一：复用" class="headerlink" title="模板模式作用一：复用"></a>模板模式作用一：复用</h1><p>模板模式把一个算法中不变的流程抽象到父类的模板方法 templateMethod() 中，将可变的部分 method1()、method2() 留给子类 ContreteClass1 和 ContreteClass2 来实现。 所有的子类都可以复用父类中模板方法定义的流程代码。</p>
<h1 id="模板模式作用二：扩展"><a href="#模板模式作用二：扩展" class="headerlink" title="模板模式作用二：扩展"></a>模板模式作用二：扩展</h1><p>模板模式的第二大作用的是扩展。这里所说的扩展，并不是指代码的扩展性，而是指框架的 扩展性，有点类似我们之前讲到的控制反转。基于这个作用，模板模式常用在框架的开发中，让框架用户可以在不修改框架源码的情况下，定制化框架的功能。</p>
<h2 id="1-Java-Servlet"><a href="#1-Java-Servlet" class="headerlink" title="1.Java Servlet"></a>1.Java Servlet</h2><p>在平时开发中，如果我们使用Servlet进行web开发，那么就需要继承 HttpServlet，并且重写其中的 doGet() 或 doPost() 方 法，来分别处理 get 和 post 请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> Expection &#123;</span><br><span class="line">        <span class="built_in">this</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throw</span> Expection &#123;</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;Hello World.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，我们还需要在配置文件 web.xml 中做如下配置。Tomcat、Jetty 等 Servlet 容 器在启动的时候，会自动加载这个配置文件中的 URL 和 Servlet 之间的映射关系。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.xzg.cd.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当我们在浏览器中输入网址（比如，<a href="http://127.0.0.1:8080/hello">http://127.0.0.1:8080/hello</a> ）的时候，Servlet 容 器会接收到相应的请求，并且根据 URL 和 Servlet 之间的映射关系，找到相应的 Servlet（HelloServlet），然后执行它的 service() 方法。service() 方法定义在父类 HttpServlet 中，它会调用 doGet() 或 doPost() 方法，然后输出数据（“Hello world”）到网页。</p>
<p>以下是service方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    HttpServletRequest request;</span><br><span class="line">    HttpServletResponse response;</span><br><span class="line">    <span class="keyword">if</span> (!(req <span class="keyword">instanceof</span> HttpServletRequest &amp;&amp;</span><br><span class="line">          res <span class="keyword">instanceof</span> HttpServletResponse)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;non-HTTP request or response&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    request = (HttpServletRequest) req;</span><br><span class="line">    response = (HttpServletResponse) res;</span><br><span class="line">    service(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">    <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// servlet doesn&#x27;t support if-modified-since, no reason</span></span><br><span class="line">            <span class="comment">// to go through further expensive logic</span></span><br><span class="line">            doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ifModifiedSince</span> <span class="operator">=</span> req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">            <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">                maybeSetLastModified(resp, lastModified);</span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">        maybeSetLastModified(resp, lastModified);</span><br><span class="line">        doHead(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">        doPut(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">        doDelete(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">        doOptions(req,resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">        doTrace(req,resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line">        errArgs[<span class="number">0</span>] = method;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中我们可以看出，HttpServlet 的 service() 方法就是一个模板方法，它实现 了整个 HTTP 请求的执行流程，doGet()、doPost() 是模板中可以由子类来定制的部分。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>接口和抽象类</title>
    <url>/2023/05/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="抽象类的例子"><a href="#抽象类的例子" class="headerlink" title="抽象类的例子"></a>抽象类的例子</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> enabled;</span><br><span class="line">    <span class="keyword">private</span> Level minPermittedLevel;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.enabled = enabled;</span><br><span class="line">        <span class="built_in">this</span>.minPermittedLevel = minPermittedLevel;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loggable</span> <span class="operator">=</span> enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intVal)</span><br><span class="line">            <span class="keyword">if</span> (!loggable) <span class="keyword">return</span>;</span><br><span class="line">        doLog(level, message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">(Level level, String message)</span>;                    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类的子类：输出日志到文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Writer fileWriter;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel, String filepath)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">        <span class="built_in">this</span>.fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(filepath);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">(Level level, String mesage)</span> &#123;</span><br><span class="line">        <span class="comment">// 格式化 level 和 message, 输出到日志文件</span></span><br><span class="line">        fileWriter.write(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类的子类: 输出日志到消息中间件 (比如 kafka)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageQueueLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MessageQueueClient msgQueueClient;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageQueueLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled,</span></span><br><span class="line"><span class="params">                              Level minPermittedLevel, MessageQueueClient msgQueueClient)</span> &#123;</span><br><span class="line">    	<span class="built_in">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">    	<span class="built_in">this</span>.msgQueueClient = msgQueueClient;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">(Level level, String mesage)</span> &#123;</span><br><span class="line">        <span class="comment">// 格式化 level 和 message, 输出到消息中间件</span></span><br><span class="line">        msgQueueClient.send(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类不允许被实例化，只能被继承。也就是说，你不能 new 一个抽象类的对象出来 （Logger logger &#x3D; new Logger(…); 会报编译错误）。 </p>
<p>抽象类可以包含属性和方法。方法既可以包含代码实现（比如 Logger 中的 log() 方 法），也可以不包含代码实现（比如 Logger 中的 doLog() 方法）。不包含代码实现的 方法叫作抽象方法。 </p>
<p>子类继承抽象类，必须实现抽象类中的所有抽象方法。对应到例子代码中就是，所有继 承 Logger 抽象类的子类，都必须重写 doLog() 方法。</p>
<h1 id="接口的例子"><a href="#接口的例子" class="headerlink" title="接口的例子"></a>接口的例子</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现类：鉴权过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthencationFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="comment">//... 鉴权逻辑..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现类：限流过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimitFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="comment">//... 限流逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 过滤器使用 demo</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="comment">// filters.add(new AuthencationFilter());</span></span><br><span class="line">    <span class="comment">// filters.add(new RateLimitFilter());</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Filter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRpcRequest</span><span class="params">(RpcRequest req)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Filter filter : fitlers) &#123;</span><br><span class="line">                filter.doFilter(req);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(RpcException e) &#123;</span><br><span class="line">            <span class="comment">// ... 处理过滤结果...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... 省略其他处理逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口不能包含属性（也就是成员变量）。 </p>
<p>接口只能声明方法，方法不能包含代码实现。 </p>
<p>类实现接口的时候，必须实现接口中声明的所有方法.</p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>接口和抽象类，他们要解决的问题不一样 ，首先接口是为了解耦，而抽象类是为了减少编写重复的代码。</p>
<p>比如说类A和类B都要写一个方法doSomething，那么就可以写一个抽象类，然后A和B都继承该抽象类，而且类A和B可以各自添加各自的功能。</p>
<p>而接口的解耦体现在，我们定义一个接口之后，他可以有多个实现，我们基于他不同的实现来达到对于模块的划分，隔离接口和具体的实现，提高代码的扩展性。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>模板方法（下）</title>
    <url>/2023/06/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<p>回调也可以实现类似于模板模式的作用。</p>
<h1 id="回调的原理解析"><a href="#回调的原理解析" class="headerlink" title="回调的原理解析"></a>回调的原理解析</h1><p>相对于普通的函数调用来说，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。</p>
<p>A 类如何将回调函数传递给 B 类呢？不同的编程语言，有不同的实现方法。C 语言可以使 用函数指针，Java 则需要使用包裹了回调函数的类对象，我们简称为回调对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICallback</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodToCallback</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(ICallback callback)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        callback.methodToCallback();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BClass</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BClass</span>();</span><br><span class="line">        b.process(<span class="keyword">new</span> <span class="title class_">ICallback</span>() &#123; <span class="comment">//回调对象</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodToCallback</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Call back me.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从代码实现中，我们可以看出，回调跟模板模 式一样，也具有复用和扩展的功能。除了回调函数之外，BClass 类的 process() 函数中的 逻辑都可以复用。</p>
<p>如果 ICallback、BClass 类是框架代码，AClass 是使用框架的客户端代码，我们可以通过 ICallback 定制 process() 函数，也就是说，框架因此具有了扩展的能力。</p>
<p>我们使用了框架的代码逻辑，而且利用回调，在框架的逻辑中插入了我们需要做的修改，因此说具有了扩展能力。</p>
<p>Spring 提供了很多 Template 类，比如，JdbcTemplate、RedisTemplate、 RestTemplate。尽管都叫作 xxxTemplate，但它们并非基于模板模式来实现的，而是基于回调来实现的，确切地说应该是同步回调。</p>
<h1 id="模板模式-VS-回调"><a href="#模板模式-VS-回调" class="headerlink" title="模板模式 VS 回调"></a>模板模式 VS 回调</h1><p>从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自 由替换其中的某个步骤，起到代码复用和扩展的目的。而异步回调跟模板模式有较大差别， 更像是观察者模式。</p>
<p>从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递 给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽 象方法，是一种类之间的关系。</p>
<p>在代码实现上，回调相对于模板 模式会更加灵活，主要体现在下面几点：</p>
<ul>
<li>像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不 再具有继承的能力。</li>
<li>回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实 现都要定义不同的子类。</li>
<li>如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到 其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需 要往用到的模板方法中注入回调对象即可。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>职责链模式（下）</title>
    <url>/2023/06/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<p>职责链模式常用在框架的开发中，为框架提供扩展点，让框架的使用者在不修改框架源码的情况下，基于扩展点添加新的功能。实际上，更具体点来说，职责链模式最常用来开发框架的过滤器和拦截器。</p>
<h1 id="Servlet-Filter"><a href="#Servlet-Filter" class="headerlink" title="Servlet Filter"></a>Servlet Filter</h1><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230625102800683.png" alt="image-20230625102800683" style="zoom:67%;" />

<p>其中核心设计代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ApplicationFilterChain</span> <span class="keyword">implements</span> <span class="title class_">FilterChain</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 当前执行到了哪个filter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n; </span><br><span class="line">    <span class="comment">// filter的个数</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationFilterConfig[] filters;</span><br><span class="line">    <span class="keyword">private</span> Servlet servlet;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">            <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> filters[pos++];</span><br><span class="line">            <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> filterConfig.getFilter();</span><br><span class="line">            <span class="comment">// 这里是一个递归调用，每次进一层时pos就会++，当到达最后时，就会走else</span></span><br><span class="line">            filter.doFilter(request, response, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// filter都处理完毕后，执行servlet</span></span><br><span class="line">            servlet.service(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(ApplicationFilterConfig filterConfig)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ApplicationFilterConfig filter:filters)</span><br><span class="line">            <span class="keyword">if</span> (filter==filterConfig)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == filters.length) &#123;</span><br><span class="line">            <span class="comment">// 扩容</span></span><br><span class="line">            ApplicationFilterConfig[] newFilters = <span class="keyword">new</span> <span class="title class_">ApplicationFilterConfig</span>[n + IN];</span><br><span class="line">            System.arraycopy(filters, <span class="number">0</span>, newFilters, <span class="number">0</span>, n);</span><br><span class="line">            filters = newFilters;</span><br><span class="line">        &#125;</span><br><span class="line">        filters[n++] = filterConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Spring-Interceptor"><a href="#Spring-Interceptor" class="headerlink" title="Spring Interceptor"></a>Spring Interceptor</h1><p>这个也是一个拦截器，和Servlet Filter不同的是，Servlet Filter 是 Servlet 规范的一部分，实现依赖于 Web 容器。 Spring Interceptor 是 Spring MVC 框架的一部分，由 Spring MVC 框架来提供实现。客 户端发送的请求，会先经过 Servlet Filter，然后再经过 Spring Interceptor，最后到达具 体的业务代码中。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230625105015677.png" alt="image-20230625105015677"></p>
<p>它的底层实现也是基于职责链模式实现。</p>
<p>其中，HandlerExecutionChain 类是职责链模式中 的处理器链。它的实现相较于 Tomcat 中的 ApplicationFilterChain 来说，逻辑更加清 晰，不需要使用递归来实现，主要是因为它将请求和响应的拦截工作，拆分到了两个函数中实现。关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerExecutionChain</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line">    <span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptor</span><span class="params">(HandlerInterceptor interceptor)</span> &#123;</span><br><span class="line">        initInterceptorList().add(interceptor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">                <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">                <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="built_in">this</span>.handler)) &#123;</span><br><span class="line">                    triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> interceptors.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">                interceptor.postHandle(request, response, <span class="built_in">this</span>.handler, mv);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    interceptor.afterCompletion(request, response, <span class="built_in">this</span>.handler, ex);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;HandlerInterceptor.afterCompletion threw exception&quot;</span>, ex2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器模式</title>
    <url>/2023/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="装饰器模式理论"><a href="#装饰器模式理论" class="headerlink" title="装饰器模式理论"></a>装饰器模式理论</h1><p>装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。</p>
<p>1、装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。</p>
<p>比如下面这种，他就是对DataInputStream的一种增强，装进了一个FileInputStream和BufferedInputStream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/user/wangzheng/test.txt&quot;</span>);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(in);</span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">din</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(bin);</span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> din.readInt();</span><br></pre></td></tr></table></figure>

<p>2、装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重 要特点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代理模式的代码结构(下面的接口也可以替换成抽象类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> impelements IA &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类，在原先的类A的f操作上添加一些其他的功能（不改变原先的A）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AProxy</span> impements IA &#123;</span><br><span class="line">    <span class="keyword">private</span> IA a;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AProxy</span><span class="params">(IA a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 新添加的代理逻辑</span></span><br><span class="line">        a.f();</span><br><span class="line">        <span class="comment">// 新添加的代理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器模式的代码结构(下面的接口也可以替换成抽象类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> impelements IA &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ADecorator</span> impements IA &#123;</span><br><span class="line">    <span class="keyword">private</span> IA a;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ADecorator</span><span class="params">(IA a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 功能增强代码</span></span><br><span class="line">        a.f();</span><br><span class="line">        <span class="comment">// 功能增强代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2023/06/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<p>策略模式，最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断，它也可以像模板模式那样，提供框架的扩展点等等。</p>
<h1 id="策略模式的原理与实现"><a href="#策略模式的原理与实现" class="headerlink" title="策略模式的原理与实现"></a>策略模式的原理与实现</h1><p>定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略 模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。</p>
<p>工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者，策略模式跟两者类似，也能起到解耦的作用，不过，它解耦的是策略的定义、创建、使用这三部分。</p>
<h2 id="1-策略的定义"><a href="#1-策略的定义" class="headerlink" title="1. 策略的定义"></a>1. 策略的定义</h2><p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//具体的算法...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//具体的算法...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-策略的创建"><a href="#2-策略的创建" class="headerlink" title="2. 策略的创建"></a>2. 策略的创建</h2><p>因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。为了封装创建逻辑，需要对客户端代码屏蔽创建细节。可以把根据 type 创建策略的逻辑抽离出来，放到工厂类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Strategy&gt; strategies = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        strategies.put(<span class="string">&quot;A&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>());</span><br><span class="line">        strategies.put(<span class="string">&quot;B&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title function_">getStrategy</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span> || type.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;type should not be empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strategies.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果策略类是无状态的，只包含算法实现，可以被共享，就可以使用上面这种方法实现。</p>
<p>但是如果策略类是有状态的，需要根据业务场景的需要获得不同的对象，那么就需要如下方式创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title function_">getStrategy</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span> || type.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;type should not be empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-策略的使用"><a href="#3-策略的使用" class="headerlink" title="3. 策略的使用"></a>3. 策略的使用</h2><p>策略模式包含一组可选策略，客户端代码一般是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景。</p>
<p>这里的“运行时动态”指的是，我们事先并不知道会使用哪个策略，而是在程序运行期间， 根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略接口：EvictionStrategy</span></span><br><span class="line"><span class="comment">// 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...</span></span><br><span class="line"><span class="comment">// 策略工厂：EvictionStrategyFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, User&gt; cacheData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> EvictionStrategy eviction;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserCache</span><span class="params">(EvictionStrategy eviction)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.eviction = eviction;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行时动态确定，根据配置文件的配置决定使用哪种策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">EvictionStrategy</span> <span class="variable">evictionStrategy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        props.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./config.properties&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;eviction_type&quot;</span>);</span><br><span class="line">        evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type);</span><br><span class="line">        <span class="type">UserCache</span> <span class="variable">userCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserCache</span>(evictionStrategy);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非运行时动态确定，在代码中指定使用哪种策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="type">EvictionStrategy</span> <span class="variable">evictionStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LruEvictionStrategy</span>();</span><br><span class="line">        <span class="type">UserCache</span> <span class="variable">userCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserCache</span>(evictionStrategy);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用策略模式来避免分支"><a href="#使用策略模式来避免分支" class="headerlink" title="使用策略模式来避免分支"></a>使用策略模式来避免分支</h2><p>分支代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">discount</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">discount</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="type">OrderType</span> <span class="variable">type</span> <span class="operator">=</span> order.getType();</span><br><span class="line">        <span class="keyword">if</span> (type.equals(OrderType.NORMAL)) &#123; <span class="comment">// 普通订单</span></span><br><span class="line">            <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.GROUPON)) &#123; <span class="comment">// 团购订单</span></span><br><span class="line">            <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.PROMOTION)) &#123; <span class="comment">// 促销订单</span></span><br><span class="line">            <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> discount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用策略模式代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DiscountStrategy</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">calDiscount</span><span class="params">(Order order)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrateg</span></span><br><span class="line"><span class="comment">// 策略的创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscountStrategyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;OrderType, DiscountStrategy&gt; strategies = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        strategies.put(OrderType.NORMAL, <span class="keyword">new</span> <span class="title class_">NormalDiscountStrategy</span>());</span><br><span class="line">        strategies.put(OrderType.GROUPON, <span class="keyword">new</span> <span class="title class_">GrouponDiscountStrategy</span>());</span><br><span class="line">        strategies.put(OrderType.PROMOTION, <span class="keyword">new</span> <span class="title class_">PromotionDiscountStrategy</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DiscountStrategy <span class="title function_">getDiscountStrategy</span><span class="params">(OrderType type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strategies.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 策略的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">discount</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="type">OrderType</span> <span class="variable">type</span> <span class="operator">=</span> order.getType();</span><br><span class="line">        <span class="type">DiscountStrategy</span> <span class="variable">discountStrategy</span> <span class="operator">=</span> DiscountStrategyFactory.getDiscountStrategy();</span><br><span class="line">        <span class="keyword">return</span> discountStrategy.calDiscount(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里通过提前在map冲存储相应的类型，直接从map中获取，而不再用那些if判断。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>职责链模式（上）</title>
    <url>/2023/06/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<h1 id="职责链模式的原理和实现"><a href="#职责链模式的原理和实现" class="headerlink" title="职责链模式的原理和实现"></a>职责链模式的原理和实现</h1><p>定义：将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这 些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。</p>
<p>在职责链模式中，多个处理器依次处理同一个请 求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。</p>
<p>一个具体的demo如下：</p>
<p>如果它能处理该请求，就不继续往下传递；如果不能处理，则交由后面的处理器来处理（也 就是调用 successor.handle()）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Handler</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerA</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (!handled &amp;&amp; successor != <span class="literal">null</span>) &#123;</span><br><span class="line">            successor.handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerB</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 这里，是因为他不能处理该请求，就往下传递，并非调用本身</span></span><br><span class="line">        <span class="comment">// 这里是一个链表，如果他自己不能处理，并且不为空，就往下传递</span></span><br><span class="line">        <span class="comment">// 这里省略的代码应该有一步需要往下找另外一个handler</span></span><br><span class="line">        <span class="keyword">if</span> (!handled &amp;&amp; successor != <span class="literal">null</span>) &#123;</span><br><span class="line">            successor.handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerChain</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHandler</span><span class="params">(Handler handler)</span> &#123;</span><br><span class="line">        handler.setSuccessor(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = handler;</span><br><span class="line">            tail = handler;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.setSuccessor(handler);</span><br><span class="line">        tail = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            head.handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HandlerChain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerChain</span>();</span><br><span class="line">        chain.addHandler(<span class="keyword">new</span> <span class="title class_">HandlerA</span>());</span><br><span class="line">        chain.addHandler(<span class="keyword">new</span> <span class="title class_">HandlerB</span>());</span><br><span class="line">        chain.handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述demo存在问题，处理器类的 handle() 函数，不仅包含自己的业务逻 辑，还包含对下一个处理器的调用，也就是代码中的 successor.handle()，如果不熟悉可能会忘记这一步操作，一个优化版本如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Handler</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这种写法，把调用链表下一个节点的操作放在了Handler中，而子类只需要重写doHandle</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> doHandle();</span><br><span class="line">        <span class="keyword">if</span> (successor != <span class="literal">null</span> &amp;&amp; !handled) &#123;</span><br><span class="line">            successor.handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">doHandle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerA</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">doHandle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerB</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">doHandle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// HandlerChain和Application代码不变</span></span><br></pre></td></tr></table></figure>

<h1 id="职责链模式的应用场景举例"><a href="#职责链模式的应用场景举例" class="headerlink" title="职责链模式的应用场景举例"></a>职责链模式的应用场景举例</h1><p>考虑以下场景：我们要设计一个针对于博客或者评论的敏感词过滤模块，就可以使用该模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SensitiveWordFilter</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">doFilter</span><span class="params">(Content content)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SexyWordFilter</span> <span class="keyword">implements</span> <span class="title class_">SensitiveWordFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doFilter</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">legal</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> legal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// PoliticalWordFilter、AdsWordFilter类代码结构与SexyWordFilter类似</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SensitiveWordFilterChain</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;SensitiveWordFilter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(SensitiveWordFilter filter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.filters.add(filter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return true if content doesn&#x27;t contain sensitive words.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (SensitiveWordFilter filter : filters) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!filter.doFilter(content)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SensitiveWordFilterChain</span> <span class="variable">filterChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SensitiveWordFilterChain</span>();</span><br><span class="line">        filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">AdsWordFilter</span>());</span><br><span class="line">        filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">SexyWordFilter</span>());</span><br><span class="line">        filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">PoliticalWordFilter</span>());</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">legal</span> <span class="operator">=</span> filterChain.filter(<span class="keyword">new</span> <span class="title class_">Content</span>());</span><br><span class="line">        <span class="keyword">if</span> (!legal) &#123;</span><br><span class="line">            <span class="comment">// 不发表</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实不使用职责链，而是直接在一个类中使用if else判断也可以完成该功能，那为什么还要使用呢？</p>
<p>1、将大块代码逻辑拆分成函数，将大类拆分成小类，是应对代码复杂性的常用方法。应用职责链模式，把各个敏感词过滤函数继续拆分出来，设计成独立的类，进一步简化了 SensitiveWordFilter 类，让 SensitiveWordFilter 类的代码不会过多，过复杂。</p>
<p>2、如果需要新添加一个过滤方法，我们只需要加一个新的类，实现SensitiveWordFilter接口，并将其添加到SensitiveWordFilterChain中即可，不需要修改太多之前已经存在的代码。如果使用if-else判断的写法，那么就需要添加新的判断。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式（上）</title>
    <url>/2023/06/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<p>观察者模式（Observer Design Pattern）也被称为发布订阅模式，在《设计模式》一书中，它的定义如下：</p>
<p>在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p>
<p>一个具体的代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(Message message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Message message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserverOne</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 获取消息通知，执行自己的逻辑...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteObserverOne is notified.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserverTwo</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 获取消息通知，执行自己的逻辑...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteObserverTwo is notified.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();</span><br><span class="line">        subject.registerObserver(<span class="keyword">new</span> <span class="title class_">ConcreteObserverOne</span>());</span><br><span class="line">        subject.registerObserver(<span class="keyword">new</span> <span class="title class_">ConcreteObserverTwo</span>());</span><br><span class="line">        subject.notifyObservers(<span class="keyword">new</span> <span class="title class_">Message</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式（下）</title>
    <url>/2023/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<p>观察者模式有几种不同的实现方式：同步阻塞、异步非阻塞、进程内、进程间的实现方式。</p>
<p>同步阻塞是最经典的实现方式，主要是为了代码解耦；异步非阻塞除了能实现代码解耦之 外，还能提高代码的执行效率；进程间的观察者模式解耦更加彻底，一般是基于消息队列来 实现，用来实现不同进程间的被观察者和观察者之间的交互。</p>
<h1 id="异步非阻塞观察者模式的简易实现"><a href="#异步非阻塞观察者模式的简易实现" class="headerlink" title="异步非阻塞观察者模式的简易实现"></a>异步非阻塞观察者模式的简易实现</h1><p>有两种实现方式：其中一种是：在每个 handleRegSuccess() 函数中创建一个新的线 程执行代码逻辑；另一种是：在 UserController 的 register() 函数中使用线程池来执行每 个观察者的 handleRegSuccess() 函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种实现方式，其他类代码不变，就没有再重复罗列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegPromotionObserver</span> <span class="keyword">implements</span> <span class="title class_">RegObserver</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PromotionService promotionService; <span class="comment">// 依赖注入</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRegSuccess</span><span class="params">(<span class="type">long</span> userId)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种实现方式，其他类代码不变，就没有再重复罗列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService; <span class="comment">// 依赖注入</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;RegObserver&gt; regObservers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Executor executor;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(Executor executor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRegObservers</span><span class="params">(List&lt;RegObserver&gt; observers)</span> &#123;</span><br><span class="line">        regObservers.addAll(observers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">        <span class="comment">//省略输入参数的校验代码</span></span><br><span class="line">        <span class="comment">//省略userService.register()异常的try-catch代码</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">userId</span> <span class="operator">=</span> userService.register(telephone, password);</span><br><span class="line">        <span class="keyword">for</span> (RegObserver observer : regObservers) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    observer.handleRegSuccess(userId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于第一种实现方式，频繁地创建和销毁线程比较耗时，并且并发线程数无法控制，创建过多的线程会导致堆栈溢出。</p>
<p>第二种实现方式，尽管利用了线程池解决了第一种实现方式的问题，但线程池、异步执行逻辑都耦合在了 register() 函数中，增加了这部分业务代码的维护成本。</p>
<h1 id="EventBus核心"><a href="#EventBus核心" class="headerlink" title="EventBus核心"></a>EventBus核心</h1><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230619110451041.png" alt="image-20230619110451041"></p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230619110502970.png" alt="image-20230619110502970"></p>
<p>从图中我们可以看出，最关键的一个数据结构是 Observer 注册表，记录了消息类型和可接收消息函数的对应关系。</p>
<p>当调用 register() 函数注册观察者的时候，EventBus 通过解析 @Subscribe 注解，生成 Observer 注册表。</p>
<p>当调用 post() 函数发送消息的时候， EventBus 通过注册表找到相应的可接收消息的函数，然后通过 Java 的反射语法来动态地 创建对象、执行函数。</p>
<p>对于同步阻塞模式，EventBus 在一个线程内依次执行相应的函数。 </p>
<p>对于异步非阻塞模式，EventBus 通过一个线程池来执行相应的函数。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>CDN</title>
    <url>/2023/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CDN/</url>
    <content><![CDATA[<h1 id="内容分发网络CDN"><a href="#内容分发网络CDN" class="headerlink" title="内容分发网络CDN"></a>内容分发网络CDN</h1><p>现阶段，很多视频公司没日需要给用户推送大量的视频，这些视频如果都从公司的主服务器推送出去，则会给主服务器造成压力，而且由于区域原因，还会带来很高的时延。</p>
<p>CDN就是为了解决上面的问题。CDN服务器可以分布在多个地区，它存储那些视频以及图片的副本，用于用户请求时将视频等内容响应给用户。可以减小主服务器带宽压力，而且根据用户地理位置，分配不同的CDN，可以减少时延。</p>
<p>CDN采用集群部署，如果用户请求的CDN集群没有用户的目标视频，则该CDN集群会从中心仓库或者另一个集群搜索该视频，然后一边给用户传输，一边缓存在本集群中。</p>
<h1 id="CDN操作"><a href="#CDN操作" class="headerlink" title="CDN操作"></a>CDN操作</h1><p>当用于从浏览器请求某视频时，CDN需要先截获用户请求，才能确定适合用户的CDN集群，以及将用户请求重定向到该集群中。</p>
<h2 id="如何截获和重定向"><a href="#如何截获和重定向" class="headerlink" title="如何截获和重定向"></a>如何截获和重定向</h2><p>截获请求和重定向需要依赖于DNS。假如公司A用了公司B提供的CDN服务，那么一个大概的流程如下：</p>
<p>1、用户访问公司A的网站，点击了一个视频，那么他会向对应的域名发起请求（例如请求<a href="https://www.bilibili.com/video/xxx%EF%BC%89%EF%BC%8C%E8%8E%B7%E5%8F%96%E8%AF%A5%E8%A7%86%E9%A2%91%E3%80%82">https://www.bilibili.com/video/xxx），获取该视频。</a></p>
<p>2、用户的本地DNS服务器会将请求转发到权威DNS服务器，权威DNS服务器发现了域名中的video，那么它并不会向用户返回一个IP地址，而是返回一个B公司的主机名。</p>
<p>3、然后，该请求就进入了B公司专用的DNS设施。然后用户本地DNS会发起第二个请求，此时就是直接向公司B发起的DNS请求，这个请求会得到一个指向B公司的ip地址，然后用户可以从这里获取到视频的信息。</p>
<p>从这里，用户发起向公司A的请求就被转变为向公司B的CDN服务器的请求。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416102329355.png" alt="image-20230416102329355" style="zoom:67%;" />

<h2 id="集群选择策略"><a href="#集群选择策略" class="headerlink" title="集群选择策略"></a>集群选择策略</h2><p>在上面的重定向过程中，公司B的CDN服务器是可以知道用户本地DNS地址，那么他就可以根据该ip来为用户分配最为临近的CDN集群。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《计算机网络导论：自顶向下方法》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
        <category>应用层</category>
      </categories>
  </entry>
  <entry>
    <title>访问者模式</title>
    <url>/2023/06/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>访问者模式：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>一般来说，访问者模式针对的是一组类型不同的对象（PdfFile、PPTFile、WordFile）。不 过，尽管这组对象的类型是不同的，但是，它们继承相同的父类（ResourceFile）或者实 现相同的接口。在不同的应用场景下，我们需要对这组对象进行一系列不相关的业务操作 （抽取文本、压缩等），但为了避免不断添加功能导致类（PdfFile、PPTFile、WordFile） 不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致的频繁代码修改，我们使用访问者模式，将<strong>对象</strong>与<strong>操作</strong>解耦，将这些业务操作抽离出来，定义在独立细分的访问者类 （Extractor、Compressor）中。</p>
<h1 id="为什么支持双分派的语言不需要访问者模式？"><a href="#为什么支持双分派的语言不需要访问者模式？" class="headerlink" title="为什么支持双分派的语言不需要访问者模式？"></a>为什么支持双分派的语言不需要访问者模式？</h1><h2 id="Single-Dispatch，"><a href="#Single-Dispatch，" class="headerlink" title="Single Dispatch，"></a>Single Dispatch，</h2><p>指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的<strong>编译时类型</strong>来决定。</p>
<h2 id="Double-Dispatch"><a href="#Double-Dispatch" class="headerlink" title="Double Dispatch"></a>Double Dispatch</h2><p>指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的<strong>运行时类型</strong>来决定。</p>
<h2 id="Single-和-Double"><a href="#Single-和-Double" class="headerlink" title="Single 和 Double"></a>Single 和 Double</h2><p>Single Dispatch 之所以称为“Single”，是因为执行哪个对象的哪个方法，<strong>只跟“对象”的运行时类型有关</strong>。Double Dispatch 之所以称为“Double”，是因为执行哪个对象的哪个方法，跟“对象”和“方法参数”两者的运行时类型有关。</p>
<h2 id="Java的Single-Dispatch"><a href="#Java的Single-Dispatch" class="headerlink" title="Java的Single Dispatch"></a>Java的Single Dispatch</h2><p>Java 支持多态特性，代码可以在运行时获得对象的实际类型（也就是前面提到的运行时类 型），然后根据实际类型决定调用哪个方法。尽管 Java 支持函数重载，但 Java 设计的函数重载的语法规则是，<strong>并不是在运行时，根据传递进函数的参数的实际类型，来决定调用哪个重载函数</strong>，<strong>而是在编译时，根据传递进函数的参数的声明类型（也就是前面提到的编译时 类型），来决定调用哪个重载函数</strong>。也就是说，具体执行哪个对象的哪个方法，只跟<strong>对象的运行时类型</strong>有关，跟参数的运行时类型无关。所以，Java 语言只支持 Single Dispatch。</p>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am ParentClass&#x27;s f().&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildClass</span> <span class="keyword">extends</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am ChildClass&#x27;s f().&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleDispatchClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">polymorphismFunction</span><span class="params">(ParentClass p)</span> &#123;</span><br><span class="line">        p.f();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">overloadFunction</span><span class="params">(ParentClass p)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am overloadFunction(ParentClass p).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">overloadFunction</span><span class="params">(ChildClass c)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am overloadFunction(ChildClass c).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SingleDispatchClass</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleDispatchClass</span>();</span><br><span class="line">        <span class="type">ParentClass</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChildClass</span>();</span><br><span class="line">        <span class="comment">// 执行哪个对象的方法，由对象的实际类型决定。</span></span><br><span class="line">        <span class="comment">// 这里对象p的实例化是ChildClass，所以调用了child的f方法。</span></span><br><span class="line">        demo.polymorphismFunction(p);</span><br><span class="line">        <span class="comment">// 执行对象的哪个方法，由参数对象的声明类型决定</span></span><br><span class="line">        <span class="comment">// 这里指的是执行SingleDispatchClass的哪一个overloadFunction方法</span></span><br><span class="line">        <span class="comment">// 他取决于参数p声明的类型，即ParentClass</span></span><br><span class="line">        demo.overloadFunction(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230627112245628.png" alt="image-20230627112245628"></p>
<p>注：Java作为Single Dispatch，执行重载方法的时候，只会根据执行方法时传递的参数<strong>声明时的类型</strong>来执行，并不会关注他到底实例化了哪一个对象。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式实战</title>
    <url>/2023/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h1><p>代码片段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 奖励服务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RewardService</span> &#123;</span><br><span class="line">    <span class="comment">// 外部服务</span></span><br><span class="line">    <span class="keyword">private</span> WaimaiService waimaiService;</span><br><span class="line">    <span class="keyword">private</span> HotelService hotelService;</span><br><span class="line">    <span class="keyword">private</span> FoodService foodService;</span><br><span class="line">    <span class="comment">// 使用对入参的条件判断进行发奖</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issueReward</span><span class="params">(String rewardType, Object ... params)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (“Waimai”.equals(rewardType)) &#123;</span><br><span class="line">            <span class="type">WaimaiRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaimaiRequest</span>();</span><br><span class="line">            <span class="comment">// 构建入参</span></span><br><span class="line">            request.setWaimaiReq(params);</span><br><span class="line">            waimaiService.issueWaimai(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (“Hotel”.equals(rewardType)) &#123;</span><br><span class="line">            <span class="type">HotelRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelRequest</span>();</span><br><span class="line">            request.addHotelReq(params);</span><br><span class="line">            hotelService.sendPrize(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (“Food”.equals(rewardType)) &#123;</span><br><span class="line">            <span class="type">FoodRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodRequest</span>(params);</span><br><span class="line">            foodService.getCoupon(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(“rewardType error!”);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样设计，如果说需要新添加一个服务，就需要添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> NewService newService;</span><br><span class="line"><span class="comment">// else if下面添加新的</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;new&quot;</span>.equals(rewardType)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过第一次修改后，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">issue</span><span class="params">(Object ... params)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外卖策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Waimai</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> WaimaiService waimaiService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issue</span><span class="params">(Object... params)</span> &#123;</span><br><span class="line">        <span class="type">WaimaiRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaimaiRequest</span>();</span><br><span class="line">        <span class="comment">// 构建入参</span></span><br><span class="line">        request.setWaimaiReq(params);</span><br><span class="line">        waimaiService.issueWaimai(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 酒旅策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hotel</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HotelService hotelService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issue</span><span class="params">(Object... params)</span> &#123;</span><br><span class="line">        <span class="type">HotelRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelRequest</span>();</span><br><span class="line">        request.addHotelReq(params);</span><br><span class="line">        hotelService.sendPrize(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 美食策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Food</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> FoodService foodService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issue</span><span class="params">(Object... params)</span> &#123;</span><br><span class="line">        <span class="type">FoodRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodRequest</span>(params);</span><br><span class="line">        foodService.payCoupon(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用分支判断获取的策略上下文</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrategyContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title function_">getStrategy</span><span class="params">(String rewardType)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (rewardType) &#123;</span><br><span class="line">            <span class="keyword">case</span>“Waimai”:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Waimai</span>();</span><br><span class="line">            <span class="keyword">case</span>“Hotel”:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Hotel</span>();</span><br><span class="line">            <span class="keyword">case</span>“Food”:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Food</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(“rewardType error!”);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后的策略服务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RewardService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issueReward</span><span class="params">(String rewardType, Object ... params)</span> &#123;</span><br><span class="line">        <span class="type">Strategy</span> <span class="variable">strategy</span> <span class="operator">=</span> StrategyContext.getStrategy(rewardType);</span><br><span class="line">        strategy.issue(params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种优化，使用了一个接口，没当需要新添加服务时，只需要实现该接口</p>
<p>这次优化后，还有一个问题，那就是策略类，可以改为单例模式，如果之前有，就不需要新创建，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 策略上下文，用于管理策略的注册和获取</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrategyContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Strategy&gt; registerMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 注册策略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerStrategy</span><span class="params">(String rewardType, Strategy strategy)</span> &#123;</span><br><span class="line">        registerMap.putIfAbsent(rewardType, strategy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取策略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title function_">getStrategy</span><span class="params">(String rewardType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> registerMap.get(rewardType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象策略类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="comment">// 类注册方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> &#123;</span><br><span class="line">        StrategyContext.registerStrategy(getClass().getSimpleName(), <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单例外卖策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Waimai</span> <span class="keyword">extends</span> <span class="title class_">AbstractStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Waimai</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Waimai</span>();</span><br><span class="line">    <span class="keyword">private</span> WaimaiService waimaiService;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Waimai</span><span class="params">()</span> &#123;</span><br><span class="line">        register();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Waimai <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issue</span><span class="params">(Object... params)</span> &#123;</span><br><span class="line">        <span class="type">WaimaiRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaimaiRequest</span>();</span><br><span class="line">        <span class="comment">// 构建入参</span></span><br><span class="line">        request.setWaimaiReq(params);</span><br><span class="line">        waimaiService.issueWaimai(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单例酒旅策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hotel</span> <span class="keyword">extends</span> <span class="title class_">AbstractStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Hotel</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hotel</span>();</span><br><span class="line">    <span class="keyword">private</span> HotelService hotelService;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Hotel</span><span class="params">()</span> &#123;</span><br><span class="line">        register();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Hotel <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issue</span><span class="params">(Object... params)</span> &#123;</span><br><span class="line">        <span class="type">HotelRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelRequest</span>();</span><br><span class="line">        request.addHotelReq(params);</span><br><span class="line">        hotelService.sendPrize(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单例美食策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Food</span> <span class="keyword">extends</span> <span class="title class_">AbstractStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Food</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Food</span>();</span><br><span class="line">    <span class="keyword">private</span> FoodService foodService;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Food</span><span class="params">()</span> &#123;</span><br><span class="line">        register();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Food <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issue</span><span class="params">(Object... params)</span> &#123;</span><br><span class="line">        <span class="type">FoodRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodRequest</span>(params);</span><br><span class="line">        foodService.payCoupon(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这次优化后，每次注册完成后，map中会有一个该对象，下次使用时就不需要创建，直接拿之前已经有的即可。</p>
<h1 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 任务状态枚举</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">TaskState</span> &#123;</span><br><span class="line">    INIT(“初始化”),</span><br><span class="line">    ONGOING( “进行中”),</span><br><span class="line">    PAUSED(“暂停中”),</span><br><span class="line">    FINISHED(“已完成”),</span><br><span class="line">    EXPIRED(“已过期”);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 行为枚举</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ActionType</span> &#123;</span><br><span class="line">    START(<span class="number">1</span>, “开始”),</span><br><span class="line">    STOP(<span class="number">2</span>, “暂停”),</span><br><span class="line">    ACHIEVE(<span class="number">3</span>, “完成”),</span><br><span class="line">    EXPIRE(<span class="number">4</span>, “过期”);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long taskId;</span><br><span class="line">    <span class="comment">// 任务的默认状态为初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TaskState</span> <span class="variable">state</span> <span class="operator">=</span> TaskState.INIT;</span><br><span class="line">    <span class="comment">// 活动服务</span></span><br><span class="line">    <span class="keyword">private</span> ActivityService activityService;</span><br><span class="line">    <span class="comment">// 任务管理器</span></span><br><span class="line">    <span class="keyword">private</span> TaskManager taskManager;</span><br><span class="line">    <span class="comment">// 使用条件分支进行任务更新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateState</span><span class="params">(ActionType actionType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (state == TaskState.INIT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (actionType == ActionType.START) &#123;</span><br><span class="line">                state = TaskState.ONGOING;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == TaskState.ONGOING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (actionType == ActionType.ACHIEVE) &#123;</span><br><span class="line">                state = TaskState.FINISHED;</span><br><span class="line">                <span class="comment">// 任务完成后进对外部服务进行通知</span></span><br><span class="line">                activityService.notifyFinished(taskId);</span><br><span class="line">                taskManager.release(taskId);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.STOP) &#123;</span><br><span class="line">                state = TaskState.PAUSED;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.EXPIRE) &#123;</span><br><span class="line">                state = TaskState.EXPIRED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == TaskState.PAUSED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (actionType == ActionType.START) &#123;</span><br><span class="line">                state = TaskState.ONGOING;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.EXPIRE) &#123;</span><br><span class="line">                state = TaskState.EXPIRED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的问题是if-else判断太多，如果新添加状态还需要添加新的if-else，这里可以用状态模式。而且Task类中冗余了TaskManager类。</p>
<p>修改后代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 任务状态抽象接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">// 默认实现，不做任何处理</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Task task, ActionType actionType)</span> &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务初始状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskInit</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Task task, ActionType actionType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (actionType == ActionType.START) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskOngoing</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务进行状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskOngoing</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ActivityService activityService;</span><br><span class="line">    <span class="keyword">private</span> TaskManager taskManager;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Task task, ActionType actionType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (actionType == ActionType.ACHIEVE) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskFinished</span>());</span><br><span class="line">            <span class="comment">// 通知</span></span><br><span class="line">            activityService.notifyFinished(taskId);</span><br><span class="line">            taskManager.release(taskId);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.STOP) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskPaused</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.EXPIRE) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskExpired</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务暂停状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskPaused</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Task task, ActionType actionType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (actionType == ActionType.START) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskOngoing</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.EXPIRE) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskExpired</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务完成状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskFinished</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务过期状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskExpired</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long taskId;</span><br><span class="line">    <span class="comment">// 初始化为初始态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskInit</span>();</span><br><span class="line">    <span class="comment">// 更新状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateState</span><span class="params">(ActionType actionType)</span> &#123;</span><br><span class="line">        state.update(<span class="built_in">this</span>, actionType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用观察者模式后，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象观察者</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">response</span><span class="params">(Long taskId)</span>; <span class="comment">// 反应</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象目标</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line">    <span class="comment">// 增加观察者方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除观察者方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知观察者方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">(Long taskId)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.response(taskId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 活动观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActivityObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ActivityService activityService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">response</span><span class="params">(Long taskId)</span> &#123;</span><br><span class="line">        activityService.notifyFinished(taskId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务管理观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskManageObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TaskManager taskManager;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">response</span><span class="params">(Long taskId)</span> &#123;</span><br><span class="line">        taskManager.release(taskId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务进行状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskOngoing</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Task task, ActionType actionType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (actionType == ActionType.ACHIEVE) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskFinished</span>());</span><br><span class="line">            <span class="comment">// 通知</span></span><br><span class="line">            notifyObserver(task.getTaskId());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.STOP) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskPaused</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.EXPIRE) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskExpired</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务初始状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskInit</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Task task, ActionType actionType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (actionType == ActionType.START) &#123;</span><br><span class="line">            <span class="type">TaskOngoing</span> <span class="variable">taskOngoing</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskOngoing</span>();</span><br><span class="line">            taskOngoing.add(<span class="keyword">new</span> <span class="title class_">ActivityObserver</span>());</span><br><span class="line">            taskOngoing.add(<span class="keyword">new</span> <span class="title class_">TaskManageObserver</span>());</span><br><span class="line">            task.setState(taskOngoing);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《美团博客》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器模式（下）</title>
    <url>/2023/06/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<p>如何实现一个支持“快照”功能的迭代器？</p>
<p>所谓“快照”，指我们为容器创建迭代器的 时候，相当于给容器拍了一张快照（Snapshot）。之后即便我们增删容器中的元素，快照 中的元素并不会做相应的改动。而迭代器遍历的对象是快照而非容器，这样就避免了在使用 迭代器遍历的过程中，增删容器中的元素，导致的不可预期的结果或者报错。</p>
<h1 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h1><p>在迭代器类中定义一个成员变量 snapshot 来存储快 照。每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这 个迭代器自己持有的快照来进行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnapshotArrayIterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cursor;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;E&gt; snapshot;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SnapshotArrayIterator</span><span class="params">(ArrayList&lt;E&gt; arrayList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cursor = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.snapshot = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.snapshot.addAll(arrayList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">currentItem</span> <span class="operator">=</span> snapshot.get(cursor);</span><br><span class="line">        cursor++;</span><br><span class="line">        <span class="keyword">return</span> currentItem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：这个解决方案虽然简单，但代价也有点高。每次创建迭代器的时候，都要拷贝一份数据到快 照中，会增加内存的消耗。如果一个容器同时有多个迭代器在遍历元素，就会导致数据在内 存中重复存储多份。不过，庆幸的是，Java 中的拷贝属于浅拷贝，也就是说，容器中的对 象并非真的拷贝了多份，而只是拷贝了对象的引用而已。</p>
<h1 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h1><p>我们可以在容器中，为每个元素保存两个时间戳，一个是添加时间戳 addTimestamp，一 个是删除时间戳 delTimestamp。</p>
<p>当元素被加入到集合中的时候，我们将 addTimestamp 设置为当前时间，将 delTimestamp 设置成最大长整型值。当元素被删除时，我们将 delTimestamp 更新为当前时间，表示已经被删除。</p>
<p>这里只是标记删除，而非真正将它从容器中删除。</p>
<p>同时，每个迭代器也保存一个迭代器创建时间戳 snapshotTimestamp，也就是迭代器对应 的快照的创建时间戳。当使用迭代器来遍历容器的时候，只有满足 addTimestamp&lt;snapshotTimestamp&lt;delTimestamp的元素，才是属于这个迭代器的快照。</p>
<p>可以将元素删除时间以及创建时间与迭代器的创建时间进行比较，来判断该元素是否是当前快照中的元素，这样就在不复制的情况下做到了快照，同时因为删除是标记删除，也不会造成影响，而且添加新的元素也不会被遍历到。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器模式（上）</title>
    <url>/2023/06/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<h1 id="迭代器模式的原理和实现"><a href="#迭代器模式的原理和实现" class="headerlink" title="迭代器模式的原理和实现"></a>迭代器模式的原理和实现</h1><p>迭代器模式（Iterator Design Pattern），也叫作游标模式（Cursor Design Pattern）。</p>
<p>迭代器是用来遍历容器的，所以，一个完整的迭代器模式一般会涉及容器和容器迭代器两部 分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代 器又包含迭代器接口、迭代器实现类。</p>
<p>一个demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口定义方式一</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">currentItem</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cursor;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;E&gt; arrayList;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayIterator</span><span class="params">(ArrayList&lt;E&gt; arrayList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cursor = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.arrayList = arrayList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayIterator</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != arrayList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        cursor++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">currentItem</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cursor &gt;= arrayList.size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayList.get(cursor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        names.add(<span class="string">&quot;xzg&quot;</span>);</span><br><span class="line">        names.add(<span class="string">&quot;wang&quot;</span>);</span><br><span class="line">        names.add(<span class="string">&quot;zheng&quot;</span>);</span><br><span class="line">        <span class="comment">// Iterator&lt;String&gt; iterator = new ArrayIterator(names);</span></span><br><span class="line">        Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.currentItem());</span><br><span class="line">            iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230626102617700.png" alt="image-20230626102617700"></p>
<h1 id="迭代器的优点"><a href="#迭代器的优点" class="headerlink" title="迭代器的优点"></a>迭代器的优点</h1><p>首先是Java中遍历的三种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">names.add(<span class="string">&quot;xzg&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;wang&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;zheng&quot;</span>);</span><br><span class="line"><span class="comment">// 第一种遍历方式：for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; names.size(); i++) &#123;</span><br><span class="line">    System.out.print(names.get(i) + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种遍历方式：foreach循环</span></span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">    System.out.print(name + <span class="string">&quot;,&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第三种遍历方式：迭代器遍历</span></span><br><span class="line">Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.print(iterator.next() + <span class="string">&quot;,&quot;</span>);<span class="comment">//Java中的迭代器接口是第二种定义方式，next</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>foreach 循环只是一个语法糖而已，底层是基于迭代器来实现的。</p>
<p>从代码上看，for循环要比 iterator简单，但是这是针对于数组这种数据结构来说的，如果是图或者树，用for循环则不那么容易。可以直接在迭代器中写好遍历，然后只注重与具体业务的开发，而不需要在业务层去书写这些遍历代码。</p>
<p>将游标指向的当前位置等信息，存储在迭代器类中，每个迭代器独享游标信息。这 样，我们就可以创建多个不同的迭代器，同时对同一个容器进行遍历而互不影响。</p>
<p>最后，容器和迭代器都提供了抽象的接口，方便我们在开发的时候，基于接口而非具体的实 现编程。当需要切换新的遍历算法的时候，比如，从前往后遍历链表切换成从后往前遍历链 表，客户端代码只需要将迭代器类从 LinkedIterator 切换为 ReversedLinkedIterator 即 可，其他代码都不需要修改。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2023/06/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>适配器模式，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类适配器: 基于继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fb</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptor</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.fa();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...重新实现f2()...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象适配器：基于组合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fb</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptor</span> <span class="keyword">implements</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adaptor</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">        adaptee.fa(); <span class="comment">//委托给Adaptee</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...重新实现f2()...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span> &#123;</span><br><span class="line">        adaptee.fc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 Adaptee 接口并不多，那两种实现方式都可以。</p>
<p>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推 荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方 式，Adaptor 的代码量要少一些。 </p>
<p>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们 推荐使用对象适配器，因为组合结构相对于继承更加灵活。</p>
<h1 id="适配器模式应用场景"><a href="#适配器模式应用场景" class="headerlink" title="适配器模式应用场景"></a>适配器模式应用场景</h1><h2 id="1、封装有缺陷的接口设计"><a href="#1、封装有缺陷的接口设计" class="headerlink" title="1、封装有缺陷的接口设计"></a>1、封装有缺陷的接口设计</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS域名解析</title>
    <url>/2023/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>DNS是一个由分层的DNS服务器实现的分布式数据库，它主要记录了域名与IP地址的对应关系。</p>
<p>我们平时访问网站，都是输入域名，而不是IP地址，而域名被解析为对应IP地址这一步，就是由DNS实现的。</p>
<p>它还提供了一些其他的服务，比如说将一个域名映射到多个IP地址上，用于减轻单个服务器的压力。</p>
<h1 id="DNS架构"><a href="#DNS架构" class="headerlink" title="DNS架构"></a>DNS架构</h1><p>它是一个分布式的数据库，且分多层次。</p>
<p>不采用单点是因为如果单点故障，那么整个因特网就不能用，而且单点无法承载那么大的请求量，存储那么多的数据。如果采用单点，还会因为地理位置原因导致很大的时延。</p>
<h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>DNS分为根域名服务器，顶级域名服务器，权威域名服务器和本地域名服务器。</p>
<p>一个用户在浏览器中输入一个域名，解析的过程大致如下（迭代查询）：</p>
<p>1、向本地域名服务器发送请求。</p>
<p>2、本地域名服务器向根域名服务器发送请求，根域名服务器返回顶级域名服务器的地址。</p>
<p>3、本地再向顶级域名服务器发起请求，顶级域名服务器返回权威域名服务器的地址，到这一步就可以获取到IP。</p>
<p>4、本地域名服务器将获取到的ip返回给用户浏览器。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/test.png" alt="test" style="zoom: 50%;" />

<p>递归查询：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414110639339.png" alt="image-20230414110639339" style="zoom: 67%;" />

<h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><p>某一个DNS服务器接受一个DNS回答时，它可以将映射存储在本地的存储器中，下一次如果有同样的映射，可以直接返回而不用去往下一层请求。</p>
<p>但是该缓存并不是永久存在的，过一段时间会被清除。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
        <category>应用层</category>
      </categories>
      <tags>
        <tag>应用层</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP</title>
    <url>/2023/04/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/</url>
    <content><![CDATA[<p>TCP是面向连接的。而且提供的是全双工服务，即如果两台主机A和B相连，那么A可以给B发数据，B也可以给A发数据。TCP连接是点对点的，即在单个发送方与单个接收方之间的连接。</p>
<h1 id="建立连接的过程"><a href="#建立连接的过程" class="headerlink" title="建立连接的过程"></a>建立连接的过程</h1><p>客户首先发送一个特殊的TCP报文段，服务器用另一个特殊的TCP报文段来响应，最后，客户再用第三个特殊报文段作为响应。</p>
<p>前两个报文段不承载“有效载荷” ，也就是不包含应用层数据；而第三个报文段可以承载有效载荷。</p>
<h1 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h1><p>一旦建立了连接之后，就需要传输数据。当应用层数据通过套接字以后，数据就交由TCP控制。TCP将这些数据引导到该连接的发送缓存里，然后不时的从发送缓存里取出一块数据，并将数据传递到网络层。</p>
<img src="C:\Users\郭俊豪\AppData\Roaming\Typora\typora-user-images\image-20230425102632021.png" alt="image-20230425102632021" style="zoom:67%;" />

<h1 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h1><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230425102923389.png" alt="image-20230425102923389" style="zoom:67%;" />

<p>其中，32比特的序号字段和32比特的确认号字段被TCP发送方和接收方用来实现可靠数据传输服务。</p>
<p>接收窗口字段用来实现流量控制。</p>
<p>TCP被称为累计确认是因为它的确认号也是按组确认的。比如说收到了0-500的报文段，那么它发送给发送方的确认号就是501，如果收到0-500，和600-900，而没有收到501-599，那么确认号还是501。</p>
<p>TCP的发送方，也使用了流水线。</p>
<h1 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h1><p>由于网络层提供的服务（IP服务）是不可靠的，无法保证数据按序交付，也无法保证完整性。而TCP则是建立在IP提供的网络服务之上，它创建了一种可靠数据传输服务。</p>
<h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>TCP有一种机制，就是延长超时时间，比如说第一个字数据经过50ms，被却认为丢失，然后重发，那么第二个就会将超时时间设置为100ms，以此类推。但是这会导致超时的时间越来越长，增加了端到端的时延。</p>
<p>解决办法是引入了快速重传，即通过冗余的ACK确认，来得知是数据错误，而不需要等待超时时间到达。</p>
<p>冗余的ACK就是再次确认已经收到的某个报文段的ACK，而发送方之前也已经收到该报文段的ACK。</p>
<p>一个具体的例子就是，比如说ACK &#x3D; 3是一个数据的确认，而且发送方也已经接收到了ACK &#x3D; 3的确认帧，而接收方收到了数据5和6，没有收到4，此时接收方就会重传ACK &#x3D; 3的确认帧，如果重传超过3次，则TCP就启动快速重传，立即重传3之后的数据。</p>
<h2 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h2><p>回退N帧协议，假设分组n的确认报文丢失，那么它会重传n以及n以后的所有报文，尽管只丢失了n，其他的全部已经正确接收。</p>
<p>而TCP则是允许接收方有选择的确认失序报文段，而不是累计的确认正确的接收最后一个。当启用重传时，它就会跳过重传那些已经被接收方选择性确认过的报文段。</p>
<h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><p>TCP连接的每一侧都为该连接设置了接收缓存。没当TCP接收到正确，按序的字节后，就会将这些数据放入接收缓存，相关的应用就会从接收缓存中读取数据。但是如果应用读取的比较慢，而发送方发送的比较快，则会导致缓存溢出。</p>
<p>所以TCP提供了流量控制服务，以消除发送方发送过快导致接收方缓存溢出的可能。</p>
<p>TCP通过让发送方维护一个接收窗口的变量来实现流量控制。接收窗口用于给发送方指示，表明现在接收方还有多少可用的缓存空间。因为TCP是全双工通信的，所以说连接两端都会维护一个接收窗口。</p>
<p>这样一来，发送方只需要根据对应接收方的窗口大小来确定此时可以发送多少数据，就能保证不溢出。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《计算机网络：自顶向下方法》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
        <category>运输层</category>
      </categories>
      <tags>
        <tag>-运输层</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP拥塞控制</title>
    <url>/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>TCP必须使用端到端拥塞控制而不是使网络辅助的拥塞控制，因为IP层不向端系统提供显式的网络拥塞反馈。TCP所采用的方法是让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率。如果感觉到没什么拥堵，就加快发送速度，如果有拥堵，就减少。</p>
<p><strong>怎么限制发送速率</strong>：TCP发送方的拥塞控制需要一个额外的变量，拥塞窗口。发送方中已发送但是未被确认的数据量不会超过拥塞窗口（cwnd）和rwnd的最小值。该约束限制了发送方中未被确认的数据量，因此间接地限制了发送方的发送速率。</p>
<p><strong>如何感知拥堵</strong>：TCP发送方的丢包事件定义是，要么超时，要么收到接收方3个冗余的ACK。当出现过度拥堵时，路径上的一台或多台路由器缓存会溢出，引起数据包被丢弃，然后发送方会得知丢包事件，然后就会认为出现了拥塞。</p>
<p>简单来说，当正确收到接收方的ACK时，会认为网络没有拥堵，慢慢调大拥塞窗口，增加发送速率。当出现丢包时，就认为网络拥堵，减小拥塞窗口，减小发送速率。</p>
<p><strong>TCP拥塞控制算法</strong>包括三部分：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>快速恢复</li>
</ul>
<h1 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h1><p>在刚开始建立连接时，拥塞窗口的大小比较小，而每当正确接收到ACK确认时，就增加拥塞窗口的大小。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230503104756403.png" alt="image-20230503104756403" style="zoom: 80%;" />

<p>何时结束这种指数增长：</p>
<p>1、在此过程中，如果出现拥堵，即出现丢包，那就重新开始慢启动，把拥塞窗口置为1。此时阈值会被设置为出现拥堵时窗口大小的一半。比如说出现拥堵时窗口大小为50，那么就将阈值设置为25。</p>
<p>2、一切正常时，当拥塞窗口大小到达拥塞窗口阈值时，结束慢启动并转移到拥塞避免模式。</p>
<p>3、如果检测到3个冗余ACK，这时TCP执行一种快速重传，并进入快速恢复状态。</p>
<h1 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h1><p>一旦进入拥塞避免状态，拥塞窗口的值大约是上次遇到拥塞时的值的一半，而且在增加拥塞窗口大小时，它并不会像启动那样一次翻一倍，而是每次增加1。</p>
<p>合适结束这种线性增长：</p>
<p>1、当出现超时丢包时，就将阈值设置为拥塞窗口的一半。</p>
<p>2、当出现3个冗余ACK所确认的丢包时，TCP将拥塞窗口的值减半，然后将阈值设置为拥塞窗口的一半。此时拥塞窗口和阈值大小一样，将不会再增加。</p>
<p>之后就进入快速恢复阶段。</p>
<h1 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h1><p>总结：出现 网络拥塞 之后 , 拥塞窗口 不降为 1 , 而是降低到 慢开始门限值 , 即当前的 拥塞窗口大小的 1&#x2F;2 , 然后线性增加 拥塞窗口 ;</p>
<p>如下图：没有快速恢复时，出现拥堵窗口会将为1，然后开始增长，到达阈值每次增加1。</p>
<p>有快速恢复时，出现拥堵窗口大小降为之前的阈值，然后每次增加1。</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230503112334911.png" alt="image-20230503112334911"></p>
<h1 id="三个过程的转换"><a href="#三个过程的转换" class="headerlink" title="三个过程的转换"></a>三个过程的转换</h1><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230503110841488.png" alt="image-20230503110841488"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《计算机网络：自顶向下》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
        <category>运输层</category>
      </categories>
  </entry>
  <entry>
    <title>TCP连接的管理</title>
    <url>/2023/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="建立连接过程"><a href="#建立连接过程" class="headerlink" title="建立连接过程"></a>建立连接过程</h1><p>TCP建立连接的过程如下：</p>
<p><strong>第一步</strong>：客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段。该报文段中不包含应用层数据。该报文段会将首部中的SYN置为1，这个特殊报文段被称为SYN报文段。</p>
<p>客户会随机地选择一个初始序号（client_isn）,并将此编号放置于该起始的TCP SYN报文段的序号字段中。该报文段会被封装在一个IP数据报中，并发送给服务器。</p>
<p><strong>第二步</strong>：一旦包含TCP SYN报文段的IP数据报到达服务器主机，服务器会从该数据报中提取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段。这个允许连接的报文段也不包含应用层数据。</p>
<p>在报文段的首部包含3个重要的信息。首先，SYN比特被置为1。其次，该TCP报文段首部的确认号字段被置为client _ isn + 1。最后，服务器选择自己的初始序号（server_isn）,并将其放置到TCP报文段首部的序号字段中。</p>
<p>这个允许连接的报文段实际上表明了： “我收到了你发起建立连接的SYN分组，该分组带有初始序号client_isn。我同意建立该连接。我自己的初始序号是server_isn。该允许连接的报文段被称为SYNACK报文段（SYNACK segment）。</p>
<p><strong>第三步</strong>：在收到SYNACK报文段后，客户也要给该连接分配缓存和变量。客户主机则向服务器发送另外一个报文段；这最后一个报文段对服务器的允许连接的报文段进行了确认（该客户通过将值server_isn + 1放置到TCP报文段首部的确认字段中来完成此项工作）。</p>
<p>该三次握手的第三个阶段可以在报文段负载中携带客户到服务器的数据。 </p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230430112825050.png" alt="image-20230430112825050" style="zoom:67%;" />

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>也就是说，第一步客户端先发起一个报文段请求，用于表明我想要建立连接，不携带数据。</p>
<p>第二步，服务器收到请求，允许建立连接，分配缓存，然后给客户端通知该消息，也不携带数据。</p>
<p>第三步，客户端收到服务端同意建立连接的请求，然后给服务端回应，我收到了你的同意建立连接。第三步其实是一个确认的消息，只不过可以携带一部分数据。</p>
<h1 id="终止连接的过程"><a href="#终止连接的过程" class="headerlink" title="终止连接的过程"></a>终止连接的过程</h1><p>当连接结束后,主机中的“资源”（即缓存和变量）将被释放。</p>
<p>当客户想要关闭连接，它会向服务端发送一个特殊的报文，服务端收到后会给他一个ACK响应。然后服务端发送自己的终止报文段，客户端收到后会给该终止报文段一个确认。之后，两台主机上用于该连接的所有资源都被释放。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230430113216637.png" alt="image-20230430113216637" style="zoom:67%;" />

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《计算机网络：自顶向下方法》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
        <category>运输层</category>
      </categories>
      <tags>
        <tag>-运输层</tag>
      </tags>
  </entry>
  <entry>
    <title>计网中的多路分解与多路复用</title>
    <url>/2023/04/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<p><strong>多路复用</strong>与<strong>多路分解</strong>是将网络层提供的主机到主机交付服务延伸到为运行在主机上的<strong>应用程序</strong>提供进程到进程的交付服务。</p>
<p>在目的主机，运输层负责从网络层接受报文段，然后将报文段中的数据交付给对应的进程。而每个进程都会有一个或者多个套接字，这些套接字可以理解为网络层和运输层传输数据的门户（一个更形象的比喻，可以把套接字理解为插座的插口。传输数据需要先连接套接字，而充电也要先找到插口）。其实数据并不是直接由网络层传输给数据层，而是网络层传送给套接字，而套接字又传送给运输层。如下图：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417220052440.png" alt="image-20230417220052440" style="zoom:67%;" />

<h1 id="多路分解"><a href="#多路分解" class="headerlink" title="多路分解"></a>多路分解</h1><p>将运输层报文段中的数据交付到正确的套接字的工作称为多路分解。</p>
<p>因为接受端不会只有一个套接字，所以需要找到正确的套接字。而每个套接字都会有唯一的标识符。</p>
<p>运输层为了找到正确的套接字，运输层的每个报文段都会有几个特殊字段，这几个字段，用于找到正确的套接字。</p>
<h1 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h1><p>在源主机中，从不同套接字收集数据块，然后将数据块封装生成报文段，并将报文段传送到网络层，这些工作统称为多路复用。</p>
<p>而在目的主机中，运输层从网络层接受到的报文段分解后交给对应的进程，这个过程是通过将报文段定向到对应套接字来完成的。</p>
<h1 id="多路复用要求"><a href="#多路复用要求" class="headerlink" title="多路复用要求"></a>多路复用要求</h1><p>1、套接字有唯一标识符</p>
<p>2、每个报文段有特殊字段来指示该报文段所要交付到的套接字。</p>
<p>报文段中会包含源端口号和目的端口号，如下图所示：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230418095136342.png" alt="image-20230418095136342" style="zoom:67%;" />

<p>运输层分解：</p>
<p>主机上的每一个套接字都会有对应的端口号，当报文段到达主机后，运输层会查看报文段中的端口号，并将其定向到相应的套接字。然后报文段中的数据就通过套接字进入套接字对应的进程。</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>只有运输层与进程之间有套接字，也就是说进程发送给运输层数据，需要指定端口号和对应套接字，然后运输层会将报文封装，添加源主机端口号和目的主机端口号，用于目的主机对数据进行分解，找到对应进程。</p>
<p>而运输层与网络层之间，没有套接字的概念。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《计算机网络：自顶向下方法》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
        <category>运输层</category>
      </categories>
      <tags>
        <tag>运输层</tag>
      </tags>
  </entry>
  <entry>
    <title>UDP</title>
    <url>/2023/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDP/</url>
    <content><![CDATA[<p>UDP是面向无连接的，它没有拥塞控制。但是这里面存在一个问题，如果大量的UDP进行传输并且不经过控制，那么会导致整个网络的拥堵，造成大量UDP报文溢出，而且还会挤占TCP的通道，影响TCP通信。</p>
<p>UDP可以提供差错的检测，但是对于错误的报文段，却无法对其进行恢复，只能选择丢弃，或者交给应用程序，并发出警告。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
        <category>运输层</category>
      </categories>
      <tags>
        <tag>运输层</tag>
      </tags>
  </entry>
  <entry>
    <title>可靠数据传输原理</title>
    <url>/2023/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>实现可靠传输是靠<strong>可靠数据传输协议</strong>来完成的，而该协议却建立在不可靠的下层协议上。就好比TCP提供可靠传输，而TCP却是建立在IP协议这个不可靠协议的基础上。</p>
<p>以下的讨论都是单向数据传输，而且暂且只考虑损坏比特或者整个报文段丢失的情况，而不考虑乱序到达的情况。</p>
<h1 id="rdt1-0：经完全可靠信道传输"><a href="#rdt1-0：经完全可靠信道传输" class="headerlink" title="rdt1.0：经完全可靠信道传输"></a>rdt1.0：经完全可靠信道传输</h1><p>该协议只考虑最简单的情况，即底层信道完全可信。</p>
<p>因为默认信道传输可信，那么它的发送端只等待来自上层的调用，接受端只等待来自下层的调用，发送端将数据发送出去之后，就不需要再管，默认一定会到达接收端。</p>
<p>而且这里也假定了接收方的接受速率和发送方的一致。</p>
<h1 id="rdt2-0：具有比特差错信道的可靠数据传输"><a href="#rdt2-0：具有比特差错信道的可靠数据传输" class="headerlink" title="rdt2.0：具有比特差错信道的可靠数据传输"></a>rdt2.0：具有比特差错信道的可靠数据传输</h1><p>在该协议中，我们只假定发送的比特可能会受损，而不考虑它们可能存在乱序到达或者丢失的情况。</p>
<p>这里可以类比打电话，我们说一句，对方听到后就会对其进行响应，如果没听清，一般会说让我们再说一边。</p>
<p>在该协议中，使用了肯定确认和否定确认，发送方收到肯定确认意味着接收方成功收到了数据，而否定确认意味着接收方收到的比特有误，需要重传。基于这种机制的协议叫做<strong>自动重传请求协议</strong>。</p>
<p>它最主要的是三点：</p>
<p>1、差错检测。它需要能够检测出传送的比特流是否有误。</p>
<p>2、接受方反馈。接收方收到比特后，如果有误，需要给发送方反馈。</p>
<p>3、重传。发送方收到接收方的否定确认后，需要重新传送刚刚发送的比特。</p>
<p>一个更具体地例子，发送方发送数据后，需要等待接收方返回一个确认分组。该分组可以是ACK或者NAK。收到ACK说明接收方正确收到分组，而受到NAK则说明有误，需要重传。而发送方发送数据后，只能等待接受对方响应的分组，这种设计也叫做<strong>停等协议</strong>。</p>
<p><strong>致命缺点：没有考虑ACK或者NAK分组受损的情况。</strong></p>
<p>简单的解决办法：发送方将发送的数据分组编号，接收方只需要根据序号就可以确定该数据分组是否被重发。这样一来，发送方接受到的AKC或者NAK由于受损而表意不明确时，直接重新发送即可。</p>
<h1 id="rdt3-0：具有比特差错的丢包信道的可靠传输"><a href="#rdt3-0：具有比特差错的丢包信道的可靠传输" class="headerlink" title="rdt3.0：具有比特差错的丢包信道的可靠传输"></a>rdt3.0：具有比特差错的丢包信道的可靠传输</h1><p>到这里，就不仅要考虑比特受损的情况，还要考虑比特丢失的情况。</p>
<p>在该协议下，我们让发送方负责检测和恢复丢包工作。假如发送方发送的数据分组丢了，那么接收方就无法响应该分组的ACK确认（因为发送的数据分组都有序号），发送方在未收到ACK时，不论是ACK丢失还是数据分组丢失，直接重传数据即可。</p>
<p>但是这个等待的时间也有要求，最低为一个数据分组从发送方到接收方以及从接收方返回发送方的时间和。这里就需要引入一个计时器，超过时间需要重传。</p>
<p>这里还要求发送方和接收方信道中引入<strong>冗余数据分组</strong>，这里面要存储已经发送了但是还没收到确认帧的数据。</p>
<p>该协议解决问题的核心点在于：</p>
<p>1、差错检测</p>
<p>2、数据分组增加编号</p>
<p>3、接收方的响应</p>
<p>4、一个计时器</p>
<p>5、冗余数据分组</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
        <category>运输层</category>
      </categories>
      <tags>
        <tag>运输层</tag>
      </tags>
  </entry>
  <entry>
    <title>对于socket的一些理解</title>
    <url>/2023/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%AF%B9%E4%BA%8Esocket%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p> 在大学刚接触到网络编程以及web编程的时候，听说过socket以及端口号，但是当时只是知道写法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> xx;</span><br><span class="line">ServerSocket serverSocket <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);;</span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(ip, port);</span><br></pre></td></tr></table></figure>

<p>但是并不明白为什么要这样做，在学习了计算机网络后，有了一些个人理解。</p>
<p>在计算机网络中，我们编写的代码，是属于应用层的内容，当需要传输数据时，需要先将数据传送给运输层，然后运输层送往网络层，依次往下传送。</p>
<p>其实我们可以将应用层与其他的几层拆分开，然后把运输层及其以下的几层当作是一个其他人已经封装好了的计算机网络。我们传输数据，只需要把数据交给这个计算机网络，它就能帮我们把数据传输到我们的目的地。而socket，就是我们的编写的程序与计算机网络之间的接口，也可以理解为一个桥梁，连接我们应用程序与计算机网络。</p>
<p>而我们在web编程，比如使用springboot框架，也需要在配置文件中指定端口号，它其实也是用于底层封装的socket指定对应端口号。</p>
<p>一个较为形象的比喻，我们的应用程序可以理解为手机，也就是应用层。而运输层及其以下的那几层可以理解为我们的房子内的电线。我们想要充电，就需要一个充电器，连接我们的手机以及那些电线。而这个充电器，可以理解为socket。</p>
<p>也就是说，每个socket都需要绑定端口号，用于标识它对应于哪个进程，我们的进程需要指定这个端口号，然后将数据通过socket传送到运输层，并进行第一次数据封装，用于目的主机找到对应的进程。到这里，就可以认为我们进程要传送的数据已经交给计算机网络，剩余的内容就由计算机网络处理。</p>
]]></content>
      <categories>
        <category>个人心得</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>拥塞控制原理</title>
    <url>/2023/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="拥塞原因与代价"><a href="#拥塞原因与代价" class="headerlink" title="拥塞原因与代价"></a>拥塞原因与代价</h1><h2 id="情况1：两个发送方和一台具有无穷大缓存的路由器"><a href="#情况1：两个发送方和一台具有无穷大缓存的路由器" class="headerlink" title="情况1：两个发送方和一台具有无穷大缓存的路由器"></a>情况1：两个发送方和一台具有无穷大缓存的路由器</h2><p>两台主机（A和B）都有一条连接，且这两条连接共享源与目的地之间的单跳路由，如下图所示：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230502102410352.png" alt="image-20230502102410352" style="zoom:67%;" />

<p>由于路由器的缓存是无限制的，那么发送方的发送速率达到一定程度，路由器中的平均排队分组数就会无限增长，源与目的地之间的平均时延也会变成无穷大。</p>
<h2 id="情况2：两个发送方和一台具有有限缓存的路由器"><a href="#情况2：两个发送方和一台具有有限缓存的路由器" class="headerlink" title="情况2：两个发送方和一台具有有限缓存的路由器"></a>情况2：两个发送方和一台具有有限缓存的路由器</h2><p>这里对情况1稍微做一些修改，假定路由器的缓存容量是有限的。这种假设的结果是，当分组到达一个已满的缓存时会被丢弃。然后我们假设连接可靠，即分组在路由器中被丢弃时，会重发。</p>
<p>假设发送方知道路由中缓存容量，只有在路由未满时才发送，那么就不会导致分组丢失。</p>
<p>但一种更为真实的情况是，发送方并不知道，那么在缓存满时发送分组，带来的代价就是需要重新发送。而且存在一种情况，分组发出但是未丢失，还在排队当中，发送方因超时重新发送了分组，那么就会导致接收方需要丢弃一个重传分组，带来了不必要的开销。</p>
<p>这里就看出拥塞的两个代价，发送方需要重传丢失的分组，而且发送方可能重传不必要的分组。</p>
<h2 id="情况3：-4个发送方和具有有限缓存的多台路由器及多跳路径"><a href="#情况3：-4个发送方和具有有限缓存的多台路由器及多跳路径" class="headerlink" title="情况3： 4个发送方和具有有限缓存的多台路由器及多跳路径"></a>情况3： 4个发送方和具有有限缓存的多台路由器及多跳路径</h2><p>考虑下图的情况：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230502104741965.png" alt="image-20230502104741965" style="zoom:67%;" />

<p>由于路由器R2的缓存容量是有限的 ，那么当A-C通信，B-D通信时，这两者势必会争抢缓存，一种极端的情况是A-C占据了所有的缓存，导致B-D流量几乎为0，导致分组丢失。</p>
<p>还会导致资源浪费的一个点是，如果R2丢弃B-D的分组，那么R3所做的转发也就成了无用功，导致资源浪费。</p>
<h1 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h1><h2 id="端到端拥寒控制"><a href="#端到端拥寒控制" class="headerlink" title="端到端拥寒控制"></a>端到端拥寒控制</h2><p>在端到端拥塞控制方法中，网络层没有为运输层拥塞控制提供显式支持。即使网络中存在拥塞，端系统也必须通过对网络行为的观察（如分组丢失与时延）来推断。</p>
<p>TCP采用端到端的方法解决拥塞控制，因为IP层不会向端系统提供有关网络拥塞的反馈信息。TCP报文段的丢失（通过超时或3次冗余确认而得知）被认为是网络拥塞的一个迹象，TCP会相应地减小其窗口长度。</p>
<h2 id="网络辅助的拥塞控制"><a href="#网络辅助的拥塞控制" class="headerlink" title="网络辅助的拥塞控制"></a>网络辅助的拥塞控制</h2><p>在网络辅助的拥塞控制中，路由器向发送方提供关于网络中拥塞状态的显式反馈信息。这种反馈可以简单地用一个比特来指示链路中的拥塞情况。</p>
<p>对于网络辅助的拥塞控制，拥塞信息从网络反馈到发送方通常有两种方式，如下图</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230502110906990.png" alt="image-20230502110906990" style="zoom:67%;" />

<p>直接反馈信息可以由网络路由器发给发送方。这种方式的通知通常采用了一种阻塞分组(choke packet) 的形式（主要是说： “我拥塞了！”）。</p>
<p>更为通用的第二种形式的通知是，路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的产生口 一旦收到一个标记的分组后，接收方就会向发送方通知该网络拥塞指示。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
        <category>运输层</category>
      </categories>
  </entry>
  <entry>
    <title>流水线可靠数据传输协议</title>
    <url>/2023/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>rdt3.0虽然是一个正确的协议，但是很多人对于它的性能并不是很满意，因为它基于停等协议。而且是发送一个报文，就需要等待对方回复后才可以发送下一个，这很大程度上会影响性能。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424143036576.png" alt="image-20230424143036576" style="zoom:67%;" />

<p>对此最简单的解决办法是，发送一个报文段后并不等待回复，而是继续发送，累计N个报文段后再等待对方回复，这样效率就会提高。如下图所示：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424143059781.png" alt="image-20230424143059781" style="zoom:67%;" />

<p>这种技术也被称为流水线。有如下要求：</p>
<p>1、必须增加序号范围，而且每个分组有一个唯一的序号，用于确认是否正确传输。</p>
<p>2、协议的发送方和接收方都需要缓存多个分组，发送方需最低要缓存已经发送的但是对方还没确认的报文，用于重新发送。</p>
<p>3、解决流水线的差错恢复有两种基本方法：回退N步和选择重传</p>
<h1 id="回退N步（GBN）"><a href="#回退N步（GBN）" class="headerlink" title="回退N步（GBN）"></a>回退N步（GBN）</h1><p>该协议中，允许发送方发送N个分组而不需要等待确认。这里的N一般称为窗口长度，如果窗口里面的数据都没有被确认，则无法继续发送，如果有数据确认，则窗口向前移动，继续发送数据。如下图所示：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424144240644.png" alt="image-20230424144240644" style="zoom:80%;" />

<p>该协议也被称为滑动窗口协议。该协议的发送方必须响应以下三类事件：</p>
<p>1、上层的调用。当上层调用时，发送方先检查窗口是否已满，即是否有N个数据未确认。如果没满，就产生分组并且发送，并更新变量。如果满了，就告诉上层窗口已满，让它过一段时间重试。</p>
<p>2、接受一个ACK。该协议中对序号为n的分组采用累计确认的方式，表明接收方已经接收到序号为n以前包括序号为n的所有分组。</p>
<p>3、超时事件。如果发送的数据超过一定时间还未收到回复，那么就需要重传所有已经发送但是还未确认收到的数据。</p>
<p>接收方也会有对应的要求：</p>
<p>如果接受方正确接收到一个分组为n的分组（即上一次交给应用层的分组号是n - 1），则会给发送方回复一个ACK，并将分组交给上层，其他情况都会丢弃该分组。因为接收方发送序号为n的ACK，意味着n以及n以前的数据都正确接收。</p>
<p>即接收方的逻辑如下图所示：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424145709764.png" alt="image-20230424145709764" style="zoom:67%;" />

<h1 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h1><p>上述协议虽然提升了性能，但是也存在一些问题。比如，当窗口和带宽的时延比较大的时候，中间有一个分组的差错，就会导致大量的重传。</p>
<p>而选择重传就是只重传错误的分组，而不是重传某一个错误分组以后的所有分组。该协议的实现需要接收方也缓存一部分的数据，而且也要有窗口。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424151809822.png" alt="image-20230424151809822" style="zoom:67%;" />

<p>具体来说就是缓存那些乱序到达的数据，比如现在已经确认接收了需要为3的分组，而分组4丢失了，此时又接收到了分组5以及后续的数据。此时分组5以及以后的都会被缓存，直到接收到4后，才会从缓存中按序读取，然后交付给上层。具体过程如下：</p>
<p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424151833002.png" alt="image-20230424151833002"></p>
<p>由上图可以看出，发送方和接收方的窗口内的数据并不总是一样的，这也就会导致以下问题：</p>
<h2 id="如何判断一个分组是重传还是一个新的分组呢？"><a href="#如何判断一个分组是重传还是一个新的分组呢？" class="headerlink" title="如何判断一个分组是重传还是一个新的分组呢？"></a>如何判断一个分组是重传还是一个新的分组呢？</h2><p>考虑下面例子中可能发生的情况，该例有包括4个分组序号0、1、2、3的有限序号范围且窗口长度为3。假定发送了分组0至2,并在接收方被正确接收且确认了。此时，接收方窗口落在第4、5、6个分组上，其序号分别为3、0、1。</p>
<p>现在考虑两种情况，第一种如下图：</p>
<p>对前3个分组的ACK丢失，因此发送方重传这些分组，接收方下一步要接收序号为0的分组，而他期望的分组却是序号为3的，而且它无法发现这是重传的前三个已经接收的分组，而会当作是分组3丢失，等待重传3，而接收传送过来的0和1，将他们放在缓存当中。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424152342787.png" alt="image-20230424152342787" style="zoom:67%;" />

<p>下图的情况是，对前3个分组的ACK都被正确交付。因此发送方向前移动窗口并发送第4、5、6个分组，其序号分别为3、0、10序号为3的分组丢失，但序号为0的分组到达（一个包含新数据的分组）。</p>
<p>这时候接收方收到序号为0的分组时，他无法判断发送方是重发自己已经接收的序号0还是新发送的序号为0的分组。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424152417252.png" alt="image-20230424152417252" style="zoom:67%;" />

<p>显然，窗口长度比序号空间小1时协议无法工作。窗口长度必须小于或等于序号空间大小的一半。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
        <category>运输层</category>
      </categories>
      <tags>
        <tag>运输层</tag>
      </tags>
  </entry>
  <entry>
    <title>路由器结构</title>
    <url>/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="路由器结构"><a href="#路由器结构" class="headerlink" title="路由器结构"></a>路由器结构</h1><p>一个路由器的体系结构如下图：</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230511101229903.png" alt="image-20230511101229903" style="zoom:80%;" />

<p><strong>输入端口作用</strong>：</p>
<p>1、接收数据链路层的数据。</p>
<p>2、查询转发表，决定数据的输出端口。到达的分组通过路由器的交换结构转发到输出端口。</p>
<p><strong>交换结构</strong>：交换结构将路由器的输入端口连接到它的输岀端口。这种交换结构完全包含在路由器之中，即它是一个网络路由器中的网络!</p>
<p><strong>输出端口：</strong>输出端口存储从交换结构接收的分组，并通过执行必要的链路层和物理层功能在输出链路上传输这些分组。</p>
<p><strong>路由选择处理器</strong>：路由选择处理器执行<strong>控制平面</strong>功能。</p>
<p>在传统的路由器中，它执行路由选择协议，维护路由选择表与关联链路状态信息，并为该路由器计算转发表。</p>
<p>在SDN路由器中，路由选择处理器（在其他活动中）负责与远程控制器通信，目的是接收由远程控制器计算的转发表项，并在该路由器的输入端口安装这些表项。路由选择处理器还执行网络管理功能。</p>
<p>以上仅仅是每个部分大致功能的描述，后续会有更为详细的介绍。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《计算机网络自顶向下》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
        <category>网络层</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>路由器结构</title>
    <url>/2023/09/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h1 id="路由器结构"><a href="#路由器结构" class="headerlink" title="路由器结构"></a>路由器结构</h1><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230511101229903.png" alt="image-20230511101229903" style="zoom:80%;" />

<p>路由器由输入端口，交换结构，路由选择处理器以及输出端口组成。输入端口负责接收数据报，并且在这里决定好要怎么进行转发，然后经过交换结构，到达输出端口。即在输入端口这里已经找到了他的下一跳的地址，然后传送给交换结构，交换结构只需要根据数据去找对应的输出端口即可，可以大大减小路由表的大小。</p>
<p>而具体怎么找到该送往那个端口，最简单的是做一个map，包含了所有的映射，但是由于映射数量达到上百亿，不可取。另一种方案是：根据最长前缀匹配，比如说0000发网接口0，0001发网接口1，以此类推。</p>
<p>这里，输入端口查找的是数据报目的的ip，可能需要经过多个路由器来进行转发，才能到达目地地址。</p>
<h1 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h1><p>交换技术有三种，经内存的交换，经总线交换，互联网络交换。</p>
<h2 id="经内存的交换"><a href="#经内存的交换" class="headerlink" title="经内存的交换"></a>经内存的交换</h2><p>这种方案下，输入端口和输出端口的功能有点像传统操作系统中的I&#x2F;O，当一个分组到达端口，改端口通过中断向路由选择处理器发送信号，然后将分组复制到处理器内存当中，路由选择器从分组的首部提取到目的地址，在转发表找适当的输出端口，再将该分组复制到输出端口的缓存当中。</p>
<h2 id="经总线交换"><a href="#经总线交换" class="headerlink" title="经总线交换"></a>经总线交换</h2><p>这种方案下，输入端口经一根总线将分组直接发送到输出端口，不需要路由选择处理器的干预。这种方案下，输入端口需要预先计划一个交换机内部标签，指示本地输出端口，该分组可以由所有输出端口接受，但是只有标签匹配的才会保留，标签在输出端口被去除。单一总线会对性能造成影响</p>
<h2 id="经互联网络交换"><a href="#经互联网络交换" class="headerlink" title="经互联网络交换"></a>经互联网络交换</h2><p>这种方案是用2N条总线连接输入和输出端口，总线可以通过交换设备自由闭合，比如A发往X的数据，可以调整只打开A和X，但是如果有多个数据报都发往X，那么在X之前还是需要排队。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《计算机网络自顶向下》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
        <category>网络层</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层概述</title>
    <url>/2023/05/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="转发和路由选择：数据平面和控制平面"><a href="#转发和路由选择：数据平面和控制平面" class="headerlink" title="转发和路由选择：数据平面和控制平面"></a>转发和路由选择：数据平面和控制平面</h1><p><strong>转发</strong>：当一个分组到达某路由器的一条输入链路时，该路由器必须将该分组移动到适当的输出链路。如果分组来自一个已知的恶意注意，那么它会被路由器阻挡。</p>
<p><strong>路由选择</strong>：当分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径。计算这些路径的算法被称为路由选择算法。</p>
<p>每台路由器中都有一个转发表。路由器检査到达分组首部的一个或多个字段值，这些值对应存储在转发表项中的值，指出了该分组将被转发的路由器的输出链路接口。</p>
<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230509111658565.png" alt="image-20230509111658565" style="zoom:67%;" />

<p>说白了，就是通过这个路由表，找到应该将数据发送到哪一个出口。</p>
<h1 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h1><p>网络层能提供的某些可能的服务：</p>
<ul>
<li>确保交付。该服务确保分组将最终到达目的地。</li>
<li>具有时延上界的确保交付。该服务不仅确保分组的交付，而且在特定的主机到主机时延上界内（例如在100ms内）交付。</li>
<li>有序分组交付。该服务确保分组以它们发送的顺序到达目的地。</li>
<li>确保最小带宽。这种网络层服务模仿在发送和接收主机之间一条特定比特率（例如1 Mbps）的传输链路的行为。只要发送主机以低于特定比特率的速率传输比特（作为分组的组成部分），则所有分组最终会交付到目的主机。</li>
<li>安全性。网络层能够在源加密所有数据报并在目的地解密这些分组，从而对所有运输层报文段提供机密性。</li>
</ul>
<p>因特网实际提供的：</p>
<p>因特网的网络层提供了单一的服务，称为尽力而为服务（best effort service）。使用尽力而为服务，传送的分组既不能保证以它们发送的顺序被接收，也不能保证它们最终交付；既不能保证端到端时延，也不能保证有最小的带宽。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
        <category>网络层</category>
      </categories>
      <tags>
        <tag>网络层</tag>
      </tags>
  </entry>
  <entry>
    <title>路由选择算法</title>
    <url>/2023/09/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>路由选择算法是为了选出从一个点发出的数据报，该如何经过各个路由器，以最小的成本或最快的速度到达目的ip的一种算法，可以理解为图中的最短路径问题。</p>
<p>一般而言，路由选择算法的一种分类方式是根据该算法是集中式还是分散式来划分。</p>
<h1 id="集中式还是分散式"><a href="#集中式还是分散式" class="headerlink" title="集中式还是分散式"></a>集中式还是分散式</h1><h2 id="集中式路由选择算法"><a href="#集中式路由选择算法" class="headerlink" title="集中式路由选择算法"></a>集中式路由选择算法</h2><p>该算法以所有节点的连通性以及所有链路的开销为输入，这就要求算法在开始之前获得这些信息。该算法可以在一个集中的控制器或者在每台路由器的路由选择组件中重复进行。</p>
<p>集中式算法具有关于连通性和链路开销方面的完整信息。具有全局状态信息的算法常被称作链路状态（Link State, LS）算法, 因为该算法必须知道网络中每条链路的开销。</p>
<h2 id="分散式路由选择算法"><a href="#分散式路由选择算法" class="headerlink" title="分散式路由选择算法"></a>分散式路由选择算法</h2><p>该算法中，路由器以迭代、分布式的方式计算出最低开销路径。没有节点拥有关于所有网络链路开销的完整信息。 相反，每个节点仅有与其直接相连链路的开销知识即可开始工作。</p>
<p>然后，通过迭代计算过程以及与相邻节点的信息交换，一个节点逐渐计算出到达某目的节点或一组目的节点的最低开销路径。</p>
<h1 id="静态的还是动态"><a href="#静态的还是动态" class="headerlink" title="静态的还是动态"></a>静态的还是动态</h1><p>路由选择算法的第二种分类是基于算法是静态的还是动态的进行分类。</p>
<p>在静态路由选择算法（static routing algorithm）中，路由随时间的变化非常缓慢，通常是人工进行调整。</p>
<p>动态路由选择算法（dynamic routing algorithm） 随着网络流量负载或拓扑发生变化而改变路由选择路径。一个动态算法可周期性地运行或 直接响应拓扑或链路开销的变化而运行。虽然动态算法易于对网络的变化做岀反应，但也 更容易受诸如路由选择循环、路由振荡之类问题的影响。</p>
<h1 id="负载敏感的还是负载迟钝"><a href="#负载敏感的还是负载迟钝" class="headerlink" title="负载敏感的还是负载迟钝"></a>负载敏感的还是负载迟钝</h1><p>负载敏感算法（load-sensitive algorithm）中，链路开销会动态地变化以反映出底层链路的当前拥塞水平。如果当前拥塞的一条链路与高开销相联系，则路由选择算法趋向于绕开该 拥塞链路来选择路由。</p>
<p>负载迟钝的并不会选择性的避开。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《计算机网络自顶向下》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
        <category>网络层</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>运输层概述</title>
    <url>/2023/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>运输层协议为运行在不同端的应用进程提供逻辑上的通信，该协议是在端系统中实现，而不是在路由器中实现。</p>
<p>在发送端，运输层将从发送应用程序进程接收到的报文转换成运输层分组，该分组称为<strong>运输层报文段</strong>（segment）。</p>
<p>转换的方法：</p>
<p>1、将应用报文划分为较小的块，并为每块加上一个运输层首部以生成运输层报文段。</p>
<p>2、然后，在发送端系统中，运输层将这些报文段传递给网络层，网路层将其封装成网络层分组（即数据报）并向目的地发送。</p>
<h1 id="运输层和网络层关系"><a href="#运输层和网络层关系" class="headerlink" title="运输层和网络层关系"></a>运输层和网络层关系</h1><p>运输层位于网络层之上。网络层提供主机到主机的逻辑通信，而运输层提供的是进程到进程的逻辑通信。</p>
<p>用书上的一个例子，场景是：假如现在有两个家庭A和B，每个家庭有4个孩子。而每个月两家孩子都会互相的写信。家庭A有一个孩子负责收集所有孩子的信件，然后送给邮局。家庭B同样有一个孩子来做这件事情。家庭A的孩子设为C，家庭B的孩子设为D。</p>
<p>在这个例子中，从这些孩子的角度来看，孩子C和孩子D就为他们提供了逻辑通信。因为其他孩子只需要把信交给孩子C和D，剩余事情都无需关心。邮局则提供了两个家庭间的逻辑通信，因为孩子C和D只需要把信交给邮局，其他的也无需关心。</p>
<p>所以可以做以下类比：</p>
<p>1、应用层报文 &#x3D; 信封上的字符</p>
<p>2、进程 &#x3D; 这群孩子 （他们是通信主体）</p>
<p>3、主机（端系统） &#x3D;  家庭  </p>
<p>4、运输层协议  &#x3D;  孩子C和D</p>
<p>5、网络层协议  &#x3D;  邮政服务</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《计算机网络导论：自顶向下方法》</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
        <category>运输层</category>
      </categories>
      <tags>
        <tag>运输层</tag>
      </tags>
  </entry>
</search>
