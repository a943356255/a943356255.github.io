<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便起个名字吧</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-17T08:54:15.770Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Guo Junhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>空闲空间管理</title>
    <link href="http://example.com/2023/04/17/%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2023/04/17/%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/</id>
    <published>2023-04-17T07:48:51.000Z</published>
    <updated>2023-04-17T08:54:15.770Z</updated>
    
    <content type="html"><![CDATA[<p>这一部分，书中做了一些假设：</p><p>1、如果请求内存，就需要指定请求内存的大小，而释放该内存则不用指定大小。</p><p>2、只考虑外部碎片，不考虑因分配空间稍微大于请求内存而造成的内部碎片。</p><p>3、内存一旦被分配给用户，那么它就不可能被重定位。即这块内存分配给用户后，除非用户调用free函数，否则无法被其他人使用。</p><p>4、分配程序管理的内存区域是连续的，而且还可以增大这块区域。</p><h1 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h1><h2 id="1、分割与合并"><a href="#1、分割与合并" class="headerlink" title="1、分割与合并"></a>1、分割与合并</h2><p>假如内存中空闲状态如下图：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417162102174.png" alt="image-20230417162102174"></p><p>那么它对应的空闲链表如图：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417162144075.png" alt="image-20230417162144075"></p><p>这也就意味着，任何长度大于10字节的分配请求都会失败。</p><p>如果请求分配的内存小于10字节，那么它会找到一块满足的空间区域，然后进行分割，第一块分给用户，剩下的加入空闲列表。</p><p>而用户在调用free时，它并不是把用户使用的那块区域直接加入，而是会看用户释放的空间左右两端是否是空闲的，如果是，则进行合并。</p><p>比如参考第一张图，如果用户释放中间用掉的10字节，它会变为如下：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417163036922.png" alt="image-20230417163036922"></p><p>而不是</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417163055234.png" alt="image-20230417163055234"></p><h2 id="2、追踪已分配空间的大小"><a href="#2、追踪已分配空间的大小" class="headerlink" title="2、追踪已分配空间的大小"></a>2、追踪已分配空间的大小</h2><p>由于在释放对应区域空间时，并不需要指出大小，这是因为在大多数分配程序都会在头块中保存一些额外的信息，头块位于内存中，就在返回的内存区域前面。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417164000218.png" alt="image-20230417164000218" style="zoom:67%;" /><p>这里释放的时候会释放头块加具体的内存空间，那么意味着在申请内存时，申请的大小也是头块加用户指明的大小。</p><h1 id="内存分配的基本策略"><a href="#内存分配的基本策略" class="headerlink" title="内存分配的基本策略"></a>内存分配的基本策略</h1><p>1、最优匹配：找到和用户申请大小最接近的一块区域，分配给用户。但是他需要遍历所有的空闲列表，性能差一点。</p><p>2、最差匹配：找最大的空闲区域，分割并分配给用户。会导致过量碎片，而且性能不好。</p><p>3、首次匹配：找到第一个足够大的块，分配给用户。不需要全部遍历，但可能会导致开头的部分有很多的小块，因此，如何管理空闲列表顺序就变的比较重要。</p><p>一种解决办法：一种方式是基于地址排序，保持空闲块按内存地址有序，会让合并变得容易，减少内存碎片。</p><p>4、下次匹配：每一次都从上一次分配完成的地址开始往后遍历。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一部分，书中做了一些假设：&lt;/p&gt;
&lt;p&gt;1、如果请求内存，就需要指定请求内存的大小，而释放该内存则不用指定大小。&lt;/p&gt;
&lt;p&gt;2、只考虑外部碎片，不考虑因分配空间稍微大于请求内存而造成的内部碎片。&lt;/p&gt;
&lt;p&gt;3、内存一旦被分配给用户，那么它就不可能被重定位。即这块</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>分段</title>
    <link href="http://example.com/2023/04/17/%E5%88%86%E6%AE%B5/"/>
    <id>http://example.com/2023/04/17/%E5%88%86%E6%AE%B5/</id>
    <published>2023-04-17T05:35:17.000Z</published>
    <updated>2023-04-17T07:48:36.505Z</updated>
    
    <content type="html"><![CDATA[<p> 在分段之前，操作系统会直接把进程的地址空间完整的加载到内存当中，但是栈和堆中间却有很大一块空间没有使用，如下图：</p><img src="C:\Users\郭俊豪\AppData\Roaming\Typora\typora-user-images\image-20230417134359838.png" alt="image-20230417134359838" style="zoom: 67%;" /><p>但是由于进程的地址空间被加载到了内存中，那么就意味着这些虚拟的地址空间都会被分配对应的物理地址，虽然这些地址没有被该进程写入内容，但是他们已经不能再分配给其他进程使用。</p><p>为了解决这个问题，引入了分段的概念。有了分段的概念后，就不是给每个地址空间一个寄存器，而是让地址空间内的每个段都有自己的基址寄存器和界限寄存器。<strong>一个段是地址空间中连续的定长区域。</strong></p><p>这样设计，就可以把进程的单个段加载到内存中，而不是将整个地址空间都加载到内存中，这样就能确保被加载到物理内存空间中的内容都是正在使用的，或者说最小程度的浪费一些空间。</p><p>在经典的地址空间中，有三个逻辑不同的段：代码，栈和堆。分段之后，我们可以把这三个部分分别加载到物理内存对应的位置，如下图所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417141138659.png" alt="image-20230417141138659" style="zoom: 67%;" /><p>而不需要像之前那样，必须把整个地址空间全部加载到内存当中。</p><h1 id="分段存在的问题"><a href="#分段存在的问题" class="headerlink" title="分段存在的问题"></a>分段存在的问题</h1><p>分段的出现会导致内存中零散的分布很多的段，如果现在有不连续的24k空间，现在有一个20k大小的段，则会导致该段进入内存失败。</p><p>即分段会造成一定的外部碎片。</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>这篇笔记是在学习操作系统导论时写的，该书采用的是层层递进的方式，由最初的设计，存在什么问题，一步一步解决问题，更改设计，得到一个现代的操作设计方案。所以本文中有些内容可能并非目前操作系统正确的设计。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 在分段之前，操作系统会直接把进程的地址空间完整的加载到内存当中，但是栈和堆中间却有很大一块空间没有使用，如下图：&lt;/p&gt;
&lt;img src=&quot;C:\Users\郭俊豪\AppData\Roaming\Typora\typora-user-images\image-2023</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>地址转换</title>
    <link href="http://example.com/2023/04/16/%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/"/>
    <id>http://example.com/2023/04/16/%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/</id>
    <published>2023-04-16T09:35:58.000Z</published>
    <updated>2023-04-16T13:47:16.710Z</updated>
    
    <content type="html"><![CDATA[<p>地址转换：硬件对每次的内存访问进行处理，将指令的虚拟地址转换为数据实际的物理地址。</p><p>但是仅仅靠硬件无法解决，它只能提高效率。还需要操作系统的帮助。</p><p>这使得每个程序好像拥有了自己私有的内存空间，存放着自己的代码和数据。但实际上是多个程序共用内存。</p><h1 id="动态重定位"><a href="#动态重定位" class="headerlink" title="动态重定位"></a>动态重定位</h1><p>每个CPU需要两个硬件寄存器：基址寄存器和界限寄存器。这两个寄存器能够让我们将地址空间放在物理内存的任何位置，同时又保证程序只访问自己的地址空间。</p><p>采用这种硬件的地址转换方式，进程中的内存引用都是虚拟地址，而虚拟地址加上基址寄存器中的内容，可以算出来真实的物理地址，再发送给内存系统。</p><p>由于这个由虚拟内存转换为具体的物理内存的过程是在运行时发生的，所以又叫做动态重定位。</p><p>这里面的界限寄存器，就是用来保证进程只访问自己范围内的空间，如果越界，则cpu会触发异常，进程会被终止。</p><h1 id="操作系统要做什么"><a href="#操作系统要做什么" class="headerlink" title="操作系统要做什么"></a>操作系统要做什么</h1><p>1、进程创建时，操作系统要为进程的地址空间找到内存空间。这就需要操作系统来维护哪些空间是可用的，哪些是已经被使用了的。</p><p>2、当进程运行结束时，操作系统要负责回收它的内存，供其他进程使用。当进程结束时，操作系统会把这些内存放入空闲列表。</p><p>3、每个cpu只有一个界限寄存器和基址寄存器，但对于每个运行的程序，他们要存入的值都是不同的。所以在发生上下文切换时，操作系统需要保存当前正在运行进程的界限寄存器和基址寄存器的值，以便后续恢复该进程时使用。</p><p>4、操作系统需要提供异常处理。比如当一个程序要越界访问时，cpu会触发异常，而操作系统需要终止该程序。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;地址转换：硬件对每次的内存访问进行处理，将指令的虚拟地址转换为数据实际的物理地址。&lt;/p&gt;
&lt;p&gt;但是仅仅靠硬件无法解决，它只能提高效率。还需要操作系统的帮助。&lt;/p&gt;
&lt;p&gt;这使得每个程序好像拥有了自己私有的内存空间，存放着自己的代码和数据。但实际上是多个程序共用内存。&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的next-key lock</title>
    <link href="http://example.com/2023/04/16/MySQL%E7%9A%84next-key%20lock/"/>
    <id>http://example.com/2023/04/16/MySQL%E7%9A%84next-key%20lock/</id>
    <published>2023-04-16T07:10:20.000Z</published>
    <updated>2023-04-16T08:31:50.128Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB引擎为了解决幻读带来的问题，引入了间隙锁。而间隙锁和行锁组合起来叫做next-key lock，他是一个左开右闭的区间，代表锁住对应数据行以及数据行之间的间隙。</p><p>比如现在有两行数据，（5，5，5）和（10，10，10）。在可重复读得隔离级别下执行如下sql ，，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where id = 7</span><br></pre></td></tr></table></figure><p>就会锁住(5, 10]之间的间隙，以及第（10，10，10）这一行。因为锁是加在索引上面，而索引是有序的，所以需要保证这两条数据间没有新的数据插入。</p><p>在《MySQL45讲》中给出了加锁的一些规则：</p><ol><li>原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。</li><li>原则2：查找过程中访问到的对象才会加锁。</li><li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。</li><li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候（比如查询id &#x3D; 5，而最后一个值是id &#x3D; 10，那么就会变为间隙锁），next-key lock退化为间隙锁。</li><li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ol><p>假如现在有如下表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure><p>下面我们看一些具体的例子。</p><h1 id="等值查询间隙锁"><a href="#等值查询间隙锁" class="headerlink" title="等值查询间隙锁"></a>等值查询间隙锁</h1><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416152532725.png" alt="image-20230416152532725"></p><p>课程中讲的是：</p><p>1、根据原则1，加锁单位是next-key lock，session A加锁范围就是(5,10]；</p><p>2、同时根据优化2，这是一个等值查询(id&#x3D;7)，而id&#x3D;10不满足查询条件，next-key lock退化成间隙锁，因此最终加锁的范围是(5,10)。</p><p>所以插入（8，8，8）失败，而update10成功。</p><p>这里有一个疑问：为什么没有根据优化1，将（5，10]的next-key lock转变为行锁呢？</p><p>个人理解：虽然是唯一索引的等值操作，但是查询条件是id &#x3D; 7，而表中的值是id &#x3D; 5和 id &#x3D; 10这两条记录，并不相等，所以没有退化成行锁。</p><h1 id="非唯一索引等值锁"><a href="#非唯一索引等值锁" class="headerlink" title="非唯一索引等值锁"></a>非唯一索引等值锁</h1><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416152814309.png" alt="image-20230416152814309"></p><p>这个例子中，由于数据是（0，0，0）（5，5，5）（10，10，10），而查询条件是c &#x3D; 5，所以会先在（0，5]之间加上next-key lock。</p><p>但是c是非唯一索引，所以需要遍历到不满足条件的为止，也就是说会访问到c &#x3D; 10这一行。所以还会给（5，10]加上锁，但是该锁最后一行c &#x3D; 10并不满足c &#x3D; 5的查询条件，所以会退化为间隙锁，也就是（5，10），并不锁c &#x3D; 10这一行。</p><p>而这个查询语走索引c，却只查询了id，恰好是覆盖索引，并不会回表，也就是说只锁了索引c，而没有锁索引id，那么意味着sessionB要操作的数据并没有加锁，所以B成功了，而C失败了。</p><h1 id="主键索引范围锁"><a href="#主键索引范围锁" class="headerlink" title="主键索引范围锁"></a>主键索引范围锁</h1><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416154441303.png" alt="image-20230416154441303" style="zoom: 50%;" /><p>sessionA会先找到id &#x3D; 5这一行，然后是id &#x3D; 10这一行，所以会加（5，10]的next-key lock。但是id &#x3D; 10满足了查询条件，所以这个锁会退化为行锁，只锁id &#x3D; 10这一行。</p><p>但是查询还有第二个条件id  &lt;  11，则会继续往后走，查找到id &#x3D; 15这一行。所以会加（10，15]的next-key lock。由于查询条件id &lt; 11在id &#x3D; 15这一行不满足，所以无法退化成间隙锁，也即是说15这一行也会被锁住。就会导致如图的情况。</p><h1 id="非唯一索引范围锁"><a href="#非唯一索引范围锁" class="headerlink" title="非唯一索引范围锁"></a>非唯一索引范围锁</h1><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416160330625.png" alt="image-20230416160330625" style="zoom:50%;" /><p>这个例子中，由于查询所有的值，所以走索引c需要回表。意味着不仅要锁索引c，也要锁id。</p><p>在第一次用c&#x3D;10定位记录的时候，索引c上加了(5,10]这个next-key lock后，由于索引c是非唯一索引，没有优化规则，也就是说不会变为行锁，因此最终sesion A加的锁是，索引c上的(5,10] 和(10,15] 这两个next-key lock。</p><p>所以插入8 和修改c &#x3D; 15也都会被阻塞。</p><h1 id="非唯一索引上存在”等值”的例子"><a href="#非唯一索引上存在”等值”的例子" class="headerlink" title="非唯一索引上存在”等值”的例子"></a>非唯一索引上存在”等值”的例子</h1><p>假如新插入了一行记录（30，10，30）那么索引c就会变为如下：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416162231844.png" alt="image-20230416162231844" style="zoom: 67%;" /><p>那么如下操作：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416162440432.png" alt="image-20230416162440432"></p><p>这里会加5，10以及10，15的锁，然后不包括端点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;InnoDB引擎为了解决幻读带来的问题，引入了间隙锁。而间隙锁和行锁组合起来叫做next-key lock，他是一个左开右闭的区间，代表锁住对应数据行以及数据行之间的间隙。&lt;/p&gt;
&lt;p&gt;比如现在有两行数据，（5，5，5）和（10，10，10）。在可重复读得隔离级别下执行如</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    <category term="锁" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/%E9%94%81/"/>
    
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>运输层概述</title>
    <link href="http://example.com/2023/04/16/%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2023/04/16/%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/</id>
    <published>2023-04-16T03:04:45.000Z</published>
    <updated>2023-04-16T06:43:27.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>运输层协议为运行在不同端的应用进程提供逻辑上的通信，该协议是在端系统中实现，而不是在路由器中实现。</p><p>在发送端，运输层将从发送应用程序进程接收到的报文转换成运输层分组，该分组称为<strong>运输层报文段</strong>（segment）。</p><p>转换的方法：</p><p>1、将应用报文划分为较小的块，并为每块加上一个运输层首部以生成运输层报文段。</p><p>2、然后，在发送端系统中，运输层将这些报文段传递给网络层，网路层将其封装成网络层分组（即数据报）并向目的地发送。</p><h1 id="运输层和网络层关系"><a href="#运输层和网络层关系" class="headerlink" title="运输层和网络层关系"></a>运输层和网络层关系</h1><p>运输层位于网络层之上。网络层提供主机到主机的逻辑通信，而运输层提供的是进程到进程的逻辑通信。</p><p>用书上的一个例子，场景是：假如现在有两个家庭A和B，每个家庭有4个孩子。而每个月两家孩子都会互相的写信。家庭A有一个孩子负责收集所有孩子的信件，然后送给邮局。家庭B同样有一个孩子来做这件事情。家庭A的孩子设为C，家庭B的孩子设为D。</p><p>在这个例子中，从这些孩子的角度来看，孩子C和孩子D就为他们提供了逻辑通信。因为其他孩子只需要把信交给孩子C和D，剩余事情都无需关心。邮局则提供了两个家庭间的逻辑通信，因为孩子C和D只需要把信交给邮局，其他的也无需关心。</p><p>所以可以做以下类比：</p><p>1、应用层报文 &#x3D; 信封上的字符</p><p>2、进程 &#x3D; 这群孩子 （他们是通信主体）</p><p>3、主机（端系统） &#x3D;  家庭  </p><p>4、运输层协议  &#x3D;  孩子C和D</p><p>5、网络层协议  &#x3D;  邮政服务</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;运输层协议为运行在不同端的应用进程提供逻辑上的通信，该协议是在端系统中实现，而不是在路由器中实现。&lt;/p&gt;
&lt;p&gt;在发送端，运输层将从发送应</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="运输层" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
    
    <category term="运输层" scheme="http://example.com/tags/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>CDN</title>
    <link href="http://example.com/2023/04/16/CDN/"/>
    <id>http://example.com/2023/04/16/CDN/</id>
    <published>2023-04-16T01:37:45.000Z</published>
    <updated>2023-04-16T02:30:28.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内容分发网络CDN"><a href="#内容分发网络CDN" class="headerlink" title="内容分发网络CDN"></a>内容分发网络CDN</h1><p>现阶段，很多视频公司没日需要给用户推送大量的视频，这些视频如果都从公司的主服务器推送出去，则会给主服务器造成压力，而且由于区域原因，还会带来很高的时延。</p><p>CDN就是为了解决上面的问题。CDN服务器可以分布在多个地区，它存储那些视频以及图片的副本，用于用户请求时将视频等内容响应给用户。可以减小主服务器带宽压力，而且根据用户地理位置，分配不同的CDN，可以减少时延。</p><p>CDN采用集群部署，如果用户请求的CDN集群没有用户的目标视频，则该CDN集群会从中心仓库或者另一个集群搜索该视频，然后一边给用户传输，一边缓存在本集群中。</p><h1 id="CDN操作"><a href="#CDN操作" class="headerlink" title="CDN操作"></a>CDN操作</h1><p>当用于从浏览器请求某视频时，CDN需要先截获用户请求，才能确定适合用户的CDN集群，以及将用户请求重定向到该集群中。</p><h2 id="如何截获和重定向"><a href="#如何截获和重定向" class="headerlink" title="如何截获和重定向"></a>如何截获和重定向</h2><p>截获请求和重定向需要依赖于DNS。假如公司A用了公司B提供的CDN服务，那么一个大概的流程如下：</p><p>1、用户访问公司A的网站，点击了一个视频，那么他会向对应的域名发起请求（例如请求<a href="https://www.bilibili.com/video/xxx%EF%BC%89%EF%BC%8C%E8%8E%B7%E5%8F%96%E8%AF%A5%E8%A7%86%E9%A2%91%E3%80%82">https://www.bilibili.com/video/xxx），获取该视频。</a></p><p>2、用户的本地DNS服务器会将请求转发到权威DNS服务器，权威DNS服务器发现了域名中的video，那么它并不会向用户返回一个IP地址，而是返回一个B公司的主机名。</p><p>3、然后，该请求就进入了B公司专用的DNS设施。然后用户本地DNS会发起第二个请求，此时就是直接向公司B发起的DNS请求，这个请求会得到一个指向B公司的ip地址，然后用户可以从这里获取到视频的信息。</p><p>从这里，用户发起向公司A的请求就被转变为向公司B的CDN服务器的请求。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416102329355.png" alt="image-20230416102329355" style="zoom:67%;" /><h2 id="集群选择策略"><a href="#集群选择策略" class="headerlink" title="集群选择策略"></a>集群选择策略</h2><p>在上面的重定向过程中，公司B的CDN服务器是可以知道用户本地DNS地址，那么他就可以根据该ip来为用户分配最为临近的CDN集群。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内容分发网络CDN&quot;&gt;&lt;a href=&quot;#内容分发网络CDN&quot; class=&quot;headerlink&quot; title=&quot;内容分发网络CDN&quot;&gt;&lt;/a&gt;内容分发网络CDN&lt;/h1&gt;&lt;p&gt;现阶段，很多视频公司没日需要给用户推送大量的视频，这些视频如果都从公司的主服务器推送</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="应用层" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
  </entry>
  
  <entry>
    <title>地址空间</title>
    <link href="http://example.com/2023/04/15/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/"/>
    <id>http://example.com/2023/04/15/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/</id>
    <published>2023-04-15T09:23:14.000Z</published>
    <updated>2023-04-15T10:39:36.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h1><p>一个线程的地址空间如下图所示：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230415172631305.png" alt="image-20230415172631305"></p><p>这个地址空间看似是从0KB开始，但这里的0KB映射到具体的物理地址并不一定是从内存的地址0开始，它可能是物理内存的任意位置。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;地址空间&quot;&gt;&lt;a href=&quot;#地址空间&quot; class=&quot;headerlink&quot; title=&quot;地址空间&quot;&gt;&lt;/a&gt;地址空间&lt;/h1&gt;&lt;p&gt;一个线程的地址空间如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image-1314238346.cos.</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>一个sleep操作引起的问题</title>
    <link href="http://example.com/2023/04/15/%E4%B8%80%E4%B8%AAsleep%E6%93%8D%E4%BD%9C%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2023/04/15/%E4%B8%80%E4%B8%AAsleep%E6%93%8D%E4%BD%9C%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2023-04-15T03:17:51.000Z</published>
    <updated>2023-04-15T08:04:44.128Z</updated>
    
    <content type="html"><![CDATA[<p>在学习Java并发编程时，有以下demo，简单演示商品出售的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 减少t</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                t--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 减少t</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                t--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是存在并发问题的，当库存为1的时候，两个线程同时判断 t &gt; 0，然后都进入t–操作，会导致输出的值为-1。</p><p>但是在本地实测的时候却发现，尝试了很多次都没有出现t为负数的情况，然后将代码改成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 减少t</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                t--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 减少t</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                t--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况，很容易出现t为负数的情况。</p><p>为什么加了sleep就很容易出现，而不加却需要尝试很多次呢？</p><h3 id="一个比较简单的解释"><a href="#一个比较简单的解释" class="headerlink" title="一个比较简单的解释"></a>一个比较简单的解释</h3><p>在不加sleep的情况下，由于操作只有t–，执行的特别快，所以说很难出现错误的情况，概率比较小。</p><p>而加了sleep之后，进入判断后会先进行sleep，sleep完再去处理t–。这样在t &#x3D; 1时，线程判断完进入while后就睡眠，另一个线程在这100ms内有很大概率也会进入相同的判断，导致结果为-1。</p><p>在这里加sleep可以理解为加大了判断与执行t–之间的时间，导致更多的线程会在这之间执行。</p><h3 id="另一种情况"><a href="#另一种情况" class="headerlink" title="另一种情况"></a>另一种情况</h3><p>如果sleep是在下面这个位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 减少t</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                t--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + t);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 减少t</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                t--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + t);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说先执行t–，然后打印，之后再进行sleep。按照这么个顺序来执行，一个线程的判断和执行扣减操作的时间并没有被加长，却也很容易出现t为负数或者打印相同t的情况。</p><h3 id="从硬件考虑"><a href="#从硬件考虑" class="headerlink" title="从硬件考虑"></a>从硬件考虑</h3><p>我的电脑是8核cpu的，该程序只开了两个线程，如果当前电脑cpu资源比较充足是时，从理论上来讲，存在一种情况就是两个线程都是并行执行，并不存在竞争cpu资源的问题。</p><p>当并发的资源竞争没那么大时，每个线程在工作内存中所做的修改，可以很快的同步回主内存，另一个线程也可以从主内存中读取到最新的值（非volatile修饰的公共变量，虚拟机并不保证其可见性，但不代表一定是不可见的），然后再进行操作。</p><p>所以，当每个线程都执行的很快且并发资源竞争没那么大时（对应上面不加sleep的demo），我们可以做一个大胆一点的假设（虽然不对）：对t &gt; 0的判断和 t –操作是原子性的。也就是说，这两步执行的太快，以至于其他线程无法在中间穿插任何操作（而事实是存在穿插操作的可能），好像加了锁一样。</p><p>而加了sleep之后，无论在哪里加，都会导致当前的线程阻塞。而阻塞操作涉及到一个从用户态切换到核心态。因为Java的线程设计是每一个Java线程都绑定了一个内核线程，要阻塞一个线程或者唤醒都需要操作系统帮忙。这里由于内核切换带来的开销，可能会导致线程写入主内存延，也可能会导致另一个线程读取主内存的数据延迟，加大了发生问题的概率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在学习Java并发编程时，有以下demo，简单演示商品出售的问题。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;s</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>多处理器调度</title>
    <link href="http://example.com/2023/04/14/%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/"/>
    <id>http://example.com/2023/04/14/%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/</id>
    <published>2023-04-14T09:20:38.000Z</published>
    <updated>2023-04-17T06:29:55.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多处理器架构"><a href="#多处理器架构" class="headerlink" title="多处理器架构"></a>多处理器架构</h1><p>多处理器与单处理器最大的区别在于对硬件缓存的使用，以及处理器之间共享数据的方式。</p><p>在单CPU系统中，存在多级硬件缓存，一般会让程序执行更快。</p><p>假设一个程序需要从内存中加载指令并读取一个值，在它第一次读取时，需要从内存中读取，之后处理器判定在短期内很可能会再次使用这个数据，会将其放入缓存中，下一次再请求时，直接从缓存中取即可。</p><p>在多CPU系统中，缓存则会变得复杂。</p><p>假如有两个CPU，一个内存。现在有一个运行在CPU1上的程序，要去地址A读值，但是CPU1里面没有该数据的缓存，所以需要去内存中读取，读取完成后，程序要修改地址A上的值，假设改为D，它会先写入缓存中，然后再去写入内存。但是写入内存时发生了中断，中断完后此程序交由CPU2执行，但是CPU2中没有数据的缓存，就需要从内存中读，这时候就会读到旧得数据，而不是修改后得D。</p><p>硬件提供了这个问题得解决方案：通过监控内存得访问，硬件可以保证获得正确数据，并确保共享内存的唯一性。</p><h1 id="单队列调度"><a href="#单队列调度" class="headerlink" title="单队列调度"></a>单队列调度</h1><p>这种调度方式就是采用一个队列来存储任务，然后有多个cpu从中获取任务，然后执行。但是这里需要用加锁的方式来保证调度的正确性，而加锁又会带来性能上的损耗。而且可能存在一种情况，一个任务频繁的在不同的cpu上运行，导致cpu的缓存几乎不起作用。我们应该尽可能保证一个任务一直在一个cpu上处理，来尽可能多的提高缓存命中率。</p><p>一个cpu缓存命中率特别低的情况：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414205315810.png" alt="image-20230414205315810"></p><h1 id="多队列调度"><a href="#多队列调度" class="headerlink" title="多队列调度"></a>多队列调度</h1><p>这种设计下，队列与CPU是多对多的关系，我们可以让一个队列对应一个CPU。</p><p>这样锁的竞争就会小很多，如果每一个CPU只从固定的一个队列获取任务，甚至可以消除锁竞争。而且它的缓存亲和性比较好，一个队列里面的任务会固定在一个CPU上运行。</p><p>如果按照一个CPU只处理自己对应队列的任务，会存在一种情况，cpu1里的任务已经执行完了，而cpu2里的任务还没有，那么cpu2一直在忙碌 ，cpu1却在空闲，导致负载不均衡。</p><p>如下图：A独占cpu0，而B 和 D交替执行在cpu1上。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414205421683.png" alt="image-20230414205421683"></p><p>若A执行完成，则会变成如下：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414205507938.png" alt="image-20230414205507938"></p><p>解决办法：迁移。通过工作的跨cpu迁移，可以实现负载均衡。</p><p><strong>即cpu1可以处理cpu2对应队列中的任务。</strong></p><p>假如cpu1队列中一开始只有任务A，而cpu2中有任务B和D，那么在迁移的设计下，执行过程如下：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414205237310.png" alt="image-20230414205237310"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多处理器架构&quot;&gt;&lt;a href=&quot;#多处理器架构&quot; class=&quot;headerlink&quot; title=&quot;多处理器架构&quot;&gt;&lt;/a&gt;多处理器架构&lt;/h1&gt;&lt;p&gt;多处理器与单处理器最大的区别在于对硬件缓存的使用，以及处理器之间共享数据的方式。&lt;/p&gt;
&lt;p&gt;在单CPU系</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="CPU虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>调度：多级反馈队列</title>
    <link href="http://example.com/2023/04/14/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2023/04/14/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97/</id>
    <published>2023-04-14T08:10:53.000Z</published>
    <updated>2023-04-17T06:30:08.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h1><p>MLFQ有许多独立的队列，每个队列都有优先级，任何时刻，一个任务只能存在一个队列当中，而MLFQ总是执行优先级最高的队列中的任务。在同一个队列中的任务，采用轮转调度。而MLFQ会观察任务的行为，然后调整他们的优先级。</p><h1 id="尝试1：改变优先级"><a href="#尝试1：改变优先级" class="headerlink" title="尝试1：改变优先级"></a>尝试1：改变优先级</h1><p>工作进入系统时，放在优先级最高的队列当中，工作用完整个时间片后，降低其优先级，如果时间片没用完，主动放弃CPU，则优先级不进行变化。</p><p>按照这种方法，如果有一个很长的cpu密集型任务要执行，那么它会被慢慢降级到最低的优先级。而此时来了一个短任务，会被放在优先级最高的队列中执行，它大概率会在降到最低优先级之前处理完，这种情况下MLFQ近似于短任务优先。</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>这样设计，如果一个任务一直不把CPU时间片用完，那么他就一直可以处于优先级最高的队列当中，那么会导致一些用完时间片而导致降级的任务永远无法处理。</p><p>而且会有程序恶意放弃CPU资源而一直占用处理器，比如在时间片用完之间，执行一段I&#x2F;O操作，主动放弃CPU。</p><h1 id="尝试2：提升优先级"><a href="#尝试2：提升优先级" class="headerlink" title="尝试2：提升优先级"></a>尝试2：提升优先级</h1><p>一个简单的设计，经过一段时间S后，就把队列中的所有任务全部放在优先级最高的队列当中。</p><p>但是这个S的值设置不合适也会导致问题，太长，会导致任务饥饿，太短的话，交互性任务达不到合适的CPU时间比例。</p><h1 id="尝试3：更好的设计"><a href="#尝试3：更好的设计" class="headerlink" title="尝试3：更好的设计"></a>尝试3：更好的设计</h1><p>为了防止一些恶意代码在CPU时间片用完前执行一次I&#x2F;O操作来放弃处理器资源，以达到刷新时间片的目的，我们可以将时间片设计为该任务在该队列可以执行的总时间。意思就是，一个任务可以执行1s，那么无论它放弃了多少次，只要执行的总时间达到1s，他就要被降到低优先级的队列当中。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本规则&quot;&gt;&lt;a href=&quot;#基本规则&quot; class=&quot;headerlink&quot; title=&quot;基本规则&quot;&gt;&lt;/a&gt;基本规则&lt;/h1&gt;&lt;p&gt;MLFQ有许多独立的队列，每个队列都有优先级，任何时刻，一个任务只能存在一个队列当中，而MLFQ总是执行优先级最高的队列中的</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="CPU虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的幻读</title>
    <link href="http://example.com/2023/04/14/MySQL%E7%9A%84%E5%B9%BB%E8%AF%BB/"/>
    <id>http://example.com/2023/04/14/MySQL%E7%9A%84%E5%B9%BB%E8%AF%BB/</id>
    <published>2023-04-14T05:55:01.000Z</published>
    <updated>2023-04-14T13:58:14.459Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章将介绍MySQL幻读相关的内容。</p><p>假设数据库中有以下表：</p><table><thead><tr><th>id</th><th>c</th><th>d</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>5</td><td>5</td><td>5</td></tr><tr><td>10</td><td>10</td><td>10</td></tr><tr><td>15</td><td>15</td><td>15</td></tr><tr><td>20</td><td>20</td><td>20</td></tr><tr><td>25</td><td>25</td><td>25</td></tr></tbody></table><p>其中id是主键，c上建立有普通索引。</p><p>以下讨论场景除非必要说明，否则都是在可重复读的隔离级别下。</p><h1 id="什么是幻读"><a href="#什么是幻读" class="headerlink" title="什么是幻读"></a>什么是幻读</h1><p>现在考虑以下场景：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414141001291.png" alt="image-20230414141001291" style="zoom:50%;" /><p>其中，select * from table for update表示当前读，并且加上写锁。</p><p>幻读就是指在同一个事务中执行相同的sql，后一次查询看到了前一次没看到的数据。就比如Q3比Q2多了一条数据。</p><p>Q2看到Q1并不被称为幻读，幻读仅仅指新插入的数据。</p><p>在可重复读的隔离级别下，普通查询是看不到其他插入的数据，只有当前读（要能读到所有已经提交的记录的最新值）才有可能出现幻读。</p><h1 id="幻读存在的问题"><a href="#幻读存在的问题" class="headerlink" title="幻读存在的问题"></a>幻读存在的问题</h1><h2 id="1、语义的破坏"><a href="#1、语义的破坏" class="headerlink" title="1、语义的破坏"></a>1、语义的破坏</h2><p>session A已经声明了写锁，即要锁住d &#x3D; 5的行，不允许其他事务进行读写，而后续却插入了一条d &#x3D; 5的数据。</p><p>考虑另一个更明显的场景：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414143724913.png" alt="image-20230414143724913" style="zoom: 50%;" /><p>sessionB将id &#x3D; 0的这一行的d改成了5，然后又把c改成了5，也就是说变化为从（0，0，5）-&gt;（0，5，5）。这样破坏了sessionA要锁住所有d&#x3D;5的行的加锁声明。</p><p>sessionC也是同样的道理，修改了d &#x3D; 5，id &#x3D; 1的行。</p><h2 id="2、数据一致性问题"><a href="#2、数据一致性问题" class="headerlink" title="2、数据一致性问题"></a>2、数据一致性问题</h2><p>现在在sessionA追加一条语句：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414144337377.png" alt="image-20230414144337377" style="zoom:50%;" /><p>此时，sessionA要锁住d &#x3D; 5的这一行，然后把d 改为100，即sessionA在T1要做的操作为将（5，5，5）-&gt; (5，5，100)。</p><p>在T2时刻，id &#x3D; 0这一行变成了（0，5，5）</p><p>在T4时刻，数据库多了一条（1，5，5）的记录。</p><p>但是我们看binlog的内容：</p><p>在T2时刻，sessionB提交，写入两条语句，两条update。</p><p>T4时刻，sessionC提交，写入两条语句，一条insert，一条update。</p><p>把上面的语句放在一起，顺序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* sessionB */</span><br><span class="line">update t set d = 5 where id = 0; /*(0,0,5)*/</span><br><span class="line">update t set c = 5 where id = 0; /*(0,5,5)*/</span><br><span class="line"></span><br><span class="line">/* sessionC */</span><br><span class="line">insert into t values(1,1,5); /*(1,1,5)*/</span><br><span class="line">update t set c = 5 where id = 1; /*(1,5,5)*/</span><br><span class="line"></span><br><span class="line">/* sessionA */</span><br><span class="line">update t set d = 100 where d = 5;/*所有d=5的行，d改成100*/</span><br></pre></td></tr></table></figure><p>通过这个语句的顺序，如果我们要拿它来恢复数据，最终恢复出来的数据会变为： (0,5,100)、(1,5,100) 和 (5,5,100)。</p><p>而正确的数据应该是（0，5，5），（1，5，5）和（5，5，100）。因为在可重复读隔离级别下，事务A没提交，事务B和C看不到A的修改，而事务A在提交之前看不到B和C的修改。</p><p>这里的数据不一致是因为我们假设了select * from t where d&#x3D;5 for update这条语句只给id &#x3D; 5这一样加锁导致的。</p><p>现在我们假设把扫描过程中的所有行都加锁，场景如下：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414150914211.png" alt="image-20230414150914211" style="zoom:50%;" /><p>这个时候，id &#x3D; 0的这一行在修改时，由于被加了锁，所以无法执行。也就是说现在的执行顺序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert into t values(1,1,5); /*(1,1,5)*/</span><br><span class="line">update t set c=5 where id=1; /*(1,5,5)*/</span><br><span class="line"></span><br><span class="line">update t set d=100 where d=5;/*所有d=5的行，d改成100*/</span><br><span class="line"></span><br><span class="line">update t set d=5 where id=0; /*(0,0,5)*/</span><br><span class="line">update t set c=5 where id=0; /*(0,5,5)*/</span><br></pre></td></tr></table></figure><p>此时，id &#x3D; 0的这一行数据正确，但是新插入的id &#x3D; 1的问题还是没有解决。</p><p><strong>也就是说，即使把所有的记录都加上锁，还是阻止不了新插入的记录</strong>，这也是为什么要单独解决幻读。</p><h1 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h1><p>即使我们在一开始就锁住所有行，但是由于插入语句是在行的间隙进行的，所以InnoDB的解决办法是引入了间隙锁(Gap Lock)。比如开头的表，有6行数据，7个间隙。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414151304834.png" alt="image-20230414151304834" style="zoom:67%;" /><p>这样，当你执行 select * from t where d&#x3D;5 for update的时候，就不止是给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。</p><p>间隙锁和间隙锁之间不冲突，两个事务可以在同一个间隙加间隙锁，与间隙锁冲突的是往间隙插入数据的操作。</p><p><strong>间隙锁和行锁合称next-key lock</strong>，每个next-key lock是前开后闭区间，</p><p>间隙锁只有在可重复读的隔离级别下才有。而且引入间隙锁会降低并发度，并且有可能造成死锁。</p><p>另外一种解决幻读的方式是采用读提交的隔离级别加binlog_format&#x3D;row。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文章将介绍MySQL幻读相关的内容。&lt;/p&gt;
&lt;p&gt;假设数据库中有以下表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;d&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    <category term="其他" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="MySQL45讲" scheme="http://example.com/tags/MySQL45%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>DNS域名解析</title>
    <link href="http://example.com/2023/04/14/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2023/04/14/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/</id>
    <published>2023-04-14T02:22:20.000Z</published>
    <updated>2023-04-16T03:05:33.659Z</updated>
    
    <content type="html"><![CDATA[<p>DNS是一个由分层的DNS服务器实现的分布式数据库，它主要记录了域名与IP地址的对应关系。</p><p>我们平时访问网站，都是输入域名，而不是IP地址，而域名被解析为对应IP地址这一步，就是由DNS实现的。</p><p>它还提供了一些其他的服务，比如说将一个域名映射到多个IP地址上，用于减轻单个服务器的压力。</p><h1 id="DNS架构"><a href="#DNS架构" class="headerlink" title="DNS架构"></a>DNS架构</h1><p>它是一个分布式的数据库，且分多层次。</p><p>不采用单点是因为如果单点故障，那么整个因特网就不能用，而且单点无法承载那么大的请求量，存储那么多的数据。如果采用单点，还会因为地理位置原因导致很大的时延。</p><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>DNS分为根域名服务器，顶级域名服务器，权威域名服务器和本地域名服务器。</p><p>一个用户在浏览器中输入一个域名，解析的过程大致如下（迭代查询）：</p><p>1、向本地域名服务器发送请求。</p><p>2、本地域名服务器向根域名服务器发送请求，根域名服务器返回顶级域名服务器的地址。</p><p>3、本地再向顶级域名服务器发起请求，顶级域名服务器返回权威域名服务器的地址，到这一步就可以获取到IP。</p><p>4、本地域名服务器将获取到的ip返回给用户浏览器。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/test.png" alt="test" style="zoom: 50%;" /><p>递归查询：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414110639339.png" alt="image-20230414110639339" style="zoom: 67%;" /><h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><p>某一个DNS服务器接受一个DNS回答时，它可以将映射存储在本地的存储器中，下一次如果有同样的映射，可以直接返回而不用去往下一层请求。</p><p>但是该缓存并不是永久存在的，过一段时间会被清除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;DNS是一个由分层的DNS服务器实现的分布式数据库，它主要记录了域名与IP地址的对应关系。&lt;/p&gt;
&lt;p&gt;我们平时访问网站，都是输入域名，而不是IP地址，而域名被解析为对应IP地址这一步，就是由DNS实现的。&lt;/p&gt;
&lt;p&gt;它还提供了一些其他的服务，比如说将一个域名映射到多</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="应用层" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
    <category term="应用层" scheme="http://example.com/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>进程调度：介绍</title>
    <link href="http://example.com/2023/04/13/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%9A%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2023/04/13/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%9A%E4%BB%8B%E7%BB%8D/</id>
    <published>2023-04-13T08:00:56.000Z</published>
    <updated>2023-04-14T09:19:58.110Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍一些基础的调度策略。</p><h1 id="调度指标"><a href="#调度指标" class="headerlink" title="调度指标"></a>调度指标</h1><p>以下算法的性能指标只考虑周转时间。</p><p>周转时间 &#x3D; 完成时间 - 到达时间</p><h1 id="先进先出（FIFO）"><a href="#先进先出（FIFO）" class="headerlink" title="先进先出（FIFO）"></a>先进先出（FIFO）</h1><p>这个算法的思路很简单，先来的先执行，并且易于实现。就好比有三个任务A，B，C，他们到来的顺序是B，A，C，那么就按照他们到来的顺序进行执行。</p><p>存在的问题：如果先来的任务执行了很长时间，会导致后边的任务等待很久才可以执行，这样会导致系统的周转时间变的很长。</p><h1 id="最短任务优先（SJF）"><a href="#最短任务优先（SJF）" class="headerlink" title="最短任务优先（SJF）"></a>最短任务优先（SJF）</h1><p>该算法会先运行短任务，然后运行次短任务，依次下去。如果任务同时到达，该算法较FIFO算法可以很好的解决平均周转时间长的问题。</p><p>但是如果任务不同时到达，那么执行时间长的任务比短时任务先到达，还是会导致短任务需要等待。</p><h1 id="最短完成时间优先（STCF）"><a href="#最短完成时间优先（STCF）" class="headerlink" title="最短完成时间优先（STCF）"></a>最短完成时间优先（STCF）</h1><p>上面两种算法都是非抢占式的。</p><p>而最短完成时间优先可以理解为一种抢占式的最短任务优先算法。</p><p>该算法下，没当有任务进入系统，会判断当前正在执行任务的剩余时间和新任务的时间，哪个短就执行哪个。</p><h1 id="新的性能指标"><a href="#新的性能指标" class="headerlink" title="新的性能指标"></a>新的性能指标</h1><p>从现在开始，性能不仅考虑周转时间，还要考虑响应时间。</p><p>响应时间 &#x3D; 首次运行 - 到达时间。</p><h1 id="轮转"><a href="#轮转" class="headerlink" title="轮转"></a>轮转</h1><p>在加入新的性能指标后，上述算法就会出现问题，因为会导致长任务的响应时间特别长。</p><p>轮转的思想是，每一个任务执行一个时间片，然后切换到队列中的下一个任务，而不是一个任务一直执行，直到完毕。</p><p>该算法需要考虑时间片长短的问题，太短会导致频繁切换而导致性能下降，而太长，则会导致周转时间和响应时间太长，所以需要权衡考虑。</p><h1 id="结合I-x2F-O"><a href="#结合I-x2F-O" class="headerlink" title="结合I&#x2F;O"></a>结合I&#x2F;O</h1><p>现在假设任务都需要进行I&#x2F;O操作，那么轮转这种设计方法就会体现出它的优势。</p><p>如果不进行轮转，先到来的任务占用处理器资源，然后又进行了I&#x2F;O操作，那么会导致一个任务占用处理器资源却不使用，而是进行I&#x2F;O操作，导致其他任务也无法执行，这是对处理器的浪费。</p><p>而轮转却能很好的解决该问题，因为任务在执行I&#x2F;O操作时，可以让出处理器，让其他任务使用。</p><h1 id="无法预知"><a href="#无法预知" class="headerlink" title="无法预知"></a>无法预知</h1><p>上面的讨论都是建立在操作系统知道任务需要处理多长时间，而事实情况是，执行时间是无法估计的，所以像SJF或者STCF这种算法，几乎无法实现。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要介绍一些基础的调度策略。&lt;/p&gt;
&lt;h1 id=&quot;调度指标&quot;&gt;&lt;a href=&quot;#调度指标&quot; class=&quot;headerlink&quot; title=&quot;调度指标&quot;&gt;&lt;/a&gt;调度指标&lt;/h1&gt;&lt;p&gt;以下算法的性能指标只考虑周转时间。&lt;/p&gt;
&lt;p&gt;周转时间 &amp;#x3D; 完</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="CPU虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>机制：受限直接执行</title>
    <link href="http://example.com/2023/04/12/%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%8F%97%E9%99%90%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C/"/>
    <id>http://example.com/2023/04/12/%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%8F%97%E9%99%90%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C/</id>
    <published>2023-04-12T12:05:09.000Z</published>
    <updated>2023-04-14T09:19:46.585Z</updated>
    
    <content type="html"><![CDATA[<p>当我们采用时分共享或者空分共享虚化CPU时，也要考虑它带来的问题，第一个是性能问题，频繁的进行上下文切换必然会导致性能下降。第二个是控制权，如何有效的运行进程，同时保留对CPU的控制。</p><p>关键问题：如何高效、可控的进行虚化。</p><h1 id="受限直接执行"><a href="#受限直接执行" class="headerlink" title="受限直接执行"></a>受限直接执行</h1><h2 id="1、直接执行"><a href="#1、直接执行" class="headerlink" title="1、直接执行"></a>1、直接执行</h2><p>直接执行比较好理解，即直接在CPU资源上运行程序即可。</p><p>当程序需要运行时，直接将代码加载到内存中，然后找到入口点运行用户代码。</p><p>但是如果没有限制，那么会产生问题：如何保证程序不做我们不想让它做的事情，另一方面是如何停止一个进程让另一个进程运行。</p><h2 id="2、受限制的操作"><a href="#2、受限制的操作" class="headerlink" title="2、受限制的操作"></a>2、受限制的操作</h2><p>关键问题：如何执行受限制的操作</p><p>一个进程要能够执行I&#x2F;O和其他一些受限制的操作，但又不能让进程控制系统。</p><p>针对这个问题，引入了一个新的处理器模式：用户模式。在用户模式下运行的代码会收到限制，比如不能发出I&#x2F;O请求。</p><p>与之对应的是内核模式。该模式代码可以做任何操作。</p><p>目前硬件提供了用户程序执行<strong>系统调用</strong>的功能，即用户代码可以通过系统调用执行如创建和销毁进程，与其他进程通信等。</p><p>要执行系统调用，程序必须执行特殊的陷阱（trap）指令。该指令跳入内核并将特权级别提升到内核模式。但是执行该指令时需要有足够多的寄存器来存储程序目前的状态，确保程序能够正确返回。</p><p>很明显的一点是，发起系统调用的过程不能让程序决定跳转到内核的哪里，因为这样会导致恶意程序在内核运行。</p><p>解决办法是由一个陷阱表，可以理解为一个map，记录了发生某种指令时需要运行那些代码，这样当用户程序执行系统调用，就会执行对应的位置的代码，而不再由程序决定跳入内核的那个位置。</p><h2 id="3、在进程之间切换"><a href="#3、在进程之间切换" class="headerlink" title="3、在进程之间切换"></a>3、在进程之间切换</h2><p>一个很关键的问题，如果进程在CPU上运行，那就意味着操作系统此时没有运行，那操作系统如何拿回控制权呢？</p><h3 id="协作方式：等待系统调用"><a href="#协作方式：等待系统调用" class="headerlink" title="协作方式：等待系统调用"></a>协作方式：等待系统调用</h3><p>在这种方式下，运行时间过长的进程会被<strong>假定主动放弃</strong>CPU，以便操作系统决定运行其他任务。注意，这里需要程序手动的将控制权交还给操作系统。</p><p>但是也有恶意或者不小的代码执行一些非法操作，就会陷入操作系统，此时操作系统将再次获得CPU。</p><h3 id="非协作方式：操作系统进行控制"><a href="#非协作方式：操作系统进行控制" class="headerlink" title="非协作方式：操作系统进行控制"></a>非协作方式：操作系统进行控制</h3><p>这里要解决的问题：如何在没有协作的情况下获得控制权。</p><p>上面的那种方式，在出现非法操作时会导致进程陷入操作系统，但是如果一个进程进入无限循环，它不进行系统调用也不出错，那么操作系统就无法获得控制权。</p><p>这个问题的解决办法是<strong>时钟中断</strong>。</p><p>时钟设备可以便成为每几毫秒产生一次中断，中断发生时，正在运行的进程停止，操作系统预先配置的中断程序会运行，然后操作系统会获得CPU的控制权。然后它就可以停止当前进程，运行另外一个进程。</p><h3 id="保存和恢复上下文"><a href="#保存和恢复上下文" class="headerlink" title="保存和恢复上下文"></a>保存和恢复上下文</h3><p>当操作系统获得CPU时，它就要确定是继续执行当前进程还是进行切换。如果进行切换，就需要为当前正在运行的进行保存一些信息到寄存器（通用寄存器，程序计数器，当前正在运行进程的内核指针），并且恢复将要运行的进程恢复一些寄存器的值。这个过程就叫做上下文切换。</p><p>当发生时钟中断时，运行进程由用户寄存器隐式保存，使用该进程的内核栈。</p><p>当操作系统决定从A切换到B，内核寄存器被操作系统（OS）明确的保存在该进程的进程结构的内存中。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当我们采用时分共享或者空分共享虚化CPU时，也要考虑它带来的问题，第一个是性能问题，频繁的进行上下文切换必然会导致性能下降。第二个是控制权，如何有效的运行进程，同时保留对CPU的控制。&lt;/p&gt;
&lt;p&gt;关键问题：如何高效、可控的进行虚化。&lt;/p&gt;
&lt;h1 id=&quot;受限直接执行</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="CPU虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>抽象：进程</title>
    <link href="http://example.com/2023/04/12/%E6%8A%BD%E8%B1%A1%EF%BC%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>http://example.com/2023/04/12/%E6%8A%BD%E8%B1%A1%EF%BC%9A%E8%BF%9B%E7%A8%8B/</id>
    <published>2023-04-12T11:03:29.000Z</published>
    <updated>2023-04-14T09:19:09.224Z</updated>
    
    <content type="html"><![CDATA[<p>进程就是运行中的程序。</p><p>一台电脑往往只有少数CPU，但是用户想要运行许多个应用，这里的关键问题：如何提供有许多CPU的假象。</p><p>操作系统通过虚拟化CPU来提供这假象，让一个进程只运行一个时间片，然后切换到其他进程。每个进程都运行一会儿，给用户的感觉就好像每个进程都在运行一样。</p><h1 id="时分共享和空分共享"><a href="#时分共享和空分共享" class="headerlink" title="时分共享和空分共享"></a>时分共享和空分共享</h1><p>时分共享是指让每个进程运行一段时间后让出处理器，让其他进程再运行一段时间，来达到虚拟化CPU的目的。</p><p>空分共享是指CPU资源在空间上被划分给希望使用它的进程。但这里需要注意，一旦分给一个进程，某些情况下如果它不释放空间，就不会再把这块空间分给其他进程。</p><h1 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h1><p>程序如何转变为进程？</p><p>操作系统运行程序必须先把代码和静态数据加载到内存中，加载到进程的地址空间中。如下图所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230412193147452.png" alt="image-20230412193147452" style="zoom: 67%;" /><p>早期操作系统在程序运行前加载完成，而现在的是懒加载，即在程序执行期间需要的代码或者数据，才会加载到内存。</p><p>通过将代码和静态数据加载到内存中，然后创建和初始化栈以及执行与I&#x2F;O设置相关的工作，就只剩下最后一个任务，启动程序。</p><h1 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h1><p>进程有以下三种状态：</p><p>1、运行。说明进程正在处理器上运行，占用着资源。意味着正在执行指令。</p><p>2、就绪。程序已经准备好运行，但出于某种原因，操作系统不在此时运行。</p><p>3、阻塞。该进程在等待其他某种操作或者某个条件达成后，才可以进入就绪状态。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230412194438253.png" alt="image-20230412194438253" style="zoom:67%;" /><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;进程就是运行中的程序。&lt;/p&gt;
&lt;p&gt;一台电脑往往只有少数CPU，但是用户想要运行许多个应用，这里的关键问题：如何提供有许多CPU的假象。&lt;/p&gt;
&lt;p&gt;操作系统通过虚拟化CPU来提供这假象，让一个进程只运行一个时间片，然后切换到其他进程。每个进程都运行一会儿，给用户的感觉</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="CPU虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引失效的情况</title>
    <link href="http://example.com/2023/04/12/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5/"/>
    <id>http://example.com/2023/04/12/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5/</id>
    <published>2023-04-12T07:08:17.000Z</published>
    <updated>2023-04-14T14:00:12.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="条件字段函数操作"><a href="#条件字段函数操作" class="headerlink" title="条件字段函数操作"></a>条件字段函数操作</h1><p>假如我们现在有如下需求，我们要统计一张表2021年和2022年8月份的记录，那么SQL语句可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select column_1, column_2 from table_1 where month(record_time) = 7;</span><br></pre></td></tr></table></figure><p>虽然数据库表在record_time上加了索引（结构图如下），但是这个sql还是会执行的特别慢。</p><img src="C:\Users\郭俊豪\AppData\Roaming\Typora\typora-user-images\image-20230412151341061.png" alt="image-20230412151341061" style="zoom:67%;" /><p>因为在用month函数对record_time做计算后，得到的数字是记录的月份，而索引的值却并不是一个单独的数字，所以会导致它走全表扫描。</p><p>也就是说，<strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 无法使用id这个索引</span><br><span class="line">select * from table_1 where id + 1 = 1000 </span><br><span class="line"></span><br><span class="line">// 可以使用</span><br><span class="line">select * from table_1 where id = 1000 - 1</span><br></pre></td></tr></table></figure><h1 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h1><p>现在有如下例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tradelog where id = 110717;</span><br></pre></td></tr></table></figure><p>其中，id是一个varchar类型的值，虽然它上面有索引，但还是走了全表扫描。这里就是因为id是varchar，而输入的值是数字，导致类型转换。</p><p>而发生转换要走全表索引的原因是转换相当于一个函数调用，上面语句相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tradelog where CAST(id AS signed int) = 110717;</span><br></pre></td></tr></table></figure><p>而对索引字段使用函数会导致无法使用索引。</p><h1 id="隐式字符编码转换"><a href="#隐式字符编码转换" class="headerlink" title="隐式字符编码转换"></a>隐式字符编码转换</h1><p>假如有如下语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select d.* from tradelog l, trade_detail d where d.tradeid = l.tradeid and l.id = 2</span><br></pre></td></tr></table></figure><p>这是一个简单的连表操作，其中tradelog为驱动表，trade_detail为被驱动表，tradeid为关联字段。</p><p>但是使用explain却发现在tradelog上使用了索引，但是在trade_detail上却走了全表扫描。</p><p>这个语句的执行流程是，从驱动表中找到一行数据，然后去被驱动表查找对值一样的数据组成结果集，过程如下：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230412153535466.png" alt="image-20230412153535466" style="zoom: 67%;" /><p>而这里走全表扫描的原因是发生了类型的转换。这里两个表的字段一个类型是utf8，另一个是utf8mb4，导致实际执行的sql相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from trade_detail  where CONVERT(traideid USING utf8mb4)=$L2.tradeid.value; </span><br></pre></td></tr></table></figure><p>CONVERT()函数，在这里的意思是把输入的字符串转成utf8mb4字符集。</p><p>而这里导致全表扫描的原因也是因为对索引字段加了函数操作。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL45讲》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;条件字段函数操作&quot;&gt;&lt;a href=&quot;#条件字段函数操作&quot; class=&quot;headerlink&quot; title=&quot;条件字段函数操作&quot;&gt;&lt;/a&gt;条件字段函数操作&lt;/h1&gt;&lt;p&gt;假如我们现在有如下需求，我们要统计一张表2021年和2022年8月份的记录，那么SQL语句可</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    <category term="索引" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/%E7%B4%A2%E5%BC%95/"/>
    
    
    <category term="MySQL45讲" scheme="http://example.com/tags/MySQL45%E8%AE%B2/"/>
    
    <category term="索引" scheme="http://example.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>order by是怎么工作的</title>
    <link href="http://example.com/2023/04/10/order%20by%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
    <id>http://example.com/2023/04/10/order%20by%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84/</id>
    <published>2023-04-10T07:38:21.000Z</published>
    <updated>2023-04-14T14:02:44.798Z</updated>
    
    <content type="html"><![CDATA[<p>假设我们现在有如下表，其中<strong>id是主键，city上有普通索引</strong>。</p><table><thead><tr><th>id</th><th>city</th><th>name</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>杭州</td><td>张三</td><td>22</td></tr><tr><td>2</td><td>杭州</td><td>李四</td><td>23</td></tr><tr><td>3</td><td>郑州</td><td>王五</td><td>24</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td></tr></tbody></table><p>现在需要查出city为杭州的人的性命和年龄，并按照年龄排序的前100个人。那么sql语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select city, name, age from t where city=&#x27;杭州&#x27; order by name limit 100;</span><br></pre></td></tr></table></figure><h1 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h1><p>先初始化sort_buffer，这是一块用于排序的内存，然后确定放入city，name，age三个字段。</p><p>之后，会在city索引树中找到值为杭州的记录，然后去主键索引取这一行的值存入sort_buffer，直到city不为杭州。</p><p>然后在sort_buffer中使用快排根据name字段进行排序，对排序结果取前100行返回给客户端。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230410155143209.png" alt="image-20230410155143209" style="zoom: 67%;" /><p>其中，如果取出的数据量太大，无法存入sort_buffer，则需要利用磁盘临时文件辅助排序。</p><h1 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h1><p>上述情况可以把所有数据都放入sort_buffer中进行排序，但是如果不能全部放入，会把原来的文件分成多份，借助临时文件来进行归并排序。如果一行的数据量太大，则要分的份数太多，会影响性能。</p><p>MySQL提供了一个参数，max_length_for_sort_data用于限制排序的行数据的长度。比如我们设置它为16，如果sort_buffer在初始时确定放入字段的长度超过16，则会采用rowid排序。</p><p>现在的排序过程如下：</p><p>初始化sort_buffer，确定放入id和name字段（只放入排序相关的字段）。</p><p>这之后的步骤与上面的排序过程类似，不过在sort_buffer内排序完成后，需要根据id去主键上取city，name，age字段后，再返回给用户。相当于多了一次回表操作。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230410160554644.png" alt="image-20230410160554644" style="zoom:67%;" /><h1 id="全字段排序和rowid排序"><a href="#全字段排序和rowid排序" class="headerlink" title="全字段排序和rowid排序"></a>全字段排序和rowid排序</h1><p>如果内存足够大，则会优先使用全字段排序，因为可以减少一次回表操作，否则会采用rowid排序。</p><p>这里也体现了MySQL的一个设计思想：能用内存就用，尽量减少磁盘访问。</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><p>上述SQL需要排序是因为数据是无序的，但是如果我们保证了从city索引中取出的数据就是按name有序的，就可以省略掉排序的过程。</p><p>所以我们可以建立一个联合索引 (city, name)，然后执行流程如下：</p><p>1、从联合索引中找到city为杭州的记录。</p><p>2、去主键索引取name、city、age三个字段的值，作为结果集的一部分直接返回。</p><p>3、一直重复上述步骤，直到city不为杭州或者够100条记录。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230410161831144.png" alt="image-20230410161831144" style="zoom:67%;" /><p>这样，就不需要使用临时表了。</p><p>如果创建了（city，name，age）的联合索引，则还可以省去回表的操作，进一步优化查询时间。但是会导致索引占用空间过多。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL45讲》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;假设我们现在有如下表，其中&lt;strong&gt;id是主键，city上有普通索引&lt;/strong&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;city&lt;/th&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th&gt;age&lt;/th&gt;
&lt;/tr&gt;
&lt;/the</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    <category term="执行流程" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    
    
    <category term="MySQL45讲" scheme="http://example.com/tags/MySQL45%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据删除</title>
    <link href="http://example.com/2023/04/07/Redis%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4/"/>
    <id>http://example.com/2023/04/07/Redis%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4/</id>
    <published>2023-04-07T06:42:37.000Z</published>
    <updated>2023-04-14T14:10:55.539Z</updated>
    
    <content type="html"><![CDATA[<p>有时候，在删除了Redis中部分数据后，会发现Redis仍然占用了很多内存，这是因为当数据删除后，Redis 释放的内存空间会由内存分配器管理，并不会立即返回给操作系统。所以，操作系统仍然会记录着给 Redis 分配了大量内存。</p><p>但是这样会导致一个问题，这些空间可能都是碎片化的，Redis无法拿来存取数据，还占用了大量的内存空间。</p><h1 id="什么是内存碎片"><a href="#什么是内存碎片" class="headerlink" title="什么是内存碎片"></a>什么是内存碎片</h1><p>一个较为简单的解释，就是虽然存在空间，但是这些空间却由于零散的分布在内存的各个地方，导致无法使用。</p><h1 id="形成原因"><a href="#形成原因" class="headerlink" title="形成原因"></a>形成原因</h1><p>1、内因：内存分配器的分配策略</p><p>内存分配器一般是按固定大小来分配内存，而不是完全按照应用程序申请的内存空间大小给程序分配。比如说现在Redis需要申请20字节的空间，但是分配器可能会分配32字节，此时如果还要写入10字节的数据，就不需要在此分配空间。但是这会导致2字节的空间很难被在此利用。</p><p>2、外因：键值对大小不一样和删改操作</p><p>Redis用来存储不同的键值对，这样就需要申请不同的空间，这一点与内因相同。而修改和删除操作，就会导致空间的扩容和释放，这就会导致新的内存分配，另一方面，删除的键值对就不再需要内存空间了，此时，就会把空间释放出来，形成空闲空间。</p><h1 id="如何清理内存碎片"><a href="#如何清理内存碎片" class="headerlink" title="如何清理内存碎片"></a>如何清理内存碎片</h1><p>1、直接重启Redis。但是这样会带来一些问题：</p><ul><li>如果Redis中的数据没有持久化，则会丢失数据。</li><li>即使持久化了，重启后需要加载RDB和AOF文件进行恢复，恢复时长取决于AOF或RDB文件的大小。而且如果Redis是单机的，此时就无法对外提供服务。</li></ul><p>2、自动内存碎片清理。大致的原理是，通过对象移位的方式，把原本不连续的空间变为连续的。</p><p><strong>碎片清理是有代价的</strong>，操作系统需要把多份数据拷贝到新位置，把原有空间释放出来，这会带来时间开销。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Redis核心技术实战》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有时候，在删除了Redis中部分数据后，会发现Redis仍然占用了很多内存，这是因为当数据删除后，Redis 释放的内存空间会由内存分配器管理，并不会立即返回给操作系统。所以，操作系统仍然会记录着给 Redis 分配了大量内存。&lt;/p&gt;
&lt;p&gt;但是这样会导致一个问题，这些空</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Redis" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis/"/>
    
    <category term="其他" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="Redis设计与实现" scheme="http://example.com/tags/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java的线程池</title>
    <link href="http://example.com/2023/04/07/Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://example.com/2023/04/07/Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2023-04-07T01:22:12.000Z</published>
    <updated>2023-04-13T09:20:20.206Z</updated>
    
    <content type="html"><![CDATA[<p>一个线程池的运行流程如下：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230407104446460.png" alt="image-20230407104446460"></p><p> 看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestExecutionWebServer</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">READS</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(READS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;do Something&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// new Thread(task).start();</span></span><br><span class="line">            executor.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被注释掉的那一行，就是没有使用线程池的写法。它会为每一个到来的请求都新建一个线程去执行任务，但是这样做有一个弊端，就是会无限制的创建线程，有100个请求就创建100个线程，然后用完再销毁，频繁的线程创建和销毁会给系统带来很大的压力，而且无休止的创建线程也会导致系统耗尽资源而崩溃。</p><p>而使用了线程池，它会固定线程的数量，每次来任务时，就从线程池里面取一个闲置的线程去执行任务，而且线程池里面的线程都是创建好了的，省略了创建线程和销毁线程的资源消耗。</p><h1 id="Executor的生命周期"><a href="#Executor的生命周期" class="headerlink" title="Executor的生命周期"></a>Executor的生命周期</h1><p>由于executor以异步的方式执行，所以任意时刻，之前提交的任务状态都是不可知的，可能运行结束，可能还在执行或者排队。所以关闭 时需要将操作中受影响的任务状态返回给应用程序。</p><p>为了解决这个问题，Executor扩展了ExecutorService接口，添加了一些有关生命周期的方法。比如说shutdown，shutdownNow，isShutdown等。下面是一个支持关闭的服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestExecutionWebServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">READS</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(READS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (!executor.isShutdown()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">                <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; handleRequest(socket);</span><br><span class="line">                executor.execute(task);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!executor.isShutdown()) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do something with socket&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。</p><p>ThreadPoolExecutor的运行状态有5种：</p><p>RUNNING：能接受新提交的任务，也能处理阻塞队列中的任务。</p><p>SHUTDOWN：关闭状态，不接受新任务，但可以处理阻塞队列中已保存的任务。</p><p>STOP：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。</p><p>TIDYING：所有任务已经终止，workerCount（有效线程数）为0。</p><p>TERMINATED：在terminated()方法执行完成后进入该状态。</p><p>线程转变过程如下：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230407104821174.png" alt="image-20230407104821174"></p><h1 id="任务执行机制"><a href="#任务执行机制" class="headerlink" title="任务执行机制"></a>任务执行机制</h1><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。具体执行过程如下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230407105329566.png" alt="image-20230407105329566" style="zoom: 80%;" /><p>注：这里的核心数是指操作系统的核心线程数，由于Java线程的设计是采用1：1的设计方案，也就是说每一个Java线程都绑定了一个操作系统的核心线程。</p><h2 id="任务缓冲"><a href="#任务缓冲" class="headerlink" title="任务缓冲"></a>任务缓冲</h2><p>线程池本质是对任务和线程的管理，做到这一点的关键是将两者解耦，不让两者关联才可以做后续的分配工作。而这一点是通过采用生产者-消费者模式，通过一个阻塞队列实现的。阻塞队列缓存任务，然后工作线程从中获取任务。</p><p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230407111347618.png" alt="image-20230407111347618"></p><h2 id="任务申请"><a href="#任务申请" class="headerlink" title="任务申请"></a>任务申请</h2><p>任务的执行有两种可能：</p><p>1、任务直接由新创建的线程执行。</p><p>2、线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。</p><p>第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。执行流程如下：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230407112022917.png" alt="image-20230407112022917" style="zoom: 80%;" /><h2 id="任务拒绝"><a href="#任务拒绝" class="headerlink" title="任务拒绝"></a>任务拒绝</h2><p>任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，以保护线程池。</p><h1 id="Worker线程管理"><a href="#Worker线程管理" class="headerlink" title="Worker线程管理"></a>Worker线程管理</h1><p>线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。</p><h2 id="Worker线程"><a href="#Worker线程" class="headerlink" title="Worker线程"></a>Worker线程</h2><p>Worker这个工作线程，实现了Runnable接口，并持有一个线程thread，一个初始化的任务firstTask。thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值是非空的，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230407121025966.png" alt="image-20230407121025966"></p><p>这里的非核心线程创建区别于核心线程。在线程池中，核心线程一般是初始化时创建的，非核心线程是在任务提交到线程池后，如果当前线程池中的线程数还没有达到最大线程数，就会创建新的线程来执行任务。</p><h3 id="生命周期管理的实现"><a href="#生命周期管理的实现" class="headerlink" title="生命周期管理的实现"></a>生命周期管理的实现</h3><p>线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。</p><p>Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。</p><p>lock方法一旦获取了独占锁，表示当前线程正在执行任务中，则不应该中断线程。如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。</p><p>线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230407122748731.png" alt="image-20230407122748731"></p><h2 id="Worker线程增加"><a href="#Worker线程增加" class="headerlink" title="Worker线程增加"></a>Worker线程增加</h2><p>增加线程的执行流程如下所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230407123051268.png" alt="image-20230407123051268" style="zoom:67%;" /><h2 id="Worker线程回收"><a href="#Worker线程回收" class="headerlink" title="Worker线程回收"></a>Worker线程回收</h2><p>线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。</p><p>Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。</p><h2 id="Worker线程执行任务"><a href="#Worker线程执行任务" class="headerlink" title="Worker线程执行任务"></a>Worker线程执行任务</h2><p>Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：</p><p>有一个while循环会不断的从阻塞队列中获取任务，如果线程池正在停止，就要保证当前线程是中断状态。然后开始执行任务，直到从阻塞队列获取任务返回为空时，销毁线程。流程图如下所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230407123642437.png" alt="image-20230407123642437" style="zoom: 80%;" /><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Java并发编程实战》</p><p>美团技术博客</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一个线程池的运行流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230407104446460.png&quot; alt=&quot;image-20230407104</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="线程池" scheme="http://example.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>HotSpot的实现细节</title>
    <link href="http://example.com/2023/04/06/HotSpot%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/"/>
    <id>http://example.com/2023/04/06/HotSpot%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/</id>
    <published>2023-04-06T08:24:48.000Z</published>
    <updated>2023-04-13T10:08:17.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h1><p>目前为止，所有收集器在根节点枚举这一步都必须暂停用户线程。</p><p>目前可达性分析算法耗时最长的查找引用链的过程可以与用户线程一起并发，但根节点枚举需要在一个类似于一致性快照才可以进行，这里一致性是指，整个枚举根节点的过程，子系统就像被冻结在某个点，这个过程中对象间的引用关系是不能发生变化的，否则分析的结果没有意义。</p><p>在暂停用户线程时，虚拟机使用了一组称为OopMap的数据结构来避免遍历所有的<strong>执行上下文</strong>和<strong>全局引用</strong>的位置。一旦类加载完成时，HotSpot就会把对象内每个偏移量上是什么类型的数据计算出来，也会在特定位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得到这些信息，就不用遍历了。</p><h1 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h1><p>上面提到使用OopMap来避免进行遍历所有的引用，但是导致OopMap进行变化的指令特别多，如果为每一条指令都生成OopMap，那么将耗费大量的内存空间。</p><p>实际上，HotSpot并没有为每一条都指令都生成对应的OopMap，而是在特定的位置记录了这些信息，这个特定的位置就是安全点。这也就意味着用户代码并不是在任何时候都可以暂停，然后进行垃圾回收，而是必须到达安全点才可以暂停。</p><p>安全点还需要考虑如何在垃圾收集发生时让所有线程（这里其实不包括执行JNI调用的线程）都跑到最近的安全点，然后停顿下来。这里有两种方案可供选择：<strong>抢先式中断</strong>（Preemptive Suspension）和<strong>主动式中断</strong>（Voluntary Suspension）</p><p>抢先式中断在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。几乎没有虚拟机使用。</p><p>主动式中断的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。</p><h1 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h1><p>上面的安全点保证了正在执行的代码每隔一段时间都会遇到一个可以进行垃圾回收的点，但是对于那些没在运行的程序，就需要另外考虑。比如用户线程处于sleep状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全点去中断挂起自己，这时候就需要引入安全区域。</p><p>安全区域能够保证在一段代码内，引用关系不会发生变化，因此在这段区域内任何地方进行垃圾回收都是安全的。</p><p>当用户线程执行到安全区域时，会标识自己已经进入，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</p><h1 id="记忆收集卡"><a href="#记忆收集卡" class="headerlink" title="记忆收集卡"></a>记忆收集卡</h1><p>记忆集是一种用于记录从<strong>非收集区域指</strong>向<strong>收集区域</strong>的指针集合的抽象数据结构。存储在新生代当中。</p><p>有了记忆集之后，在进行垃圾收集时，收集器只需要通过记忆集判断出某一块非收集区域是否有指向目前正在收集区域的指针就可以了。</p><p>一种最常用的实现记忆集的方式是卡表，卡表的每个记录精确到一块内存区域，该区域内有对象含有的跨代指针。</p><p>一个具体的卡表结构如下：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230313203352373.png" alt="image-20230313203352373" style="zoom:50%;" /><p>字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作“卡页”（Card Page）。</p><p>一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着<strong>跨代指针</strong>，那就将对应卡表的数组元素的值标识为1，称为这个<strong>元素变脏（Dirty）</strong>，没有则标识为0。在垃圾收集发生时，<strong>只要筛选出卡表中变脏的元素</strong>，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。</p><h1 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h1><p>在有其他分代区域中的对象引用了本区域的对象时，卡表需要变脏，变脏的时间点原则上在发生引用类型字段赋值的那一刻。但是如何在赋值的那一刻更新维护卡表呢？如果是解释执行的字节码，好处理一点，因为虚拟机负责每条字节码指令的执行。但是在经过即时编译的代码已经是纯粹的机器指令，虚拟机无法处理。</p><p>在HotSpot虚拟机中是通过<strong>写屏障</strong>维护卡表状态的。写屏障可以看作在虚拟机层面对引用类型字段赋值这个动作的AOP切面，在引用对象赋值时会产生一个环形通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。在赋值前的屏障叫做写前屏障，赋值后的屏障叫做写后屏障。</p><p>卡表在高并发场景下还面临着<strong>伪共享的问题</strong>。伪共享是处理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题。</p><p>为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏。</p><h1 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入理解Java虚拟机》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;根节点枚举&quot;&gt;&lt;a href=&quot;#根节点枚举&quot; class=&quot;headerlink&quot; title=&quot;根节点枚举&quot;&gt;&lt;/a&gt;根节点枚举&lt;/h1&gt;&lt;p&gt;目前为止，所有收集器在根节点枚举这一步都必须暂停用户线程。&lt;/p&gt;
&lt;p&gt;目前可达性分析算法耗时最长的查找引用链的过</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="虚拟机" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="Jvm" scheme="http://example.com/tags/Jvm/"/>
    
    <category term="深入理解Java虚拟机" scheme="http://example.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
</feed>
