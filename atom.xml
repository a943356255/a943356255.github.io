<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便起个名字吧</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-06-24T02:26:27.297Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Guo Junhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>职责链模式（上）</title>
    <link href="http://example.com/2023/06/24/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://example.com/2023/06/24/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2023-06-24T01:39:10.000Z</published>
    <updated>2023-06-24T02:26:27.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="职责链模式的原理和实现"><a href="#职责链模式的原理和实现" class="headerlink" title="职责链模式的原理和实现"></a>职责链模式的原理和实现</h1><p>定义：将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这 些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。</p><p>在职责链模式中，多个处理器依次处理同一个请 求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。</p><p>一个具体的demo如下：</p><p>如果它能处理该请求，就不继续往下传递；如果不能处理，则交由后面的处理器来处理（也 就是调用 successor.handle()）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Handler</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerA</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (!handled &amp;&amp; successor != <span class="literal">null</span>) &#123;</span><br><span class="line">            successor.handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerB</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 这里，是因为他不能处理该请求，就往下传递，并非调用本身</span></span><br><span class="line">        <span class="comment">// 这里是一个链表，如果他自己不能处理，并且不为空，就往下传递</span></span><br><span class="line">        <span class="comment">// 这里省略的代码应该有一步需要往下找另外一个handler</span></span><br><span class="line">        <span class="keyword">if</span> (!handled &amp;&amp; successor != <span class="literal">null</span>) &#123;</span><br><span class="line">            successor.handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerChain</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHandler</span><span class="params">(Handler handler)</span> &#123;</span><br><span class="line">        handler.setSuccessor(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = handler;</span><br><span class="line">            tail = handler;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.setSuccessor(handler);</span><br><span class="line">        tail = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            head.handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HandlerChain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerChain</span>();</span><br><span class="line">        chain.addHandler(<span class="keyword">new</span> <span class="title class_">HandlerA</span>());</span><br><span class="line">        chain.addHandler(<span class="keyword">new</span> <span class="title class_">HandlerB</span>());</span><br><span class="line">        chain.handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述demo存在问题，处理器类的 handle() 函数，不仅包含自己的业务逻 辑，还包含对下一个处理器的调用，也就是代码中的 successor.handle()，如果不熟悉可能会忘记这一步操作，一个优化版本如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Handler</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这种写法，把调用链表下一个节点的操作放在了Handler中，而子类只需要重写doHandle</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> doHandle();</span><br><span class="line">        <span class="keyword">if</span> (successor != <span class="literal">null</span> &amp;&amp; !handled) &#123;</span><br><span class="line">            successor.handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">doHandle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerA</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">doHandle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerB</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">doHandle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// HandlerChain和Application代码不变</span></span><br></pre></td></tr></table></figure><h1 id="职责链模式的应用场景举例"><a href="#职责链模式的应用场景举例" class="headerlink" title="职责链模式的应用场景举例"></a>职责链模式的应用场景举例</h1><p>考虑以下场景：我们要设计一个针对于博客或者评论的敏感词过滤模块，就可以使用该模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SensitiveWordFilter</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">doFilter</span><span class="params">(Content content)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SexyWordFilter</span> <span class="keyword">implements</span> <span class="title class_">SensitiveWordFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doFilter</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">legal</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> legal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// PoliticalWordFilter、AdsWordFilter类代码结构与SexyWordFilter类似</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SensitiveWordFilterChain</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;SensitiveWordFilter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(SensitiveWordFilter filter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.filters.add(filter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return true if content doesn&#x27;t contain sensitive words.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (SensitiveWordFilter filter : filters) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!filter.doFilter(content)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SensitiveWordFilterChain</span> <span class="variable">filterChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SensitiveWordFilterChain</span>();</span><br><span class="line">        filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">AdsWordFilter</span>());</span><br><span class="line">        filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">SexyWordFilter</span>());</span><br><span class="line">        filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">PoliticalWordFilter</span>());</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">legal</span> <span class="operator">=</span> filterChain.filter(<span class="keyword">new</span> <span class="title class_">Content</span>());</span><br><span class="line">        <span class="keyword">if</span> (!legal) &#123;</span><br><span class="line">            <span class="comment">// 不发表</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实不使用职责链，而是直接在一个类中使用if else判断也可以完成该功能，那为什么还要使用呢？</p><p>1、将大块代码逻辑拆分成函数，将大类拆分成小类，是应对代码复杂性的常用方法。应用职责链模式，把各个敏感词过滤函数继续拆分出来，设计成独立的类，进一步简化了 SensitiveWordFilter 类，让 SensitiveWordFilter 类的代码不会过多，过复杂。</p><p>2、如果需要新添加一个过滤方法，我们只需要加一个新的类，实现SensitiveWordFilter接口，并将其添加到SensitiveWordFilterChain中即可，不需要修改太多之前已经存在的代码。如果使用if-else判断的写法，那么就需要添加新的判断。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;职责链模式的原理和实现&quot;&gt;&lt;a href=&quot;#职责链模式的原理和实现&quot; class=&quot;headerlink&quot; title=&quot;职责链模式的原理和实现&quot;&gt;&lt;/a&gt;职责链模式的原理和实现&lt;/h1&gt;&lt;p&gt;定义：将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="http://example.com/2023/06/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://example.com/2023/06/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2023-06-23T10:19:20.000Z</published>
    <updated>2023-06-24T01:46:52.948Z</updated>
    
    <content type="html"><![CDATA[<p>策略模式，最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断，它也可以像模板模式那样，提供框架的扩展点等等。</p><h1 id="策略模式的原理与实现"><a href="#策略模式的原理与实现" class="headerlink" title="策略模式的原理与实现"></a>策略模式的原理与实现</h1><p>定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略 模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。</p><p>工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者，策略模式跟两者类似，也能起到解耦的作用，不过，它解耦的是策略的定义、创建、使用这三部分。</p><h2 id="1-策略的定义"><a href="#1-策略的定义" class="headerlink" title="1. 策略的定义"></a>1. 策略的定义</h2><p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//具体的算法...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//具体的算法...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-策略的创建"><a href="#2-策略的创建" class="headerlink" title="2. 策略的创建"></a>2. 策略的创建</h2><p>因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。为了封装创建逻辑，需要对客户端代码屏蔽创建细节。可以把根据 type 创建策略的逻辑抽离出来，放到工厂类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Strategy&gt; strategies = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        strategies.put(<span class="string">&quot;A&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>());</span><br><span class="line">        strategies.put(<span class="string">&quot;B&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title function_">getStrategy</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span> || type.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;type should not be empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strategies.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果策略类是无状态的，只包含算法实现，可以被共享，就可以使用上面这种方法实现。</p><p>但是如果策略类是有状态的，需要根据业务场景的需要获得不同的对象，那么就需要如下方式创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title function_">getStrategy</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span> || type.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;type should not be empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-策略的使用"><a href="#3-策略的使用" class="headerlink" title="3. 策略的使用"></a>3. 策略的使用</h2><p>策略模式包含一组可选策略，客户端代码一般是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景。</p><p>这里的“运行时动态”指的是，我们事先并不知道会使用哪个策略，而是在程序运行期间， 根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 策略接口：EvictionStrategy</span></span><br><span class="line"><span class="comment">// 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...</span></span><br><span class="line"><span class="comment">// 策略工厂：EvictionStrategyFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, User&gt; cacheData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> EvictionStrategy eviction;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserCache</span><span class="params">(EvictionStrategy eviction)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.eviction = eviction;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行时动态确定，根据配置文件的配置决定使用哪种策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">EvictionStrategy</span> <span class="variable">evictionStrategy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        props.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./config.properties&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;eviction_type&quot;</span>);</span><br><span class="line">        evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type);</span><br><span class="line">        <span class="type">UserCache</span> <span class="variable">userCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserCache</span>(evictionStrategy);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非运行时动态确定，在代码中指定使用哪种策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="type">EvictionStrategy</span> <span class="variable">evictionStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LruEvictionStrategy</span>();</span><br><span class="line">        <span class="type">UserCache</span> <span class="variable">userCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserCache</span>(evictionStrategy);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用策略模式来避免分支"><a href="#使用策略模式来避免分支" class="headerlink" title="使用策略模式来避免分支"></a>使用策略模式来避免分支</h2><p>分支代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">discount</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">discount</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="type">OrderType</span> <span class="variable">type</span> <span class="operator">=</span> order.getType();</span><br><span class="line">        <span class="keyword">if</span> (type.equals(OrderType.NORMAL)) &#123; <span class="comment">// 普通订单</span></span><br><span class="line">            <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.GROUPON)) &#123; <span class="comment">// 团购订单</span></span><br><span class="line">            <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.PROMOTION)) &#123; <span class="comment">// 促销订单</span></span><br><span class="line">            <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> discount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用策略模式代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 策略的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DiscountStrategy</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">calDiscount</span><span class="params">(Order order)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrateg</span></span><br><span class="line"><span class="comment">// 策略的创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscountStrategyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;OrderType, DiscountStrategy&gt; strategies = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        strategies.put(OrderType.NORMAL, <span class="keyword">new</span> <span class="title class_">NormalDiscountStrategy</span>());</span><br><span class="line">        strategies.put(OrderType.GROUPON, <span class="keyword">new</span> <span class="title class_">GrouponDiscountStrategy</span>());</span><br><span class="line">        strategies.put(OrderType.PROMOTION, <span class="keyword">new</span> <span class="title class_">PromotionDiscountStrategy</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DiscountStrategy <span class="title function_">getDiscountStrategy</span><span class="params">(OrderType type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strategies.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 策略的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">discount</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="type">OrderType</span> <span class="variable">type</span> <span class="operator">=</span> order.getType();</span><br><span class="line">        <span class="type">DiscountStrategy</span> <span class="variable">discountStrategy</span> <span class="operator">=</span> DiscountStrategyFactory.getDiscountStrategy();</span><br><span class="line">        <span class="keyword">return</span> discountStrategy.calDiscount(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里通过提前在map冲存储相应的类型，直接从map中获取，而不再用那些if判断。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;策略模式，最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断，它也可以像模板模式那样，提供框架的扩展点等等。&lt;/p&gt;
&lt;h1 id=&quot;策略模式的原理与实现&quot;&gt;&lt;a href=&quot;#策略模式的原理与实现&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>模板方法（下）</title>
    <link href="http://example.com/2023/06/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://example.com/2023/06/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2023-06-22T02:54:49.000Z</published>
    <updated>2023-06-22T04:39:30.001Z</updated>
    
    <content type="html"><![CDATA[<p>回调也可以实现类似于模板模式的作用。</p><h1 id="回调的原理解析"><a href="#回调的原理解析" class="headerlink" title="回调的原理解析"></a>回调的原理解析</h1><p>相对于普通的函数调用来说，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。</p><p>A 类如何将回调函数传递给 B 类呢？不同的编程语言，有不同的实现方法。C 语言可以使 用函数指针，Java 则需要使用包裹了回调函数的类对象，我们简称为回调对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICallback</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodToCallback</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(ICallback callback)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        callback.methodToCallback();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BClass</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BClass</span>();</span><br><span class="line">        b.process(<span class="keyword">new</span> <span class="title class_">ICallback</span>() &#123; <span class="comment">//回调对象</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodToCallback</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Call back me.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从代码实现中，我们可以看出，回调跟模板模 式一样，也具有复用和扩展的功能。除了回调函数之外，BClass 类的 process() 函数中的 逻辑都可以复用。</p><p>如果 ICallback、BClass 类是框架代码，AClass 是使用框架的客户端代码，我们可以通过 ICallback 定制 process() 函数，也就是说，框架因此具有了扩展的能力。</p><p>我们使用了框架的代码逻辑，而且利用回调，在框架的逻辑中插入了我们需要做的修改，因此说具有了扩展能力。</p><p>Spring 提供了很多 Template 类，比如，JdbcTemplate、RedisTemplate、 RestTemplate。尽管都叫作 xxxTemplate，但它们并非基于模板模式来实现的，而是基于回调来实现的，确切地说应该是同步回调。</p><h1 id="模板模式-VS-回调"><a href="#模板模式-VS-回调" class="headerlink" title="模板模式 VS 回调"></a>模板模式 VS 回调</h1><p>从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自 由替换其中的某个步骤，起到代码复用和扩展的目的。而异步回调跟模板模式有较大差别， 更像是观察者模式。</p><p>从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递 给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽 象方法，是一种类之间的关系。</p><p>在代码实现上，回调相对于模板 模式会更加灵活，主要体现在下面几点：</p><ul><li>像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不 再具有继承的能力。</li><li>回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实 现都要定义不同的子类。</li><li>如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到 其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需 要往用到的模板方法中注入回调对象即可。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;回调也可以实现类似于模板模式的作用。&lt;/p&gt;
&lt;h1 id=&quot;回调的原理解析&quot;&gt;&lt;a href=&quot;#回调的原理解析&quot; class=&quot;headerlink&quot; title=&quot;回调的原理解析&quot;&gt;&lt;/a&gt;回调的原理解析&lt;/h1&gt;&lt;p&gt;相对于普通的函数调用来说，回调是一种双向调用关系</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>模板方法（上）</title>
    <link href="http://example.com/2023/06/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://example.com/2023/06/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2023-06-22T02:17:25.000Z</published>
    <updated>2023-06-22T02:51:50.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板模式的原理与实现"><a href="#模板模式的原理与实现" class="headerlink" title="模板模式的原理与实现"></a>模板模式的原理与实现</h1><p>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类 中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些 步骤。</p><p>一个具体的例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        method1();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        method2();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass1</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass2</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">AbstractClass</span> <span class="variable">demo</span> <span class="operator">=</span> ConcreteClass1();</span><br><span class="line">demo.templateMethod();</span><br></pre></td></tr></table></figure><h1 id="模板模式作用一：复用"><a href="#模板模式作用一：复用" class="headerlink" title="模板模式作用一：复用"></a>模板模式作用一：复用</h1><p>模板模式把一个算法中不变的流程抽象到父类的模板方法 templateMethod() 中，将可变的部分 method1()、method2() 留给子类 ContreteClass1 和 ContreteClass2 来实现。 所有的子类都可以复用父类中模板方法定义的流程代码。</p><h1 id="模板模式作用二：扩展"><a href="#模板模式作用二：扩展" class="headerlink" title="模板模式作用二：扩展"></a>模板模式作用二：扩展</h1><p>模板模式的第二大作用的是扩展。这里所说的扩展，并不是指代码的扩展性，而是指框架的 扩展性，有点类似我们之前讲到的控制反转。基于这个作用，模板模式常用在框架的开发中，让框架用户可以在不修改框架源码的情况下，定制化框架的功能。</p><h2 id="1-Java-Servlet"><a href="#1-Java-Servlet" class="headerlink" title="1.Java Servlet"></a>1.Java Servlet</h2><p>在平时开发中，如果我们使用Servlet进行web开发，那么就需要继承 HttpServlet，并且重写其中的 doGet() 或 doPost() 方 法，来分别处理 get 和 post 请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> Expection &#123;</span><br><span class="line">        <span class="built_in">this</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throw</span> Expection &#123;</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;Hello World.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，我们还需要在配置文件 web.xml 中做如下配置。Tomcat、Jetty 等 Servlet 容 器在启动的时候，会自动加载这个配置文件中的 URL 和 Servlet 之间的映射关系。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.xzg.cd.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们在浏览器中输入网址（比如，<a href="http://127.0.0.1:8080/hello">http://127.0.0.1:8080/hello</a> ）的时候，Servlet 容 器会接收到相应的请求，并且根据 URL 和 Servlet 之间的映射关系，找到相应的 Servlet（HelloServlet），然后执行它的 service() 方法。service() 方法定义在父类 HttpServlet 中，它会调用 doGet() 或 doPost() 方法，然后输出数据（“Hello world”）到网页。</p><p>以下是service方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    HttpServletRequest request;</span><br><span class="line">    HttpServletResponse response;</span><br><span class="line">    <span class="keyword">if</span> (!(req <span class="keyword">instanceof</span> HttpServletRequest &amp;&amp;</span><br><span class="line">          res <span class="keyword">instanceof</span> HttpServletResponse)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;non-HTTP request or response&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    request = (HttpServletRequest) req;</span><br><span class="line">    response = (HttpServletResponse) res;</span><br><span class="line">    service(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">    <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// servlet doesn&#x27;t support if-modified-since, no reason</span></span><br><span class="line">            <span class="comment">// to go through further expensive logic</span></span><br><span class="line">            doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ifModifiedSince</span> <span class="operator">=</span> req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">            <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">                maybeSetLastModified(resp, lastModified);</span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">        maybeSetLastModified(resp, lastModified);</span><br><span class="line">        doHead(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">        doPut(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">        doDelete(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">        doOptions(req,resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">        doTrace(req,resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line">        errArgs[<span class="number">0</span>] = method;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以看出，HttpServlet 的 service() 方法就是一个模板方法，它实现 了整个 HTTP 请求的执行流程，doGet()、doPost() 是模板中可以由子类来定制的部分。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模板模式的原理与实现&quot;&gt;&lt;a href=&quot;#模板模式的原理与实现&quot; class=&quot;headerlink&quot; title=&quot;模板模式的原理与实现&quot;&gt;&lt;/a&gt;模板模式的原理与实现&lt;/h1&gt;&lt;p&gt;模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类 中实现。模</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式（下）</title>
    <link href="http://example.com/2023/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://example.com/2023/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2023-06-19T02:27:26.000Z</published>
    <updated>2023-06-19T03:06:04.327Z</updated>
    
    <content type="html"><![CDATA[<p>观察者模式有几种不同的实现方式：同步阻塞、异步非阻塞、进程内、进程间的实现方式。</p><p>同步阻塞是最经典的实现方式，主要是为了代码解耦；异步非阻塞除了能实现代码解耦之 外，还能提高代码的执行效率；进程间的观察者模式解耦更加彻底，一般是基于消息队列来 实现，用来实现不同进程间的被观察者和观察者之间的交互。</p><h1 id="异步非阻塞观察者模式的简易实现"><a href="#异步非阻塞观察者模式的简易实现" class="headerlink" title="异步非阻塞观察者模式的简易实现"></a>异步非阻塞观察者模式的简易实现</h1><p>有两种实现方式：其中一种是：在每个 handleRegSuccess() 函数中创建一个新的线 程执行代码逻辑；另一种是：在 UserController 的 register() 函数中使用线程池来执行每 个观察者的 handleRegSuccess() 函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种实现方式，其他类代码不变，就没有再重复罗列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegPromotionObserver</span> <span class="keyword">implements</span> <span class="title class_">RegObserver</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PromotionService promotionService; <span class="comment">// 依赖注入</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRegSuccess</span><span class="params">(<span class="type">long</span> userId)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种实现方式，其他类代码不变，就没有再重复罗列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService; <span class="comment">// 依赖注入</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;RegObserver&gt; regObservers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Executor executor;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(Executor executor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRegObservers</span><span class="params">(List&lt;RegObserver&gt; observers)</span> &#123;</span><br><span class="line">        regObservers.addAll(observers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">        <span class="comment">//省略输入参数的校验代码</span></span><br><span class="line">        <span class="comment">//省略userService.register()异常的try-catch代码</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">userId</span> <span class="operator">=</span> userService.register(telephone, password);</span><br><span class="line">        <span class="keyword">for</span> (RegObserver observer : regObservers) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    observer.handleRegSuccess(userId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第一种实现方式，频繁地创建和销毁线程比较耗时，并且并发线程数无法控制，创建过多的线程会导致堆栈溢出。</p><p>第二种实现方式，尽管利用了线程池解决了第一种实现方式的问题，但线程池、异步执行逻辑都耦合在了 register() 函数中，增加了这部分业务代码的维护成本。</p><h1 id="EventBus核心"><a href="#EventBus核心" class="headerlink" title="EventBus核心"></a>EventBus核心</h1><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230619110451041.png" alt="image-20230619110451041"></p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230619110502970.png" alt="image-20230619110502970"></p><p>从图中我们可以看出，最关键的一个数据结构是 Observer 注册表，记录了消息类型和可接收消息函数的对应关系。</p><p>当调用 register() 函数注册观察者的时候，EventBus 通过解析 @Subscribe 注解，生成 Observer 注册表。</p><p>当调用 post() 函数发送消息的时候， EventBus 通过注册表找到相应的可接收消息的函数，然后通过 Java 的反射语法来动态地 创建对象、执行函数。</p><p>对于同步阻塞模式，EventBus 在一个线程内依次执行相应的函数。 </p><p>对于异步非阻塞模式，EventBus 通过一个线程池来执行相应的函数。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;观察者模式有几种不同的实现方式：同步阻塞、异步非阻塞、进程内、进程间的实现方式。&lt;/p&gt;
&lt;p&gt;同步阻塞是最经典的实现方式，主要是为了代码解耦；异步非阻塞除了能实现代码解耦之 外，还能提高代码的执行效率；进程间的观察者模式解耦更加彻底，一般是基于消息队列来 实现，用来实现不</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式（上）</title>
    <link href="http://example.com/2023/06/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://example.com/2023/06/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2023-06-17T02:36:09.000Z</published>
    <updated>2023-06-18T04:09:40.450Z</updated>
    
    <content type="html"><![CDATA[<p>观察者模式（Observer Design Pattern）也被称为发布订阅模式，在《设计模式》一书中，它的定义如下：</p><p>在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p><p>一个具体的代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(Message message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Message message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserverOne</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 获取消息通知，执行自己的逻辑...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteObserverOne is notified.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserverTwo</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 获取消息通知，执行自己的逻辑...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteObserverTwo is notified.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcreteSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();</span><br><span class="line">        subject.registerObserver(<span class="keyword">new</span> <span class="title class_">ConcreteObserverOne</span>());</span><br><span class="line">        subject.registerObserver(<span class="keyword">new</span> <span class="title class_">ConcreteObserverTwo</span>());</span><br><span class="line">        subject.notifyObservers(<span class="keyword">new</span> <span class="title class_">Message</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;观察者模式（Observer Design Pattern）也被称为发布订阅模式，在《设计模式》一书中，它的定义如下：&lt;/p&gt;
&lt;p&gt;在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。&lt;/p&gt;
&lt;p&gt;一个具体的代码示例如下：&lt;/p&gt;
</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>享元模式（下）</title>
    <link href="http://example.com/2023/06/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://example.com/2023/06/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2023-06-16T02:52:05.000Z</published>
    <updated>2023-06-16T03:13:35.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="享元模式在-Java-Integer-中的应用"><a href="#享元模式在-Java-Integer-中的应用" class="headerlink" title="享元模式在 Java Integer 中的应用"></a>享元模式在 Java Integer 中的应用</h1><h2 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h2><p>Java中的基本数据类型对应的有包装器类型，他们之前存在着自动装箱和拆箱的过程。</p><p>所谓的自动装箱，就是自动将基本数据类型转换为包装器类型。所谓的自动拆箱，也就是自 动将包装器类型转化为基本数据类型。具体的代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">56</span>; <span class="comment">//自动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; <span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure><p>数值 56 是基本数据类型 int，当赋值给包装器类型（Integer）变量的时候，触发自动装箱 操作，创建一个 Integer 类型的对象，并且赋值给变量 i。其底层相当于执行了下面这条语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">59</span>；底层执行了：<span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">59</span>);</span><br></pre></td></tr></table></figure><p>反过来，当把包装器类型的变量 i，赋值给基本数据类型变量 j 的时候，触发自动拆箱操 作，将 i 中的数据取出，赋值给 j。其底层相当于执行了下面这条语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; 底层执行了：<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i.intValue();</span><br></pre></td></tr></table></figure><h2 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">123</span>, <span class="number">23</span>); <span class="comment">// id=123, age=23</span></span><br></pre></td></tr></table></figure><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230616110300848.png" alt="image-20230616110300848" style="zoom:67%;" /><p>当我们通过“&#x3D;&#x3D;”来判定两个对象是否相等的时候，实际上是在判断两个局部变量存储的 地址是否相同，换句话说，是在判断两个局部变量是否指向相同的对象。</p><h2 id="一个具体的例子"><a href="#一个具体的例子" class="headerlink" title="一个具体的例子"></a>一个具体的例子</h2><p>看下面的代码，它的结果是什么样的？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">56</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">56</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">129</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">129</span>;</span><br><span class="line">System.out.println(i1 == i2);</span><br><span class="line">System.out.println(i3 == i4);</span><br></pre></td></tr></table></figure><p>前 4 行赋值语句都会触发自动装箱操作，也就是会创建 Integer 对象并且赋值给 i1、i2、 i3、i4 这四个变量。i1、i2 尽管存储的数值相同，都是 56，但是指向不同的 Integer 对象，所以通过“&#x3D;&#x3D;”来判定是否相同的时候，会返回 false，同理第二个也是false。这样对吗？</p><p>答案并非是两个 false，而是一个 true，一个 false。</p><p>实际上，这正是因为 Integer 用到了享元模式来复用对象，才 导致了这样的运行结果。当我们通过自动装箱，也就是调用 valueOf() 来创建 Integer 对象的时候，<strong>如果要创建的 Integer 对象的值在 -128 到 127 之间，会从 IntegerCache 类中 直接返回</strong>，否则才调用 new 方法创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 56 处于 -128 和 127 之间，i1 和 i2 会指向相同 的享元对象，所以 i1&#x3D;&#x3D;i2 返回 true。而 129 大于 127，并不会被缓存，每次都会创建一 个全新的对象，也就是说，i3 和 i4 指向不同的 Integer 对象，所以 i3&#x3D;&#x3D;i4 返回 false。</p><p>在平时开发中，优先使用后两种创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>第一种创建方式并不会使用到 IntegerCache，而后面两种创建方法可以利用 IntegerCache 缓存，返回共享的对象，以达到节省内存的目的。</p><h1 id="享元模式在-Java-String-中的应用"><a href="#享元模式在-Java-String-中的应用" class="headerlink" title="享元模式在 Java String 中的应用"></a>享元模式在 Java String 中的应用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line">System.out.println(s1 == s3);</span><br></pre></td></tr></table></figure><p>上面代码的运行结果是：一个 true，一个 false。String 类 利用享元模式来复用相同的字符串常量，JVM 会专门开辟 一块存储区来存储字符串常量，这块存储区叫作“字符串常量池”。</p><p>不过，String 类的享元模式的设计，跟 Integer 类稍微有些不同。Integer 类中要共享的对 象，是在类加载的时候，就集中一次性创建好的。但是，对于字符串来说，我们没法事先知 道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的 时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需 要再重新创建了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;享元模式在-Java-Integer-中的应用&quot;&gt;&lt;a href=&quot;#享元模式在-Java-Integer-中的应用&quot; class=&quot;headerlink&quot; title=&quot;享元模式在 Java Integer 中的应用&quot;&gt;&lt;/a&gt;享元模式在 Java Intege</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>享元模式（上）</title>
    <link href="http://example.com/2023/06/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-16T02:30:33.000Z</published>
    <updated>2023-06-16T02:51:49.211Z</updated>
    
    <content type="html"><![CDATA[<p>享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。</p><p>具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我 们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这 样可以减少内存中对象的数量，起到节省内存的目的。</p><h1 id="享元模式的两个应用场景"><a href="#享元模式的两个应用场景" class="headerlink" title="享元模式的两个应用场景"></a>享元模式的两个应用场景</h1><p>1、在象棋游戏中，每一句的棋子都是一样的，当有多个玩家时，不同玩家之间只是象棋的位置不同，那么我们就可以将一些基础的属性抽出来，供多个人使用，节省了内存。</p><p>2、文本编辑器中，每一个字体都可以单独的设置格式。对于字体格式，我们可以将它设计成享元，让不同的文字共享使用。</p><h1 id="享元模式-vs-单例、缓存、对象池"><a href="#享元模式-vs-单例、缓存、对象池" class="headerlink" title="享元模式 vs 单例、缓存、对象池"></a>享元模式 vs 单例、缓存、对象池</h1><h2 id="享元模式跟单例的区别"><a href="#享元模式跟单例的区别" class="headerlink" title="享元模式跟单例的区别"></a>享元模式跟单例的区别</h2><p>在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每 个对象被多处代码引用共享。实际上，享元模式有点类似于之前讲到的单例的变体：多例</p><p>应用享元模式是为了对象复用，节省内存，而应用单例模式是为 了限制对象的个数。</p><h2 id="享元模式跟缓存的区别"><a href="#享元模式跟缓存的区别" class="headerlink" title="享元模式跟缓存的区别"></a>享元模式跟缓存的区别</h2><p>在享元模式的实现中，我们通过工厂类来“缓存”已经创建好的对象。这里的“缓存”实际 上是“存储”的意思，跟我们平时所说的“数据库缓存”“CPU 缓存”“MemCache 缓 存”是两回事。我们平时所讲的缓存，主要是为了提高访问效率，而非复用。</p><h2 id="享元模式跟对象池的区别"><a href="#享元模式跟对象池的区别" class="headerlink" title="享元模式跟对象池的区别"></a>享元模式跟对象池的区别</h2><p>为了避免频繁地进行对象创 建和释放导致内存碎片，我们可以预先申请一片连续的内存空间，也就是这里说的对象池。每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放 回到对象池中以供后续复用，而非直接释放掉。</p><p><strong>池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间（比如从数据库池中 取一个连接，不需要重新创建）</strong>。在任意时刻，每一个对象、连接、线程，并不会被多处使 用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。</p><p>享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享 的，<strong>主要目的是节省空间。</strong></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。&lt;/p&gt;
&lt;p&gt;具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我 们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这 样可以减少内存中对象的数量，起</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="http://example.com/2023/06/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-14T03:35:11.000Z</published>
    <updated>2023-06-14T04:36:14.396Z</updated>
    
    <content type="html"><![CDATA[<p>适配器模式，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类适配器: 基于继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fb</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptor</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.fa();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...重新实现f2()...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象适配器：基于组合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fa</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fb</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptor</span> <span class="keyword">implements</span> <span class="title class_">ITarget</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adaptor</span><span class="params">(Adaptee adaptee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">        adaptee.fa(); <span class="comment">//委托给Adaptee</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...重新实现f2()...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fc</span><span class="params">()</span> &#123;</span><br><span class="line">        adaptee.fc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 Adaptee 接口并不多，那两种实现方式都可以。</p><p>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推 荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方 式，Adaptor 的代码量要少一些。 </p><p>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们 推荐使用对象适配器，因为组合结构相对于继承更加灵活。</p><h1 id="适配器模式应用场景"><a href="#适配器模式应用场景" class="headerlink" title="适配器模式应用场景"></a>适配器模式应用场景</h1><h2 id="1、封装有缺陷的接口设计"><a href="#1、封装有缺陷的接口设计" class="headerlink" title="1、封装有缺陷的接口设计"></a>1、封装有缺陷的接口设计</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;适配器模式，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>装饰器模式</title>
    <link href="http://example.com/2023/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-13T02:33:13.000Z</published>
    <updated>2023-06-13T03:57:36.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="装饰器模式理论"><a href="#装饰器模式理论" class="headerlink" title="装饰器模式理论"></a>装饰器模式理论</h1><p>装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。</p><p>1、装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。</p><p>比如下面这种，他就是对DataInputStream的一种增强，装进了一个FileInputStream和BufferedInputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/user/wangzheng/test.txt&quot;</span>);</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(in);</span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">din</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(bin);</span><br><span class="line"><span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> din.readInt();</span><br></pre></td></tr></table></figure><p>2、装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重 要特点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代理模式的代码结构(下面的接口也可以替换成抽象类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> impelements IA &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类，在原先的类A的f操作上添加一些其他的功能（不改变原先的A）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AProxy</span> impements IA &#123;</span><br><span class="line">    <span class="keyword">private</span> IA a;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AProxy</span><span class="params">(IA a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 新添加的代理逻辑</span></span><br><span class="line">        a.f();</span><br><span class="line">        <span class="comment">// 新添加的代理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器模式的代码结构(下面的接口也可以替换成抽象类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IA</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> impelements IA &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ADecorator</span> impements IA &#123;</span><br><span class="line">    <span class="keyword">private</span> IA a;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ADecorator</span><span class="params">(IA a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 功能增强代码</span></span><br><span class="line">        a.f();</span><br><span class="line">        <span class="comment">// 功能增强代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;装饰器模式理论&quot;&gt;&lt;a href=&quot;#装饰器模式理论&quot; class=&quot;headerlink&quot; title=&quot;装饰器模式理论&quot;&gt;&lt;/a&gt;装饰器模式理论&lt;/h1&gt;&lt;p&gt;装饰器模式相对于简单的组合关系，还有两个比较特殊的地方。&lt;/p&gt;
&lt;p&gt;1、装饰器类和原始类继承同样</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="http://example.com/2023/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-12T08:13:14.000Z</published>
    <updated>2023-06-12T11:31:05.196Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式在不改变原始类 （或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。</p><p>为了将框架代码和业务代码解耦，代理模式就派上用场了。代理类 UserControllerProxy 和原始类 UserController 实现相同的接口 IUserController。UserController 类只负责业 务功能。代理类 UserControllerProxy 负责在业务代码执行前后附加其他逻辑代码，并通 过委托的方式调用原始类来执行业务代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserController</span> &#123;</span><br><span class="line">    UserVo <span class="title function_">login</span><span class="params">(String telephone, String password)</span>;</span><br><span class="line">    UserVo <span class="title function_">register</span><span class="params">(String telephone, String password)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里只写业务逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> <span class="keyword">implements</span> <span class="title class_">IUserController</span> &#123;</span><br><span class="line">    <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserVo <span class="title function_">login</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">        <span class="comment">//...省略login逻辑...</span></span><br><span class="line">        <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserVo <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">        <span class="comment">//...省略register逻辑...</span></span><br><span class="line">        <span class="comment">//...返回UserVo数据...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理类使用UserController，然后添加一些其他的逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserControllerProxy</span> <span class="keyword">implements</span> <span class="title class_">IUserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line">    <span class="keyword">private</span> UserController userController;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserControllerProxy</span><span class="params">(UserController userController)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userController = userController;</span><br><span class="line">        <span class="built_in">this</span>.metricsCollector = <span class="keyword">new</span> <span class="title class_">MetricsCollector</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserVo <span class="title function_">login</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 委托</span></span><br><span class="line">        <span class="type">UserVo</span> <span class="variable">userVo</span> <span class="operator">=</span> userController.login(telephone, password);</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">        <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;login&quot;</span>, responseTime, startTimes);</span><br><span class="line">        metricsCollector.recordRequest(requestInfo);</span><br><span class="line">        <span class="keyword">return</span> userVo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserVo <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">UserVo</span> <span class="variable">userVo</span> <span class="operator">=</span> userController.register(telephone, password);</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">        <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;register&quot;</span>, responseTime, startTimes);</span><br><span class="line">        metricsCollector.recordRequest(requestInfo);</span><br><span class="line">        <span class="keyword">return</span> userVo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//UserControllerProxy使用举例</span></span><br><span class="line"><span class="comment">//因为原始类和代理类实现相同的接口，是基于接口而非实现编程</span></span><br><span class="line"><span class="comment">//将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码</span></span><br><span class="line"><span class="type">IUserController</span> <span class="variable">userController</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserControllerProxy</span>(<span class="keyword">new</span> <span class="title class_">UserController</span>())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是上面这种需要原始类是一个接口，如果原始类并不是我们开发的，比如说原始类是框架中的一个类，改怎么办？</p><p>对于这种外部类的扩展，我们一般都是采用继承的方式。我们让代理类继承 原始类，然后扩展附加功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserControllerProxy</span> <span class="keyword">extends</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserControllerProxy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.metricsCollector = <span class="keyword">new</span> <span class="title class_">MetricsCollector</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> UserVo <span class="title function_">login</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">UserVo</span> <span class="variable">userVo</span> <span class="operator">=</span> <span class="built_in">super</span>.login(telephone, password);</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">        <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;login&quot;</span>, responseTime, startTimes);</span><br><span class="line">        metricsCollector.recordRequest(requestInfo);</span><br><span class="line">        <span class="keyword">return</span> userVo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> UserVo <span class="title function_">register</span><span class="params">(String telephone, String password)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">UserVo</span> <span class="variable">userVo</span> <span class="operator">=</span> <span class="built_in">super</span>.register(telephone, password);</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">        <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(<span class="string">&quot;register&quot;</span>, responseTime, startTimes);</span><br><span class="line">        metricsCollector.recordRequest(requestInfo);</span><br><span class="line">        <span class="keyword">return</span> userVo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//UserControllerProxy使用举例</span></span><br><span class="line"><span class="type">UserController</span> <span class="variable">userController</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserControllerProxy</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="动态代理的原理解析"><a href="#动态代理的原理解析" class="headerlink" title="动态代理的原理解析"></a>动态代理的原理解析</h1><p>上面的写法，每多一个代理类，就需要重新创建一个新的类，这样会导致比较繁琐。</p><p>我们可以使用动态代理，就是不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MetricsCollectorProxy</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MetricsCollectorProxy</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.metricsCollector = <span class="keyword">new</span> <span class="title class_">MetricsCollector</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">createProxy</span><span class="params">(Object proxiedObject)</span> &#123;</span><br><span class="line">    Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();</span><br><span class="line">    <span class="type">DynamicProxyHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DynamicProxyHandler</span>(proxiedObject);</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object proxiedObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DynamicProxyHandler</span><span class="params">(Object proxiedObject)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.proxiedObject = proxiedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(proxiedObject, args);</span><br><span class="line">      <span class="type">long</span> <span class="variable">endTimeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      <span class="type">long</span> <span class="variable">responseTime</span> <span class="operator">=</span> endTimeStamp - startTimestamp;</span><br><span class="line">      <span class="type">String</span> <span class="variable">apiName</span> <span class="operator">=</span> proxiedObject.getClass().getName() + <span class="string">&quot;:&quot;</span> + method.getName();</span><br><span class="line">      <span class="type">RequestInfo</span> <span class="variable">requestInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestInfo</span>(apiName, responseTime, startTimestamp);</span><br><span class="line">      metricsCollector.recordRequest(requestInfo);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MetricsCollectorProxy使用举例</span></span><br><span class="line"><span class="type">MetricsCollectorProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MetricsCollectorProxy</span>();</span><br><span class="line"><span class="type">IUserController</span> <span class="variable">userController</span> <span class="operator">=</span> (IUserController) proxy.createProxy(<span class="keyword">new</span> <span class="title class_">UserController</span>());</span><br></pre></td></tr></table></figure><p>Spring AOP 底层的实现原理就是基于动态代理。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h2 id="1-业务系统的非功能性需求开发"><a href="#1-业务系统的非功能性需求开发" class="headerlink" title="1. 业务系统的非功能性需求开发"></a>1. 业务系统的非功能性需求开发</h2><p>在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类中统一处理。</p><h2 id="2-代理模式在-RPC、缓存中的应用"><a href="#2-代理模式在-RPC、缓存中的应用" class="headerlink" title="2. 代理模式在 RPC、缓存中的应用"></a>2. 代理模式在 RPC、缓存中的应用</h2><p>实际上，RPC 框架也可以看作一种代理模式，GoF 的《设计模式》一书中把它称作远程代理。通过远程代理，将网络通信、数据编解码等细节隐藏起来。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;代理模式在不改变原始类 （或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。&lt;/p&gt;
&lt;p&gt;为了将框架代码和业务代码解耦，代理模式就派上用场了。代理类 UserControllerProxy 和原始类 UserController 实现相同的接口 IUserCo</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="http://example.com/2023/06/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-10T03:24:23.000Z</published>
    <updated>2023-06-14T03:39:09.714Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型模式的原理与应用"><a href="#原型模式的原理与应用" class="headerlink" title="原型模式的原理与应用"></a>原型模式的原理与应用</h1><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同）， 在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新 对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式 （Prototype Design Pattern），简称原型模式。</p><h2 id="什么是对象成本创建比较大"><a href="#什么是对象成本创建比较大" class="headerlink" title="什么是对象成本创建比较大"></a>什么是对象成本创建比较大</h2><p>如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需 要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利 用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执 行这些耗时的操作。</p><h1 id="原型模式的实现方式：深拷贝和浅拷贝"><a href="#原型模式的实现方式：深拷贝和浅拷贝" class="headerlink" title="原型模式的实现方式：深拷贝和浅拷贝"></a>原型模式的实现方式：深拷贝和浅拷贝</h1><p>散列表索引中，每个结点存储的 key 是搜索关 键词，value 是 SearchWord 对象的内存地址。SearchWord 对象本身存储在散列表之外 的内存空间中。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230612154147518.png" alt="image-20230612154147518" style="zoom:67%;" /><p>浅拷贝和深拷贝的区别在于，<strong>浅拷贝只会复制图中的索引（散列表），不会复制数据 （SearchWord 对象）本身</strong>。相反，<strong>深拷贝不仅仅会复制索引，还会复制数据本身</strong>。浅拷 贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据 （SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230612154246807.png" alt="image-20230612154246807"></p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230612154256726.png" alt="image-20230612154256726"></p><p>在 Java 语言中，Object 类的 clone() 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对 象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存 地址，不会递归地拷贝引用对象本身。</p><h1 id="两个深拷贝demo"><a href="#两个深拷贝demo" class="headerlink" title="两个深拷贝demo"></a>两个深拷贝demo</h1><p>递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对 象只包含基本数据类型数据，没有引用对象为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastUpdateTime</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Deep copy</span></span><br><span class="line">        HashMap&lt;String, SearchWord&gt; newKeywords = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) &#123;</span><br><span class="line">            <span class="type">SearchWord</span> <span class="variable">searchWord</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            <span class="type">SearchWord</span> <span class="variable">newSearchWord</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchWord</span>(</span><br><span class="line">                searchWord.getKeyword(), searchWord.getCount(), searchWord.getLast());</span><br><span class="line">            newKeywords.put(e.getKey(), newSearchWord);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中</span></span><br><span class="line">        List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class="line">        <span class="type">long</span> <span class="variable">maxNewUpdatedTime</span> <span class="operator">=</span> lastUpdateTime;</span><br><span class="line">        <span class="keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) &#123;</span><br><span class="line">            <span class="keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;</span><br><span class="line">                maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) &#123;</span><br><span class="line">                <span class="type">SearchWord</span> <span class="variable">oldSearchWord</span> <span class="operator">=</span> newKeywords.get(searchWord.getKeyword());</span><br><span class="line">                oldSearchWord.setCount(searchWord.getCount());</span><br><span class="line">                oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lastUpdateTime = maxNewUpdatedTime;</span><br><span class="line">        currentKeywords = newKeywords;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> List&lt;SearchWord&gt; <span class="title function_">getSearchWords</span><span class="params">(<span class="type">long</span> lastUpdateTime)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 从数据库中取出更新时间&gt;lastUpdateTime的数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>demo2先将对象序列化，然后再反序列化成新的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">deepCopy</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">bo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bo);</span><br><span class="line">    oo.writeObject(object);</span><br><span class="line">    <span class="type">ByteArrayInputStream</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bo.toByteArray());</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">oi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bi);</span><br><span class="line">    <span class="keyword">return</span> oi.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原型模式的原理与应用&quot;&gt;&lt;a href=&quot;#原型模式的原理与应用&quot; class=&quot;headerlink&quot; title=&quot;原型模式的原理与应用&quot;&gt;&lt;/a&gt;原型模式的原理与应用&lt;/h1&gt;&lt;p&gt;如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式（下）</title>
    <link href="http://example.com/2023/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://example.com/2023/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2023-06-08T03:17:07.000Z</published>
    <updated>2023-06-08T03:43:59.833Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要涉及的内容是依赖注入框架，或者叫依赖注入容器，简称DI容器。</p><h1 id="工厂模式和-DI-容器的区别"><a href="#工厂模式和-DI-容器的区别" class="headerlink" title="工厂模式和 DI 容器的区别"></a>工厂模式和 DI 容器的区别</h1><p>DI 容器底层最基本的设计思路就是<strong>基于工厂模式</strong>的。DI 容器相当于一个大的工厂 类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪 些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。</p><p>一个工厂类只负责某个对象或者某一组相关类的创建，而DI容器负责的是整个应用中所有类对象的创建。</p><h1 id="DI-容器的核心功能"><a href="#DI-容器的核心功能" class="headerlink" title="DI 容器的核心功能"></a>DI 容器的核心功能</h1><p>一般有三个：配置解析、对象创建和对象生命周期管理。</p><h2 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h2><p>工厂类要创建哪个对象都是写死的，属于事先定义好的，但是DI容器并不知道应用会创建哪个对象，与不可能全部写死。</p><p>我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对 应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象。</p><p>DI容器通过解析这些配置文件，来得知具体创建哪些对象。</p><h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，我们只需要将所有类对象的创建都放到 一个工厂类中完成就可以了，比如 BeansFactory。</p><p>而通过反射，我们可以保证BeansFactory中的代码并不会根据创建对象的增加而增多，不管是创建一个对象还是十个对象， BeansFactory 工厂类代码都是一样的。</p><h2 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文章主要涉及的内容是依赖注入框架，或者叫依赖注入容器，简称DI容器。&lt;/p&gt;
&lt;h1 id=&quot;工厂模式和-DI-容器的区别&quot;&gt;&lt;a href=&quot;#工厂模式和-DI-容器的区别&quot; class=&quot;headerlink&quot; title=&quot;工厂模式和 DI 容器的区别&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式（上）</title>
    <link href="http://example.com/2023/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://example.com/2023/06/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2023-06-08T01:35:20.000Z</published>
    <updated>2023-06-08T02:45:24.333Z</updated>
    
    <content type="html"><![CDATA[<p>一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。其中抽象工厂是最复杂得一个，在本篇文章中，之介绍简单工厂和抽象工厂。</p><h1 id="简单工厂（Simple-Factory）"><a href="#简单工厂（Simple-Factory）" class="headerlink" title="简单工厂（Simple Factory）"></a>简单工厂（Simple Factory）</h1><p>如下代码，我们根据配置文件的后缀（json、xml、yaml、properties），选择不 同的解析器（JsonRuleConfigParser、XmlRuleConfigParser……），将存储在文件中的 配置解析成内存对象 RuleConfig。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigSource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> RuleConfig <span class="title function_">load</span><span class="params">(String ruleConfigFilePath)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ruleConfigFileExtension</span> <span class="operator">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class="line">        <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;json&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;xml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParser</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;yaml&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParser</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;properties&quot;</span>.equalsIgnoreCase(ruleConfigFileExtension)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParser</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidRuleConfigException</span>(</span><br><span class="line">                <span class="string">&quot;Rule config file format is not supported: &quot;</span> + ruleConfigFilePath)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">configText</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">        <span class="type">RuleConfig</span> <span class="variable">ruleConfig</span> <span class="operator">=</span> parser.parse(configText);</span><br><span class="line">        <span class="keyword">return</span> ruleConfig;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getFileExtension</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂模式的第一种实现"><a href="#简单工厂模式的第一种实现" class="headerlink" title="简单工厂模式的第一种实现"></a>简单工厂模式的第一种实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigSource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> RuleConfig <span class="title function_">load</span><span class="params">(String ruleConfigFilePath)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ruleConfigFileExtension</span> <span class="operator">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class="line">        <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> RuleConfigParserFactory.createParser(ruleConfigFileExtension);</span><br><span class="line">        <span class="keyword">if</span> (parser == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidRuleConfigException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">configText</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">        <span class="type">RuleConfig</span> <span class="variable">ruleConfig</span> <span class="operator">=</span> parser.parse(configText);</span><br><span class="line">        <span class="keyword">return</span> ruleConfig;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getFileExtension</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体的工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigParserFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">(String configFormat)</span> &#123;</span><br><span class="line">        <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;json&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;xml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParser</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;yaml&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParser</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;properties&quot;</span>.equalsIgnoreCase(configFormat)) &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParser</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单工厂模式的第二种实现"><a href="#简单工厂模式的第二种实现" class="headerlink" title="简单工厂模式的第二种实现"></a>简单工厂模式的第二种实现</h2><p>第一种实现下，我们每次调用 RuleConfigParserFactory 的 createParser() 的时 候，都要创建一个新的 parser。</p><p>如果 parser 可以复用，为了节省内存和对象创建 的时间，我们可以将 parser 事先创建好缓存起来。当调用 createParser() 函数的时候，我 们从缓存中取出 parser 对象直接使用，也就是下面这种实现。</p><p>这种实现是为了对象的复用，也就是说单例模式和简单工厂结合起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigParserFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, RuleConfigParser&gt; cachedParsers = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        cachedParsers.put(<span class="string">&quot;json&quot;</span>, <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>());</span><br><span class="line">        cachedParsers.put(<span class="string">&quot;xml&quot;</span>, <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParser</span>());</span><br><span class="line">        cachedParsers.put(<span class="string">&quot;yaml&quot;</span>, <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParser</span>());</span><br><span class="line">        cachedParsers.put(<span class="string">&quot;properties&quot;</span>, <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParser</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">(String configFormat)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (configFormat == <span class="literal">null</span> || configFormat.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//返回null还是IllegalArgumentException全凭你自己说了算</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> cachedParsers.get(configFormat.toLowerCase());</span><br><span class="line">        <span class="keyword">return</span> parser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h1><p>上面的if分支还不算太多，可以接收。但是如果我们非要把if分支去了，就可以利用多态，按照下面这种方法重构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IRuleConfigParserFactory</span> &#123;</span><br><span class="line">    IRuleConfigParser <span class="title function_">createParser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IRuleConfigParserFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XmlRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IRuleConfigParserFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YamlRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IRuleConfigParserFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title class_">IRuleConfigParserFact</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IRuleConfigParser <span class="title function_">createParser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParser</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是工厂方法模式的典型代码实现。这样当我们新增一种 parser 的时候，只需 要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，工厂方法模 式比起简单工厂模式更加符合开闭原则。</p><p>但这种写法并没有解决问题，反到让设计更加复杂。</p><p>解决办法：我们可以为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。</p><p>其中，RuleConfigParserFactoryMap 类是创建工厂对象的工厂类，getParserFactory() 返回的是缓存好的单例工厂对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigSource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> RuleConfig <span class="title function_">load</span><span class="params">(String ruleConfigFilePath)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ruleConfigFileExtension</span> <span class="operator">=</span> getFileExtension(ruleConfigFilePath);</span><br><span class="line"></span><br><span class="line">        <span class="type">IRuleConfigParserFactory</span> <span class="variable">parserFactory</span> <span class="operator">=</span> RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);</span><br><span class="line">        <span class="keyword">if</span> (parserFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidRuleConfigException</span>(ruleConfigFilePath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">IRuleConfigParser</span> <span class="variable">parser</span> <span class="operator">=</span> parserFactory.createParser();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">configText</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//从ruleConfigFilePath文件中读取配置文本到configText中</span></span><br><span class="line">        <span class="type">RuleConfig</span> <span class="variable">ruleConfig</span> <span class="operator">=</span> parser.parse(configText);</span><br><span class="line">        <span class="keyword">return</span> ruleConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getFileExtension</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="comment">//...解析文件名获取扩展名，比如rule.json，返回json</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为工厂类只包含方法，不包含成员变量，完全可以复用，</span></span><br><span class="line"><span class="comment">//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuleConfigParserFactoryMap</span> &#123; <span class="comment">//工厂的工厂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        cachedFactories.put(<span class="string">&quot;json&quot;</span>, <span class="keyword">new</span> <span class="title class_">JsonRuleConfigParserFactory</span>());</span><br><span class="line">        cachedFactories.put(<span class="string">&quot;xml&quot;</span>, <span class="keyword">new</span> <span class="title class_">XmlRuleConfigParserFactory</span>());</span><br><span class="line">        cachedFactories.put(<span class="string">&quot;yaml&quot;</span>, <span class="keyword">new</span> <span class="title class_">YamlRuleConfigParserFactory</span>());</span><br><span class="line">        cachedFactories.put(<span class="string">&quot;properties&quot;</span>, <span class="keyword">new</span> <span class="title class_">PropertiesRuleConfigParserFactory</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParserFactory <span class="title function_">getParserFactory</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span> || type.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">IRuleConfigParserFactory</span> <span class="variable">parserFactory</span> <span class="operator">=</span> cachedFactories.get(type.toLowerCase());</span><br><span class="line">        <span class="keyword">return</span> parserFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要添加新的规则配置解析器的时候，我们只需要创建新的 parser 类和 parser factory 类，并且在 RuleConfigParserFactoryMap 类中，将新的 parser factory 对象添加到 cachedFactories 中即可。</p><h1 id="怎么选择使用哪个"><a href="#怎么选择使用哪个" class="headerlink" title="怎么选择使用哪个"></a>怎么选择使用哪个</h1><p>当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，推荐使用<strong>工厂方法模式</strong>，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。而使用简单工厂模式，将所有的创建逻辑都放到一个工厂类中，会导致这个工厂类变得很复杂。</p><p>除此之外，在某些场景下，如果对象不可复用，那工厂类每次都要返回不同的对象。如果我们使用简单工厂模式来实现，就只能选择第一种包含 if 分支逻辑的实现方式。如果我们还想避免烦人的 if-else 分支逻辑，这个时候，我们就推荐使用工厂方法模式。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一般情况下，工厂模式分为三种更加细分的类型：简单工厂、工厂方法和抽象工厂。其中抽象工厂是最复杂得一个，在本篇文章中，之介绍简单工厂和抽象工厂。&lt;/p&gt;
&lt;h1 id=&quot;简单工厂（Simple-Factory）&quot;&gt;&lt;a href=&quot;#简单工厂（Simple-Factory）&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式（下）</title>
    <link href="http://example.com/2023/06/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://example.com/2023/06/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2023-06-07T07:21:16.000Z</published>
    <updated>2023-06-08T01:36:36.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何理解单例模式中的唯一性"><a href="#如何理解单例模式中的唯一性" class="headerlink" title="如何理解单例模式中的唯一性"></a>如何理解单例模式中的唯一性</h1><p>这个唯一性指的是进程内只允许创建一个对象。</p><h1 id="如何实现线程唯一的单例"><a href="#如何实现线程唯一的单例" class="headerlink" title="如何实现线程唯一的单例"></a>如何实现线程唯一的单例</h1><p>“进程唯一”指的是进程内唯一，进程间不唯一。“线程唯一”指的是线程内唯 一，线程间可以不唯一。</p><p>我们通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以 做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本 身提供了 ThreadLocal 工具类，可以更加轻松地实现线程唯一单例。不过，ThreadLocal 底层实现原理也是基于下面代码中所示的 HashMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Long, IdGenerator&gt; instances</span><br><span class="line">        = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">currentThreadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        instances.putIfAbsent(currentThreadId, <span class="keyword">new</span> <span class="title class_">IdGenerator</span>());</span><br><span class="line">        <span class="keyword">return</span> instances.get(currentThreadId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何实现集群环境下的单例"><a href="#如何实现集群环境下的单例" class="headerlink" title="如何实现集群环境下的单例"></a>如何实现集群环境下的单例</h1><p>集群相当于多个进程构成的 一个集合，“集群唯一”就相当于是进程内唯一、进程间也唯一。也就是说，不同的进程间 共享同一个对象，不能创建同一个类的多个对象。</p><p>具体来说，我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在 使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对 象，然后再使用，使用完成之后还需要再存储回外部共享存储区。</p><p>为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对 象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内 存中删除，并且释放对对象的加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IdGenerator instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SharedObjectStorage</span> <span class="variable">storage</span> <span class="operator">=</span> FileSharedObjectStorage();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DistributedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DistributedLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            instance = storage.load(IdGenerator.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> synchroinzed <span class="keyword">void</span> <span class="title function_">freeInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        storage.save(<span class="built_in">this</span>, IdGeneator.class);</span><br><span class="line">        instance = <span class="literal">null</span>; <span class="comment">//释放对象</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// IdGenerator使用举例</span></span><br><span class="line"><span class="type">IdGenerator</span> <span class="variable">idGeneator</span> <span class="operator">=</span> IdGenerator.getInstance();</span><br><span class="line"><span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> idGenerator.getId();</span><br><span class="line">IdGenerator.freeInstance();</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何理解单例模式中的唯一性&quot;&gt;&lt;a href=&quot;#如何理解单例模式中的唯一性&quot; class=&quot;headerlink&quot; title=&quot;如何理解单例模式中的唯一性&quot;&gt;&lt;/a&gt;如何理解单例模式中的唯一性&lt;/h1&gt;&lt;p&gt;这个唯一性指的是进程内只允许创建一个对象。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式（中）</title>
    <link href="http://example.com/2023/06/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
    <id>http://example.com/2023/06/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%AD%EF%BC%89/</id>
    <published>2023-06-07T06:40:38.000Z</published>
    <updated>2023-06-08T01:36:06.859Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例存在的问题"><a href="#单例存在的问题" class="headerlink" title="单例存在的问题"></a>单例存在的问题</h1><p>我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息 类、连接池类、ID 生成器类，但 是，这种使用方法有点类似硬编码（hard code），会带来诸多问题。</p><h2 id="1、对-OOP-特性的支持不友好"><a href="#1、对-OOP-特性的支持不友好" class="headerlink" title="1、对 OOP 特性的支持不友好"></a>1、对 OOP 特性的支持不友好</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(...)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> IdGenerator.getInstance().getId();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(...)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> IdGenerator.getInstance().getId();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种涉及违背了基于接口而非实现的设计原则，如果未来某一天，我们希望针对不同的业务采用不同的 ID 生成算法。 比如，订单 ID 和用户 ID 采用不同的 ID 生成器来生成。为了应对这个需求变化，我们需要修改所有用到 IdGenerator 类的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(...)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> IdGenerator.getInstance().getId();</span><br><span class="line">        <span class="comment">// 需要将上面一行代码，替换为下面一行代码</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> OrderIdGenerator.getIntance().getId();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(...)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> IdGenerator.getInstance().getId();</span><br><span class="line">        <span class="comment">// 需要将上面一行代码，替换为下面一行代码</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> UserIdGenerator.getIntance().getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，单例对继承、多态特性的支持也不友好。</p><h2 id="2、单例会隐藏类之间的依赖关系"><a href="#2、单例会隐藏类之间的依赖关系" class="headerlink" title="2、单例会隐藏类之间的依赖关系"></a>2、单例会隐藏类之间的依赖关系</h2><p>通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能 很容易识别出来。但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用 就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。</p><h2 id="3、单例对代码的扩展性不友好"><a href="#3、单例对代码的扩展性不友好" class="headerlink" title="3、单例对代码的扩展性不友好"></a>3、单例对代码的扩展性不友好</h2><p>比如，在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据 库连接资源的消耗。所以，我们把数据库连接池类设计成了单例类。</p><p>但之后我们发现，系统 中有些 SQL 语句运行得非常慢。这些 SQL 语句在执行的时候，长时间占用数据库连接资源，导致其他 SQL 请求无法响应。为了解决这个问题，我们希望将慢 SQL 与其他 SQL 隔 离开来执行。</p><p>为了实现这样的目的，我们可以在系统中创建两个数据库连接池，慢 SQL 独 享一个数据库连接池，其他 SQL 独享另外一个数据库连接池，这样就能避免慢 SQL 影响到 其他 SQL 的执行。</p><h2 id="4、单例对代码的可测试性不友好"><a href="#4、单例对代码的可测试性不友好" class="headerlink" title="4、单例对代码的可测试性不友好"></a>4、单例对代码的可测试性不友好</h2><p>如果单例类依赖比较重的外部资源，比如 DB， 我们在写单元测试的时候，希望能通过 mock 的方式将它替换掉。而单例类这种硬编码式 的使用方式，导致无法实现 mock 替换。</p><p>而且单例往往可以理解为一个全局唯一的变量，在编写单元测试时，需要注意不同测试用例之间修改了单例的值，对测试结果的影响。</p><h2 id="5、单例不支持有参数的构造函数"><a href="#5、单例不支持有参数的构造函数" class="headerlink" title="5、单例不支持有参数的构造函数"></a>5、单例不支持有参数的构造函数</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单例存在的问题&quot;&gt;&lt;a href=&quot;#单例存在的问题&quot; class=&quot;headerlink&quot; title=&quot;单例存在的问题&quot;&gt;&lt;/a&gt;单例存在的问题&lt;/h1&gt;&lt;p&gt;我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息 类、连接池类、ID 生成器类，但 </summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式（上）</title>
    <link href="http://example.com/2023/06/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://example.com/2023/06/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2023-06-06T02:18:00.000Z</published>
    <updated>2023-06-08T01:36:29.929Z</updated>
    
    <content type="html"><![CDATA[<p>单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p><h1 id="案例1：处理资源访问冲突"><a href="#案例1：处理资源访问冲突" class="headerlink" title="案例1：处理资源访问冲突"></a>案例1：处理资源访问冲突</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class="line">        writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>); <span class="comment">//true表示追加写入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        writer.write(mesasge);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Logger类的应用示例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">        logger.log(username + <span class="string">&quot; logined!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(OrderVo order)</span> &#123;</span><br><span class="line">        <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">        logger.log(<span class="string">&quot;Created an order: &quot;</span> + order.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的例子可以看出，我们在两个controller中创建了两个Logger对象，在多线程环境下，如果两个 Servlet 线程同时分别执行 login() 和 create() 两个函数，同时写入日志文件，则可能会导致日志互相覆盖的情况。</p><h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><h3 id="1、加锁"><a href="#1、加锁" class="headerlink" title="1、加锁"></a>1、加锁</h3><p>我们可以给Logger对象加一把类级别的锁，同一时刻只有一个线程可以访问Logger对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class="line">        writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>); <span class="comment">//true表示追加写入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Logger.class) &#123; <span class="comment">// 类级别的锁</span></span><br><span class="line">            writer.write(mesasge);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，分布式锁以及并发队列也可以解决这个问题。</p><h3 id="2、单例模式"><a href="#2、单例模式" class="headerlink" title="2、单例模式"></a>2、单例模式</h3><p>我们将 Logger 设计成一个单例类，程序中只允许创建一个 Logger 对象，所有的线程共享 使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线 程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Logger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class="line">        writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>); <span class="comment">//true表示追加写入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        writer.write(mesasge);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Logger类的应用示例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">        Logger.getInstance().log(username + <span class="string">&quot; logined!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(OrderVo order)</span> &#123;</span><br><span class="line">        <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">        Logger.getInstance().log(<span class="string">&quot;Created a order: &quot;</span> + order.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="案例2：表示全局唯一类"><a href="#案例2：表示全局唯一类" class="headerlink" title="案例2：表示全局唯一类"></a>案例2：表示全局唯一类</h1><p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类，比如配置信息类，全局唯一id的生成器类等。</p><p>此处省略代码。</p><h1 id="如何实现一个单例？"><a href="#如何实现一个单例？" class="headerlink" title="如何实现一个单例？"></a>如何实现一个单例？</h1><p>实现单例需要关注以下几个点：</p><ul><li>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；</li><li>考虑对象创建时的线程安全问题；</li><li>考虑是否支持延迟加载；</li><li>考虑 getInstance() 性能是否高（是否加锁）。</li></ul><h2 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1. 饿汉式"></a>1. 饿汉式</h2><p>饿汉式的实现方式比较简单。在类加载的时候，instance 静态实例就已经创建并初始化好 了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加 载（在真正用到 IdGenerator 的时候，再创建实例）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">IdGenerator</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdGenerator</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2. 懒汉式"></a>2. 懒汉式</h2><p>懒汉式相对于饿汉式的优势是支持延迟加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IdGenerator instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">IdGenerator</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点也很明显，我们加了锁，导致并发度之有1，即串行操作，如果频繁的被用到，则会影响性能。</p><h2 id="3-双重检测"><a href="#3-双重检测" class="headerlink" title="3. 双重检测"></a>3. 双重检测</h2><p>该方法既支持延迟 加载、又支持高并发的单例实现方式。该方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再 进入到加锁逻辑中了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IdGenerator instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(IdGenerator.class) &#123; <span class="comment">// 此处为类级别的锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">IdGenerator</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现在低版本的jdk中，会因指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才 行。</p><p>但是在高版本的jdk不存在这个问题。</p><h2 id="4-静态内部类"><a href="#4-静态内部类" class="headerlink" title="4. 静态内部类"></a>4. 静态内部类</h2><p>它有点 类似饿汉式，但又能做到了延迟加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">IdGenerator</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdGenerator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会 被加载，这个时候才会创建 instance。insance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。&lt;/p&gt;
&lt;h1 id=&quot;案例1：处理资源访问冲突&quot;&gt;&lt;a href=&quot;#案例1：处</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>NIO优化实现原理</title>
    <link href="http://example.com/2023/05/29/Java/NIO%E4%BC%98%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2023/05/29/Java/NIO%E4%BC%98%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2023-05-29T06:53:42.000Z</published>
    <updated>2023-05-29T12:03:22.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络-I-x2F-O-模型优化"><a href="#网络-I-x2F-O-模型优化" class="headerlink" title="网络 I&#x2F;O 模型优化"></a>网络 I&#x2F;O 模型优化</h1><p>最开始的阻塞式 I&#x2F;O，它在每一个连接创建时，都需要一个用户线程来处理，并且在 I&#x2F;O 操作 没有就绪或结束时，线程会被挂起，进入阻塞等待状态，阻塞式 I&#x2F;O 就成为了导致性能瓶颈的 根本原因。</p><p>首先是一次简单的TCP数据传输：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529150511602.png" alt="image-20230529150511602" style="zoom:67%;" /><p>首先，应用程序通过系统调用 socket 创建一个套接字，它是系统分配给应用程序的一个文件描述符；</p><p>其次，应用程序会通过系统调用 bind，绑定地址和端口号，给套接字命名一个名称； </p><p>然后，系统会调用 listen 创建一个队列用于存放客户端进来的连接； </p><p>最后，应用服务会通过系统调用 accept 来监听客户端的连接请求。</p><h2 id="1-阻塞式-I-x2F-O"><a href="#1-阻塞式-I-x2F-O" class="headerlink" title="1. 阻塞式 I&#x2F;O"></a>1. 阻塞式 I&#x2F;O</h2><p>在整个 socket 通信工作流程中，socket 的默认状态是阻塞的。也就是说，当发出一个不能立 即完成的套接字调用时，其进程将被阻塞，被系统挂起，进入睡眠状态，一直等待相应的操作 响应。从上图中，我们可以发现，可能存在的阻塞主要包括以下三种。</p><p><strong>connect阻塞：</strong></p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529153114099.png" alt="image-20230529153114099" style="zoom:67%;" /><p><strong>accept阻塞：</strong></p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529153138808.png" alt="image-20230529153138808" style="zoom:67%;" /><p><strong>read、write 阻塞：</strong></p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529153200868.png" alt="image-20230529153200868" style="zoom:67%;" /><h2 id="2-非阻塞式-I-x2F-O"><a href="#2-非阻塞式-I-x2F-O" class="headerlink" title="2. 非阻塞式 I&#x2F;O"></a>2. 非阻塞式 I&#x2F;O</h2><p>当我们把以上操作设置为了非阻塞状态，我们需要设置一个线程对该操作进行轮询检查，这也是最传统的非阻塞 I&#x2F;O 模型。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529153340669.png" alt="image-20230529153340669" style="zoom:67%;" /><h2 id="3-I-x2F-O-复用"><a href="#3-I-x2F-O-复用" class="headerlink" title="3. I&#x2F;O 复用"></a>3. I&#x2F;O 复用</h2><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529160244459.png" alt="image-20230529160244459" style="zoom:67%;" /><h2 id="4-信号驱动式-I-x2F-O"><a href="#4-信号驱动式-I-x2F-O" class="headerlink" title="4. 信号驱动式 I&#x2F;O"></a>4. 信号驱动式 I&#x2F;O</h2><p>信号驱动式 I&#x2F;O 类似观察者模式，内核就是一个观察者，信号回调则是通知。用户进程发起一 个 I&#x2F;O 请求操作，会通过系统调用 sigaction 函数，给对应的套接字注册一个信号回调，此时 不阻塞用户进程，进程会继续工作。当内核数据就绪时，内核就为该进程生成一个 SIGIO 信 号，通过信号回调通知进程进行相关 I&#x2F;O 操作。</p><p>信号驱动式 I&#x2F;O 相比于前三种 I&#x2F;O 模式，实现了在等待数据就绪时，进程不被阻塞，主循环可以继续工作，所以性能更佳。</p><h2 id="5-异步-I-x2F-O"><a href="#5-异步-I-x2F-O" class="headerlink" title="5. 异步 I&#x2F;O"></a>5. 异步 I&#x2F;O</h2><p>信号驱动式 I&#x2F;O 虽然在等待数据就绪时，没有阻塞进程，但在被通知后进行的 I&#x2F;O 操作还是 阻塞的，进程会等待数据从内核空间复制到用户空间中。而异步 I&#x2F;O 则是实现了真正的非阻塞 I&#x2F;O。</p><p>当用户进程发起一个 I&#x2F;O 请求操作，系统会告知内核启动某个操作，并让内核在整个操作完成 后通知进程。这个操作包括等待数据就绪和数据从内核复制到用户空间。</p><p>linux不支持，比较少见。</p><p>在 NIO 服务端通信编程中，首先会创建一个 Channel，用于监听客户端连接；接着，创建多 路复用器 Selector，并将 Channel 注册到 Selector，程序会通过 Selector 来轮询注册在其 上的 Channel，当发现一个或多个 Channel 处于就绪状态时，返回就绪的监听事件，最后程 序匹配到监听事件，进行相关的 I&#x2F;O 操作。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529175854015.png" alt="image-20230529175854015" style="zoom:67%;" /><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>零拷贝是一种避免多次内存复制的技术，用来优化读写 I&#x2F;O 操作。</p><p>在网络编程中，通常由 read、write 来完成一次 I&#x2F;O 读写操作。每一次 I&#x2F;O 读写操作都需要 完成四次内存拷贝，路径是 I&#x2F;O 设备 -&gt; 内核空间 -&gt; 用户空间 -&gt; 内核空间 -&gt; 其它 I&#x2F;O 设 备。</p><p>Linux 内核中的 mmap 函数可以代替 read、write 的 I&#x2F;O 读写操作，实现用户空间和内核空间共享一个缓存数据。mmap 将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址，不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射 到物理内存地址。这种方式避免了内核空间与用户空间的数据交换。I&#x2F;O 复用中的 epoll 函数 中就是使用了 mmap 减少了内存拷贝。</p><h2 id="线程模型优化"><a href="#线程模型优化" class="headerlink" title="线程模型优化"></a>线程模型优化</h2><p>NIO 是基于事件驱动模型 来实现的 I&#x2F;O 操作。Reactor 模型是同步 I&#x2F;O 事件处理的一种常见模型，其核心思想是将 I&#x2F;O 事件注册到多路复用器上，一旦有 I&#x2F;O 事件触发，多路复用器就会将事件分发到事件处理器 中，执行就绪的 I&#x2F;O 事件操作。</p><p>该模型有以下三个主要组件：</p><p>事件接收器 Acceptor：主要负责接收请求连接； </p><p>事件分离器 Reactor：接收请求后，会将建立的连接注册到分离器中，依赖于循环监听多路 复用器 Selector，一旦监听到事件，就会将事件 dispatch 到事件处理器； </p><p>事件处理器 Handlers：事件处理器主要是完成相关的事件处理，比如读写 I&#x2F;O 操作。</p><h3 id="1-单线程-Reactor-线程模型"><a href="#1-单线程-Reactor-线程模型" class="headerlink" title="1. 单线程 Reactor 线程模型"></a>1. 单线程 Reactor 线程模型</h3><p>最开始 NIO 是基于单线程实现的，所有的 I&#x2F;O 操作都是在一个 NIO 线程上完成。由于 NIO 是非阻塞 I&#x2F;O，理论上一个线程可以完成所有的 I&#x2F;O 操作。</p><p>但 NIO 其实还不算真正地实现了非阻塞 I&#x2F;O 操作，因为读写 I&#x2F;O 操作时用户进程还是处于阻 塞状态，这种方式在高负载、高并发的场景下会存在性能瓶颈，一个 NIO 线程如果同时处理 上万连接的 I&#x2F;O 操作，系统是无法支撑这种量级的请求的。</p><h3 id="2-多线程-Reactor-线程模型"><a href="#2-多线程-Reactor-线程模型" class="headerlink" title="2. 多线程 Reactor 线程模型"></a>2. 多线程 Reactor 线程模型</h3><p>为了解决这种单线程的 NIO 在高负载、高并发场景下的性能瓶颈，后来使用了线程池。</p><p>在 Tomcat 和 Netty 中都使用了一个 Acceptor 线程来监听连接请求事件，当连接成功之 后，会将建立的连接注册到多路复用器中，一旦监听到事件，将交给 Worker 线程池来负责处理。</p><h3 id="3-主从-Reactor-线程模型"><a href="#3-主从-Reactor-线程模型" class="headerlink" title="3. 主从 Reactor 线程模型"></a>3. 主从 Reactor 线程模型</h3><p>现在主流通信框架中的 NIO 通信框架都是基于主从 Reactor 线程模型来实现的。在这个模型 中，Acceptor 不再是一个单独的 NIO 线程，而是一个线程池。Acceptor 接收到客户端的 TCP 连接请求，建立连接之后，后续的 I&#x2F;O 操作将交给 Worker I&#x2F;O 线程。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529200317906.png" alt="image-20230529200317906" style="zoom:67%;" /><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Java性能调优实战》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络-I-x2F-O-模型优化&quot;&gt;&lt;a href=&quot;#网络-I-x2F-O-模型优化&quot; class=&quot;headerlink&quot; title=&quot;网络 I&amp;#x2F;O 模型优化&quot;&gt;&lt;/a&gt;网络 I&amp;#x2F;O 模型优化&lt;/h1&gt;&lt;p&gt;最开始的阻塞式 I&amp;#x2F;O</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="其他" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="调优" scheme="http://example.com/tags/%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>Java的I/O</title>
    <link href="http://example.com/2023/05/26/Java/Java%E7%9A%84I-O/"/>
    <id>http://example.com/2023/05/26/Java/Java%E7%9A%84I-O/</id>
    <published>2023-05-26T02:57:20.000Z</published>
    <updated>2023-05-26T05:07:27.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是I-x2F-O流"><a href="#什么是I-x2F-O流" class="headerlink" title="什么是I&#x2F;O流"></a>什么是I&#x2F;O流</h1><p>我们通常把机器或者应用程序接收外界的信息称为输入流（InputStream），从机器或者应用程 序向外输出的信息称为输出流（OutputStream），合称为输入 &#x2F; 输出流（I&#x2F;O Streams）。</p><p>Java 的 I&#x2F;O 分为以下两类：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230526110237837.png" alt="image-20230526110237837" style="zoom:67%;" /><p>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么还要存在字符流呢？</p><p>字符到字节必须经过转码，这个过程非常耗时，如果我们不知道编码类型就很容易出现乱码问题，所以提供了直接操作字符的接口。</p><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230526110336147.png" alt="image-20230526110336147" style="zoom:67%;" /><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230526110352335.png" alt="image-20230526110352335" style="zoom:67%;" /><h1 id="传统I-x2F-O的性能问题"><a href="#传统I-x2F-O的性能问题" class="headerlink" title="传统I&#x2F;O的性能问题"></a>传统I&#x2F;O的性能问题</h1><h2 id="1-多次内存复制"><a href="#1-多次内存复制" class="headerlink" title="1. 多次内存复制"></a>1. 多次内存复制</h2><p>在传统 I&#x2F;O 中，我们可以通过 InputStream 从源数据中读取数据流输入到缓冲区里，通过 OutputStream 将数据输出到外部设备（包括磁盘、网络），输入操作在操作系统中的具体流程如下：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230526110921118.png" alt="image-20230526110921118" style="zoom:67%;" /><p>JVM 会发出 read() 系统调用，并通过 read 系统调用向内核发起读请求； </p><p>内核向硬件发送读指令，并等待读就绪； </p><p>内核把将要读取的数据复制到指向的内核缓存中；</p><p>操作系统内核将数据复制到用户空间缓冲区，然后 read 系统调用返回。</p><p>数据先从外部设备复制到内核空间，再从内核空间复制到用户空间，这就发生 了两次内存复制操作。</p><h2 id="2-阻塞"><a href="#2-阻塞" class="headerlink" title="2. 阻塞"></a>2. 阻塞</h2><p>在传统 I&#x2F;O 中，InputStream 的 read() 是一个 while 循环操作，它会一直等待数据读取，直到数据就绪才会返回。这就意味着如果没有数据就绪，这个读取操作将会一直被挂起，用户线程将会处于阻塞状态。</p><p>这种处理方式在少量连接没问题，但在发生大量连接请求时，就需要创建大量监听线程，这时如果线程没有数据就绪就会被挂起，然后进入阻塞状态。 一旦发生线程阻塞，这些线程将会不断地抢夺 CPU 资源，从而导致大量的 CPU 上下文切换，增加系统的性能开销。</p><h1 id="如何优化-I-x2F-O-操作"><a href="#如何优化-I-x2F-O-操作" class="headerlink" title="如何优化 I&#x2F;O 操作"></a>如何优化 I&#x2F;O 操作</h1><p>NIO 的发布优化了内存复制以及阻塞导致的 严重性能问题，NIO2提出了从操作系统层面实现的异步 I&#x2F;O。</p><h2 id="1-使用缓冲区优化读写流操作"><a href="#1-使用缓冲区优化读写流操作" class="headerlink" title="1. 使用缓冲区优化读写流操作"></a>1. 使用缓冲区优化读写流操作</h2><p>NIO是基于块的，在 NIO 中， 最为重要的两个组件是缓冲区（Buffer）和通道（Channel）。Buffer 是一块连续的内存块， 是 NIO 读写数据的中转地。Channel 表示缓冲数据的源头或者目的地，它用于读取缓冲或者写入数据，是访问缓冲的接口。</p><p>NIO 是面向 Buffer。Buffer 可以将文 件一次性读入内存再做后续处理，而传统的方式是边读文件边处理数据。</p><h2 id="2-使用-DirectBuffer-减少内存复制"><a href="#2-使用-DirectBuffer-减少内存复制" class="headerlink" title="2. 使用 DirectBuffer 减少内存复制"></a>2. 使用 DirectBuffer 减少内存复制</h2><p>NIO 的 Buffer 除了做了缓冲块优化之外，还提供了一个可以直接访问物理内存的类 DirectBuffer。普通的 Buffer 分配的是 JVM 堆内存，而 DirectBuffer 是直接分配物理内存 (非堆内存)。</p><p>数据要输出到外部设备，必须先从用户空间复制到内核空间，再复制到输出设备，而在 Java 中，在用户空间中又存在一个拷贝，那就是从 <strong>Java 堆内存中拷贝到临时的直接内存中</strong>，通过<strong>临时的直接内存拷贝到内存空间中</strong>去。此时的直接内存和堆内存都是属于用户空间。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230526112218554.png" alt="image-20230526112218554" style="zoom:67%;" /><p>如果单纯使用 Java 堆内存进行数据拷贝，当拷贝的数据量比较大的情况下，Java 堆的 GC 压力会比较大，而使用非堆内存可以减低 GC 的压力。</p><p>DirectBuffer 则是直接将步骤简化为数据直接保存到非堆内存，从而减少了一次数据拷贝。</p><p>由于 DirectBuffer 申请的是非 JVM 的物理内存，所以创建和销毁的代价很 高。DirectBuffer 申请的内存并不是直接由 JVM 负责垃圾回收，但在 DirectBuffer 包装类被 回收时，会通过 Java Reference 机制来释放该内存块。</p><p>MappedByteBuffer 是通过本 地类调用 mmap 进行文件内存映射的，map() 系统调用方法会直接将文件从硬盘拷贝到用户 空间，只进行一次数据拷贝，从而减少了传统的 read() 方法从硬盘拷贝到内核空间这一步。</p><h2 id="3-避免阻塞，优化-I-x2F-O-操作"><a href="#3-避免阻塞，优化-I-x2F-O-操作" class="headerlink" title="3. 避免阻塞，优化 I&#x2F;O 操作"></a>3. 避免阻塞，优化 I&#x2F;O 操作</h2><p>传统的 I&#x2F;O 即使使用了缓冲块，依然存在阻塞问题。由于线程池线程数量有限，一旦发生大量 并发请求，超过最大数量的线程就只能等待，直到线程池中有空闲的线程可以被复用。而对 Socket 的输入流进行读取时，读取流会一直阻塞，直到发生以下三种情况的任意一种才会解 除阻塞：</p><p>1、有数据可读； </p><p>2、连接释放； </p><p>3、空指针或 I&#x2F;O 异常。</p><p>NIO 发布后，通道和多路复用器这两个基本组件实现 了 NIO 的非阻塞</p><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>最开始，在应用程序调用操作系统 I&#x2F;O 接口时，是由 CPU 完成分配，这种方式最大的问题是 “发生大量 I&#x2F;O 请求时，非常消耗 CPU“；之后，操作系统引入了 DMA（直接存储器存 储），内核空间与磁盘之间的存取完全由 DMA 负责，但这种方式依然需要向 CPU 申请权 限，且需要借助 DMA 总线来完成数据的复制操作，如果 DMA 总线过多，就会造成总线冲突。</p><p>Channel 有自己的处理器，可以完成内核空间和磁盘之间的 I&#x2F;O 操作。在 NIO 中，我们读取和写入数据都要通过 Channel，由于 Channel 是双向的，所以 读、写可以同时进行。</p><h3 id="多路复用器（Selector）"><a href="#多路复用器（Selector）" class="headerlink" title="多路复用器（Selector）"></a>多路复用器（Selector）</h3><p>Selector 是 Java NIO 编程的基础。用于检查一个或多个 NIO Channel 的状态是否处于可 读、可写。</p><p>Selector 是基于事件驱动实现的，我们可以在 Selector 中注册 accpet、read 监听事件， Selector 会不断轮询注册在其上的 Channel，如果某个 Channel 上面发生监听事件，这个 Channel 就处于就绪状态，然后进行 I&#x2F;O 操作。</p><p>一个线程使用一个 Selector，通过轮询的方式，可以监听多个 Channel 上的事件。我们可以 在注册 Channel 时设置该通道为非阻塞，当 Channel 上没有 I&#x2F;O 操作时，该线程就不会一直 等待了，而是会不断轮询所有 Channel，从而避免发生阻塞。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Java性能调优实战》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是I-x2F-O流&quot;&gt;&lt;a href=&quot;#什么是I-x2F-O流&quot; class=&quot;headerlink&quot; title=&quot;什么是I&amp;#x2F;O流&quot;&gt;&lt;/a&gt;什么是I&amp;#x2F;O流&lt;/h1&gt;&lt;p&gt;我们通常把机器或者应用程序接收外界的信息称为输入流（InputS</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="其他" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="调优" scheme="http://example.com/tags/%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>Java的Stream</title>
    <link href="http://example.com/2023/05/24/Java/Java%E7%9A%84Stream/"/>
    <id>http://example.com/2023/05/24/Java/Java%E7%9A%84Stream/</id>
    <published>2023-05-24T14:18:39.000Z</published>
    <updated>2023-05-26T02:57:48.067Z</updated>
    
    <content type="html"><![CDATA[<p> 需求：过滤分组一所中学里身高在 160cm 以上的男女同学</p><p>之前的代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; stuMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;Student&gt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Student stu: studentsList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stu.getHeight() &gt; <span class="number">160</span>) &#123; <span class="comment">//如果身高大于160</span></span><br><span class="line">        <span class="keyword">if</span> (stuMap.get(stu.getSex()) == <span class="literal">null</span>) &#123; <span class="comment">//该性别还没分类</span></span><br><span class="line">            List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;(); <span class="comment">//新建该性别学生的</span></span><br><span class="line">            list.add(stu);<span class="comment">//将学生放进去列表</span></span><br><span class="line">            stuMap.put(stu.getSex(), list);<span class="comment">//将列表放到map中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//该性别分类已存在</span></span><br><span class="line">            stuMap.get(stu.getSex()).add(stu);<span class="comment">//该性别分类已存在，则直接放进去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Stream API实现：</p><p>串行实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; stuMap = stuList.stream().filter((Student s) -&gt; s.getHeight() &gt; <span class="number">160</span>) .collect(Collectors.groupingBy(Student ::getSex)); </span><br></pre></td></tr></table></figure><p>并行实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; stuMap = stuList.parallelStream().filter((Student s) -&gt; s.getHeight() &gt; <span class="number">160</span>) .collect(Collectors.groupingBy(Student ::getSex)); </span><br></pre></td></tr></table></figure><h1 id="Stream-如何优化遍历"><a href="#Stream-如何优化遍历" class="headerlink" title="Stream 如何优化遍历"></a>Stream 如何优化遍历</h1><p>官方将 Stream 中的操作分为两大类：中间操作（Intermediate operations）和终结操作（Terminal operations）</p><p>中间操作只对操作进行了记录，即只会返回一个流，不会进行计算操作，而终结操作是实现了计算操作。</p><p>中间操作又可以分为无状态（Stateless）与有状态（Stateful）操作，前者是指元素的处理不受之前元素的影响，后者是指该操作只有拿到所有元素之后才能继续下去。</p><p>终结操作又可以分为短路（Short-circuiting）与非短路（Unshort-circuiting）操作，前者是指遇到某些符合条件的元素就可以得到最终结果，后者是指必须处理完所有元素才能得到最终结果。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230524223653374.png" alt="image-20230524223653374"></p><p>Stream如何迭代大数据集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王老五&quot;</span>, <span class="string">&quot;李三&quot;</span>, <span class="string">&quot;刘老四&quot;</span>, <span class="string">&quot;王小二&quot;</span>, <span class="string">&quot;张四&quot;</span>, <span class="string">&quot;张五六七&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">maxLenStartWithZ</span> <span class="operator">=</span> names.stream()</span><br><span class="line">                  .filter(name -&gt; name.startsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">                  .mapToInt(String::length)</span><br><span class="line">                  .max()</span><br><span class="line">                  .toString();</span><br></pre></td></tr></table></figure><p>Stream 并行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王老五&quot;</span>, <span class="string">&quot;李三&quot;</span>, <span class="string">&quot;刘老四&quot;</span>, <span class="string">&quot;王小二&quot;</span>, <span class="string">&quot;张四&quot;</span>, <span class="string">&quot;张五六七&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">maxLenStartWithZ</span> <span class="operator">=</span> names.stream()</span><br><span class="line">                  .parallel()</span><br><span class="line">                  .filter(name -&gt; name.startsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">                  .mapToInt(String::length)</span><br><span class="line">                  .max()</span><br><span class="line">                  .toString();</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Java性能调优实战》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 需求：过滤分组一所中学里身高在 160cm 以上的男女同学&lt;/p&gt;
&lt;p&gt;之前的代码实现如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    
    <category term="Stream" scheme="http://example.com/tags/Stream/"/>
    
  </entry>
  
</feed>
