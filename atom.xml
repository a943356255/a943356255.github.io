<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便起个名字吧</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-11-21T03:18:29.371Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Guo Junhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2^32 怎么表示4GB</title>
    <link href="http://example.com/2023/11/21/%E5%86%85%E5%AD%98%E8%A1%A8%E7%A4%BA/"/>
    <id>http://example.com/2023/11/21/%E5%86%85%E5%AD%98%E8%A1%A8%E7%A4%BA/</id>
    <published>2023-11-21T03:11:54.000Z</published>
    <updated>2023-11-21T03:18:29.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-32-怎么表示4GB"><a href="#2-32-怎么表示4GB" class="headerlink" title="2^32 怎么表示4GB"></a>2^32 怎么表示4GB</h1><p>一般来说，32位最大支持4GB内存，怎么计算出来的呢？</p><p>如果按照这样计算： 2^32 bit &#x3D; 2^29 byte &#x3D; 2^19 KB &#x3D; 2^9 MB &#x3D; 0.5 GB，其实并不够4GB。</p><p>但其实，计算机规定8bit&#x3D;1byte 就是1字节&#x3D;8位，内存的大小就根据格子的多少来进行计算的。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231121111621868.png" alt="image-20231121111621868" style="zoom:67%;" /><p>实际上，4GB &#x3D;  2^2 GB &#x3D; 2^12 MB &#x3D; 2^22 KB &#x3D; 2^32 byte &#x3D; 2^35 bit。也就是说，4GB需要35位。</p><p><strong>实际上内存是把8个bit排成1组， 每1组成为1个单位， 大小是1byte(字节）， cpu每一次只能访问1个byte， 而不能单独去访问具体的1个小格子(bit). 1个byte字节就是内存的最小的IO单位。</strong></p><p>即这里3^32次方，后面的单位并不是bit，而是byte。</p><p>计算机操作系统会给内存每1个字节分配1个内存地址, cpu只需要知道某个数据类型的地址, 就可以直接去到读影的内存位置去提取数据了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2-32-怎么表示4GB&quot;&gt;&lt;a href=&quot;#2-32-怎么表示4GB&quot; class=&quot;headerlink&quot; title=&quot;2^32 怎么表示4GB&quot;&gt;&lt;/a&gt;2^32 怎么表示4GB&lt;/h1&gt;&lt;p&gt;一般来说，32位最大支持4GB内存，怎么计算出来的呢？&lt;/p</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java的方法调用</title>
    <link href="http://example.com/2023/11/20/Java%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/"/>
    <id>http://example.com/2023/11/20/Java%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</id>
    <published>2023-11-20T01:21:21.000Z</published>
    <updated>2023-11-20T01:22:38.471Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>Java中方法的重载，在编译过程中可以完成识别，而具体调用哪一个方法，Java编译器会根据所传入<strong>参数的声明类型（注意与实际类型区分比如声明的是一个List，实际实例化传入的可能是一个ArrayList）</strong>来选取重载方法。选取过程分以下三个阶段：</p><ol><li>在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法；（这里是只找普通方法）</li><li>如果在第 1 个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；（加入自动装箱拆箱的方法）</li><li>如果在第 2 个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况 下选取重载方法。（所有方法）</li></ol><p>如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么它会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是<strong>形式参数类型的继承关系</strong>。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(String s, Object obj, Object... args)</span> &#123; ... &#125;</span><br><span class="line">invoke(<span class="literal">null</span>, <span class="number">1</span>); <span class="comment">// 调用第二个invoke方法</span></span><br><span class="line">invoke(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用第二个invoke方法</span></span><br><span class="line">invoke(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">1</span>&#125;); <span class="comment">// 只有手动绕开可变长参数的语法糖</span></span><br></pre></td></tr></table></figure><p>为什么会调用第二个呢？因为String 类型 是Object 的子类，所以编译器会认为它更贴合（范围更小）。</p><p>而如果子类继承父类，而且有一个方法和父类中非私有的方法同名，而且参数相同，如果两个方法都是静态的，那么子类中会隐藏父类的方法，如果不是静态切都不是私有的，那么子类的方法相当于重写了父类的方法。</p><h4 id="JVM-的静态绑定和动态绑定"><a href="#JVM-的静态绑定和动态绑定" class="headerlink" title="JVM 的静态绑定和动态绑定"></a>JVM 的静态绑定和动态绑定</h4><p>Java 虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）。方法描述符，是由方法的<strong>参数类型</strong>以及<strong>返回类型</strong>所构成。在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么 Java 虚拟机会在<strong>类的验证阶段</strong>报错。</p><p>因为描述符包含了返回类型，所以说并不会限制同一个类中有方法名和参数一样，但返回值不一样的方法。而在上述提到的子类有一个父类同名，同返回值，同参数的非私有，非静态方法，才会被虚拟机判定为重写。</p><p>因为重载方法在编译阶段已经区分，可以认为虚拟机层面没有重载的概念。因此，<strong>重载也被称为静态绑定</strong>（static binding），或者编译时多态 （compile-time polymorphism）；而<strong>重写则被称为动态绑定</strong>（dynamic binding）。</p><p>这个说法在虚拟机语境下并不完全正确，因为某个类的重载方法可能会被它的子类所重写，因此，Java编译器会对所有非私有方法的调用，编译为需要动态绑定的类型（考虑子类继承父类，并重写父类的方法。此时通过子类调用重写的方法，并不能在编译期间确定）。</p><p>确切地说，Java 虚拟机中的<strong>静态绑定指的是在解析时便能够直接识别目标方法的情况</strong>，而<strong>动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法</strong>的情况。</p><h4 id="调用指令的符号引用"><a href="#调用指令的符号引用" class="headerlink" title="调用指令的符号引用"></a>调用指令的符号引用</h4><p>在编译过程中，并不知道目标方法的具体内存地址（编译阶段该对象并没有被实例化，似乎没实例化说法不太准确，gpt说是并不需要知到。有了符号引用后，在运行时，JVM会将符号引用解析为实际的地址引用）。</p><p>因此，Java 编译器会暂时用<strong>符号引用（这个符号引用应该就是暂时指代该方法）</strong>来表示该目标方法。这一符号引用包括目标方法所在的<strong>类</strong>或<strong>接口</strong>的名字，以及目标方法的<strong>方法名</strong>和<strong>方法描述符</strong>。</p><p>符号引用存储在 class 文件的常量池之中。根据目标方法是否为接口方法，这些引用可分为接口符号引用和非接口符号引用。</p><h4 id="虚方法调用"><a href="#虚方法调用" class="headerlink" title="虚方法调用"></a>虚方法调用</h4><p>Java 里所有非私有实例方法调用都会被编译成 invokevirtual 指令， 而接口方法调用都会被编译成 invokeinterface 指令。这两种指令，均属于 Java 虚拟机中的 <strong>虚方法调用</strong>。</p><p>Java 虚拟机需要根据调用者的动态类型，来确定虚方法调用的目标方法。这个过程我们称之为<strong>动态绑定</strong>。（这里，调用者的动态类型，应该是受Java多态的影响，即List list &#x3D; new ArrayList这种写法，List是一个接口，并不知道它的实例化是哪一个，需要根据具体的动态类型来决定调用的是它的哪一个实现）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里的打印结果是123</span></span><br><span class="line">        test.testExe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testExe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">        father.fatherMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="type">int</span> test;</span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fatherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">childMethod</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fatherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法表（用于优化动态绑定，即虚方法）"><a href="#方法表（用于优化动态绑定，即虚方法）" class="headerlink" title="方法表（用于优化动态绑定，即虚方法）"></a>方法表（用于优化动态绑定，即虚方法）</h4><p>Java 虚拟机中采取了一种用空间换取时间的策略来实现动态绑定。它为每个类生成一张方法表，用以快速定位目标方法。</p><p>方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。这些方法可能是具体的，可执行的方法，也可能是抽象的方法。方法表有以下两个特征：</p><ol><li>子类的方法表中包含了父类的方法表中的所有方法。</li><li>子类重写了父类方法时，该方法在子类中的索引值与父类中的一样。即通过索引只能找到子类的方法。</li></ol><p>在符号引用解析为实际引用的时候，对于静态绑定的调用而言，实际引用是直接指向具体的目标方法，而动态绑定，则是实际引用则是指向了方法表的索引值（并不仅是索引值）。</p><p>在执行过程中，Java 虚拟机将获取调用者的实际类型，并在该实际类型的虚方法表中，根据 索引值获得目标方法。这个过程便是动态绑定。</p><p>使用了方法表的动态绑定与静态绑定相比，仅仅多出几个内存解引用操作：访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值所对应的目标方法。</p><p>这种优化仅存在于<strong>解释执行</strong>中，或者<strong>即时编译代码的最坏情况</strong>中。这是因为即时编译还有另外两种更好的优化，<strong>内联缓存</strong> （inlining cache）和<strong>方法内联</strong>（method inlining）。</p><h4 id="内联缓存"><a href="#内联缓存" class="headerlink" title="内联缓存"></a>内联缓存</h4><p>它能够缓存虚方法调用中调用者的<strong>动态类型</strong>，以及<strong>该类型所对应的目标方法</strong>。在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接 调用该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定，即当内联缓存没有命中的情况下，Java 虚拟机需要重新使用方法表进行动态绑定。</p><p>Java虚拟机采用的是单态的，即只会缓存对应方法的一种实例，那么在一种极端的情况下，两个不同的类型频繁调同一个 方法，就会导致缓存被频繁的切换，而且每次都需要去重新绑定一下。情况如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal makes a sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat meows&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 在不同的调用者（不同的对象类型）上轮流调用相同的虚方法</span></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                animal1.makeSound(); <span class="comment">// Dog 调用</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                animal2.makeSound(); <span class="comment">// Cat 调用</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;方法调用&quot;&gt;&lt;a href=&quot;#方法调用&quot; class=&quot;headerlink&quot; title=&quot;方法调用&quot;&gt;&lt;/a&gt;方法调用&lt;/h3&gt;&lt;p&gt;Java中方法的重载，在编译过程中可以完成识别，而具体调用哪一个方法，Java编译器会根据所传入&lt;strong&gt;参数的声明类</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="虚拟机" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="Jvm" scheme="http://example.com/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>AQS</title>
    <link href="http://example.com/2023/11/15/AQS/"/>
    <id>http://example.com/2023/11/15/AQS/</id>
    <published>2023-11-15T03:14:16.000Z</published>
    <updated>2023-11-20T01:22:48.134Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS是什么：AQS，是AbstractQueuedSynchronizer简称，直翻过来叫抽象的<code>队列式同步器</code>， 也可以称作队列同步器，它是java.util.concurrent.lock包下的一个工具类。直观来讲，AQS是Java提供的一个类，这个类是被Abstract修饰的，需要被子类继承。也就是说<strong>AQS是Java并发中用以解决多线程访问共享资源问题的同步机制的基本的框架</strong>（或者说是一种规范），<strong>为Java并发同步组件提供统一的底层支持</strong>。即，AQS是个为各个同步组件提供基本框架的一个抽象类。</p><p>AQS做了什么：<code>提供解决同步问题的基础框架</code>。AQS类内维护了一个volatile int型的变量state，用于表示同步状态（锁的释放与获取），同时提供了一些列诸如getstate、setstate、compareAndSetState的方法来管理该同步状态，这些方法是子类中需要重写的部分，并且，AQS提供了模板方法去调用这些重写的方法；另外，AQS用一个虚拟的CLH FIFO的双向队列来管理被阻塞的线程。</p><p>AQS的整体框架如下：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/82077ccf14127a87b77cefd1ccf562d3253591.png" alt="img"></p><ul><li><p>有颜色的为方法，没颜色的为属性。</p></li><li><p>框架共分为5层，从上到下，由浅入深，从AQS对外暴露的API到底层基础数据。</p></li><li><p>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。</p><p>当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</p></li></ul><h4 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h4><p>AQS核心思想是：</p><ul><li><p>如果被请求的共享资源空闲，那么就将当前<strong>请求资源的线程</strong>设置为有效的工作线程，将共享资源设置为锁定状态；</p></li><li><p>如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p></li></ul><p>CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的<strong>虚拟双向队列（FIFO）</strong>，AQS是通过将每条<strong>请求共享资源的线程</strong>封装成一个节点来实现锁的分配。</p><p>原理如下：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/7132e4cef44c26f62835b197b239147b18062.png" alt="img"></p><p>AOS使用一个Volatile修饰的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值得修改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;AQS&quot;&gt;&lt;a href=&quot;#AQS&quot; class=&quot;headerlink&quot; title=&quot;AQS&quot;&gt;&lt;/a&gt;AQS&lt;/h3&gt;&lt;p&gt;AQS是什么：AQS，是AbstractQueuedSynchronizer简称，直翻过来叫抽象的&lt;code&gt;队列式同步器&lt;/cod</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>文件系统</title>
    <link href="http://example.com/2023/11/15/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2023/11/15/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-11-15T02:04:48.000Z</published>
    <updated>2023-11-15T02:05:43.011Z</updated>
    
    <content type="html"><![CDATA[<p>文件系统将硬盘空间以块进行划分，每个文件占用其中的几个块，然后再通过一个<strong>文件控制块 FCB</strong> 记录每个文件占据的硬盘数据块。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231115093943594.png" alt="image-20231115093943594" style="zoom:67%;" /><p>在linux中，这个文件控制块就是inode，想要访问文件，就要先获取这个inode，然后在inode中查找文件数据块的索引表，根据索引中记录的硬盘地址信息来访问硬盘，读写数据。</p><p>inode的结构是固定的，只有15个索引，前12个索引直接指向数据块地址，第13个索引记录索引地址，即不直接指向数据块，而是指向一张索引表，每张索引表可以记录256个索引，访问这里的数据需要多一次查找。第 14 个索引记录二级索引地址，第 15 个索引记录三级索引地址。</p><h1 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h1><p>RAID，即独立硬盘冗余阵列，将多块硬盘通过硬件 RAID 卡或者软件 RAID 的方案管理起 来，使其共同对外提供服务。</p><p>RAID 的核心思路其实是利用文件系统<strong>将数据写入硬盘中不同数据块的特性</strong>，将多块硬盘上的空闲空间看做一个整体，进行数据写入，也就是说，一个文件的 多个数据块可能写入多个硬盘。</p><p>RAID常用的方式有5种，分别是 RAID 0、RAID 1、RAID 10、 RAID 5 和 RAID 6。</p><h2 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h2><p>该方式是将一个文件的数据分成N块，然后同时写入N个硬盘，这样单个文件可以存储在N个硬盘上，文件容量可以扩大N倍，理论上读写速度也扩大N倍。但是有一个问题，这N个磁盘任何一个损坏，就会导致文件的不完整。文件可用性降低。</p><h2 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h2><p>利用两块硬盘进行数据备份，文件同时向两块硬盘写入，这样任何一块硬盘损坏都不会出现文件数据丢失的情况，文件的可用性得到提升。</p><h2 id="RAID-10"><a href="#RAID-10" class="headerlink" title="RAID 10"></a>RAID 10</h2><p>将多块硬盘进行两两分组，文件数据分成 N 片，每个分组 写入一片，每个分组内的两块硬盘再进行数据备份。这样既扩大了文件的容量，又提高了文件 的可用性。但是这种方式硬盘的利用率只有 50%，有一半的硬盘被用来做数据备份。</p><h2 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID 5"></a>RAID 5</h2><p>RAID 5 针对 RAID 10 硬盘浪费的情况，将数据分成 N-1 片，再利用这 N-1 片数据进行位运算，计算一片校验数据，然后将这 N 片数据写入 N 个硬盘。这样任何一块硬盘损坏，都可以 利用校验片的数据和其他数据进行计算得到这片丢失的数据，而硬盘的利用率也提高到( N - 1&#x2F;N)。</p><h1 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h1><p>文件的inode，是以索引的方式记录每个文件所在的磁盘位置，如果这些索引记录的不是在本地的磁盘位置，而是记录一个其他服务器的地址，那么查询到的数据块就不止是本地磁盘，还可以是其他服务器的磁盘。这样磁盘的容量就是整个分布式集群的大小，读写速度也会加快。</p><p>这样的文件系统就是分布式文件系统，将文件分成很多片，同时向多台服务器写入，然后做好备份，解决单一服务器崩溃导致文件缺失的情况。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文件系统将硬盘空间以块进行划分，每个文件占用其中的几个块，然后再通过一个&lt;strong&gt;文件控制块 FCB&lt;/strong&gt; 记录每个文件占据的硬盘数据块。&lt;/p&gt;
&lt;img src=&quot;https://image-1314238346.cos.ap-chongqing.my</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="文件系统" scheme="http://example.com/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>索引下推</title>
    <link href="http://example.com/2023/11/07/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/"/>
    <id>http://example.com/2023/11/07/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/</id>
    <published>2023-11-07T01:27:54.000Z</published>
    <updated>2023-11-07T01:28:17.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h1><p>首先，MySQL的结构图如下：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231107091604104.png" alt="image-20231107091604104" style="zoom:80%;" /><p>其中，Server层所做的事情，就是负责SQL的语法解析，生成执行计划，并调用存储引擎层去执行数据的存储核检索，<strong>判断引擎返回的数据是否满足where条件</strong>。<code>索引下推</code>就是指将上层（Server层）负责的事情，交给了下层（引擎层）去处理。具体的查询区别如下：</p><p>在没有使用索引下推时：</p><ul><li>存储引擎读取索引记录；</li><li>根据索引中的主键值，定位并读取完整的行记录；</li><li>存储引擎把记录交给<code>Server</code>层去检测该记录是否满足<code>WHERE</code>条件。</li></ul><p>而使用了索引下推的查询过程：</p><ul><li>存储引擎读取索引记录（不是完整的行记录）；</li><li>判断<code>WHERE</code>条件部分能否用<strong>索引中的列来做检查</strong>，条件不满足，则处理下一行索引记录；</li><li>条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；</li><li>存储引擎把记录交给<code>Server</code>层，<code>Server</code>层检测该记录是否满足<code>WHERE</code>条件的<strong>其余部分</strong>。</li></ul><p>这里的优化点在于，可以提前根据索引中的数据过滤掉一部分不满足的值，这一部分数据不需要回表查询，也不需要交由Server层去处理。</p><p>但是要注意，这个提前判断只能判断索引中存在的值，比如说where条件中有a , b , c 三个字段，但是这个索引（<strong>只能是二级索引，也叫辅助索引</strong>）是建立在a 和 b上面的，那么就只能提前判断a 和 b 是否满足，去除这两个不满足的，然后回表查询数据，返回给Server 然后去判断 c 是否满足条件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;索引下推&quot;&gt;&lt;a href=&quot;#索引下推&quot; class=&quot;headerlink&quot; title=&quot;索引下推&quot;&gt;&lt;/a&gt;索引下推&lt;/h1&gt;&lt;p&gt;首先，MySQL的结构图如下：&lt;/p&gt;
&lt;img src=&quot;https://image-1314238346.cos.ap-</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    <category term="索引" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/%E7%B4%A2%E5%BC%95/"/>
    
    
    <category term="索引" scheme="http://example.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的最左前缀原则</title>
    <link href="http://example.com/2023/11/03/MySQL%E7%9A%84%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99/"/>
    <id>http://example.com/2023/11/03/MySQL%E7%9A%84%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99/</id>
    <published>2023-11-03T08:09:51.000Z</published>
    <updated>2023-11-03T08:12:26.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h1><p>比如我们建立了一个（姓名，年龄）的索引，那么它可以用来匹配按名字的查找，但是按照年龄就不行。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p><p>MySQL的索引中，有一种形式，叫做联合索引。即它可以创建多个字段联合起来的索引。语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index index_name on table_name(column_1, column_2, column_3)</span><br></pre></td></tr></table></figure><p>这种联合索引的好处在于：</p><ol><li><p>创建联合索引，<strong>相当于</strong>创建了column_1，（column_1，column_2），（column_1，column_2，column_3）这三个索引。但是实际上只存在一个索引。这可以大大减小插入数据时修改索引所消耗的时间。</p></li><li><p>存在联合索引时，如果只查询联合索引这些字段，可以省去回表的时间。</p></li><li><p>通过联合索引可以筛选出来更少的数据。比如说下面的查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select from table where col1 = 1 and col2 = 2 and col3 = 3</span><br></pre></td></tr></table></figure><p>如果只有第一个索引，那么查询完满足第一个条件的数据后，还需要回表去看是否满足第二个条件，第二个条件满足完后还需要看第三个条件。但是如果有联合索引，可以直接查出来满足所有的，这里其实也是满足不回表。</p></li></ol><h1 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h1><p>假设存在联合索引（a，b，c），那么索引结构中，首先是按照a字段有序的，当a相同的时候，b是有序的，b相同后c才是有序的。但是整体来看，索引中b和c都是无序的。</p><p>所以说，当出现以下查询时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select from table where b = 1 and c = 1</span><br></pre></td></tr></table></figure><p>是无法走索引的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select from table where b = 1 and c = 1 and a = 1</span><br></pre></td></tr></table></figure><p>当有a的时候，是可以走索引的。因为MySQL执行器是有优化的，会把sql改成以下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select from table where a = 1 and b = 1 and c = 1</span><br></pre></td></tr></table></figure><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231103161043899.png" alt="image-20231103161043899"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最左匹配原则&quot;&gt;&lt;a href=&quot;#最左匹配原则&quot; class=&quot;headerlink&quot; title=&quot;最左匹配原则&quot;&gt;&lt;/a&gt;最左匹配原则&lt;/h1&gt;&lt;p&gt;比如我们建立了一个（姓名，年龄）的索引，那么它可以用来匹配按名字的查找，但是按照年龄就不行。这个最左前缀可以</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    <category term="索引" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/%E7%B4%A2%E5%BC%95/"/>
    
    
    <category term="索引" scheme="http://example.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL驱动加载</title>
    <link href="http://example.com/2023/11/02/MySQL%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD/"/>
    <id>http://example.com/2023/11/02/MySQL%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD/</id>
    <published>2023-11-02T01:40:52.000Z</published>
    <updated>2023-11-02T02:47:28.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h1><p>使用Java代码连接MySQL需要走以下流程（使用框架也要做对应的配置）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">driverClassName</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="comment">// 注册驱动</span></span><br><span class="line">    Class.forName(driverClassName);</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里边涉及到一个问题，为什么一定要写一句<code>Class.forName(driverClassName)</code>？</p><blockquote><p>这里首先涉及到Java的类加载机制</p><p>想要使用一个类，则必须要求该类已经被加载到JVM中，加载的过程实际上就是<strong>通过类的全限定名来获取定义该类二进制字节流</strong>，然后将这个字节流所表示的静态存储结构转换为方法去的动态运行时数据结构。同时在在内存中实例化一个java.lang.Class对象，作为方法区中该类的数据访问入口(供我们使用)。</p><p>​—— 出自《深入理解Java虚拟机》</p></blockquote><p>其实在一开始，我并不了解<code>Class.forName()</code>是干嘛的，后边了解到它用作加载类，官方解释为：在运行时动态的加载一个类，返回值为生成的Class对象。所以这行代码的目的，就是将<code>com.mysql.cj.jdbc.Driver</code>类加载到Jvm中了。</p><p>这里，<code>forName</code>方法的具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">// 注意这个true，该参数用来标识在将该类加载后是否进行初始化操作。</span></span><br><span class="line">    <span class="keyword">return</span> forName0(className, <span class="literal">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; forName0(String name, <span class="type">boolean</span> initialize,ClassLoader loader,Class&lt;?&gt; caller);</span><br></pre></td></tr></table></figure><p>到这里，也就是说这一行代码不仅加载了对应的类，也做了初始化操作。</p><p>至于说后续为什么可以直接在<code>DriverManager</code>使用，就要看Driver类里面实现了什么。</p><p>MySQL的驱动实现了Java官方提供的Driver接口，这也是每一个数据库厂商所必须要做的事情。而且他们都需要以下这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title class_">java</span>.sql.Driver &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里也是规范的一种，要求每个厂商都把自己的驱动注册到驱动管理里面</span></span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类中定义了一个静态代码块，静态代码快中创建了一个驱动类实例注册给了DriverManager，而静态代码块的内容会在初始化的过程中执行，所以才能通过<code>DriverManager.getConnection</code>直接获取一个连接。</p><h1 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h1><p>在jdbc4.0之后，使用了spi机制，破坏了双亲委派机制。也就是说我们不再需要写哪一行<code>Class.forName(driverClassName);</code></p><p>我们只需要将对应的驱动类的jar包放到工程的<code>class path</code>下，驱动类会 自动被加载。</p><blockquote><p>SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。</p><p>SPI的目的是为了提前使用某些未被实现的方法。定义一组接口，然后直接通过接口使用它的方法，但是这些方法还未被实现，留给第三方去实现，这就是spi的目的。</p><p>还有一种说法，SPI，为了解耦，从配置里获取某个接口的具体实现类。</p></blockquote><p>为了支持这个新特性，各个数据库厂商的jar包都有一个<code>META-INF/services</code>目录，里面有一个<code>java.sql.Driver</code>，这里指定了driver的全限定名。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231102102705989.png" alt="image-20231102102705989" style="zoom:80%;" /><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>JDBC的driver接口是定义在JDK中的，但是它的实现类，确在一个jar包中，放在classpath下。就存在以下问题：</p><ul><li><code>DriverManager</code>类会加载每个Driver接口的实现类并管理它们，但是<code>DriverManager</code>类自身是 <code>jre/lib/rt.jar</code> 里的类，是由<code>bootstrap classloader</code>加载的。</li><li>根据类加载机制，<strong>某个类需要引用其它类的时候，虚拟机将会用这个类的classloader去加载被引用的类</strong>，但是<code>bootstrap classloader</code>是无法加载这个driver的（<code>bootstrap classloader</code>只能加载Java 的核心类库包）。</li><li>因此只能在DriverManager里强行指定下层classloader来加载Driver实现类，而这就会打破双亲委派模型。</li></ul><p>具体的做法是，添加了一个线程上下文类加载器<code>Thread Context ClassLoader</code>，在启动类加载器中获取应用程序类加载器。<strong>Thread.setContextClassLoaser()</strong> 设置线程上下文类加载器，如果创建线程的时候没有设置，会从父类继承一个，默认应用程序类加载器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;传统方法&quot;&gt;&lt;a href=&quot;#传统方法&quot; class=&quot;headerlink&quot; title=&quot;传统方法&quot;&gt;&lt;/a&gt;传统方法&lt;/h1&gt;&lt;p&gt;使用Java代码连接MySQL需要走以下流程（使用框架也要做对应的配置）：&lt;/p&gt;
&lt;figure class=&quot;highl</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring事务失效场景</title>
    <link href="http://example.com/2023/10/31/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF/"/>
    <id>http://example.com/2023/10/31/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF/</id>
    <published>2023-10-31T02:13:30.000Z</published>
    <updated>2023-10-31T02:15:26.166Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务失效"><a href="#事务失效" class="headerlink" title="事务失效"></a>事务失效</h3><blockquote><p>写在前面</p><p><strong>Spring的事务是通过AOP这种代理的方式实现的。</strong></p></blockquote><p>事务失效的场景有以下几个</p><h4 id="1-访问权限问题"><a href="#1-访问权限问题" class="headerlink" title="1.访问权限问题"></a>1.访问权限问题</h4><p>java的访问权限主要有四种：private、default、protected、public，如果我们加注解的方法不是public，那么事务就会返回空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="comment">// 这里，方法不是public修饰，而spring要求被代理的方法必须是public</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">         saveData(userModel);</span><br><span class="line">         updateData(userModel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-方法用final修饰"><a href="#2-方法用final修饰" class="headerlink" title="2.方法用final修饰"></a>2.方法用final修饰</h4><p>一般用final修饰的方法，都是在该方法不想被子类重写，但是如果将事务方法定义为final，则会导致问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span>&#123;</span><br><span class="line">        saveData(userModel);</span><br><span class="line">        updateData(userModel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring的事务，是通过AOP实现的，而AOP则是通过jdk动态代理或者cglib动态代理，来帮我们生成一个代理类，然后重写对应的方法。final修饰的方法没有办法被重写，所以无法使用事务。</p><h4 id="3-方法内部调用"><a href="#3-方法内部调用" class="headerlink" title="3.方法内部调用"></a>3.方法内部调用</h4><p>在某个Service类的某个方法里，调用另一个事务方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        updateStatus(userModel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateStatus</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">        doSameThing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法，调用的是该方法本身，想要事务生效，要走spring的调用。即需要调用<code>UserService.add()</code>, <code>userService.updateStatus()</code>，spring才能为其生成代理对象，然后事务才能生效，直接调用该方法事务无法生效。</p><p>如何解决：</p><p><strong>1、新增Service类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Servcie</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    prvate ServiceB serviceB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        queryData1();</span><br><span class="line">        queryData2();</span><br><span class="line">        serviceB.doSave(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Servcie</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSave</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        addData1();</span><br><span class="line">        updateData2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、在Service中注入自己（spring三级缓存会解决循环依赖问题）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Servcie</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    prvate ServiceA serviceA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        queryData1();</span><br><span class="line">        queryData2();</span><br><span class="line">        serviceA.doSave(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSave</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        addData1();</span><br><span class="line">        updateData2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、通过AopContent类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Servcie</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        queryData1();</span><br><span class="line">        queryData2();</span><br><span class="line">        ((ServiceA)AopContext.currentProxy()).doSave(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSave</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        addData1();</span><br><span class="line">        updateData2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-未被spring管理"><a href="#4-未被spring管理" class="headerlink" title="4.未被spring管理"></a>4.未被spring管理</h4><p>只有该bean被spring管理的情况下，才能生成代理对象，事务才可以生效。通过@Controller、@Service、@Component、@Repository等注解，可以自动实现bean实例化和依赖注入的功能，如果类没有这类注解，事务无法生效。</p><h4 id="5-多线程调用"><a href="#5-多线程调用" class="headerlink" title="5.多线程调用"></a>5.多线程调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RoleService roleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            roleService.doOtherThing();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOtherThing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存role表数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述案例中，<code>add</code>方法在调用另一个事务方法<code>doOtherThing</code>的时候，开启了一个新的线程，这会导致一个问题，即两个方法不是在同一个线程里面调用的，那么他们两个获取到的数据库连接就不是同一个，那他们就是两个事务。</p><p>原因：<strong>spring的事务是通过数据库连接来实现的，当前线程中保存一个map，key是数据源，value是数据库连接。</strong>通常所说的事务，指的是同一个数据库连接，同一个数据库连接才能同时提交和回滚，不同的线程无法实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;事务失效&quot;&gt;&lt;a href=&quot;#事务失效&quot; class=&quot;headerlink&quot; title=&quot;事务失效&quot;&gt;&lt;/a&gt;事务失效&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;写在前面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring的事务是通过AOP这种代理的方式实现的。&lt;/s</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Spring" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>可重复读隔离级别会出现幻读吗</title>
    <link href="http://example.com/2023/10/30/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%B9%BB%E8%AF%BB%E5%90%97/"/>
    <id>http://example.com/2023/10/30/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%B9%BB%E8%AF%BB%E5%90%97/</id>
    <published>2023-10-30T01:10:16.000Z</published>
    <updated>2023-10-30T01:12:09.965Z</updated>
    
    <content type="html"><![CDATA[<p>放在最前面：<strong>InnoDB的默认事务隔离级别是可重复读</strong></p><h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><p>MySQL的隔离级别包括四种：<strong>读未提交</strong>（read uncommitted）、<strong>读提交</strong>（read committed）、<strong>可重复读</strong>（repeatable read）和<strong>串行化</strong>（serializable ）。</p><ul><li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化，对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><p>前两种隔离级别，是一定会出现幻读。而<strong>可重复读隔离级</strong>别是采用MVCC，即一致性视图来解决<strong>不可重复读的问题</strong>。具体而言，就是采用快照的方式，事务开启的时候会有一个版本号，然后数据是否可见都是基于版本号来判断的，低于该版本号的数据可见，高于的都不可见。</p><p>而可重复读隔离级别下，如果事务A开启后，事务B做了一定的修改并提交事务，在事务A还未提交的时候，对事务B提交的数据做了修改，这个修改是在事务B提交数据的基础上进行修改的，因为不这样的话会导致事务B提交的数据丢失。那也就意味着此次修改会修改数据的事务版本号，后续进行查询的时候，该版本号就可能会导致幻读的问题，以及查询结果与认为中的不一致问题。这也是为什么在可重复读隔离级别下仍然会出现幻读的问题。</p><p>上述问题有一个原因：<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong>当前读意味着会读取最新的数据。</p><p>其实除了Update语句外，select语句如果加了锁，即<code>for share</code>或者<code>for update </code>也是当前读。</p><p>实现可重复读的核心是<strong>一致性读</strong>，而更新数据必须使用<strong>当前读</strong>，这也是为什么会失效的原因。</p><h1 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h1><p>在可重复读的隔离级别下，普通读都是<strong>快照读</strong>，是看不见其他事务修改的数据的，幻读的问题只会发生在<strong>当前读</strong>。即<code>select for update</code>  或者<code>select for share</code>这种。</p><p>幻读是指在一个事务（假定事务A）的两次查询中，第二次查询查到了第一次没有的数据。发生幻读的根本原因是另外的事务（假定事务B）添加或修改了数据，该数据正好满足事务A的查询条件。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>可重复读的隔离级别，在某些场景下是无法防止幻读的问题，需要用到间隙锁来解决。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;放在最前面：&lt;strong&gt;InnoDB的默认事务隔离级别是可重复读&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;隔离级别&quot;&gt;&lt;a href=&quot;#隔离级别&quot; class=&quot;headerlink&quot; title=&quot;隔离级别&quot;&gt;&lt;/a&gt;隔离级别&lt;/h1&gt;&lt;p&gt;MySQL的隔离级别包</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="场景分析" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    
    
    <category term="场景分析" scheme="http://example.com/tags/%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码简单解读</title>
    <link href="http://example.com/2023/10/29/Java/Netty%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%A7%A3%E8%AF%BB/"/>
    <id>http://example.com/2023/10/29/Java/Netty%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%A7%A3%E8%AF%BB/</id>
    <published>2023-10-29T01:56:54.000Z</published>
    <updated>2023-10-29T03:27:38.060Z</updated>
    
    <content type="html"><![CDATA[<p>注：仅仅是尝试看源码，锻炼一下看源码能力，理解并不一定正确。</p><h1 id="Netty的服务端创建"><a href="#Netty的服务端创建" class="headerlink" title="Netty的服务端创建"></a>Netty的服务端创建</h1><p>创建代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">    <span class="comment">// 接收新连接线程，创建新的连接</span></span><br><span class="line">    <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    <span class="comment">// 对应读取数据的线程，用于处理数据读取以及业务逻辑处理</span></span><br><span class="line">    <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    serverBootstrap</span><br><span class="line">        .group(boss, worker)</span><br><span class="line">        <span class="comment">// 这里是接收一个Channel的类型，然后通过反射创建一个工厂类</span></span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        <span class="comment">// 这个NioSocketChannel是Netty设计的</span></span><br><span class="line">        .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        System.out.println(s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).bind(<span class="number">8000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="group-boss-worker"><a href="#group-boss-worker" class="headerlink" title="group(boss, worker)"></a>group(boss, worker)</h2><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerBootstrap</span> <span class="keyword">extends</span> <span class="title class_">AbstractBootstrap</span>&lt;ServerBootstrap, ServerChannel&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> EventLoopGroup childGroup;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ServerBootstrap <span class="title function_">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.group(parentGroup);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.childGroup != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;childGroup set already&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.childGroup = (EventLoopGroup)ObjectUtil.checkNotNull(childGroup, <span class="string">&quot;childGroup&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，将boss也就是parentGroup传递给了父类的<code>group</code>方法，即<code>AbstractBootstrap</code>，而将worker传递给了<code>ServerBootstrap</code> ，并将ServerBootstrap返回。</p><p>父类的group方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBootstrap</span>&lt;B <span class="keyword">extends</span> <span class="title class_">AbstractBootstrap</span>&lt;B, C&gt;, C <span class="keyword">extends</span> <span class="title class_">Channel</span>&gt; <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> EventLoopGroup group;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> B <span class="title function_">group</span><span class="params">(EventLoopGroup group)</span> &#123;</span><br><span class="line">        ObjectUtil.checkNotNull(group, <span class="string">&quot;group&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.group != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;group set already&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.group = group;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.self();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对于这个group方法，做的事情比较简单，将两个<code>NioEventLoopGroup</code>传递给<code>ServerBootstrap</code>，然后将赋值后的<code>ServerBootstrap</code>返回。</p><h2 id="channel-NioServerSocketChannel-class"><a href="#channel-NioServerSocketChannel-class" class="headerlink" title="channel(NioServerSocketChannel.class)"></a>channel(NioServerSocketChannel.class)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> B <span class="title function_">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.channelFactory((io.netty.channel.ChannelFactory)(<span class="keyword">new</span> <span class="title class_">ReflectiveChannelFactory</span>((Class)ObjectUtil.checkNotNull(channelClass, <span class="string">&quot;channelClass&quot;</span>))));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码涉及到一个工厂类的创建<code>new ReflectiveChannelFactory()</code>，该工厂类的创建需要接收传入的<code>channelClass</code></p><p>工厂类的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectiveChannelFactory</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Channel</span>&gt; <span class="keyword">implements</span> <span class="title class_">ChannelFactory</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; constructor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReflectiveChannelFactory</span><span class="params">(Class&lt;? extends T&gt; clazz)</span> &#123;</span><br><span class="line">        ObjectUtil.checkNotNull(clazz, <span class="string">&quot;clazz&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.constructor = clazz.getConstructor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Class &quot;</span> + StringUtil.simpleClassName(clazz) + <span class="string">&quot; does not have a public non-arg constructor&quot;</span>, var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是通过反射，获取了传入类的构造方法。</p><p>另一个方法就是<code>this.channelFactory()</code>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> B <span class="title function_">channelFactory</span><span class="params">(io.netty.channel.ChannelFactory&lt;? extends C&gt; channelFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.channelFactory((ChannelFactory)channelFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> B <span class="title function_">channelFactory</span><span class="params">(ChannelFactory&lt;? extends C&gt; channelFactory)</span> &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(channelFactory, <span class="string">&quot;channelFactory&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.channelFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;channelFactory set already&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.channelFactory = channelFactory;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.self();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做的事情就是将上一步创建的<code>ReflectiveChannelFactory</code>赋值给<code>AbstractBootstrap</code>的<code>ChannelFactory</code>。</p><p>因为在创建<code>ReflectiveChannelFactory</code>时，获取到了传入class的构造方法，就可以创建对应的对象。</p><h2 id="childHandler-new-ChannelInitializer"><a href="#childHandler-new-ChannelInitializer" class="headerlink" title="childHandler(new ChannelInitializer(){}"></a>childHandler(new ChannelInitializer<NioSocketChannel>(){}</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerBootstrap</span> <span class="keyword">extends</span> <span class="title class_">AbstractBootstrap</span>&lt;ServerBootstrap, ServerChannel&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ChannelHandler childHandler;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ServerBootstrap <span class="title function_">childHandler</span><span class="params">(ChannelHandler childHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.childHandler = (ChannelHandler)ObjectUtil.checkNotNull(childHandler, <span class="string">&quot;childHandler&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是一个成员属性的赋值，主要看创建<code>ChannelHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ChannelInitializer</span>&lt;C <span class="keyword">extends</span> <span class="title class_">Channel</span>&gt; <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 这是一个抽象方法，必须实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(C var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 案例中重写的代码如下：</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">    nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="comment">// 重写的这个方法就是我们要做的业务逻辑处理</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">// 这个方法，客户端传递数据时应该会调用</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 案例中方法重写的代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;I&gt; <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext var1, I var2)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Netty客户端创建"><a href="#Netty客户端创建" class="headerlink" title="Netty客户端创建"></a>Netty客户端创建</h1><p>创建代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">    <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">    bootstrap.group(group)</span><br><span class="line">        .channel(NioSocketChannel.class)</span><br><span class="line">        .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8000</span>).channel();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: hello world&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就存在了第一个区别<code> ServerBootstrap</code> 和 <code>Bootstrap</code></p><p><code>Bootstrap</code>并没有自己的group方法，它是直接调用了父类的group，也就是说传入的group直接赋值给了<code>AbstractBootstrap</code>的<code>EventLoopGroup</code>。</p><p>其他的代码与服务端差不多，主要看<code>writeAndFlush</code>和<code>connect</code></p><h2 id="writeAndFlush"><a href="#writeAndFlush" class="headerlink" title="writeAndFlush"></a>writeAndFlush</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractChannel</span> <span class="keyword">extends</span> <span class="title class_">DefaultAttributeMap</span> <span class="keyword">implements</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line">    <span class="comment">// 默认的管道</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultChannelPipeline pipeline;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ChannelFuture <span class="title function_">writeAndFlush</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.pipeline.writeAndFlush(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultChannelPipeline</span> <span class="keyword">implements</span> <span class="title class_">ChannelPipeline</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext tail;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title function_">writeAndFlush</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.tail.writeAndFlush(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractChannelHandlerContext</span> <span class="keyword">implements</span> <span class="title class_">ChannelHandlerContext</span>, ResourceLeakHint &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> EventExecutor executor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultChannelPipeline pipeline;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ChannelFuture <span class="title function_">writeAndFlush</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.writeAndFlush(msg, <span class="built_in">this</span>.newPromise());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ChannelPromise <span class="title function_">newPromise</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(<span class="built_in">this</span>.channel(), <span class="built_in">this</span>.executor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Channel <span class="title function_">channel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.pipeline.channel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EventExecutor <span class="title function_">executor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (EventExecutor)(<span class="built_in">this</span>.executor == <span class="literal">null</span> ? <span class="built_in">this</span>.channel().eventLoop() : <span class="built_in">this</span>.executor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ChannelFuture <span class="title function_">writeAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.write(msg, <span class="literal">true</span>, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(Object msg, <span class="type">boolean</span> flush, ChannelPromise promise)</span> &#123;</span><br><span class="line">        ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里，如果promise不可用，那么就释放消息</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isNotValidPromise(promise, <span class="literal">true</span>)) &#123;</span><br><span class="line">                ReferenceCountUtil.release(msg);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException var8) &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">            <span class="keyword">throw</span> var8;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">AbstractChannelHandlerContext</span> <span class="variable">next</span> <span class="operator">=</span> <span class="built_in">this</span>.findContextOutbound(flush ? <span class="number">98304</span> : <span class="string">&#x27;耀&#x27;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> <span class="built_in">this</span>.pipeline.touch(msg, next);</span><br><span class="line">        <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">        <span class="comment">// 这里是判断当前的任务是否在循环当中</span></span><br><span class="line">        <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">                next.invokeWriteAndFlush(m, promise);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next.invokeWrite(m, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AbstractChannelHandlerContext.<span class="type">WriteTask</span> <span class="variable">task</span> <span class="operator">=</span> AbstractChannelHandlerContext.WriteTask.newInstance(next, m, promise, flush);</span><br><span class="line">            <span class="keyword">if</span> (!safeExecute(executor, task, promise, m, !flush)) &#123;</span><br><span class="line">                task.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;注：仅仅是尝试看源码，锻炼一下看源码能力，理解并不一定正确。&lt;/p&gt;
&lt;h1 id=&quot;Netty的服务端创建&quot;&gt;&lt;a href=&quot;#Netty的服务端创建&quot; class=&quot;headerlink&quot; title=&quot;Netty的服务端创建&quot;&gt;&lt;/a&gt;Netty的服务端创建&lt;/h1</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="源码分析" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>传统网络编程与NIO编程</title>
    <link href="http://example.com/2023/10/26/Java/%E4%BC%A0%E7%BB%9F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2023/10/26/Java/%E4%BC%A0%E7%BB%9F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO%E7%BC%96%E7%A8%8B/</id>
    <published>2023-10-26T02:47:23.000Z</published>
    <updated>2023-10-28T03:38:02.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传统网络编程"><a href="#传统网络编程" class="headerlink" title="传统网络编程"></a>传统网络编程</h1><p>首先看一段最传统的Java网络编程。</p><p>服务端代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8000</span>);</span><br><span class="line">        <span class="comment">// 接收新连接的线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 阻塞方法获取新的连接</span></span><br><span class="line">                    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 每一个新的连接都创建一个线程，负责读取数据</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                        <span class="type">int</span> len;</span><br><span class="line">                        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">                            <span class="comment">// 按字节流读取数据</span></span><br><span class="line">                            <span class="keyword">while</span> ((len = inputStream.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, len));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).start();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 我自己运行时，这里只创建了一次连接，然后没3s发送一次数据</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8000</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 网络传输都是传输的字节</span></span><br><span class="line">                    socket.getOutputStream().write((<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot; hello world&quot;</span>).getBytes());</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，服务端启动时创建了一个线程，建立了<code>ServerSocket</code>，循环的等待客户端的连接。客户端每次连接，服务端都会创建一个新的线程去处理请求，然后读取数据。</p><p>这种模型在客户端数量比较小的时候是没问题的，但是如果客户端数量较多，服务端就需要创建很多的线程，线程的创建比较消耗成本，而且线程数过多时，CPU调度导致的线程切换也会影响性能。</p><p>主要有以下三个问题：</p><ol><li>创建太多线程，而线程是很宝贵的资源，同一时刻大量线程处于阻塞会浪费资源。</li><li>线程切换效率低下。</li><li>IO编程中，数据传输都是以字节为单位。</li></ol><p>为了解决上述问题，引入了NIO，即同步非阻塞IO。</p><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p>在NIO中，只会创建一个线程去进行while循环，该线程监控所有的客户端连接，而不会像传统的有多少个客户端连接就创建多少个线程去进行while循环。</p><p>传统的模型中，在每一时刻，只有少数线程会有数据读写需求，而没有数据需要读写的就白白浪费了CPU资源。NIO中，通过将所有的客户端连接都注册到selector上，通过检测selector上是否有数据数据需要读写，就可以达到批量读取数据的目的。</p><p>这样，就解决了创建太多线程浪费资源和CPU频繁切换线程导致的性能问题。而传统IO是面向字节流，读取数据后需要自己缓存，流中就不存在该数据。而NIO的读写是面向Buffer的，解决了数据只能用字节传输的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">serverSelector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">clientSelector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 对应IO编程中服务端启动</span></span><br><span class="line">                <span class="type">ServerSocketChannel</span> <span class="variable">listenerChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">                listenerChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8000</span>));</span><br><span class="line">                listenerChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                listenerChannel.register(serverSelector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 检测是否有新的连接，1指的是阻塞时间为1ms</span></span><br><span class="line">                    <span class="keyword">if</span> (serverSelector.select(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Set&lt;SelectionKey&gt; set = serverSelector.selectedKeys();</span><br><span class="line">                        Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();</span><br><span class="line">                        <span class="comment">// 遍历所有有数据的SelectionKey</span></span><br><span class="line">                        <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                            <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">                            <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="comment">// 这里就是区别，当有一个新的连接请求到来时，不再创建一个线程，而是直接注册到clientSelector</span></span><br><span class="line">                                    <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> ((ServerSocketChannel) selectionKey.channel()).accept();</span><br><span class="line">                                    clientChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                                    clientChannel.register(clientSelector, SelectionKey.OP_READ);</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    <span class="comment">// 每个客户端只注册一次就可以了</span></span><br><span class="line">                                    keyIterator.remove();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 批量轮询是否有哪些连接的数据可读，1同样为阻塞时间</span></span><br><span class="line">                    <span class="keyword">if</span> (clientSelector.select(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Set&lt;SelectionKey&gt; set = clientSelector.selectedKeys();</span><br><span class="line">                        Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();</span><br><span class="line">                        <span class="comment">// 轮询所有已经注册了的客户端，然后判断哪一个可读</span></span><br><span class="line">                        <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                            <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">                            <span class="comment">// 这里是判断可读</span></span><br><span class="line">                            <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                                    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                                    <span class="comment">// 面向buffer</span></span><br><span class="line">                                    clientChannel.read(byteBuffer);</span><br><span class="line">                                    byteBuffer.flip();</span><br><span class="line">                                    System.out.println(Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    <span class="comment">// 这里为什么移除，是否是因为每个客户端传输一次数据后，就从注册中移除</span></span><br><span class="line">                                    keyIterator.remove();</span><br><span class="line">                                    key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NIO编程的核心思路：</p><ol><li>NIO 模型中通常会有两个线程，每个线程绑定一个轮询器 selector ，在上面的例子中 serverSelector负责轮询是否有新的连接，clientSelector负责轮询连接是否有数据可读。</li><li>服务端监测到新的连接之后，不再创建一个新的线程，而是直接将新连接绑定到clientSelector上， 这样就不用 IO 模型中 每个连接一个while循环。</li><li>clientSelector被一个 while 死循环包裹着，如果在某一时刻有多条连接有数据可读，那么通过 clientSelector.select(1)方法可以轮询出来，进而批量处理。</li><li>数据读写面向Buffer。</li></ol><p>但是不难看出，整个编码变得极其复杂。所有，就有了Netty。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;传统网络编程&quot;&gt;&lt;a href=&quot;#传统网络编程&quot; class=&quot;headerlink&quot; title=&quot;传统网络编程&quot;&gt;&lt;/a&gt;传统网络编程&lt;/h1&gt;&lt;p&gt;首先看一段最传统的Java网络编程。&lt;/p&gt;
&lt;p&gt;服务端代码如下：&lt;/p&gt;
&lt;figure class=&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/"/>
    
    <category term="netty" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/netty/"/>
    
    
    <category term="网络编程" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>单例模式的双重锁检查</title>
    <link href="http://example.com/2023/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8F%8C%E9%87%8D%E9%94%81%E6%A3%80%E6%9F%A5/"/>
    <id>http://example.com/2023/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8F%8C%E9%87%8D%E9%94%81%E6%A3%80%E6%9F%A5/</id>
    <published>2023-10-24T02:52:22.000Z</published>
    <updated>2023-10-24T03:08:47.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一般的单例模式"><a href="#一般的单例模式" class="headerlink" title="一般的单例模式"></a>一般的单例模式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            uniqueSingleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在多线程情况下，可能会导致多个实例：</p><table><thead><tr><th><strong>Time</strong></th><th>Thread A</th><th>Thread B</th></tr></thead><tbody><tr><td>T1</td><td>检查到<code>uniqueSingleton</code>为空</td><td></td></tr><tr><td>T2</td><td></td><td>检查到<code>uniqueSingleton</code>为空</td></tr><tr><td>T3</td><td></td><td>初始化对象A</td></tr><tr><td>T4</td><td></td><td>返回对象A</td></tr><tr><td>T5</td><td>初始化对象B</td><td></td></tr><tr><td>T6</td><td>返回对象B</td><td></td></tr></tbody></table><p>这种场景，就会创建两次对象。</p><h1 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h1><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            uniqueSingleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法也存在问题，加锁的粒度太大了，只有在创建对象时才需要加锁，后续获取对象时并不需要加锁。</p><h1 id="双重锁检查"><a href="#双重锁检查" class="headerlink" title="双重锁检查"></a>双重锁检查</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">                    <span class="comment">// 可能存在问题</span></span><br><span class="line">                    uniqueSingleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写，顺序就变成下面这样：</p><ol><li>先判断对象是否存在，不存在则加锁。</li><li>加完锁之后再次判断对象是否存在。</li><li>不存在则创建。</li></ol><p>双重加锁是因为如果多个线程同时通过了第一次判断，那么这几个线程中会有一个线程加锁成功，然后创建对象，后续线程在获取锁之后，就不用再继续创建对象。</p><h2 id="存在的隐患"><a href="#存在的隐患" class="headerlink" title="存在的隐患"></a>存在的隐患</h2><p>在实例化一个对象时，可以分为以下步骤：</p><ol><li>分配内存空间</li><li>初始化对象</li><li>将对象指向刚分配的内存空间</li></ol><p>但是编译器在为了执行速度，可能会进行<strong>指令重排序</strong>，那么顺序就有可能如下：</p><ol><li>分配内存空间</li><li>将对象指向刚分配的内存空间</li><li>初始化对象</li></ol><p>现在考虑如下场景：</p><table><thead><tr><th><strong>Time</strong></th><th>Thread A</th><th>Thread B</th></tr></thead><tbody><tr><td>T1</td><td>检查到<code>uniqueSingleton</code>为空</td><td></td></tr><tr><td>T2</td><td>获取锁</td><td></td></tr><tr><td>T3</td><td>第二次检查<code>uniqueSingleton</code>为空</td><td></td></tr><tr><td>T4</td><td>为<code>uniqueSingleton</code>分配空间</td><td></td></tr><tr><td>T5</td><td>将<code>uniqueSingleton</code>指向内存空间</td><td></td></tr><tr><td>T6</td><td></td><td>检查到<code>uniqueSingleton</code>不为空</td></tr><tr><td>T7</td><td></td><td>访问<code>uniqueSingleton</code>（此时对象还未完成初始化）</td></tr><tr><td>T8</td><td>初始化将<code>uniqueSingleton</code></td><td></td></tr></tbody></table><p>这种情况下，线程B就访问到了一个还未初始化完成的对象。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>使用<code>volatile</code>关键字禁止指令重排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">                    uniqueSingleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一般的单例模式&quot;&gt;&lt;a href=&quot;#一般的单例模式&quot; class=&quot;headerlink&quot; title=&quot;一般的单例模式&quot;&gt;&lt;/a&gt;一般的单例模式&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JDK动态代理和CGlib动态代理</title>
    <link href="http://example.com/2023/10/23/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGlib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://example.com/2023/10/23/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGlib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>2023-10-23T02:57:21.000Z</published>
    <updated>2023-11-02T02:54:16.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h1><p>JDK动态代理是Spring动态代理的默认实现方法。如果我们的类实现了一个接口，那么Spring就会使用这种方法，因为使用JDK动态代理的一个缺陷就是代理的类必须实现接口。</p><p><code>JDK</code>实现动态代理需要两个组件，首先第一个就是<code>InvocationHandler</code>接口。我们在使用<code>JDK</code>的动态代理时，需要编写一个类，去实现这个接口，然后重写<code>invoke</code>方法，这个方法其实就是我们提供的代理方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里是一个动态的代理类，只需要传入对应的类，就会执行对应类的对应方法</span></span><br><span class="line"><span class="comment"> * 也就是说我们只用实现这一个代理类就行了，我们所有相同的代理实现都可以用该类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里的Method，我们通过new Proxy创建的一个代理对象，调用它的哪个方法，这里传过来的就是哪个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object o, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------插入前置通知代码-------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行相应的目标方法，rs是方法的返回值</span></span><br><span class="line">        <span class="comment">// 这里是执行被代理对象的方法。由于被代理对象是传进来的，所以一个方法就可以了。</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">rs</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;------插入后置处理代码-------------&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> rs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后<code>JDK</code>动态代理需要使用的第二个组件就是<code>Proxy</code>这个类，我们可以通过这个类的<code>newProxyInstance</code>方法，返回一个代理对象。生成的代理类实现了原来那个类的所有接口，并对接口的方法进行了代理，我们通过代理对象调用这些方法时，底层将通过反射，调用我们实现的<code>invoke</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IHello</span> <span class="variable">iHello2</span> <span class="operator">=</span> (IHello) Proxy.newProxyInstance(IHello.class.getClassLoader(), <span class="comment">// 加载接口的类加载器</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;IHello.class&#125;, <span class="comment">// 一组接口</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(<span class="keyword">new</span> <span class="title class_">HelloImpl</span>())); <span class="comment">// 自定义的InvocationHandle</span></span><br><span class="line"><span class="comment">// 这里执行哪个方法，传给MyInvocationHandler的Method就是哪个方法</span></span><br><span class="line">iHello2.sayHello();</span><br></pre></td></tr></table></figure><p>JDK动态代理的要求：</p><ul><li>委托类和代理类实现的公共接口</li><li>实现公共接口的具体委托类</li><li>InvocationHandler接口被Proxy类回调处理，一般实现 InvocationHandler 接口的类具有委托类引用，接口方法 invoke 中添加公共代码并调用委托类的接口方法</li><li>JDK提供生成动态代理类的核心类Proxy</li></ul><p>JDK的动态代理，是创建了一个匿名类来继承Proxy类，然后实现了需要被代理的接口。因为Java只能单继承，所以代理类不能通过继承来实现。</p><h1 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h1><p>若需要代理的类没有实现接口，此时<code>JDK</code>的动态代理将没有办法使用，于是<code>Spring</code>会使用<code>CGLib</code>的动态代理来生成代理对象。</p><p>CGLib是基于继承的，如果对应的类无法被继承，或者对应方法无法被重写，那么CGLib也无法生成代理对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JDK动态代理&quot;&gt;&lt;a href=&quot;#JDK动态代理&quot; class=&quot;headerlink&quot; title=&quot;JDK动态代理&quot;&gt;&lt;/a&gt;JDK动态代理&lt;/h1&gt;&lt;p&gt;JDK动态代理是Spring动态代理的默认实现方法。如果我们的类实现了一个接口，那么Spring就会</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Spring" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal源码</title>
    <link href="http://example.com/2023/10/21/Java/ThreadLocal%E6%BA%90%E7%A0%81/"/>
    <id>http://example.com/2023/10/21/Java/ThreadLocal%E6%BA%90%E7%A0%81/</id>
    <published>2023-10-21T07:04:29.000Z</published>
    <updated>2023-10-22T03:22:34.445Z</updated>
    
    <content type="html"><![CDATA[<p>以下源码是基于JDK11。</p><h1 id="Get以及Set"><a href="#Get以及Set" class="headerlink" title="Get以及Set"></a>Get以及Set</h1><p>一开始，一直在疑惑这个ThreadLocal到底是用来干嘛的，其实他可以用来存储一些变量，这些变量普通存储会由于被多线程访问或导致一些并发问题，用ThreadLocal存储，就会为每一个线程存储它自己的副本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这一步，它首先获取到了当前的线程，也就是说哪一个线程去调用ThreadLocal，就获取到哪一个线程。</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 这一步就是获取到线程对应的ThreadLocalMap，后文会有具体的结构</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="built_in">this</span>.getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里就是从ThreadLocalMap中获取到对应的元素</span></span><br><span class="line">        ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果之前的map为空，则调用该方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这个初始化值为null</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.initialValue();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 这里又重新判断了一次，应该是考虑到其他的线程可能在此之间已经创建了对应的map</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="built_in">this</span>.getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里判断map为空，那么就创建新的map</span></span><br><span class="line">        <span class="built_in">this</span>.createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> TerminatingThreadLocal) &#123;</span><br><span class="line">        TerminatingThreadLocal.register((TerminatingThreadLocal)<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    <span class="comment">// 这个threadLocals的类型是ThreadLocalMap</span></span><br><span class="line">    <span class="comment">// 这个创建，是为当前的线程创建一个ThreadLocalMap</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">// 这一步set的设计思路与get一致，都是获取到当前的线程之后，再进行操作。</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="built_in">this</span>.getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实中源码中可以看出，get和set操作都是先获取到当前线程，而每一个Thread中有一个变量ThreadLocalMap，然后去该变量中获取对应的元素。也就是说在每一个Thread中存储了对应的变量，这样就避免了并发访问的问题。</p><h1 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h1><p>ThreadLocalMap是ThreadLocal的一个内部类，ThreadLocalMap内部还有一个内部类，表示ThreadLocalMap的每一个节点。</p><p>首先看ThreadLocalMap的两个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">    <span class="comment">// creatMap调用的构造方法就是该方法。</span></span><br><span class="line">    <span class="comment">// 这里创建该ThreadLocalMap时，需要传入ThreadLocal，其目的就是为了获取对应的hash值，然后将该元素放入对应的下标即可。</span></span><br><span class="line">    <span class="comment">// 而且要获取到该ThreadLocal的table，因为元素的值需要与ThreadLocal绑定，我们要能通过ThreadLocal来拿到对应的元素。</span></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        <span class="built_in">this</span>.table = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry[<span class="number">16</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; <span class="number">15</span>;</span><br><span class="line">        <span class="built_in">this</span>.table[i] = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry(firstKey, firstValue);</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">this</span>.setThreshold(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ThreadLocalMap</span><span class="params">(ThreadLocal.ThreadLocalMap parentMap)</span> &#123;</span><br><span class="line">        ThreadLocal.ThreadLocalMap.Entry[] parentTable = parentMap.table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> parentTable.length;</span><br><span class="line">        <span class="built_in">this</span>.setThreshold(len);</span><br><span class="line">        <span class="built_in">this</span>.table = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry[len];</span><br><span class="line">        ThreadLocal.ThreadLocalMap.Entry[] var4 = parentTable;</span><br><span class="line">        <span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> parentTable.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="number">0</span>; var6 &lt; var5; ++var6) &#123;</span><br><span class="line">            ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> var4[var6];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                ThreadLocal&lt;Object&gt; key = (ThreadLocal)e.get();</span><br><span class="line">                <span class="keyword">if</span> (key != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> key.childValue(e.value);</span><br><span class="line">                    ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry(key, value);</span><br><span class="line">                    <span class="type">int</span> h;</span><br><span class="line">                    <span class="keyword">for</span>(h = key.threadLocalHashCode &amp; len - <span class="number">1</span>; <span class="built_in">this</span>.table[h] != <span class="literal">null</span>; h = nextIndex(h, len)) &#123;&#125;</span><br><span class="line">                    <span class="built_in">this</span>.table[h] = c;</span><br><span class="line">                    ++<span class="built_in">this</span>.size;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ThreadLocalMap的一个静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="built_in">super</span>(k);</span><br><span class="line">            <span class="built_in">this</span>.value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的Entry，就是对应存储的具体值，比如说如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该代码中，Entry就是一个City</span></span><br><span class="line">ThreadLocal&lt;City&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>每一个Thread有一个变量ThreadLocalMap，在创建该变量时，需要传入首个key以及value，其中key是一个ThreadLocal。</p><p>为什么要传入这个ThreadLocal呢？</p><p>我的理解是ThreadLocal要与对应的Thread绑定。换句话说，我们在使用ThreadLocal时，一般都是在多个线程中通过ThreadLocal来获取一个本该是共享的变量，而在ThreadLocal内部，它会先获取到当前线程，然后调用该线程的ThreadLocalMap来返回线程所需要的变量。所以，创建ThreadLocalMap时就需要传入一个ThreadLocal，方便后续获取值。</p><h2 id="Get以及Set-1"><a href="#Get以及Set-1" class="headerlink" title="Get以及Set"></a>Get以及Set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里，是根据传入的key先获取到hash值，然后去table的对应下标获取元素，存在则直接返回，不存在则调用getEntryAfterMiss</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ThreadLocal.ThreadLocalMap.Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; <span class="built_in">this</span>.table.length - <span class="number">1</span>;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> <span class="built_in">this</span>.table[i];</span><br><span class="line">    <span class="keyword">return</span> e != <span class="literal">null</span> &amp;&amp; e.get() == key ? e : <span class="built_in">this</span>.getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里就是遍历table所有的元素（该ThreadLocalMap存储的所有元素），找是否有key匹配的，有就直接返回</span></span><br><span class="line"><span class="comment"> * 如果table中某一个值为空，则调用expungeStaleEntry方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ThreadLocal.ThreadLocalMap.Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, ThreadLocal.ThreadLocalMap.Entry e)</span> &#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = <span class="built_in">this</span>.table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length; e != <span class="literal">null</span>; e = tab[i]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = (ThreadLocal)e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.expungeStaleEntry(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法的主要目的是为了清除对应下标的元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = <span class="built_in">this</span>.table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">    --<span class="built_in">this</span>.size;</span><br><span class="line"></span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 这里是遍历该ThreadLocalMap的Entry数组，也就是看该ThreadLocalMap存储的所有元素</span></span><br><span class="line">    <span class="keyword">for</span>(i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = nextIndex(i, len)) &#123;</span><br><span class="line">       <span class="comment">// 获取到对应的ThreadLocal</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = (ThreadLocal)e.get();</span><br><span class="line">        <span class="comment">// 这里应该是考虑对应的ThreadLocal已经被释放了</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">            --<span class="built_in">this</span>.size;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这几步操作，就是为了调整元素位置，将他们放在合适的位置，以减小tab大小</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                <span class="comment">// 这一步是循环，断开强引用</span></span><br><span class="line">                <span class="keyword">for</span>(tab[i] = <span class="literal">null</span>; tab[h] != <span class="literal">null</span>; h = nextIndex(h, len)) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = <span class="built_in">this</span>.table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = (ThreadLocal)e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++<span class="built_in">this</span>.size;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= <span class="built_in">this</span>.threshold) &#123;</span><br><span class="line">        <span class="built_in">this</span>.rehash();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value, <span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = <span class="built_in">this</span>.table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line"></span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = prevIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = prevIndex(i, len)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = (ThreadLocal)e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot) &#123;</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.cleanSomeSlots(<span class="built_in">this</span>.expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot) &#123;</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry(key, value);</span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot) &#123;</span><br><span class="line">        <span class="built_in">this</span>.cleanSomeSlots(<span class="built_in">this</span>.expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，ThreadLocalMap是用Entry[]去保存value，而Entry继承了WeakReference，查资料得知这里Entry的key是弱引用，意味着当ThreadLocal没有外部强引用时，会被GC回收，而对应的该ThreadLocal对应的value却不会被回收，若当前线程一直没有结束，会存在一条强引用链, value也会一直累加导致内存泄露。</p><p>而<code>expungeStaleEntry</code>方法就是为了解决上述问题。主动去清理key为空的ThreadLocal对应的value。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以下源码是基于JDK11。&lt;/p&gt;
&lt;h1 id=&quot;Get以及Set&quot;&gt;&lt;a href=&quot;#Get以及Set&quot; class=&quot;headerlink&quot; title=&quot;Get以及Set&quot;&gt;&lt;/a&gt;Get以及Set&lt;/h1&gt;&lt;p&gt;一开始，一直在疑惑这个ThreadLocal到底是</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="源码分析" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>如何使用3m内存来找到1G文件中词频前100的单词</title>
    <link href="http://example.com/2023/10/17/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A81m%E5%86%85%E5%AD%98%E6%9D%A5%E6%89%BE%E5%88%B01G%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%8D%E9%A2%91%E5%89%8D100%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <id>http://example.com/2023/10/17/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A81m%E5%86%85%E5%AD%98%E6%9D%A5%E6%89%BE%E5%88%B01G%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%8D%E9%A2%91%E5%89%8D100%E7%9A%84%E5%8D%95%E8%AF%8D/</id>
    <published>2023-10-17T01:36:12.000Z</published>
    <updated>2023-11-04T01:00:43.157Z</updated>
    
    <content type="html"><![CDATA[<p>题目原场景与标题相似，只不过文件的每一行是一个单词，然后在内存只有3m空间，需要获取到1G文件中所有单词频率前100的单词。</p><p>想到了用bitmap。</p><h1 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h1><p>bitmap往往是做一个映射，来减小数原数据占用空间的大小。在Java中，一个int类型的大小是32位，也就是32bit，它占4字节，也就是4byte，现考虑如下场景：</p><p>现在要存储三个数字，比如说5，16，20，如果用一个int数组存储，那么就需要3 * 4 &#x3D; 12字节，但是我们可以换一个思路，比如说使用byte数组，1byte是8位，也就是说可以通过这8位的值位0或1，来代表是否存在数字0-7。那么原来的4字节，就可以代表数字0-31是否存在于集合当中。具体如下表所示</p><table><thead><tr><th>数组值</th><th>1</th><th>1</th><th>0</th><th>0</th><th>0</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>下标</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>说明</td><td>值为1，代表存在数字0</td><td>值为1，代表存在数字1</td><td>值为0，代表不存在数字2</td><td>值为0，代表不存在数字3</td><td>值为0，代表不存在数字4</td><td>值为0，代表不存在数字5</td><td>值为1，代表存在数字6</td><td>值为1，代表存在数字7</td></tr></tbody></table><p>通过这种转换，我们就使用了1字节存储原来需要16字节（4个数字0，1，6，7）才可以存储的集合。</p><p>在具体的实现中，我们初始化一个byte数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><p>我们在计算某一个数字是否存在时，我们要先计算该数字在byte[]数组中的下标，当计算完下标之后，我们就需要将该数字移位，计算出它在该下标在哪一位。</p><p>这里的bytes[i]就是上面表格中的样子。每一个byte的大小为2^8 - 1，可以表示0~2^8 - 1。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>1GB大小的文件，全部存储单词，我们假设平均每个单词的长度为10，查阅资料得知Java中空字符串占用40字节，我们做一个大致的估算，一个单词长度为10，那么每个单词占用空间大小就是60字节（一个char[]数组中每个字符占2字节）。那么这1GB大小的文件当中一共有1 * 1024 * 1024 &#x2F; 60 &#x3D; 17476个单词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象头（<span class="number">8</span> 字节）+ 引用 (<span class="number">4</span> 字节 )  + <span class="type">char</span> 数组（<span class="number">16</span> 字节）+ <span class="number">1</span>个 <span class="type">int</span>（<span class="number">4</span>字节）+ <span class="number">1</span>个<span class="type">long</span>（<span class="number">8</span>字节）= <span class="number">40</span> 字节</span><br></pre></td></tr></table></figure><p>一个最笼统的思路，我们可以对每一个单词做一个Hash，然后将他映射到一个bitmap上，通过这种转化，原先1G大小的单词，就可以通过该映射存储到对应的位置。</p><p>但是这种思路好像没办法解决对应的问题，因为bitmap只能存储0或者1，如果存在两个相同的单词，并不能够进行统计，并且还有Hash冲突的可能。</p><h1 id="另外一个思路"><a href="#另外一个思路" class="headerlink" title="另外一个思路"></a>另外一个思路</h1><p>这是一个经典的top k的问题，所以说一般采用大根堆或者小根堆来处理。但是文件比较大，内存又比较小，这时就引入另一种解决问题的方案，分治。</p><p>即我们可以先通过hash，将这一个文件打散，这里可以确定地一点是，相同地单词一定可以hash到一个文件中，不同的单词有可能hash到一个文件中，可以经过多次打散，具体可以看内存中可以读入多少个单词。然后记录每个文件中的top k ，最终将所有文件的统计结果做一个合并即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目原场景与标题相似，只不过文件的每一行是一个单词，然后在内存只有3m空间，需要获取到1G文件中所有单词频率前100的单词。&lt;/p&gt;
&lt;p&gt;想到了用bitmap。&lt;/p&gt;
&lt;h1 id=&quot;bitmap&quot;&gt;&lt;a href=&quot;#bitmap&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="场景分析" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    
    
    <category term="场景分析" scheme="http://example.com/tags/%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Spring的事务传播</title>
    <link href="http://example.com/2023/10/15/Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD/"/>
    <id>http://example.com/2023/10/15/Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD/</id>
    <published>2023-10-15T07:39:21.000Z</published>
    <updated>2023-10-30T08:51:44.373Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务传播"><a href="#事务传播" class="headerlink" title="事务传播"></a>事务传播</h3><blockquote><p>写在前面</p><p><strong>Spring的事务是通过AOP这种代理的方式实现的。</strong></p></blockquote><p>事务传播就是多个事务方法相互调用时，事务如何在这些方法间传播。比如事务方法A调用了方法B，那么方法B有无事务以及方法B对事务的要求不同都会对方法A的事务执行造成影响，而方法A的事务对方法B的事务执行也有影响，这种影响就由两个方法定义的事务传播类型所决定。</p><p>spring中的事务传播定义了七种类型：<strong>REQUIRED、SUPPORTS、MANDATORY、REQUIRES_NEW、NOT_SUPPORTED、NEVER、NESTED</strong>。这七种类型以枚举的形式存储在<code>org.springframework.transaction.annotation</code>的<code>Propagation</code>。</p><p>下面根据集体的例子来解释每一个情况。</p><p>假设现在有两个方法A和B，A会在ATable中插入一条数据，B会在BTable中插入一条数据。伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将传入参数a存入ATable</span></span><br><span class="line">pubilc <span class="keyword">void</span> <span class="title function_">A</span><span class="params">(a)</span>&#123;</span><br><span class="line">    insertIntoATable(a);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将传入参数b存入BTable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">B</span><span class="params">(b)</span>&#123;</span><br><span class="line">    insertIntoBTable(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设没有事务时，如下场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMain</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 调用A入参a1</span></span><br><span class="line">    A(a1);</span><br><span class="line">    <span class="comment">// 调用testB</span></span><br><span class="line">    testB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 调用B入参b1</span></span><br><span class="line">    B(b1);</span><br><span class="line">    <span class="comment">// 发生异常抛出</span></span><br><span class="line">    <span class="keyword">throw</span> Exception;</span><br><span class="line">    <span class="comment">// 调用B入参b2</span></span><br><span class="line">    B(b2);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，a1和b1这两条数据会存入对用的数据库，而b2这条数据会因为异常而没有入库。</p><h4 id="REQUIRED（Spring默认的事务传播）"><a href="#REQUIRED（Spring默认的事务传播）" class="headerlink" title="REQUIRED（Spring默认的事务传播）"></a>REQUIRED（Spring默认的事务传播）</h4><blockquote><p><strong>如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务</strong></p></blockquote><p>使用场景如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMain</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 调用A入参a1</span></span><br><span class="line">    A(a1);</span><br><span class="line">    <span class="comment">// 调用testB</span></span><br><span class="line">    testB();    </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 调用B入参b1</span></span><br><span class="line">    B(b1);</span><br><span class="line">    <span class="comment">// 发生异常抛出</span></span><br><span class="line">    <span class="keyword">throw</span> Exception;</span><br><span class="line">    <span class="comment">// 调用B入参b2</span></span><br><span class="line">    B(b2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，数据库的状态会停留在没有执行这两个方法的状态。</p><p><code>testMain()</code>声明了事务，它执行时会创建事务，在执行<code>testB()</code>的时候，它就会加入<code>testMain()</code>的事务，而不会自己创建。</p><h4 id="SUPPORTS"><a href="#SUPPORTS" class="headerlink" title="SUPPORTS"></a>SUPPORTS</h4><blockquote><p><strong>当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMain</span><span class="params">()</span>&#123;</span><br><span class="line">    A(a1);  <span class="comment">//调用A入参a1</span></span><br><span class="line">    testB();    <span class="comment">//调用testB</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.SUPPORTS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>&#123;</span><br><span class="line">    B(b1);  <span class="comment">//调用B入参b1</span></span><br><span class="line">    <span class="keyword">throw</span> Exception;     <span class="comment">//发生异常抛出</span></span><br><span class="line">    B(b2);  <span class="comment">//调用B入参b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，a1和b1会插入数据库，b2不会插入，因为<code>testMain()</code>是没有事务的，所以执行<code>testB()</code>方法时，无法加入其他的事务。</p><h4 id="MANDATORY"><a href="#MANDATORY" class="headerlink" title="MANDATORY"></a>MANDATORY</h4><blockquote><p><strong>当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。</strong></p></blockquote><p>上面的代码在这种情况下，执行结果就是a1存储数据库，而b1和b2没有存入，因为<code>testMain()</code>没有事务而产生报错。</p><h4 id="REQUIRES-NEW"><a href="#REQUIRES-NEW" class="headerlink" title="REQUIRES_NEW"></a>REQUIRES_NEW</h4><blockquote><p><strong>创建一个新事务，如果存在当前事务，则挂起该事务。</strong>可以理解为在执行时，不论当前是否存在事务，总是会新建一个事务。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMain</span><span class="params">()</span>&#123;</span><br><span class="line">    A(a1);  <span class="comment">//调用A入参a1</span></span><br><span class="line">    testB();    <span class="comment">//调用testB</span></span><br><span class="line">    <span class="keyword">throw</span> Exception;     <span class="comment">//发生异常抛出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>&#123;</span><br><span class="line">    B(b1);  <span class="comment">//调用B入参b1</span></span><br><span class="line">    B(b2);  <span class="comment">//调用B入参b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，a1没有存入成功，而b1和b2会存入成功。因为<code>testB()</code>会新建一个事务，而不是采用<code>testMain()</code>的事务。</p><h4 id="NOT-SUPPORTED"><a href="#NOT-SUPPORTED" class="headerlink" title="NOT_SUPPORTED"></a>NOT_SUPPORTED</h4><blockquote><p><strong>始终以非事务方式执行,如果当前存在事务，则挂起当前事务</strong>，可以理解为始终不执行事务。</p></blockquote><h4 id="NEVER"><a href="#NEVER" class="headerlink" title="NEVER"></a>NEVER</h4><blockquote><p><strong>不使用事务，如果当前事务存在，则抛出异常</strong></p></blockquote><h4 id="NESTED"><a href="#NESTED" class="headerlink" title="NESTED"></a>NESTED</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;事务传播&quot;&gt;&lt;a href=&quot;#事务传播&quot; class=&quot;headerlink&quot; title=&quot;事务传播&quot;&gt;&lt;/a&gt;事务传播&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;写在前面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring的事务是通过AOP这种代理的方式实现的。&lt;/s</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Spring" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码</title>
    <link href="http://example.com/2023/10/14/Java/HashMap%E6%BA%90%E7%A0%81/"/>
    <id>http://example.com/2023/10/14/Java/HashMap%E6%BA%90%E7%A0%81/</id>
    <published>2023-10-14T02:29:37.000Z</published>
    <updated>2023-10-21T07:05:27.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap源码"><a href="#HashMap源码" class="headerlink" title="HashMap源码"></a>HashMap源码</h1><h2 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    HashMap.Node e;</span><br><span class="line">    <span class="keyword">return</span> (e = <span class="built_in">this</span>.getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> HashMap.Node&lt;K, V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    HashMap.Node[] tab;</span><br><span class="line">    HashMap.Node first;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 这里，先把tab指向了整个类的table，也就是先获取目前存储的所有元素</span></span><br><span class="line">    <span class="comment">// 同时判断是否为空，长度是否大于0，并初始化first的值，n - 1 &amp; hash是为了保证hash值有效</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = <span class="built_in">this</span>.table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (first = tab[n - <span class="number">1</span> &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">// 这里是为了判断是否存在hash冲突，如果hash值相等，并且key也相当，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; ((k = first.key) == key || key != <span class="literal">null</span> &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap.Node e;</span><br><span class="line">        <span class="comment">// 这里是判断冲突后，是否还存在下一个元素</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断此时的结构是否为红黑树，如果是，则遍历红黑树找节点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> HashMap.TreeNode) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((HashMap.TreeNode)first).getTreeNode(hash, key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不是红黑树，那么就是一个链表，直接遍历链表到结尾，找对应元素即可。</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key != <span class="literal">null</span> &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span>((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getTreeNode"><a href="#getTreeNode" class="headerlink" title="getTreeNode"></a>getTreeNode</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap.TreeNode&lt;K, V&gt; <span class="title function_">getTreeNode</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span> ? <span class="built_in">this</span>.root() : <span class="built_in">this</span>).find(h, k, (Class)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> HashMap.TreeNode&lt;K, V&gt; <span class="title function_">find</span><span class="params">(<span class="type">int</span> h, Object k, Class&lt;?&gt; kc)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先获取到该节点的整个红黑树</span></span><br><span class="line">    HashMap.<span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        HashMap.TreeNode&lt;K, V&gt; pl = p.left;</span><br><span class="line">        HashMap.TreeNode&lt;K, V&gt; pr = p.right;</span><br><span class="line">        <span class="type">int</span> ph;</span><br><span class="line">        <span class="comment">// 首先，是因为发生hash冲突后，才会用这个红黑树来解决hash冲突，那么该树中节点的hash值不是应该全部相等吗？</span></span><br><span class="line">        <span class="comment">// 应该是没有看生成代码的原因，转变为红黑树后，应该要做一次reHash，那么他们就会有新的hash值来用于构建红黑树</span></span><br><span class="line">        <span class="comment">// 这里，就是获取到左子树和右子树的hash值，然后与传入的值进行比较，一直找到相等的</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h) &#123;</span><br><span class="line">            p = pl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) &#123;</span><br><span class="line">            p = pr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里是找到了Hash值相等的</span></span><br><span class="line">            Object pk;</span><br><span class="line">            <span class="comment">// 先判断key值是否相等，如果相等则返回</span></span><br><span class="line">            <span class="keyword">if</span> ((pk = p.key) == k || k != <span class="literal">null</span> &amp;&amp; k.equals(pk)) &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里是仍然有冲突，那么就看该节点的左右子树</span></span><br><span class="line">            <span class="keyword">if</span> (pl == <span class="literal">null</span>) &#123;</span><br><span class="line">                p = pr;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="literal">null</span>) &#123;</span><br><span class="line">                p = pl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 这里是左右子树都不为空</span></span><br><span class="line">                <span class="type">int</span> dir;</span><br><span class="line">                <span class="comment">// 这里由于没有传入比较器，所以不会走if，只会走else</span></span><br><span class="line">                <span class="keyword">if</span> ((kc != <span class="literal">null</span> || (kc = HashMap.comparableClassFor(k)) != <span class="literal">null</span>) &amp;&amp; (dir = HashMap.compareComparables(kc, k, pk)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    p = dir &lt; <span class="number">0</span> ? pl : pr;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 这里是左右子树都不为空，则递归的进行搜索即可</span></span><br><span class="line">                    HashMap.TreeNode q;</span><br><span class="line">                    <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    p = pl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(p != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HashMap源码&quot;&gt;&lt;a href=&quot;#HashMap源码&quot; class=&quot;headerlink&quot; title=&quot;HashMap源码&quot;&gt;&lt;/a&gt;HashMap源码&lt;/h1&gt;&lt;h2 id=&quot;get操作&quot;&gt;&lt;a href=&quot;#get操作&quot; class=&quot;header</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="源码分析" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>单点登录</title>
    <link href="http://example.com/2023/10/13/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <id>http://example.com/2023/10/13/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</id>
    <published>2023-10-13T06:33:30.000Z</published>
    <updated>2023-10-30T08:51:55.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h1><p>一个真正的单点登录流程如下：该流程属于不同域下的单点登录。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/637ec3d1265a44629a45aa7571a77c9f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><ul><li>用户进入 A 系统，没有登录凭证（ticket），A 系统给他跳到 SSO。</li><li>SSO 没登录过，也就没有 sso 系统下没有凭证（怎么感知到的）（注意这个和前面 A ticket 是两回事），输入账号密码登录。</li><li>SSO 账号密码验证成功，通过接口返回做两件事：一是种下 sso 系统下凭证（记录用户在 SSO 登录状态）；二是下发一个 ticket。</li><li>客户端拿到 ticket，保存起来，带着请求系统 A 接口。</li><li>系统 A 校验 ticket，成功后正常处理业务请求。</li><li>此时用户第一次进入系统 B，没有登录凭证（ticket），B 系统给他跳到 SSO。</li><li>SSO 登录过，系统下有凭证，不用再次登录，只需要下发 ticket。</li><li>客户端拿到 ticket，保存起来，并携带ticket请求系统B的接口。</li></ul><p>至此，还存在问题，SSO 域下返回的数据要怎么存，才能在访问 A 的时候带上？因为浏览器对跨域有严格限制，cookie、localStorage 等方式都是有域限制的。</p><p>下面这张图是一个更细致的流程：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/6dabc898da7149d9b8972a7830825bc9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><ul><li>在 SSO 域下，SSO 不是通过接口把 ticket 直接返回，而是通过一个带 code 的 URL 重定向到系统 A 的接口上，这个接口通常在 A 向 SSO 注册时约定。相当于提前定义好了一个接口来接收SSO系统返回的code。</li><li>浏览器被重定向到 A 域下，带着 code 访问了 A 的 callback 接口，callback 接口通过 code 换取 ticket。</li><li>这个 code 不同于 ticket，code 是一次性的，暴露在 URL 中，只为了传一下换 ticket，换完就失效。</li><li>callback 接口拿到 ticket 后，在自己的域下 set cookie 成功。</li><li>在后续请求中，只需要把 cookie 中的 ticket 解析出来，去 SSO 验证就好。</li></ul><p>这里，用户第一次请求时，由于本地没有cookie，所以验证会失败，跳转到SSO系统去验证，而这个验证也会因为没有cookie而失败，所以要求用户进行登录。当登录完成过后，会跳转到系统A提前定义好的接口，并携带code，此时也会在用户本地存储SSO域的一个cookie。该接口会拿到code后去SSO系统换取ticket，拿到ticket后会向SSO系统验证这个ticket是否正确（防止有人伪造ticket而直接请求接口），如果正确则可以正常处理。</p><p>此时如果用户使用系统B，因为本地已经有SSO域的cookie 了，携带者去请求SSO就可以，然后可以直接下发凭证。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单点登录&quot;&gt;&lt;a href=&quot;#单点登录&quot; class=&quot;headerlink&quot; title=&quot;单点登录&quot;&gt;&lt;/a&gt;单点登录&lt;/h1&gt;&lt;p&gt;一个真正的单点登录流程如下：该流程属于不同域下的单点登录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image-1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL limit 1和limit 10000，1性能一样吗</title>
    <link href="http://example.com/2023/10/11/MySQL%E7%9A%84limit/"/>
    <id>http://example.com/2023/10/11/MySQL%E7%9A%84limit/</id>
    <published>2023-10-11T02:50:37.000Z</published>
    <updated>2023-10-26T03:31:19.582Z</updated>
    
    <content type="html"><![CDATA[<p> 考虑两条MySQL语句的执行，其中key1是二级索引，id是主键。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from my_table order by key1 limit 1;</span><br></pre></td></tr></table></figure><p>该条语句，key1是二级索引，本身就是有序的，那么当查询一条语句之后，它就会直接回表查询具体的数据然后返回。</p><p>但是如果SQL变为下面的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from my_table order by key1 limit 10000, 1;</span><br></pre></td></tr></table></figure><p>执行这条语句就会发现它走了全表的扫描 + filesort，它并没有像想象中的那样，扫描到10001的索引，然后回表返回结果。</p><h1 id="limit的执行"><a href="#limit的执行" class="headerlink" title="limit的执行"></a>limit的执行</h1><p>MySQL分为Server层和具体的存储引擎层，Server层是统一的，而存储引擎我们这里默认使用InnoDB。</p><p>当具体执行一个带有limit操作的SQL时，它并不会在存储引擎层进行过滤，存储引擎查询到所需要的所有数据，然后返回给Server层，Server层依据具体的查询需求来进行过滤，也就是说需要先查询10001条数据返回给Server，然后进行过滤。</p><h1 id="优化器选择"><a href="#优化器选择" class="headerlink" title="优化器选择"></a>优化器选择</h1><p>优化器在执行这个查询时会有两种选择</p><ol><li>全表扫描，然后返回，过滤掉不需要的数据。</li><li>第二种查询方案涉及到数据返回策略，InnoDB在执行查询索引时，查找到一条满足条件的数据后，会进行回表，查找完整数据，然后返回给Server层，Server层在返回给用户时发现还有limit，所以要做限制，就不能进行返回，并开始计数。直到引擎层给Server层返回了10001条数据后，才可以完成limit操作，之后再将结果返回给用户，也就是说这里需要进行10001次回表操作，并且要查询10001行数据，然后前10000行全部被Server层丢弃。</li></ol><p>这两种方案会由优化器决定走哪一种，但不管走哪一种，都需要进行大量的回表操作。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>当执行 <code>limit 1</code> 和执行 <code>limit 10000，1</code>时，性能上的差距还是很大的。并且由于MySQL内存有限，在查询前10000行数据时，难免会有数据页被移出内存，然后从磁盘中加载新的数据页，这也会消耗一定的时间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 考虑两条MySQL语句的执行，其中key1是二级索引，id是主键。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="场景分析" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    
    
    <category term="场景分析" scheme="http://example.com/tags/%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>远程调用</title>
    <link href="http://example.com/2023/10/08/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
    <id>http://example.com/2023/10/08/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/</id>
    <published>2023-10-08T03:14:44.000Z</published>
    <updated>2023-10-18T04:08:01.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h1><p>本地调用通常指的是，进程内函数之间的相互调用；而远程调用，是进程间函数的相互调用，是进程间通信 IPC（Inter-Process Communication）的一种方式。</p><p>根据进程是否部署在一台机器上，远程调用可以分为以下两类：</p><ol><li><strong>本地过程调用（Local Procedure Call，LPC）</strong>，是指运行在同一台机器上的进程之间 的互相通信，即在多进程操作系统中，运行的不同进程之间可以通过 LPC 进行函数调 用。</li><li><strong>远程过程调用（Remote Procedure Call，RPC）</strong>，是指不同机器中运行的进程之间的 相互通信，某一机器上运行的进程在不知道底层通信细节的情况下，就像访问本地服务 一样，去调用远程机器上的服务。</li></ol><h2 id="远程调用的原理"><a href="#远程调用的原理" class="headerlink" title="远程调用的原理"></a>远程调用的原理</h2><p>在B&#x2F;S ( Browser&#x2F;Server，浏览器 &#x2F; 服务器) 架构中，被调用方（服务器）会有一个开放的接口，然后调用方（用户）会通过Browser使用这个接口，来间接的调用相应的服务。</p><p>但是，B&#x2F;S 架构是基于 HTTP 协议实现的，每次调用接口时，都需要先进行 HTTP 请求，比较的耗时，不适合分布式中的远程调用。更为常用的是 <strong>远程过程调用 RPC(Remote Procedure Call)</strong> 和 **远程方法调用 RMI(Remote Method Invocation)**。</p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>简单地说，RPC 就是调用方采用参数传递的方式，通过调用本机器上的一个函数或方法， 去执行远程机器上的函数或方法（可以统称为服务），并返回结果。在整个过程中，RPC 会隐藏具体的通信细节。一个支付流程的网络调用如下图所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231012092420486.png" alt="image-20231012092420486" style="zoom:80%;" /><p>其中，Stub 是用于转换 RPC 过程中在订单系统和支付系统所在机器之间传递的参数。说白了，客户端的Stub用于封装参数，而服务端的Stub就是为了将收到的封装后的参数解析出来。</p><p>不难看出，机器 A 上的 Pay(Order)、 Client Stub 和网络调用之间的交互属于本地调用，机器 B 上的 Pay(Order)、Server Stub 和网络调用之间的交互也属于本地调用。而机器 A 和机器 B 之间的远程调用的核心是，发生在机器 A 上的网络调用和机器 B 上的网络调用。</p><p>RPC的目的是，将第 2 到第 8 步的几个过程封装起来，让用户看不到这些细节。 从用户的角度看，订单系统的进程只是做了一次普通的本地调用，然后就得到了结果。</p><p>订单系统进程并不需要知道底层是如何传输的，在用户眼里，远程过程调用和调用一次本地服务没什么不同。这就是 RPC 的核心。</p><h4 id="RPC与本地调用的区别"><a href="#RPC与本地调用的区别" class="headerlink" title="RPC与本地调用的区别"></a>RPC与本地调用的区别</h4><p>第一个区别是<strong>调用 ID 和函数的映射</strong>。在本地调用中，进程内可共享内存地址空间，因此程序可直接通过函数名来调用函数。函数名的本质是一个函数指针，可以看作函数在内存中的地址。而在远程调用中，只通过函数名却不行，因为不同进程的地址空间不一样，所以必须通过一个调用ID来标识，在远程调用时要附上ID。</p><p>调用方首先通过映射表，先找到调用函数的ID，传给被调用方。被调用方拿到ID后，通过ID找到具体被调用的函数。</p><p>第二个区别是，<strong>序列化和反序列化</strong>。在本地调用中，进程之间共享内存等，因此我们只需要把参数压到栈里，然后进程自己去栈 里读取就行。但是在 RPC 中，两个进程分布在不同的机器上，使用的是不同机器的内存， 因此不可能通过内存来传递参数。</p><p>而网络协议传输的内容是二进制流，无法直接传输参数的类型，因此这就需要调用方把参数 先转成一个二进制流，传到被调用方后，被调用方再把二进制流转换成自己能读取的格式。 这个过程，就叫作序列化和反序列化。</p><p>第三个区别是，<strong>网络传输协议</strong>。序列化和反序列化解决了调用方和被调用方之间的数据传输 格式问题，但要想序列化后的数据能在网络中顺利传输，还需要有相应的网络协议，比如 TCP、UDP 等，因此就需要有一个底层通信层。而大部分的RPC框架，采用的都是TCP协议。</p><h3 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h3><p>RMI 是一个基于 Java 环境的应用编程接口，能够让本地 Java 虚拟机上运行的对象，像调用本地对象一样调用远程 Java 虚拟机上的对象。RMI可以说是RPC的一种具体形式，原理与RPC基本一致，不同的是RMI 是基于对象的，充分利用了面向对象的思想去实现整个过程，其本质就是一种基于对象的 RPC 实现。</p><p>RMI 与 PRC 最大的不同在于调用方式和返回结果的形式，RMI 通 过对象作为远程接口来进行远程方法的调用，返回的结果也是对象形式，可以是 Java 对象 类型，也可以是基本数据类型。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《分布式技术原理与算法实战》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;远程调用&quot;&gt;&lt;a href=&quot;#远程调用&quot; class=&quot;headerlink&quot; title=&quot;远程调用&quot;&gt;&lt;/a&gt;远程调用&lt;/h1&gt;&lt;p&gt;本地调用通常指的是，进程内函数之间的相互调用；而远程调用，是进程间函数的相互调用，是进程间通信 IPC（Inter-Proc</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="分布式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
</feed>
