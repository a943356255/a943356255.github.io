<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便起个名字吧</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-23T05:43:57.915Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Guo Junhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL读写分离存在的问题</title>
    <link href="http://example.com/2023/04/23/MySQL/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2023/04/23/MySQL/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2023-04-23T02:49:01.000Z</published>
    <updated>2023-04-23T05:43:57.915Z</updated>
    
    <content type="html"><![CDATA[<p>在MySQL的一主多从的架构中，往往有以下两种设计方案：</p><p>1、由客户端决定连接哪个数据库</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230423105127688.png" alt="image-20230423105127688" style="zoom:67%;" /><p>2、由代理决定请求分发到哪一个数据库</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230423105207833.png" alt="image-20230423105207833" style="zoom:67%;" /><p>但不管是哪种方案，都存在过期读的问题，即主库和从库存在一定的时延，用户刚做一个修改，然后立马发起查询，就有可能查到过期数据。以下给出几种解决方案。</p><h1 id="强制走主库"><a href="#强制走主库" class="headerlink" title="强制走主库"></a>强制走主库</h1><p>该方案将请求分为了两类：</p><p>1、必须拿到最新数据的，就强制走主库查询。</p><p>2、对于可以读取到旧数据的，就走从库查询。</p><h1 id="Sleep-方案"><a href="#Sleep-方案" class="headerlink" title="Sleep 方案"></a>Sleep 方案</h1><p>该方案的设计很简单，读从库之前先sleep一段时间。</p><p>它假设大多情况下主备延迟在1秒之内，所以简单的sleep可以拿到最新的数据。</p><h1 id="判断主备无延迟方案"><a href="#判断主备无延迟方案" class="headerlink" title="判断主备无延迟方案"></a>判断主备无延迟方案</h1><p>这里有几种办法，第一种是从库查询前，先判断seconds_behind_master是否已经等于0。如果还不等于0 ，那就必须等到这个参数变为0才能执行查询请求。</p><p>第二种和第三种方案，都是通过对比主库和从库的日志执行位点来判断是否有延迟，即通过对比主库和从库执行的日志，来判断，要比对比时间准确。</p><p>但是这里也存在问题，主库存在一部分日志刚刚提交，而从库还没收到该日志，也会导致有一定的延迟。</p><h1 id="配合semi-sync"><a href="#配合semi-sync" class="headerlink" title="配合semi-sync"></a>配合semi-sync</h1><p>这里引入了半同步复制，semi-sync做了这样的设计：</p><ol><li>事务提交的时候，主库把binlog发给从库；</li><li>从库收到binlog以后，发回给主库一个ack，表示收到了；</li><li>主库收到这个ack以后，才能给客户端返回“事务完成”的确认。</li></ol><p>这样可以保证如果从库发送过确认消息，就代表收到了日志。这样，semi-sync配合前面关于位点的判断，就能够确定在从库上执行的查询请求，可以避免过期读。</p><p>但是该方案适合一主一从的架构，如果一主多从，那么一个从库响应，就默认已经同步成功，但是其他从库不确定。如果此时查询走的是其他从库，则还是会有问题。</p><p>而且存在一种情况，如果高峰期日志写的很快，可能会导致主库位点一直不一致的情况，就出现从库迟迟无法响应的问题。</p><h1 id="等主库位点方案"><a href="#等主库位点方案" class="headerlink" title="等主库位点方案"></a>等主库位点方案</h1><p>该方案涉及到以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select master_pos_wait(file, pos[, timeout]);</span><br></pre></td></tr></table></figure><p>该命令在从库执行，参数file和pos指向从库上的某个文件以及对应位置，timeout可选，表示这个函数最多的等待时间。</p><p>这个命令正常返回的结果是一个正整数M，表示从命令开始执行，到应用完file和pos表示的binlog位置，执行了多少事务。</p><p>那么我们的查询逻辑变为以下：</p><p>1、主库执行完事务后，执行show master status得到当前主库执行到的File和Position；</p><p>2、从库查询之间，先执行master_pos_wait（File，Position）</p><p>3、如果返回 &gt;&#x3D; 0的正整数，则在该从库执行查询，否则到主库查询。</p><h1 id="GTID方案"><a href="#GTID方案" class="headerlink" title="GTID方案"></a>GTID方案</h1><p>该方案和上述等主库位点方案思路一致，只不过是后续MySQL做了优化。</p><p>我们不再需要去主库执行show master status来获取位点，而是主库执行完后，直接返回一个事务的GTID，然后从库执行时，只需要在从库执行select wait_for_executed_gtid_set(gtid1, 1)，该命令也是用于等待主从同步的命令。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL45讲》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在MySQL的一主多从的架构中，往往有以下两种设计方案：&lt;/p&gt;
&lt;p&gt;1、由客户端决定连接哪个数据库&lt;/p&gt;
&lt;img src=&quot;https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-2023042310</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    <category term="其他" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="MySQL45讲" scheme="http://example.com/tags/MySQL45%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>高并发系统的通用设计方案</title>
    <link href="http://example.com/2023/04/22/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%80%9A%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/"/>
    <id>http://example.com/2023/04/22/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%80%9A%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/</id>
    <published>2023-04-22T10:07:31.000Z</published>
    <updated>2023-04-22T10:29:26.107Z</updated>
    
    <content type="html"><![CDATA[<p>高并发系统的通用设计：</p><p>Scale-out（横向扩展）：采用分布式部署的方式把流量分流开，让每个服务器都承担一部分并发和流量。</p><p>缓存：使用缓存来提高系统的性能，就好比用“拓宽河道”的方式抵抗高并发大流量的冲击。</p><p>异步：在某些场景下，未处理完成之前我们可以让请求先返回，在数据准备好之后再通知请求方，这样可以在单位时间内处理更多的请求。</p><h1 id="Scale-out"><a href="#Scale-out" class="headerlink" title="Scale-out"></a>Scale-out</h1><p>这里牵扯到一个横向扩展（Scale-out）与纵向扩展（Scale-up）。其中纵向扩展是不断的提高单个cpu的处理能力，来处理更多的请求。而横向扩展则是指利用多个cpu资源来并行处理，来处理更多请求。</p><p>一般来说，在项目初期，我们可以采用纵向扩展，当单机无法承受时，再使用横向扩展。</p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>我们的数据都是存储在磁盘上的，而磁盘的读取速度特别的慢，会给处理请求带来很大的压力。所以产生了缓存。在现代的设计中，从操作系统到浏览器，从数据库到消息队列都可以看到缓存的影子。</p><p>由于缓存是基于内存读写的，所以速度要比磁盘读取快很多。如果能够能快的读写数据，那么每个请求的处理时间都会变短，那么就会提高系统的并发度。</p><h1 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h1><p>异步处理相对应的就是同步。</p><p>同步是指调用一个方法，需要等到该方法返回之后，才可以继续执行后续的操作。这种情况下，如果调用的方法响应时间太长的话，会导致后续的业务阻塞。</p><p>异步处理是指调用方法后，并不需要等待方法处理完，可以直接执行后续的请求。比如说，我们可以将请求放入队列当中，然后响应用户一个信息，等处理完结果后，再给用户反馈一下，这样可以处理更多的请求。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230422182314880.png" alt="image-20230422182314880"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《高并发系统设计40问》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;高并发系统的通用设计：&lt;/p&gt;
&lt;p&gt;Scale-out（横向扩展）：采用分布式部署的方式把流量分流开，让每个服务器都承担一部分并发和流量。&lt;/p&gt;
&lt;p&gt;缓存：使用缓存来提高系统的性能，就好比用“拓宽河道”的方式抵抗高并发大流量的冲击。&lt;/p&gt;
&lt;p&gt;异步：在某些场景下，</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="高并发系统设计" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>超越物理内存的策略</title>
    <link href="http://example.com/2023/04/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B6%85%E8%B6%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E7%AD%96%E7%95%A5/"/>
    <id>http://example.com/2023/04/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B6%85%E8%B6%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E7%AD%96%E7%95%A5/</id>
    <published>2023-04-21T12:47:18.000Z</published>
    <updated>2023-04-22T10:07:51.541Z</updated>
    
    <content type="html"><![CDATA[<p>当有足够的内存时，发生页错误，只需要将页加入内存即可，但是如果内存不够，就需要将内存中的一些页换出，放入磁盘中去。那么现在问题就在于，要将那些页面换出呢？</p><p>这些存在于内存中的页，可以看作是一个缓存，如果访问该页时，页在内存，就当作缓存命中，不在就是没命中，那么我们的目标就变为让缓存的命中率尽可能地提高。</p><h1 id="最优替换策略"><a href="#最优替换策略" class="headerlink" title="最优替换策略"></a>最优替换策略</h1><p>该替换策略是将最远的将来才会使用到的页替换出去，这样就能使得命中率最高，但是也很难实现，或者换种方式说，几乎无法实现。因为我们无法知道哪个页最远才会被使用，该算法只能作为一个比较使用。</p><h1 id="FIFO（先进先出）"><a href="#FIFO（先进先出）" class="headerlink" title="FIFO（先进先出）"></a>FIFO（先进先出）</h1><p>先进入系统的页就先被换出。优点是实现很简单。缺点是可能导致内存页命中率特别低，极端情况下还会为0。</p><h1 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h1><p>依靠随机数，替换出某些页。该策略实现页比较简单，但是依靠运气。</p><h1 id="利用历史数据：LRU"><a href="#利用历史数据：LRU" class="headerlink" title="利用历史数据：LRU"></a>利用历史数据：LRU</h1><p>该算法考虑历史使用数据，如果一个页被很频繁的使用，那么它应该是比较重要的，不应该被换出。那么那些最近最不经常使用的页，就会被换出内存。</p><p>这里使用了局部性原则，包括空间局部性和时间局部性。</p><p>面临的问题：</p><p>该算法要求我们，每次访问内存，都需要同步的做一些修改，来更新页面位于队列中的位置。为了记录那些页最少被访问，我们需要记录内存的引用，但是这些记录可能会导致占用大量空间。</p><p>如果通过硬件实现，比如给每个页设置一个时间，每次系统访问内存时，硬件去更新该时间，而需要替换出页时，扫描所有页找到最久的即可。但是页特别多的话，耗时非常高。</p><h1 id="近似的LRU"><a href="#近似的LRU" class="headerlink" title="近似的LRU"></a>近似的LRU</h1><p>该算法的实现需要硬件添加一个使用位。系统的每一个页都有一个存在位，该值是0或者1。每当该页被引用时，就将该位改为1。但是硬件不会将其置为0，这是由操作系统设置的。</p><p>该算法的实现是始终算法。即将所有的页放在一个循环队列中，时钟指针开始时指向某个页，当需要替换页时，会检查时钟指针指向的页的标记为是0还是1，如果是1就说明不适合换出，而0就将它换出。如果是1，就会找下一个页，一直到找到一个是0的为止。如果找完所有的页，还是没有0，那么就将所有的页都设置为0。</p><p>它的一个改进算法为，扫描到1的，不置换出该页，但是将标记位改为0，防止遍历完一遍后找不到为0的标记位。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当有足够的内存时，发生页错误，只需要将页加入内存即可，但是如果内存不够，就需要将内存中的一些页换出，放入磁盘中去。那么现在问题就在于，要将那些页面换出呢？&lt;/p&gt;
&lt;p&gt;这些存在于内存中的页，可以看作是一个缓存，如果访问该页时，页在内存，就当作缓存命中，不在就是没命中，那么</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>超越物理内存的机制</title>
    <link href="http://example.com/2023/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B6%85%E8%B6%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2023/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B6%85%E8%B6%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E6%9C%BA%E5%88%B6/</id>
    <published>2023-04-20T14:04:38.000Z</published>
    <updated>2023-04-20T14:40:46.917Z</updated>
    
    <content type="html"><![CDATA[<p> 在本章之前，我们所做的假设都是将进程的所有页都可以放入内存当中，但实际情况是，物理内存无法存储这么多的页。而且，为了更大的地址空间，我们也需要更大的物理内存来存储更大的页表。</p><p>这里的一个解决办法就是，利用磁盘空间，也就是说将页表取出一部分，放入磁盘当中。而操作系统需要知道这些被换出的页存在于磁盘的哪个位置，以便后续将他们加载到内存当中。</p><h1 id="交换空间"><a href="#交换空间" class="headerlink" title="交换空间"></a>交换空间</h1><p>在磁盘上开辟一块空间，用于物理页的移入和移出，这些空间就称为交换空间。而交换空间的大小，决定了系统在某一时刻能够使用的最大内存页数。而且操作系统需要记得给定页的硬件地址。</p><h1 id="存在位"><a href="#存在位" class="headerlink" title="存在位"></a>存在位</h1><p>按照之前的设定，一个虚拟地址转换为物理地址，会先检查TLB（快速地址转换），如果命中，则直接从中获取到映射，速度很快。</p><p>如果未命中，则需要先去内存中去找页目录，然后从页目录中找到对应页表页（页表被分为了很多个页），然后从页表中找到对应的映射，之后再把它加入TLB中。</p><p>如果添加了交换空间，这里边就需要考虑页是否在内存中的情况，则需要多一个标记位，即存在位，用于标记该页是否在内存当中。</p><h1 id="页错误"><a href="#页错误" class="headerlink" title="页错误"></a>页错误</h1><p>如果访问的页不在内存当中，就会发生页错误。</p><p>发生页错误，可能是因为该页被换出磁盘，那么系统就需要从对应的磁盘当中去加载内存页，这也就要求操作系统需要知道被换出的页的存储位置。操作系统可以使用PTE（页表项）的某些位来存储硬盘地址。</p><p>当将该页加载到内存后，操作系统会更新页表，将该页标记为存在内存当中，并且更新页表项中对应位置，它之前是记录了在硬盘的地址，现在把他改为在内存中的地址。</p><h1 id="何时交换页"><a href="#何时交换页" class="headerlink" title="何时交换页"></a>何时交换页</h1><p>操作系统都会设置一个高水位线，也就是说并不会等到内存满了才执行换出，而是会预留一部分内存。当内存的使用情况超过高水位线时，就会从内存中清除页。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 在本章之前，我们所做的假设都是将进程的所有页都可以放入内存当中，但实际情况是，物理内存无法存储这么多的页。而且，为了更大的地址空间，我们也需要更大的物理内存来存储更大的页表。&lt;/p&gt;
&lt;p&gt;这里的一个解决办法就是，利用磁盘空间，也就是说将页表取出一部分，放入磁盘当中。而操</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized的使用</title>
    <link href="http://example.com/2023/04/20/Java/Synchronized%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/04/20/Java/Synchronized%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-04-20T07:27:09.000Z</published>
    <updated>2023-04-20T13:15:25.945Z</updated>
    
    <content type="html"><![CDATA[<p> 考虑如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncTest</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SyncTest</span> <span class="variable">syncTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyncTest</span>();</span><br><span class="line">        <span class="type">SyncTest</span> <span class="variable">syncTest1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyncTest</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(syncTest, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(syncTest1, <span class="string">&quot;thread2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在run方法上加了synchronized，也就意味着锁住的是该对象，也就是synchronized（this），当我们实例化两个对象时，他们是互相不影响的，所以打印结果如下：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230420161141896.png" alt="image-20230420161141896" style="zoom: 80%;" /><p>另一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt) &#123;</span><br><span class="line">      <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">      target.balance += amt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写，在转账的场景中并不能解决问题。</p><p>因为synchronized锁的是当前对象，它并不能锁住传进来的target，也就是说，如果此时实例化的对象是A，然后调用A.transfer(B, 100),它只能锁住A的balance，并不能锁住B的balance还会存在另一个线程修改B的balance的问题。</p><p>一开始看到这里有一个疑问，为什么不直接在接口中锁主呢，像如下写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JSONObject <span class="title function_">testInterface</span><span class="params">(<span class="meta">@RequestBody</span> Map&lt;String, Object&gt; map)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> crudServiceImpl.getCrudValue(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法会导致另外一个问题，也就是说我在A给B转账时，会进行加锁，导致C给D转账的时候，也无法进行。也就是说这种写法会导致锁的粒度太大，在实际场景中是无法使用的。</p><p>第一个优化版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target, <span class="type">int</span> amt)</span>&#123;</span><br><span class="line">    <span class="comment">// 锁定转出账户</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">      <span class="comment">// 锁定转入账户</span></span><br><span class="line">      <span class="keyword">synchronized</span>(target)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt) &#123;</span><br><span class="line">          <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">          target.balance += amt;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写可以保证this 和target都被锁住，达到我们预期地效果。但是也存在问题，如果A给B转账地同时，B也要给A转账，那么就会出现死锁。两者同时锁this，也就是对象A和对象B都被锁住，然后往下执行时，发现请求资源已经被锁，导致死锁。</p><p>第二个优化版本，防止死锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Allocator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; als = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次性申请所有资源</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(Object from, Object to)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (als.contains(from) || als.contains(to)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            als.add(from);</span><br><span class="line">            als.add(to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归还资源</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">(Object from, Object to)</span> &#123;</span><br><span class="line">        als.remove(from);</span><br><span class="line">        als.remove(to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// actr应该为单例</span></span><br><span class="line">    <span class="keyword">private</span> Allocator actr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转账</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">        <span class="comment">// 一次性申请转出账户和转入账户，直到成功</span></span><br><span class="line">        <span class="keyword">while</span> (!actr.apply(<span class="built_in">this</span>, target));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 锁定转出账户</span></span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 锁定转入账户</span></span><br><span class="line">                <span class="keyword">synchronized</span>(target) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">                        target.balance += amt;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            actr.free(<span class="built_in">this</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本中，Allocator是一个单例，也就意味着只有一个，然后在加锁之前，先判断是否可以同时获取两个对象的锁，如果可以，再进行加锁。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>上述代码都忽略了在两个线程中new 出来的对象不是同一个的问题。也就是说，transfer里传入的对象，在另一个线程中也是这两个。仅作为演示破会死锁。</p><p>而事实情况是，如果这段代码放在两个不同的线程中运行，线程A实例化account C和D，线程B实例化account C和D，在线程A执行transfer（C，D），在线程B执行transfer（D，C）还是有可能会发生死锁。</p><p>而上述代码的逻辑是建立在线程A 实例化的C和D 与线程B实例化的C和D是同一个对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 考虑如下代码&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>可靠数据传输原理</title>
    <link href="http://example.com/2023/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2023/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/</id>
    <published>2023-04-20T02:51:07.000Z</published>
    <updated>2023-04-21T03:01:09.568Z</updated>
    
    <content type="html"><![CDATA[<p>实现可靠传输是靠<strong>可靠数据传输协议</strong>来完成的，而该协议却建立在不可靠的下层协议上。就好比TCP提供可靠传输，而TCP却是建立在IP协议这个不可靠协议的基础上。</p><p>以下的讨论都是单向数据传输，而且暂且只考虑损坏比特或者整个报文段丢失的情况，而不考虑乱序到达的情况。</p><h1 id="rdt1-0：经完全可靠信道传输"><a href="#rdt1-0：经完全可靠信道传输" class="headerlink" title="rdt1.0：经完全可靠信道传输"></a>rdt1.0：经完全可靠信道传输</h1><p>该协议只考虑最简单的情况，即底层信道完全可信。</p><p>因为默认信道传输可信，那么它的发送端只等待来自上层的调用，接受端只等待来自下层的调用，发送端将数据发送出去之后，就不需要再管，默认一定会到达接收端。</p><p>而且这里也假定了接收方的接受速率和发送方的一致。</p><h1 id="rdt2-0：具有比特差错信道的可靠数据传输"><a href="#rdt2-0：具有比特差错信道的可靠数据传输" class="headerlink" title="rdt2.0：具有比特差错信道的可靠数据传输"></a>rdt2.0：具有比特差错信道的可靠数据传输</h1><p>在该协议中，我们只假定发送的比特可能会受损，而不考虑它们可能存在乱序到达或者丢失的情况。</p><p>这里可以类比打电话，我们说一句，对方听到后就会对其进行响应，如果没听清，一般会说让我们再说一边。</p><p>在该协议中，使用了肯定确认和否定确认，发送方收到肯定确认意味着接收方成功收到了数据，而否定确认意味着接收方收到的比特有误，需要重传。基于这种机制的协议叫做<strong>自动重传请求协议</strong>。</p><p>它最主要的是三点：</p><p>1、差错检测。它需要能够检测出传送的比特流是否有误。</p><p>2、接受方反馈。接收方收到比特后，如果有误，需要给发送方反馈。</p><p>3、重传。发送方收到接收方的否定确认后，需要重新传送刚刚发送的比特。</p><p>一个更具体地例子，发送方发送数据后，需要等待接收方返回一个确认分组。该分组可以是ACK或者NAK。收到ACK说明接收方正确收到分组，而受到NAK则说明有误，需要重传。而发送方发送数据后，只能等待接受对方响应的分组，这种设计也叫做<strong>停等协议</strong>。</p><p><strong>致命缺点：没有考虑ACK或者NAK分组受损的情况。</strong></p><p>简单的解决办法：发送方将发送的数据分组编号，接收方只需要根据序号就可以确定该数据分组是否被重发。这样一来，发送方接受到的AKC或者NAK由于受损而表意不明确时，直接重新发送即可。</p><h1 id="rdt3-0：具有比特差错的丢包信道的可靠传输"><a href="#rdt3-0：具有比特差错的丢包信道的可靠传输" class="headerlink" title="rdt3.0：具有比特差错的丢包信道的可靠传输"></a>rdt3.0：具有比特差错的丢包信道的可靠传输</h1><p>到这里，就不仅要考虑比特受损的情况，还要考虑比特丢失的情况。</p><p>在该协议下，我们让发送方负责检测和恢复丢包工作。假如发送方发送的数据分组丢了，那么接收方就无法响应该分组的ACK确认（因为发送的数据分组都有序号），发送方在未收到ACK时，不论是ACK丢失还是数据分组丢失，直接重传数据即可。</p><p>但是这个等待的时间也有要求，最低为一个数据分组从发送方到接收方以及从接收方返回发送方的时间和。这里就需要引入一个计时器，超过时间需要重传。</p><p>这里还要求发送方和接收方信道中引入<strong>冗余数据分组</strong>，这里面要存储已经发送了但是还没收到确认帧的数据。</p><p>该协议解决问题的核心点在于：</p><p>1、差错检测</p><p>2、数据分组增加编号</p><p>3、接收方的响应</p><p>4、一个计时器</p><p>5、冗余数据分组</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;实现可靠传输是靠&lt;strong&gt;可靠数据传输协议&lt;/strong&gt;来完成的，而该协议却建立在不可靠的下层协议上。就好比TCP提供可靠传输，而TCP却是建立在IP协议这个不可靠协议的基础上。&lt;/p&gt;
&lt;p&gt;以下的讨论都是单向数据传输，而且暂且只考虑损坏比特或者整个报文段丢失的</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="运输层" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
    
    <category term="运输层" scheme="http://example.com/tags/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>UDP</title>
    <link href="http://example.com/2023/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDP/"/>
    <id>http://example.com/2023/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDP/</id>
    <published>2023-04-20T01:53:33.000Z</published>
    <updated>2023-04-20T02:50:43.706Z</updated>
    
    <content type="html"><![CDATA[<p>UDP是面向无连接的，它没有拥塞控制。但是这里面存在一个问题，如果大量的UDP进行传输并且不经过控制，那么会导致整个网络的拥堵，造成大量UDP报文溢出，而且还会挤占TCP的通道，影响TCP通信。</p><p>UDP可以提供差错的检测，但是对于错误的报文段，却无法对其进行恢复，只能选择丢弃，或者交给应用程序，并发出警告。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;UDP是面向无连接的，它没有拥塞控制。但是这里面存在一个问题，如果大量的UDP进行传输并且不经过控制，那么会导致整个网络的拥堵，造成大量UDP报文溢出，而且还会挤占TCP的通道，影响TCP通信。&lt;/p&gt;
&lt;p&gt;UDP可以提供差错的检测，但是对于错误的报文段，却无法对其进行恢</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="运输层" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
    
    <category term="运输层" scheme="http://example.com/tags/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>分页：较小的表</title>
    <link href="http://example.com/2023/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E9%A1%B5%EF%BC%9A%E8%BE%83%E5%B0%8F%E7%9A%84%E8%A1%A8/"/>
    <id>http://example.com/2023/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E9%A1%B5%EF%BC%9A%E8%BE%83%E5%B0%8F%E7%9A%84%E8%A1%A8/</id>
    <published>2023-04-19T11:42:21.000Z</published>
    <updated>2023-04-19T14:35:36.346Z</updated>
    
    <content type="html"><![CDATA[<p>由于一个地址空间可能会对应很多页，从而导致每一个页表比较大。而每一个进程都有一个页表，则会给内存带来很大的压力。这里就是为了解决这个问题，如何让页表变得更小。</p><h1 id="更大的页"><a href="#更大的页" class="headerlink" title="更大的页"></a>更大的页</h1><p>我们可以让每一个页更大，如果每一个页可以对应更多的地址空间，那么页表需要存储的映射将会变少。这也意味着每一个页表会变得更小。</p><p>这种解决办法会带来新的问题，如果每个页太大，则会导致每个页所分配的内存用不完，导致内部碎片。</p><h1 id="分页和分段混合"><a href="#分页和分段混合" class="headerlink" title="分页和分段混合"></a>分页和分段混合</h1><p>在单独采用页表时，一个进程的地址空间映射可能如下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230419213904915.png" alt="image-20230419213904915" style="zoom:67%;" /><p>在上图中，一个地址空间会分为多个页，它单独对应一个页表。但是真正使用的空间却只有上图那些白色区域，而灰色区域是没有使用的，但是他们也被映射了具体的物理地址，而且这些映射还存在页表当中。</p><p>所以我们可以采用分段时的思想，不再将进程的整个空间分配单个页表，而是为进程的每个逻辑分段提供一个页表。</p><p>在上图的例子中，我们可以给代码段一个页表，给堆和栈分别一个页表。</p><p>在分段中，一个基址寄存器告诉我们每个段对应的物理地址，还有界限寄存器告诉我们段的大小。而在分段和分页混合的方案中，我们的基址寄存器存储的是该段的页表的物理地址。界限寄存器用于指示页表有有多少有效页。</p><p><strong>存在的问题</strong>：</p><p>如果存在一个大而稀疏的堆，那么还是要为他分配对应的物理空间，这些映射都要存储在页表当中，也会造成页表的浪费。</p><p>其次，这种杂合的方式会导致外部碎片产生。</p><h1 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h1><p>多级页表将线性页表变成了类似于树的东西。而且也是为了解决页表中存在着没有用的映射。</p><p>它的设计是，将页表分成页大小的单元。如果整个页的页表项都是无效的，就不为该页分配页表。为了追踪页表的页是否有效，以及有效页对应物理内存的位置，使用了一种页目录的新结构。</p><p>之前的页表与多级页表的对比如下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230419222341075.png" alt="image-20230419222341075" style="zoom:67%;" /><p>上图左边，页表中存储了203以及204这两页对应的虚拟地址到物理地址的映射，但是这两页却没有存储任何内容。</p><p>而在右图，内存中存储了页目录，页目录标记了哪些页是使用过的，而此时的页表中也有多个页，我们只需要加载页表中两个页即可。这两个页存储了使用了的页的映射。</p><p>存在的问题：</p><p>如果TLB未命中，那么我们就需要从内存中访问两次，才可以找到虚拟地址到物理地址的映射。第一次用于访问页目录，从页目录中找到对应页表，第二次用于从页表中找到对应虚拟地址到物理地址的映射。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于一个地址空间可能会对应很多页，从而导致每一个页表比较大。而每一个进程都有一个页表，则会给内存带来很大的压力。这里就是为了解决这个问题，如何让页表变得更小。&lt;/p&gt;
&lt;h1 id=&quot;更大的页&quot;&gt;&lt;a href=&quot;#更大的页&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>分页：快速地址转换</title>
    <link href="http://example.com/2023/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E9%A1%B5%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/"/>
    <id>http://example.com/2023/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E9%A1%B5%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/</id>
    <published>2023-04-19T08:12:14.000Z</published>
    <updated>2023-04-19T08:59:23.485Z</updated>
    
    <content type="html"><![CDATA[<p>为了解决分页带来的额外内存访问，又引入了地址转换旁路缓冲存储器，又称TLB。它是一个硬件缓存，它记录了频繁发生的虚拟地址到物理地址的转换。</p><p>引入该缓存后，每次需要访问内存时，硬件会先检查TLB中是否有期望的映射，如果有就直接转换。</p><h1 id="TLB的基本算法"><a href="#TLB的基本算法" class="headerlink" title="TLB的基本算法"></a>TLB的基本算法</h1><p>硬件会先从虚拟地址中提取页号，然后检查TLB中是否有该页号（在引入TLB之前，这里需要直接访问一次内存，去读取页表），如果有，则可以根据TLB的值，经过计算得到正确的物理地址。</p><p>如果没有找到，那么硬件需要去内存访问页表，然后将映射更新到TLB当中，前提是该虚拟地址有效，而且我们有权限访问。</p><h1 id="上下文切换时对TLB的处理"><a href="#上下文切换时对TLB的处理" class="headerlink" title="上下文切换时对TLB的处理"></a>上下文切换时对TLB的处理</h1><p>引入TLB之后，我们在发生上下文切换时，要对TLB进行特殊的处理。因为TLB记录的是某一个进程的地址空间到物理地址的转换，如果切换进程，那么当前的TLB对于另一个进程是不可用的。</p><p>一种解决方案：</p><p>在发生上下文切换时，直接清空TLB，那么就不会有进程读到错误的TLB。但是也存在问题，每个进程刚运行时，都会发生TLB未命中。</p><p>第二种解决方案：</p><p>增加一个地址空间标识符，也可以看作是进程标识符，用于标识存储的内容是那个进程的映射。这样一来，TLB可以同时缓存多个进程的地址映射。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了解决分页带来的额外内存访问，又引入了地址转换旁路缓冲存储器，又称TLB。它是一个硬件缓存，它记录了频繁发生的虚拟地址到物理地址的转换。&lt;/p&gt;
&lt;p&gt;引入该缓存后，每次需要访问内存时，硬件会先检查TLB中是否有期望的映射，如果有就直接转换。&lt;/p&gt;
&lt;h1 id=&quot;TL</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL怎么保证主备一致</title>
    <link href="http://example.com/2023/04/19/MySQL/MySQL%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4/"/>
    <id>http://example.com/2023/04/19/MySQL/MySQL%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4/</id>
    <published>2023-04-19T06:59:51.000Z</published>
    <updated>2023-04-19T07:20:53.857Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL在进行主备同步时，主库会直接把binlog拿到从库中去执行。这里就涉及到binlog的一些内容。</p><h1 id="binlog的三种格式"><a href="#binlog的三种格式" class="headerlink" title="binlog的三种格式"></a>binlog的三种格式</h1><p>binlog有三种格式，分别是statement，row和mixed。其中第三种是前两种的混合方式。</p><h2 id="这三种日志的区别"><a href="#这三种日志的区别" class="headerlink" title="这三种日志的区别"></a>这三种日志的区别</h2><p>假如说执行如下sql语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from t where a &gt;= 4 and t_modified &lt;= &#x27;2018-11-10&#x27; limit 1;</span><br></pre></td></tr></table></figure><p>如果说binlog的格式为statement，那么binlog中会记录一个事务，事务中会执行这个sql。也就是说，该设置下，相当于把该条sql语句直接拿到从库中去执行。</p><p>如果说格式为row，那么binglog中会记录很多的内容，但是总的来说，它能够根据这些内容，去从库中直接定位到主库删除的那一条记录。就比如说，主库删除主键是1的那一行，如果记录为row格式，那么从库一定可以定位到从库中主键是1的那一行。</p><p>为什么说要定位到从库主键是1的这一行呢？</p><p>因为如果格式为statement，那么直接在从库中执行上述语句，可能会导致一些主备不一致的情况。</p><p>上述语句，如果走索引a，那么会找到第一条a &gt;&#x3D; 4的记录后，就直接删除。而走索引t_modified，则会找到第一条满足t_modified &lt;&#x3D; ‘2018-11-10’的后，就直接删除。这样的话，如果主备的索引不一致，那么就会导致删除不同的行，导致主备不一致。</p><p>而mixed就是结合了两者的优点。因为row格式需要记录 太多的内容，会占用大量的空间。比如我删除10万行数据，row格式就需要10万条记录。而statement格式只需要记录一条sql，但有可能会导致主备不一致，所以采用结合的方式。由系统判断该sql是否会产生主备不一致的可能，如果会就用row记录，否则用statement。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL45讲》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL在进行主备同步时，主库会直接把binlog拿到从库中去执行。这里就涉及到binlog的一些内容。&lt;/p&gt;
&lt;h1 id=&quot;binlog的三种格式&quot;&gt;&lt;a href=&quot;#binlog的三种格式&quot; class=&quot;headerlink&quot; title=&quot;binlog的三种</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    <category term="日志" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="MySQL45讲" scheme="http://example.com/tags/MySQL45%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>MySQL怎么保证数据不丢失</title>
    <link href="http://example.com/2023/04/18/MySQL/MySQL%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1/"/>
    <id>http://example.com/2023/04/18/MySQL/MySQL%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1/</id>
    <published>2023-04-18T06:11:22.000Z</published>
    <updated>2023-04-18T07:57:57.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="binlog的写入机制"><a href="#binlog的写入机制" class="headerlink" title="binlog的写入机制"></a>binlog的写入机制</h1><p>总的流程：先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。</p><p>但是需要注意，一个事务的binlog无论多大，都需要一次性写入，这就涉及到binlog cache的保存。</p><p>每一个线程都会有一个binlog cache，可以设置其大小。如果超过大小限制，就要暂存在磁盘当中。但是所有的线程共享一个binlog file，也就是说，每个线程的binlog cache，都会存入到同一个文件。</p><p>一个具体的例子如下：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230418143649904.png" alt="image-20230418143649904" style="zoom:67%;" /><p>上图中的write操作，其实只是把binlog cache的内容写入文件系统的缓存，并没有直接同步到磁盘，而fsync才是真正的将文件系统缓存的内容写入到磁盘上。</p><p>write 和fsync的时机，是由参数sync_binlog控制的：</p><ol><li>sync_binlog&#x3D;0的时候，表示每次提交事务都只write，不fsync；</li><li>sync_binlog&#x3D;1的时候，表示每次提交事务都会执行fsync；</li><li>sync_binlog&#x3D;N(N&gt;1)的时候，表示每次提交事务都write，但累积N个事务后才fsync。</li></ol><h1 id="redo-log的写入机制"><a href="#redo-log的写入机制" class="headerlink" title="redo log的写入机制"></a>redo log的写入机制</h1><p>redo log 每次写入时，生成的redo log会先写入redo log buffer，而redo log buffer里面的内容并不需要每次写完后都同步到磁盘。</p><p>因为事务还没提交时，数据库异常重启，这部分日志会丢失，但是因为事务没提交，所以不会对数据一致性造成影响。因为事务只有在提交时，事务内所作的修改才真正起作用。</p><p><strong>但是事务还没提交时，redo log buffer里面的内容也会有刷入磁盘的情况。</strong></p><h2 id="redo-log可能存在的三种状态"><a href="#redo-log可能存在的三种状态" class="headerlink" title="redo log可能存在的三种状态"></a>redo log可能存在的三种状态</h2><p>1、存在于redo log buffer中，也就是还在MySQL进程中。</p><p>2、写入了文件系统的缓存当中。</p><p>3、写入了磁盘当中。</p><h2 id="redo-log的写入策略"><a href="#redo-log的写入策略" class="headerlink" title="redo log的写入策略"></a>redo log的写入策略</h2><p>为了控制redo log的写入策略，InnoDB提供了innodb_flush_log_at_trx_commit参数，控制写入策略：</p><ol><li>设置为0的时候，表示每次事务提交时都只是把redo log留在redo log buffer中;</li><li>设置为1的时候，表示每次事务提交时都将redo log直接持久化到磁盘；</li><li>设置为2的时候，表示每次事务提交时都只是把redo log写到page cache。</li></ol><p>InnoDB有一个后台线程，每隔1秒，就会把redo log buffer中的日志，调用write写到文件系统的page cache，然后调用fsync持久化到磁盘。</p><p>这也就解释了为什么会有没提交事务的redo log也被写入了磁盘当中。因为事务执行时，日志就会先写入redo log buffer中，后台线程会在事务没提交时，将数据刷入磁盘当中。</p><p>另外两种会导致事务没提交时，redo log 被写入磁盘：</p><p><strong>一种是，redo log buffer占用的空间即将达到 innodb_log_buffer_size一半的时候，后台线程会主动写盘。</strong>但这里只是写入文件系统的缓存中，不是写入磁盘。</p><p><strong>另一种是，并行的事务提交的时候，顺带将这个事务的redo log buffer持久化到磁盘。</strong>比如说事务A执行了一半，它已经写入了一部分日志到redo log buffer中。如果此时另一个事务提交了，而且innodb_flush_log_at_trx_commit参数设置的是1，那么它就会直接将redo log buffer中的内容直接写入磁盘，这样事务A的一部分日志就被写入了磁盘当中。</p><h1 id="双一配置"><a href="#双一配置" class="headerlink" title="双一配置"></a>双一配置</h1><p>两阶段提交的流程是：时序上redo log先prepare， 再写binlog，最后再把redo log commit。</p><p>将innodb_flush_log_at_trx_commit设置为1时，redo log在处于prepare阶段时，就会刷新到磁盘当中。</p><p>通常我们说MySQL的“双1”配置，指的就是sync_binlog和innodb_flush_log_at_trx_commit都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是redo log（prepare 阶段），一次是binlog。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL45讲》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;binlog的写入机制&quot;&gt;&lt;a href=&quot;#binlog的写入机制&quot; class=&quot;headerlink&quot; title=&quot;binlog的写入机制&quot;&gt;&lt;/a&gt;binlog的写入机制&lt;/h1&gt;&lt;p&gt;总的流程：先把日志写到binlog cache，事务提交的时候，再把</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    <category term="日志" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="MySQL45讲" scheme="http://example.com/tags/MySQL45%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>分页</title>
    <link href="http://example.com/2023/04/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E9%A1%B5/"/>
    <id>http://example.com/2023/04/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E9%A1%B5/</id>
    <published>2023-04-18T06:03:04.000Z</published>
    <updated>2023-04-19T09:10:06.629Z</updated>
    
    <content type="html"><![CDATA[<p>因为分段采用的是将空间划分为大小不同的部分，这样的话会导致整个空间比较零碎，会给内存维护带来一定的困难。</p><p>为了解决这个问题，我们可以把内存空间分割成大小一样的片段，这种思想称为分页。</p><p>分页不是将一个进程的地址空间分割成几个不同长度的逻辑段（即代码、堆、段），而是分割成固定大小的单元，每个单元称为一页。</p><p>我们把物理内存看成是定长的一个分割过的槽，叫作页帧（page frame）。每个这样的页帧包含一个虚拟内存页。如下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230418170854468.png" alt="image-20230418170854468" style="zoom:67%;" /><p>当分页出现以后，一个进程地址空间被引入内存就变为下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230418171040236.png" alt="image-20230418171040236" style="zoom:67%;" /><p>为了记录地址空间的每个虚拟页放在物理内存中的位置，操作系统通常为每个进程保存一个数据结构，称为页表（page table）。</p><p>页表的主要作用是为地址空间的每个虚拟页面保存地址转换（address translation），从而让我们知道每个页在物理内存中的位置。</p><h1 id="页表中有什么"><a href="#页表中有什么" class="headerlink" title="页表中有什么"></a>页表中有什么</h1><p>页表中有一个有效位的标识符。该标识符用于标记对应的地址空间是否使用，如果尝试访问标记为未使用的地址空间，那么程序可能会被终止。</p><p>通过有效位，我们可以只对标识为已经使用了的地址空间进行分配物理内存，这样就节省了大量内存。</p><p>还有一个存在位，用于标识该页是在内存中还是被换出到了磁盘。</p><p>参考位用于标记该页是否被访问。</p><h1 id="分页带来的问题"><a href="#分页带来的问题" class="headerlink" title="分页带来的问题"></a>分页带来的问题</h1><p>引入分页后，我们每次想要找到具体的物理地址时，系统需要先从进程的页表中取到对应的页表项，然后才能进行具体的地址空间到物理地址的转换。</p><p>在分段的设计下，我们可以直接从进程的基址寄存器中找到对应的物理位置。</p><p>而引入分页后，我们需要先从内存中取出页表，然后在页表中去找对应的地址空间到物理地址的转换。相当于多了一次取页表的操作。</p><p>而且页表需要占用物理内存。</p><p>要注意，每一个进程都会对应一个页表。每次都要从内存中找到该进程对应的页表，然后从页表中取地址的映射。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为分段采用的是将空间划分为大小不同的部分，这样的话会导致整个空间比较零碎，会给内存维护带来一定的困难。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我们可以把内存空间分割成大小一样的片段，这种思想称为分页。&lt;/p&gt;
&lt;p&gt;分页不是将一个进程的地址空间分割成几个不同长度的逻辑段（即代码</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>对于socket的一些理解</title>
    <link href="http://example.com/2023/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%AF%B9%E4%BA%8Esocket%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2023/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%AF%B9%E4%BA%8Esocket%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</id>
    <published>2023-04-18T03:13:41.000Z</published>
    <updated>2023-04-18T05:34:59.279Z</updated>
    
    <content type="html"><![CDATA[<p> 在大学刚接触到网络编程以及web编程的时候，听说过socket以及端口号，但是当时只是知道写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> xx;</span><br><span class="line">ServerSocket serverSocket <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);;</span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(ip, port);</span><br></pre></td></tr></table></figure><p>但是并不明白为什么要这样做，在学习了计算机网络后，有了一些个人理解。</p><p>在计算机网络中，我们编写的代码，是属于应用层的内容，当需要传输数据时，需要先将数据传送给运输层，然后运输层送往网络层，依次往下传送。</p><p>其实我们可以将应用层与其他的几层拆分开，然后把运输层及其以下的几层当作是一个其他人已经封装好了的计算机网络。我们传输数据，只需要把数据交给这个计算机网络，它就能帮我们把数据传输到我们的目的地。而socket，就是我们的编写的程序与计算机网络之间的接口，也可以理解为一个桥梁，连接我们应用程序与计算机网络。</p><p>而我们在web编程，比如使用springboot框架，也需要在配置文件中指定端口号，它其实也是用于底层封装的socket指定对应端口号。</p><p>一个较为形象的比喻，我们的应用程序可以理解为手机，也就是应用层。而运输层及其以下的那几层可以理解为我们的房子内的电线。我们想要充电，就需要一个充电器，连接我们的手机以及那些电线。而这个充电器，可以理解为socket。</p><p>也就是说，每个socket都需要绑定端口号，用于标识它对应于哪个进程，我们的进程需要指定这个端口号，然后将数据通过socket传送到运输层，并进行第一次数据封装，用于目的主机找到对应的进程。到这里，就可以认为我们进程要传送的数据已经交给计算机网络，剩余的内容就由计算机网络处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 在大学刚接触到网络编程以及web编程的时候，听说过socket以及端口号，但是当时只是知道写法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络编程" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>计网中的多路分解与多路复用</title>
    <link href="http://example.com/2023/04/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>http://example.com/2023/04/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2023-04-17T13:46:42.000Z</published>
    <updated>2023-04-18T04:25:05.598Z</updated>
    
    <content type="html"><![CDATA[<p><strong>多路复用</strong>与<strong>多路分解</strong>是将网络层提供的主机到主机交付服务延伸到为运行在主机上的<strong>应用程序</strong>提供进程到进程的交付服务。</p><p>在目的主机，运输层负责从网络层接受报文段，然后将报文段中的数据交付给对应的进程。而每个进程都会有一个或者多个套接字，这些套接字可以理解为网络层和运输层传输数据的门户（一个更形象的比喻，可以把套接字理解为插座的插口。传输数据需要先连接套接字，而充电也要先找到插口）。其实数据并不是直接由网络层传输给数据层，而是网络层传送给套接字，而套接字又传送给运输层。如下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417220052440.png" alt="image-20230417220052440" style="zoom:67%;" /><h1 id="多路分解"><a href="#多路分解" class="headerlink" title="多路分解"></a>多路分解</h1><p>将运输层报文段中的数据交付到正确的套接字的工作称为多路分解。</p><p>因为接受端不会只有一个套接字，所以需要找到正确的套接字。而每个套接字都会有唯一的标识符。</p><p>运输层为了找到正确的套接字，运输层的每个报文段都会有几个特殊字段，这几个字段，用于找到正确的套接字。</p><h1 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h1><p>在源主机中，从不同套接字收集数据块，然后将数据块封装生成报文段，并将报文段传送到网络层，这些工作统称为多路复用。</p><p>而在目的主机中，运输层从网络层接受到的报文段分解后交给对应的进程，这个过程是通过将报文段定向到对应套接字来完成的。</p><h1 id="多路复用要求"><a href="#多路复用要求" class="headerlink" title="多路复用要求"></a>多路复用要求</h1><p>1、套接字有唯一标识符</p><p>2、每个报文段有特殊字段来指示该报文段所要交付到的套接字。</p><p>报文段中会包含源端口号和目的端口号，如下图所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230418095136342.png" alt="image-20230418095136342" style="zoom:67%;" /><p>运输层分解：</p><p>主机上的每一个套接字都会有对应的端口号，当报文段到达主机后，运输层会查看报文段中的端口号，并将其定向到相应的套接字。然后报文段中的数据就通过套接字进入套接字对应的进程。</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>只有运输层与进程之间有套接字，也就是说进程发送给运输层数据，需要指定端口号和对应套接字，然后运输层会将报文封装，添加源主机端口号和目的主机端口号，用于目的主机对数据进行分解，找到对应进程。</p><p>而运输层与网络层之间，没有套接字的概念。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《计算机网络：自顶向下方法》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;多路复用&lt;/strong&gt;与&lt;strong&gt;多路分解&lt;/strong&gt;是将网络层提供的主机到主机交付服务延伸到为运行在主机上的&lt;strong&gt;应用程序&lt;/strong&gt;提供进程到进程的交付服务。&lt;/p&gt;
&lt;p&gt;在目的主机，运输层负责从网络层接受报文段，然后将</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="运输层" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
    
    <category term="运输层" scheme="http://example.com/tags/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>空闲空间管理</title>
    <link href="http://example.com/2023/04/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2023/04/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/</id>
    <published>2023-04-17T07:48:51.000Z</published>
    <updated>2023-04-17T08:54:15.770Z</updated>
    
    <content type="html"><![CDATA[<p>这一部分，书中做了一些假设：</p><p>1、如果请求内存，就需要指定请求内存的大小，而释放该内存则不用指定大小。</p><p>2、只考虑外部碎片，不考虑因分配空间稍微大于请求内存而造成的内部碎片。</p><p>3、内存一旦被分配给用户，那么它就不可能被重定位。即这块内存分配给用户后，除非用户调用free函数，否则无法被其他人使用。</p><p>4、分配程序管理的内存区域是连续的，而且还可以增大这块区域。</p><h1 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h1><h2 id="1、分割与合并"><a href="#1、分割与合并" class="headerlink" title="1、分割与合并"></a>1、分割与合并</h2><p>假如内存中空闲状态如下图：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417162102174.png" alt="image-20230417162102174"></p><p>那么它对应的空闲链表如图：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417162144075.png" alt="image-20230417162144075"></p><p>这也就意味着，任何长度大于10字节的分配请求都会失败。</p><p>如果请求分配的内存小于10字节，那么它会找到一块满足的空间区域，然后进行分割，第一块分给用户，剩下的加入空闲列表。</p><p>而用户在调用free时，它并不是把用户使用的那块区域直接加入，而是会看用户释放的空间左右两端是否是空闲的，如果是，则进行合并。</p><p>比如参考第一张图，如果用户释放中间用掉的10字节，它会变为如下：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417163036922.png" alt="image-20230417163036922"></p><p>而不是</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417163055234.png" alt="image-20230417163055234"></p><h2 id="2、追踪已分配空间的大小"><a href="#2、追踪已分配空间的大小" class="headerlink" title="2、追踪已分配空间的大小"></a>2、追踪已分配空间的大小</h2><p>由于在释放对应区域空间时，并不需要指出大小，这是因为在大多数分配程序都会在头块中保存一些额外的信息，头块位于内存中，就在返回的内存区域前面。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417164000218.png" alt="image-20230417164000218" style="zoom:67%;" /><p>这里释放的时候会释放头块加具体的内存空间，那么意味着在申请内存时，申请的大小也是头块加用户指明的大小。</p><h1 id="内存分配的基本策略"><a href="#内存分配的基本策略" class="headerlink" title="内存分配的基本策略"></a>内存分配的基本策略</h1><p>1、最优匹配：找到和用户申请大小最接近的一块区域，分配给用户。但是他需要遍历所有的空闲列表，性能差一点。</p><p>2、最差匹配：找最大的空闲区域，分割并分配给用户。会导致过量碎片，而且性能不好。</p><p>3、首次匹配：找到第一个足够大的块，分配给用户。不需要全部遍历，但可能会导致开头的部分有很多的小块，因此，如何管理空闲列表顺序就变的比较重要。</p><p>一种解决办法：一种方式是基于地址排序，保持空闲块按内存地址有序，会让合并变得容易，减少内存碎片。</p><p>4、下次匹配：每一次都从上一次分配完成的地址开始往后遍历。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一部分，书中做了一些假设：&lt;/p&gt;
&lt;p&gt;1、如果请求内存，就需要指定请求内存的大小，而释放该内存则不用指定大小。&lt;/p&gt;
&lt;p&gt;2、只考虑外部碎片，不考虑因分配空间稍微大于请求内存而造成的内部碎片。&lt;/p&gt;
&lt;p&gt;3、内存一旦被分配给用户，那么它就不可能被重定位。即这块</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>分段</title>
    <link href="http://example.com/2023/04/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E6%AE%B5/"/>
    <id>http://example.com/2023/04/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E6%AE%B5/</id>
    <published>2023-04-17T05:35:17.000Z</published>
    <updated>2023-04-17T07:48:36.505Z</updated>
    
    <content type="html"><![CDATA[<p> 在分段之前，操作系统会直接把进程的地址空间完整的加载到内存当中，但是栈和堆中间却有很大一块空间没有使用，如下图：</p><img src="C:\Users\郭俊豪\AppData\Roaming\Typora\typora-user-images\image-20230417134359838.png" alt="image-20230417134359838" style="zoom: 67%;" /><p>但是由于进程的地址空间被加载到了内存中，那么就意味着这些虚拟的地址空间都会被分配对应的物理地址，虽然这些地址没有被该进程写入内容，但是他们已经不能再分配给其他进程使用。</p><p>为了解决这个问题，引入了分段的概念。有了分段的概念后，就不是给每个地址空间一个寄存器，而是让地址空间内的每个段都有自己的基址寄存器和界限寄存器。<strong>一个段是地址空间中连续的定长区域。</strong></p><p>这样设计，就可以把进程的单个段加载到内存中，而不是将整个地址空间都加载到内存中，这样就能确保被加载到物理内存空间中的内容都是正在使用的，或者说最小程度的浪费一些空间。</p><p>在经典的地址空间中，有三个逻辑不同的段：代码，栈和堆。分段之后，我们可以把这三个部分分别加载到物理内存对应的位置，如下图所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417141138659.png" alt="image-20230417141138659" style="zoom: 67%;" /><p>而不需要像之前那样，必须把整个地址空间全部加载到内存当中。</p><h1 id="分段存在的问题"><a href="#分段存在的问题" class="headerlink" title="分段存在的问题"></a>分段存在的问题</h1><p>分段的出现会导致内存中零散的分布很多的段，如果现在有不连续的24k空间，现在有一个20k大小的段，则会导致该段进入内存失败。</p><p>即分段会造成一定的外部碎片。</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>这篇笔记是在学习操作系统导论时写的，该书采用的是层层递进的方式，由最初的设计，存在什么问题，一步一步解决问题，更改设计，得到一个现代的操作设计方案。所以本文中有些内容可能并非目前操作系统正确的设计。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 在分段之前，操作系统会直接把进程的地址空间完整的加载到内存当中，但是栈和堆中间却有很大一块空间没有使用，如下图：&lt;/p&gt;
&lt;img src=&quot;C:\Users\郭俊豪\AppData\Roaming\Typora\typora-user-images\image-2023</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>地址转换</title>
    <link href="http://example.com/2023/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/"/>
    <id>http://example.com/2023/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/</id>
    <published>2023-04-16T09:35:58.000Z</published>
    <updated>2023-04-18T01:43:09.564Z</updated>
    
    <content type="html"><![CDATA[<p>地址转换：硬件对每次的内存访问进行处理，将指令的虚拟地址转换为数据实际的物理地址。</p><p>但是仅仅靠硬件无法解决，它只能提高效率。还需要操作系统的帮助。</p><p>这使得每个程序好像拥有了自己私有的内存空间，存放着自己的代码和数据。但实际上是多个程序共用内存。</p><h1 id="动态重定位"><a href="#动态重定位" class="headerlink" title="动态重定位"></a>动态重定位</h1><p>每个CPU需要两个硬件寄存器：基址寄存器和界限寄存器。这两个寄存器能够让我们将地址空间放在物理内存的任何位置，同时又保证程序只访问自己的地址空间。</p><p>采用这种硬件的地址转换方式，进程中的内存引用都是虚拟地址，而虚拟地址加上基址寄存器中的内容，可以算出来真实的物理地址，再发送给内存系统。</p><p>由于这个由虚拟内存转换为具体的物理内存的过程是在运行时发生的，所以又叫做动态重定位。</p><p>这里面的界限寄存器，就是用来保证进程只访问自己范围内的空间，如果越界，则cpu会触发异常，进程会被终止。</p><h1 id="操作系统要做什么"><a href="#操作系统要做什么" class="headerlink" title="操作系统要做什么"></a>操作系统要做什么</h1><p>1、进程创建时，操作系统要为进程的地址空间找到内存空间。这就需要操作系统来维护哪些空间是可用的，哪些是已经被使用了的。</p><p>2、当进程运行结束时，操作系统要负责回收它的内存，供其他进程使用。当进程结束时，操作系统会把这些内存放入空闲列表。</p><p>3、每个cpu只有一个界限寄存器和基址寄存器，但对于每个运行的程序，他们要存入的值都是不同的。所以在发生上下文切换时，操作系统需要保存当前正在运行进程的界限寄存器和基址寄存器的值，以便后续恢复该进程时使用。</p><p>4、操作系统需要提供异常处理。比如当一个程序要越界访问时，cpu会触发异常，而操作系统需要终止该程序。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;地址转换：硬件对每次的内存访问进行处理，将指令的虚拟地址转换为数据实际的物理地址。&lt;/p&gt;
&lt;p&gt;但是仅仅靠硬件无法解决，它只能提高效率。还需要操作系统的帮助。&lt;/p&gt;
&lt;p&gt;这使得每个程序好像拥有了自己私有的内存空间，存放着自己的代码和数据。但实际上是多个程序共用内存。&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的next-key lock</title>
    <link href="http://example.com/2023/04/16/MySQL/MySQL%E7%9A%84next-key%20lock/"/>
    <id>http://example.com/2023/04/16/MySQL/MySQL%E7%9A%84next-key%20lock/</id>
    <published>2023-04-16T07:10:20.000Z</published>
    <updated>2023-04-16T08:31:50.128Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB引擎为了解决幻读带来的问题，引入了间隙锁。而间隙锁和行锁组合起来叫做next-key lock，他是一个左开右闭的区间，代表锁住对应数据行以及数据行之间的间隙。</p><p>比如现在有两行数据，（5，5，5）和（10，10，10）。在可重复读得隔离级别下执行如下sql ，，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where id = 7</span><br></pre></td></tr></table></figure><p>就会锁住(5, 10]之间的间隙，以及第（10，10，10）这一行。因为锁是加在索引上面，而索引是有序的，所以需要保证这两条数据间没有新的数据插入。</p><p>在《MySQL45讲》中给出了加锁的一些规则：</p><ol><li>原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。</li><li>原则2：查找过程中访问到的对象才会加锁。</li><li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。</li><li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候（比如查询id &#x3D; 5，而最后一个值是id &#x3D; 10，那么就会变为间隙锁），next-key lock退化为间隙锁。</li><li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ol><p>假如现在有如下表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure><p>下面我们看一些具体的例子。</p><h1 id="等值查询间隙锁"><a href="#等值查询间隙锁" class="headerlink" title="等值查询间隙锁"></a>等值查询间隙锁</h1><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416152532725.png" alt="image-20230416152532725"></p><p>课程中讲的是：</p><p>1、根据原则1，加锁单位是next-key lock，session A加锁范围就是(5,10]；</p><p>2、同时根据优化2，这是一个等值查询(id&#x3D;7)，而id&#x3D;10不满足查询条件，next-key lock退化成间隙锁，因此最终加锁的范围是(5,10)。</p><p>所以插入（8，8，8）失败，而update10成功。</p><p>这里有一个疑问：为什么没有根据优化1，将（5，10]的next-key lock转变为行锁呢？</p><p>个人理解：虽然是唯一索引的等值操作，但是查询条件是id &#x3D; 7，而表中的值是id &#x3D; 5和 id &#x3D; 10这两条记录，并不相等，所以没有退化成行锁。</p><h1 id="非唯一索引等值锁"><a href="#非唯一索引等值锁" class="headerlink" title="非唯一索引等值锁"></a>非唯一索引等值锁</h1><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416152814309.png" alt="image-20230416152814309"></p><p>这个例子中，由于数据是（0，0，0）（5，5，5）（10，10，10），而查询条件是c &#x3D; 5，所以会先在（0，5]之间加上next-key lock。</p><p>但是c是非唯一索引，所以需要遍历到不满足条件的为止，也就是说会访问到c &#x3D; 10这一行。所以还会给（5，10]加上锁，但是该锁最后一行c &#x3D; 10并不满足c &#x3D; 5的查询条件，所以会退化为间隙锁，也就是（5，10），并不锁c &#x3D; 10这一行。</p><p>而这个查询语走索引c，却只查询了id，恰好是覆盖索引，并不会回表，也就是说只锁了索引c，而没有锁索引id，那么意味着sessionB要操作的数据并没有加锁，所以B成功了，而C失败了。</p><h1 id="主键索引范围锁"><a href="#主键索引范围锁" class="headerlink" title="主键索引范围锁"></a>主键索引范围锁</h1><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416154441303.png" alt="image-20230416154441303" style="zoom: 50%;" /><p>sessionA会先找到id &#x3D; 5这一行，然后是id &#x3D; 10这一行，所以会加（5，10]的next-key lock。但是id &#x3D; 10满足了查询条件，所以这个锁会退化为行锁，只锁id &#x3D; 10这一行。</p><p>但是查询还有第二个条件id  &lt;  11，则会继续往后走，查找到id &#x3D; 15这一行。所以会加（10，15]的next-key lock。由于查询条件id &lt; 11在id &#x3D; 15这一行不满足，所以无法退化成间隙锁，也即是说15这一行也会被锁住。就会导致如图的情况。</p><h1 id="非唯一索引范围锁"><a href="#非唯一索引范围锁" class="headerlink" title="非唯一索引范围锁"></a>非唯一索引范围锁</h1><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416160330625.png" alt="image-20230416160330625" style="zoom:50%;" /><p>这个例子中，由于查询所有的值，所以走索引c需要回表。意味着不仅要锁索引c，也要锁id。</p><p>在第一次用c&#x3D;10定位记录的时候，索引c上加了(5,10]这个next-key lock后，由于索引c是非唯一索引，没有优化规则，也就是说不会变为行锁，因此最终sesion A加的锁是，索引c上的(5,10] 和(10,15] 这两个next-key lock。</p><p>所以插入8 和修改c &#x3D; 15也都会被阻塞。</p><h1 id="非唯一索引上存在”等值”的例子"><a href="#非唯一索引上存在”等值”的例子" class="headerlink" title="非唯一索引上存在”等值”的例子"></a>非唯一索引上存在”等值”的例子</h1><p>假如新插入了一行记录（30，10，30）那么索引c就会变为如下：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416162231844.png" alt="image-20230416162231844" style="zoom: 67%;" /><p>那么如下操作：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416162440432.png" alt="image-20230416162440432"></p><p>这里会加5，10以及10，15的锁，然后不包括端点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;InnoDB引擎为了解决幻读带来的问题，引入了间隙锁。而间隙锁和行锁组合起来叫做next-key lock，他是一个左开右闭的区间，代表锁住对应数据行以及数据行之间的间隙。&lt;/p&gt;
&lt;p&gt;比如现在有两行数据，（5，5，5）和（10，10，10）。在可重复读得隔离级别下执行如</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    <category term="锁" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/%E9%94%81/"/>
    
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>运输层概述</title>
    <link href="http://example.com/2023/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2023/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/</id>
    <published>2023-04-16T03:04:45.000Z</published>
    <updated>2023-04-18T01:42:32.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>运输层协议为运行在不同端的应用进程提供逻辑上的通信，该协议是在端系统中实现，而不是在路由器中实现。</p><p>在发送端，运输层将从发送应用程序进程接收到的报文转换成运输层分组，该分组称为<strong>运输层报文段</strong>（segment）。</p><p>转换的方法：</p><p>1、将应用报文划分为较小的块，并为每块加上一个运输层首部以生成运输层报文段。</p><p>2、然后，在发送端系统中，运输层将这些报文段传递给网络层，网路层将其封装成网络层分组（即数据报）并向目的地发送。</p><h1 id="运输层和网络层关系"><a href="#运输层和网络层关系" class="headerlink" title="运输层和网络层关系"></a>运输层和网络层关系</h1><p>运输层位于网络层之上。网络层提供主机到主机的逻辑通信，而运输层提供的是进程到进程的逻辑通信。</p><p>用书上的一个例子，场景是：假如现在有两个家庭A和B，每个家庭有4个孩子。而每个月两家孩子都会互相的写信。家庭A有一个孩子负责收集所有孩子的信件，然后送给邮局。家庭B同样有一个孩子来做这件事情。家庭A的孩子设为C，家庭B的孩子设为D。</p><p>在这个例子中，从这些孩子的角度来看，孩子C和孩子D就为他们提供了逻辑通信。因为其他孩子只需要把信交给孩子C和D，剩余事情都无需关心。邮局则提供了两个家庭间的逻辑通信，因为孩子C和D只需要把信交给邮局，其他的也无需关心。</p><p>所以可以做以下类比：</p><p>1、应用层报文 &#x3D; 信封上的字符</p><p>2、进程 &#x3D; 这群孩子 （他们是通信主体）</p><p>3、主机（端系统） &#x3D;  家庭  </p><p>4、运输层协议  &#x3D;  孩子C和D</p><p>5、网络层协议  &#x3D;  邮政服务</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《计算机网络导论：自顶向下方法》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;运输层协议为运行在不同端的应用进程提供逻辑上的通信，该协议是在端系统中实现，而不是在路由器中实现。&lt;/p&gt;
&lt;p&gt;在发送端，运输层将从发送应</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="运输层" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
    
    <category term="运输层" scheme="http://example.com/tags/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>CDN</title>
    <link href="http://example.com/2023/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CDN/"/>
    <id>http://example.com/2023/04/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CDN/</id>
    <published>2023-04-16T01:37:45.000Z</published>
    <updated>2023-04-18T01:43:39.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内容分发网络CDN"><a href="#内容分发网络CDN" class="headerlink" title="内容分发网络CDN"></a>内容分发网络CDN</h1><p>现阶段，很多视频公司没日需要给用户推送大量的视频，这些视频如果都从公司的主服务器推送出去，则会给主服务器造成压力，而且由于区域原因，还会带来很高的时延。</p><p>CDN就是为了解决上面的问题。CDN服务器可以分布在多个地区，它存储那些视频以及图片的副本，用于用户请求时将视频等内容响应给用户。可以减小主服务器带宽压力，而且根据用户地理位置，分配不同的CDN，可以减少时延。</p><p>CDN采用集群部署，如果用户请求的CDN集群没有用户的目标视频，则该CDN集群会从中心仓库或者另一个集群搜索该视频，然后一边给用户传输，一边缓存在本集群中。</p><h1 id="CDN操作"><a href="#CDN操作" class="headerlink" title="CDN操作"></a>CDN操作</h1><p>当用于从浏览器请求某视频时，CDN需要先截获用户请求，才能确定适合用户的CDN集群，以及将用户请求重定向到该集群中。</p><h2 id="如何截获和重定向"><a href="#如何截获和重定向" class="headerlink" title="如何截获和重定向"></a>如何截获和重定向</h2><p>截获请求和重定向需要依赖于DNS。假如公司A用了公司B提供的CDN服务，那么一个大概的流程如下：</p><p>1、用户访问公司A的网站，点击了一个视频，那么他会向对应的域名发起请求（例如请求<a href="https://www.bilibili.com/video/xxx%EF%BC%89%EF%BC%8C%E8%8E%B7%E5%8F%96%E8%AF%A5%E8%A7%86%E9%A2%91%E3%80%82">https://www.bilibili.com/video/xxx），获取该视频。</a></p><p>2、用户的本地DNS服务器会将请求转发到权威DNS服务器，权威DNS服务器发现了域名中的video，那么它并不会向用户返回一个IP地址，而是返回一个B公司的主机名。</p><p>3、然后，该请求就进入了B公司专用的DNS设施。然后用户本地DNS会发起第二个请求，此时就是直接向公司B发起的DNS请求，这个请求会得到一个指向B公司的ip地址，然后用户可以从这里获取到视频的信息。</p><p>从这里，用户发起向公司A的请求就被转变为向公司B的CDN服务器的请求。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416102329355.png" alt="image-20230416102329355" style="zoom:67%;" /><h2 id="集群选择策略"><a href="#集群选择策略" class="headerlink" title="集群选择策略"></a>集群选择策略</h2><p>在上面的重定向过程中，公司B的CDN服务器是可以知道用户本地DNS地址，那么他就可以根据该ip来为用户分配最为临近的CDN集群。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《计算机网络导论：自顶向下方法》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内容分发网络CDN&quot;&gt;&lt;a href=&quot;#内容分发网络CDN&quot; class=&quot;headerlink&quot; title=&quot;内容分发网络CDN&quot;&gt;&lt;/a&gt;内容分发网络CDN&lt;/h1&gt;&lt;p&gt;现阶段，很多视频公司没日需要给用户推送大量的视频，这些视频如果都从公司的主服务器推送</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="应用层" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
  </entry>
  
</feed>
