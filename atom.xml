<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便起个名字吧</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-10-29T07:08:37.037Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Guo Junhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>服务治理</title>
    <link href="http://example.com/2023/10/29/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    <id>http://example.com/2023/10/29/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/</id>
    <published>2023-10-29T07:07:56.000Z</published>
    <updated>2023-10-29T07:08:37.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务治理手段"><a href="#服务治理手段" class="headerlink" title="服务治理手段"></a>服务治理手段</h1><p>服务的调用涉及到注册中心，服务调用的发起方和提供方三者，这三者中任意两个的通信都是通过网络，那么不论是网络出现问题，还是说这三者中任意一个出现问题，此次调用都会失败。所以就需要服务治理。</p><h2 id="节点管理"><a href="#节点管理" class="headerlink" title="节点管理"></a>节点管理</h2><p>该部分可以分为两点。</p><ol><li>注册中心主动摘除机制。这种机制要求服务提供者定时向注册中心汇报心跳，当两次汇报中间的时间超过规定时间后，就认为服务提供者出现问题，进行摘除，然后把最近的可用服务列表推送给服务消费者。</li><li>服务消费者摘除机制。上述机制可能因为网络问题导致一个正常的服务被摘除，最坏情况所有服务都正常，但是全被摘除。一个更合理的摘除办法就是让服务的调用者去执行。即服务调用者调用失败时，就从本地缓存的可用服务列表中去移除该服务，而不进行实际的摘除。</li></ol><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>这里边有几个算法：</p><ol><li>随机算法</li><li>轮询算法</li><li>最少活跃调用算法</li><li>一致性Hash算法</li></ol><h2 id="服务路由"><a href="#服务路由" class="headerlink" title="服务路由"></a>服务路由</h2><p>对于服务消费者而言，在内存中的可用服务节点列表中选择哪个节点不仅由负载均衡算法决定，还由路由规则确定。而指定路由规则的主要原因有以下两点：</p><ol><li>服务功能做了变更，需要灰度发布，根据这部分人的使用反馈来决定是否全量发布时，就可以做一些路由规则的限制，比如说使用尾号限制，让特定比例的人群才会访问到新发布的服务节点。</li><li>部分规模比较大的公司，为了业务高可用，会将业务部署在不止一个IDC中，这时候不同IDC之间访问要跨IDC，而距离比较远时延迟就会比较大。所以一次服务调用尽可能选择同一个IDC内部的节点，减少网络开销，提高性能。</li></ol><p>路由的配置规则一般有<strong>静态配置</strong>和<strong>动态配置</strong>。其中静态配置是防止在每一个服务本地的，服务上线后规则不发生改变。而动态配置一般都是放在注册中心，需要修改时改动注册中心的内容即可。</p><h2 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h2><p>对于服务调用失败的情况，需要有手段自动恢复，来保证调用成功。常用手段有以下几种：</p><ol><li>失败自动切换。顾名思义，调用失败了后就从最近的可用服务列表中选一个进行重试，可以限制重试次数，但是这种操作要求服务的调用操作是<strong>幂等</strong>的。</li><li>失败通知。服务调用失败后，不再进行重试，而是根据失败返回的信息而决定后续的操作。</li><li>失败缓存。服务调用失败后，并不立即进行重试，而是隔一段时间后再进行重试。</li><li>快速失败。调用失败后就不管了。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《从0开始学微服务》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;服务治理手段&quot;&gt;&lt;a href=&quot;#服务治理手段&quot; class=&quot;headerlink&quot; title=&quot;服务治理手段&quot;&gt;&lt;/a&gt;服务治理手段&lt;/h1&gt;&lt;p&gt;服务的调用涉及到注册中心，服务调用的发起方和提供方三者，这三者中任意两个的通信都是通过网络，那么不论是网络出</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Netty源码简单解读</title>
    <link href="http://example.com/2023/10/29/Netty%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%A7%A3%E8%AF%BB/"/>
    <id>http://example.com/2023/10/29/Netty%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%A7%A3%E8%AF%BB/</id>
    <published>2023-10-29T01:56:54.000Z</published>
    <updated>2023-10-29T03:27:38.060Z</updated>
    
    <content type="html"><![CDATA[<p>注：仅仅是尝试看源码，锻炼一下看源码能力，理解并不一定正确。</p><h1 id="Netty的服务端创建"><a href="#Netty的服务端创建" class="headerlink" title="Netty的服务端创建"></a>Netty的服务端创建</h1><p>创建代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">    <span class="comment">// 接收新连接线程，创建新的连接</span></span><br><span class="line">    <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    <span class="comment">// 对应读取数据的线程，用于处理数据读取以及业务逻辑处理</span></span><br><span class="line">    <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    serverBootstrap</span><br><span class="line">        .group(boss, worker)</span><br><span class="line">        <span class="comment">// 这里是接收一个Channel的类型，然后通过反射创建一个工厂类</span></span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        <span class="comment">// 这个NioSocketChannel是Netty设计的</span></span><br><span class="line">        .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        System.out.println(s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).bind(<span class="number">8000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="group-boss-worker"><a href="#group-boss-worker" class="headerlink" title="group(boss, worker)"></a>group(boss, worker)</h2><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerBootstrap</span> <span class="keyword">extends</span> <span class="title class_">AbstractBootstrap</span>&lt;ServerBootstrap, ServerChannel&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> EventLoopGroup childGroup;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ServerBootstrap <span class="title function_">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.group(parentGroup);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.childGroup != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;childGroup set already&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.childGroup = (EventLoopGroup)ObjectUtil.checkNotNull(childGroup, <span class="string">&quot;childGroup&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，将boss也就是parentGroup传递给了父类的<code>group</code>方法，即<code>AbstractBootstrap</code>，而将worker传递给了<code>ServerBootstrap</code> ，并将ServerBootstrap返回。</p><p>父类的group方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBootstrap</span>&lt;B <span class="keyword">extends</span> <span class="title class_">AbstractBootstrap</span>&lt;B, C&gt;, C <span class="keyword">extends</span> <span class="title class_">Channel</span>&gt; <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> EventLoopGroup group;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> B <span class="title function_">group</span><span class="params">(EventLoopGroup group)</span> &#123;</span><br><span class="line">        ObjectUtil.checkNotNull(group, <span class="string">&quot;group&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.group != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;group set already&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.group = group;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.self();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对于这个group方法，做的事情比较简单，将两个<code>NioEventLoopGroup</code>传递给<code>ServerBootstrap</code>，然后将赋值后的<code>ServerBootstrap</code>返回。</p><h2 id="channel-NioServerSocketChannel-class"><a href="#channel-NioServerSocketChannel-class" class="headerlink" title="channel(NioServerSocketChannel.class)"></a>channel(NioServerSocketChannel.class)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> B <span class="title function_">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.channelFactory((io.netty.channel.ChannelFactory)(<span class="keyword">new</span> <span class="title class_">ReflectiveChannelFactory</span>((Class)ObjectUtil.checkNotNull(channelClass, <span class="string">&quot;channelClass&quot;</span>))));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码涉及到一个工厂类的创建<code>new ReflectiveChannelFactory()</code>，该工厂类的创建需要接收传入的<code>channelClass</code></p><p>工厂类的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectiveChannelFactory</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Channel</span>&gt; <span class="keyword">implements</span> <span class="title class_">ChannelFactory</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; constructor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReflectiveChannelFactory</span><span class="params">(Class&lt;? extends T&gt; clazz)</span> &#123;</span><br><span class="line">        ObjectUtil.checkNotNull(clazz, <span class="string">&quot;clazz&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.constructor = clazz.getConstructor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Class &quot;</span> + StringUtil.simpleClassName(clazz) + <span class="string">&quot; does not have a public non-arg constructor&quot;</span>, var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是通过反射，获取了传入类的构造方法。</p><p>另一个方法就是<code>this.channelFactory()</code>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> B <span class="title function_">channelFactory</span><span class="params">(io.netty.channel.ChannelFactory&lt;? extends C&gt; channelFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.channelFactory((ChannelFactory)channelFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> B <span class="title function_">channelFactory</span><span class="params">(ChannelFactory&lt;? extends C&gt; channelFactory)</span> &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(channelFactory, <span class="string">&quot;channelFactory&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.channelFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;channelFactory set already&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.channelFactory = channelFactory;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.self();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做的事情就是将上一步创建的<code>ReflectiveChannelFactory</code>赋值给<code>AbstractBootstrap</code>的<code>ChannelFactory</code>。</p><p>因为在创建<code>ReflectiveChannelFactory</code>时，获取到了传入class的构造方法，就可以创建对应的对象。</p><h2 id="childHandler-new-ChannelInitializer"><a href="#childHandler-new-ChannelInitializer" class="headerlink" title="childHandler(new ChannelInitializer(){}"></a>childHandler(new ChannelInitializer<NioSocketChannel>(){}</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerBootstrap</span> <span class="keyword">extends</span> <span class="title class_">AbstractBootstrap</span>&lt;ServerBootstrap, ServerChannel&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ChannelHandler childHandler;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ServerBootstrap <span class="title function_">childHandler</span><span class="params">(ChannelHandler childHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.childHandler = (ChannelHandler)ObjectUtil.checkNotNull(childHandler, <span class="string">&quot;childHandler&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是一个成员属性的赋值，主要看创建<code>ChannelHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ChannelInitializer</span>&lt;C <span class="keyword">extends</span> <span class="title class_">Channel</span>&gt; <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 这是一个抽象方法，必须实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(C var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 案例中重写的代码如下：</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">    nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="comment">// 重写的这个方法就是我们要做的业务逻辑处理</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">// 这个方法，客户端传递数据时应该会调用</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 案例中方法重写的代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;I&gt; <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext var1, I var2)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Netty客户端创建"><a href="#Netty客户端创建" class="headerlink" title="Netty客户端创建"></a>Netty客户端创建</h1><p>创建代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">    <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">    bootstrap.group(group)</span><br><span class="line">        .channel(NioSocketChannel.class)</span><br><span class="line">        .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8000</span>).channel();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: hello world&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就存在了第一个区别<code> ServerBootstrap</code> 和 <code>Bootstrap</code></p><p><code>Bootstrap</code>并没有自己的group方法，它是直接调用了父类的group，也就是说传入的group直接赋值给了<code>AbstractBootstrap</code>的<code>EventLoopGroup</code>。</p><p>其他的代码与服务端差不多，主要看<code>writeAndFlush</code>和<code>connect</code></p><h2 id="writeAndFlush"><a href="#writeAndFlush" class="headerlink" title="writeAndFlush"></a>writeAndFlush</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractChannel</span> <span class="keyword">extends</span> <span class="title class_">DefaultAttributeMap</span> <span class="keyword">implements</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line">    <span class="comment">// 默认的管道</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultChannelPipeline pipeline;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ChannelFuture <span class="title function_">writeAndFlush</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.pipeline.writeAndFlush(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultChannelPipeline</span> <span class="keyword">implements</span> <span class="title class_">ChannelPipeline</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext tail;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title function_">writeAndFlush</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.tail.writeAndFlush(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractChannelHandlerContext</span> <span class="keyword">implements</span> <span class="title class_">ChannelHandlerContext</span>, ResourceLeakHint &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> EventExecutor executor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultChannelPipeline pipeline;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ChannelFuture <span class="title function_">writeAndFlush</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.writeAndFlush(msg, <span class="built_in">this</span>.newPromise());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ChannelPromise <span class="title function_">newPromise</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(<span class="built_in">this</span>.channel(), <span class="built_in">this</span>.executor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Channel <span class="title function_">channel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.pipeline.channel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EventExecutor <span class="title function_">executor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (EventExecutor)(<span class="built_in">this</span>.executor == <span class="literal">null</span> ? <span class="built_in">this</span>.channel().eventLoop() : <span class="built_in">this</span>.executor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ChannelFuture <span class="title function_">writeAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.write(msg, <span class="literal">true</span>, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(Object msg, <span class="type">boolean</span> flush, ChannelPromise promise)</span> &#123;</span><br><span class="line">        ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里，如果promise不可用，那么就释放消息</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isNotValidPromise(promise, <span class="literal">true</span>)) &#123;</span><br><span class="line">                ReferenceCountUtil.release(msg);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException var8) &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">            <span class="keyword">throw</span> var8;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">AbstractChannelHandlerContext</span> <span class="variable">next</span> <span class="operator">=</span> <span class="built_in">this</span>.findContextOutbound(flush ? <span class="number">98304</span> : <span class="string">&#x27;耀&#x27;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> <span class="built_in">this</span>.pipeline.touch(msg, next);</span><br><span class="line">        <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">        <span class="comment">// 这里是判断当前的任务是否在循环当中</span></span><br><span class="line">        <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">                next.invokeWriteAndFlush(m, promise);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next.invokeWrite(m, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AbstractChannelHandlerContext.<span class="type">WriteTask</span> <span class="variable">task</span> <span class="operator">=</span> AbstractChannelHandlerContext.WriteTask.newInstance(next, m, promise, flush);</span><br><span class="line">            <span class="keyword">if</span> (!safeExecute(executor, task, promise, m, !flush)) &#123;</span><br><span class="line">                task.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;注：仅仅是尝试看源码，锻炼一下看源码能力，理解并不一定正确。&lt;/p&gt;
&lt;h1 id=&quot;Netty的服务端创建&quot;&gt;&lt;a href=&quot;#Netty的服务端创建&quot; class=&quot;headerlink&quot; title=&quot;Netty的服务端创建&quot;&gt;&lt;/a&gt;Netty的服务端创建&lt;/h1</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="源码分析" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>传统网络编程与NIO编程</title>
    <link href="http://example.com/2023/10/26/%E4%BC%A0%E7%BB%9F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2023/10/26/%E4%BC%A0%E7%BB%9F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO%E7%BC%96%E7%A8%8B/</id>
    <published>2023-10-26T02:47:23.000Z</published>
    <updated>2023-10-28T03:38:02.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传统网络编程"><a href="#传统网络编程" class="headerlink" title="传统网络编程"></a>传统网络编程</h1><p>首先看一段最传统的Java网络编程。</p><p>服务端代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8000</span>);</span><br><span class="line">        <span class="comment">// 接收新连接的线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 阻塞方法获取新的连接</span></span><br><span class="line">                    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 每一个新的连接都创建一个线程，负责读取数据</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                        <span class="type">int</span> len;</span><br><span class="line">                        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">                            <span class="comment">// 按字节流读取数据</span></span><br><span class="line">                            <span class="keyword">while</span> ((len = inputStream.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, len));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).start();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 我自己运行时，这里只创建了一次连接，然后没3s发送一次数据</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8000</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 网络传输都是传输的字节</span></span><br><span class="line">                    socket.getOutputStream().write((<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot; hello world&quot;</span>).getBytes());</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，服务端启动时创建了一个线程，建立了<code>ServerSocket</code>，循环的等待客户端的连接。客户端每次连接，服务端都会创建一个新的线程去处理请求，然后读取数据。</p><p>这种模型在客户端数量比较小的时候是没问题的，但是如果客户端数量较多，服务端就需要创建很多的线程，线程的创建比较消耗成本，而且线程数过多时，CPU调度导致的线程切换也会影响性能。</p><p>主要有以下三个问题：</p><ol><li>创建太多线程，而线程是很宝贵的资源，同一时刻大量线程处于阻塞会浪费资源。</li><li>线程切换效率低下。</li><li>IO编程中，数据传输都是以字节为单位。</li></ol><p>为了解决上述问题，引入了NIO，即同步非阻塞IO。</p><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p>在NIO中，只会创建一个线程去进行while循环，该线程监控所有的客户端连接，而不会像传统的有多少个客户端连接就创建多少个线程去进行while循环。</p><p>传统的模型中，在每一时刻，只有少数线程会有数据读写需求，而没有数据需要读写的就白白浪费了CPU资源。NIO中，通过将所有的客户端连接都注册到selector上，通过检测selector上是否有数据数据需要读写，就可以达到批量读取数据的目的。</p><p>这样，就解决了创建太多线程浪费资源和CPU频繁切换线程导致的性能问题。而传统IO是面向字节流，读取数据后需要自己缓存，流中就不存在该数据。而NIO的读写是面向Buffer的，解决了数据只能用字节传输的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">serverSelector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">clientSelector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 对应IO编程中服务端启动</span></span><br><span class="line">                <span class="type">ServerSocketChannel</span> <span class="variable">listenerChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">                listenerChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8000</span>));</span><br><span class="line">                listenerChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                listenerChannel.register(serverSelector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 检测是否有新的连接，1指的是阻塞时间为1ms</span></span><br><span class="line">                    <span class="keyword">if</span> (serverSelector.select(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Set&lt;SelectionKey&gt; set = serverSelector.selectedKeys();</span><br><span class="line">                        Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();</span><br><span class="line">                        <span class="comment">// 遍历所有有数据的SelectionKey</span></span><br><span class="line">                        <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                            <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">                            <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="comment">// 这里就是区别，当有一个新的连接请求到来时，不再创建一个线程，而是直接注册到clientSelector</span></span><br><span class="line">                                    <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> ((ServerSocketChannel) selectionKey.channel()).accept();</span><br><span class="line">                                    clientChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                                    clientChannel.register(clientSelector, SelectionKey.OP_READ);</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    <span class="comment">// 每个客户端只注册一次就可以了</span></span><br><span class="line">                                    keyIterator.remove();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 批量轮询是否有哪些连接的数据可读，1同样为阻塞时间</span></span><br><span class="line">                    <span class="keyword">if</span> (clientSelector.select(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Set&lt;SelectionKey&gt; set = clientSelector.selectedKeys();</span><br><span class="line">                        Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();</span><br><span class="line">                        <span class="comment">// 轮询所有已经注册了的客户端，然后判断哪一个可读</span></span><br><span class="line">                        <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                            <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">                            <span class="comment">// 这里是判断可读</span></span><br><span class="line">                            <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                                    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                                    <span class="comment">// 面向buffer</span></span><br><span class="line">                                    clientChannel.read(byteBuffer);</span><br><span class="line">                                    byteBuffer.flip();</span><br><span class="line">                                    System.out.println(Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    <span class="comment">// 这里为什么移除，是否是因为每个客户端传输一次数据后，就从注册中移除</span></span><br><span class="line">                                    keyIterator.remove();</span><br><span class="line">                                    key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NIO编程的核心思路：</p><ol><li>NIO 模型中通常会有两个线程，每个线程绑定一个轮询器 selector ，在上面的例子中 serverSelector负责轮询是否有新的连接，clientSelector负责轮询连接是否有数据可读。</li><li>服务端监测到新的连接之后，不再创建一个新的线程，而是直接将新连接绑定到clientSelector上， 这样就不用 IO 模型中 每个连接一个while循环。</li><li>clientSelector被一个 while 死循环包裹着，如果在某一时刻有多条连接有数据可读，那么通过 clientSelector.select(1)方法可以轮询出来，进而批量处理。</li><li>数据读写面向Buffer。</li></ol><p>但是不难看出，整个编码变得极其复杂。所有，就有了Netty。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;传统网络编程&quot;&gt;&lt;a href=&quot;#传统网络编程&quot; class=&quot;headerlink&quot; title=&quot;传统网络编程&quot;&gt;&lt;/a&gt;传统网络编程&lt;/h1&gt;&lt;p&gt;首先看一段最传统的Java网络编程。&lt;/p&gt;
&lt;p&gt;服务端代码如下：&lt;/p&gt;
&lt;figure class=&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/"/>
    
    <category term="netty" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/netty/"/>
    
    
    <category term="网络编程" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>单例模式的双重锁检查</title>
    <link href="http://example.com/2023/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8F%8C%E9%87%8D%E9%94%81%E6%A3%80%E6%9F%A5/"/>
    <id>http://example.com/2023/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8F%8C%E9%87%8D%E9%94%81%E6%A3%80%E6%9F%A5/</id>
    <published>2023-10-24T02:52:22.000Z</published>
    <updated>2023-10-24T03:08:47.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一般的单例模式"><a href="#一般的单例模式" class="headerlink" title="一般的单例模式"></a>一般的单例模式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            uniqueSingleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在多线程情况下，可能会导致多个实例：</p><table><thead><tr><th><strong>Time</strong></th><th>Thread A</th><th>Thread B</th></tr></thead><tbody><tr><td>T1</td><td>检查到<code>uniqueSingleton</code>为空</td><td></td></tr><tr><td>T2</td><td></td><td>检查到<code>uniqueSingleton</code>为空</td></tr><tr><td>T3</td><td></td><td>初始化对象A</td></tr><tr><td>T4</td><td></td><td>返回对象A</td></tr><tr><td>T5</td><td>初始化对象B</td><td></td></tr><tr><td>T6</td><td>返回对象B</td><td></td></tr></tbody></table><p>这种场景，就会创建两次对象。</p><h1 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h1><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            uniqueSingleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法也存在问题，加锁的粒度太大了，只有在创建对象时才需要加锁，后续获取对象时并不需要加锁。</p><h1 id="双重锁检查"><a href="#双重锁检查" class="headerlink" title="双重锁检查"></a>双重锁检查</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">                    <span class="comment">// 可能存在问题</span></span><br><span class="line">                    uniqueSingleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写，顺序就变成下面这样：</p><ol><li>先判断对象是否存在，不存在则加锁。</li><li>加完锁之后再次判断对象是否存在。</li><li>不存在则创建。</li></ol><p>双重加锁是因为如果多个线程同时通过了第一次判断，那么这几个线程中会有一个线程加锁成功，然后创建对象，后续线程在获取锁之后，就不用再继续创建对象。</p><h2 id="存在的隐患"><a href="#存在的隐患" class="headerlink" title="存在的隐患"></a>存在的隐患</h2><p>在实例化一个对象时，可以分为以下步骤：</p><ol><li>分配内存空间</li><li>初始化对象</li><li>将对象指向刚分配的内存空间</li></ol><p>但是编译器在为了执行速度，可能会进行<strong>指令重排序</strong>，那么顺序就有可能如下：</p><ol><li>分配内存空间</li><li>将对象指向刚分配的内存空间</li><li>初始化对象</li></ol><p>现在考虑如下场景：</p><table><thead><tr><th><strong>Time</strong></th><th>Thread A</th><th>Thread B</th></tr></thead><tbody><tr><td>T1</td><td>检查到<code>uniqueSingleton</code>为空</td><td></td></tr><tr><td>T2</td><td>获取锁</td><td></td></tr><tr><td>T3</td><td>第二次检查<code>uniqueSingleton</code>为空</td><td></td></tr><tr><td>T4</td><td>为<code>uniqueSingleton</code>分配空间</td><td></td></tr><tr><td>T5</td><td>将<code>uniqueSingleton</code>指向内存空间</td><td></td></tr><tr><td>T6</td><td></td><td>检查到<code>uniqueSingleton</code>不为空</td></tr><tr><td>T7</td><td></td><td>访问<code>uniqueSingleton</code>（此时对象还未完成初始化）</td></tr><tr><td>T8</td><td>初始化将<code>uniqueSingleton</code></td><td></td></tr></tbody></table><p>这种情况下，线程B就访问到了一个还未初始化完成的对象。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>使用<code>volatile</code>关键字禁止指令重排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">                    uniqueSingleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一般的单例模式&quot;&gt;&lt;a href=&quot;#一般的单例模式&quot; class=&quot;headerlink&quot; title=&quot;一般的单例模式&quot;&gt;&lt;/a&gt;一般的单例模式&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal源码</title>
    <link href="http://example.com/2023/10/21/ThreadLocal%E6%BA%90%E7%A0%81/"/>
    <id>http://example.com/2023/10/21/ThreadLocal%E6%BA%90%E7%A0%81/</id>
    <published>2023-10-21T07:04:29.000Z</published>
    <updated>2023-10-22T03:22:34.445Z</updated>
    
    <content type="html"><![CDATA[<p>以下源码是基于JDK11。</p><h1 id="Get以及Set"><a href="#Get以及Set" class="headerlink" title="Get以及Set"></a>Get以及Set</h1><p>一开始，一直在疑惑这个ThreadLocal到底是用来干嘛的，其实他可以用来存储一些变量，这些变量普通存储会由于被多线程访问或导致一些并发问题，用ThreadLocal存储，就会为每一个线程存储它自己的副本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这一步，它首先获取到了当前的线程，也就是说哪一个线程去调用ThreadLocal，就获取到哪一个线程。</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 这一步就是获取到线程对应的ThreadLocalMap，后文会有具体的结构</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="built_in">this</span>.getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里就是从ThreadLocalMap中获取到对应的元素</span></span><br><span class="line">        ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果之前的map为空，则调用该方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这个初始化值为null</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.initialValue();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 这里又重新判断了一次，应该是考虑到其他的线程可能在此之间已经创建了对应的map</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="built_in">this</span>.getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里判断map为空，那么就创建新的map</span></span><br><span class="line">        <span class="built_in">this</span>.createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> TerminatingThreadLocal) &#123;</span><br><span class="line">        TerminatingThreadLocal.register((TerminatingThreadLocal)<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    <span class="comment">// 这个threadLocals的类型是ThreadLocalMap</span></span><br><span class="line">    <span class="comment">// 这个创建，是为当前的线程创建一个ThreadLocalMap</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">// 这一步set的设计思路与get一致，都是获取到当前的线程之后，再进行操作。</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="built_in">this</span>.getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实中源码中可以看出，get和set操作都是先获取到当前线程，而每一个Thread中有一个变量ThreadLocalMap，然后去该变量中获取对应的元素。也就是说在每一个Thread中存储了对应的变量，这样就避免了并发访问的问题。</p><h1 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h1><p>ThreadLocalMap是ThreadLocal的一个内部类，ThreadLocalMap内部还有一个内部类，表示ThreadLocalMap的每一个节点。</p><p>首先看ThreadLocalMap的两个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">    <span class="comment">// creatMap调用的构造方法就是该方法。</span></span><br><span class="line">    <span class="comment">// 这里创建该ThreadLocalMap时，需要传入ThreadLocal，其目的就是为了获取对应的hash值，然后将该元素放入对应的下标即可。</span></span><br><span class="line">    <span class="comment">// 而且要获取到该ThreadLocal的table，因为元素的值需要与ThreadLocal绑定，我们要能通过ThreadLocal来拿到对应的元素。</span></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        <span class="built_in">this</span>.table = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry[<span class="number">16</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; <span class="number">15</span>;</span><br><span class="line">        <span class="built_in">this</span>.table[i] = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry(firstKey, firstValue);</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">this</span>.setThreshold(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ThreadLocalMap</span><span class="params">(ThreadLocal.ThreadLocalMap parentMap)</span> &#123;</span><br><span class="line">        ThreadLocal.ThreadLocalMap.Entry[] parentTable = parentMap.table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> parentTable.length;</span><br><span class="line">        <span class="built_in">this</span>.setThreshold(len);</span><br><span class="line">        <span class="built_in">this</span>.table = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry[len];</span><br><span class="line">        ThreadLocal.ThreadLocalMap.Entry[] var4 = parentTable;</span><br><span class="line">        <span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> parentTable.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="number">0</span>; var6 &lt; var5; ++var6) &#123;</span><br><span class="line">            ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> var4[var6];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                ThreadLocal&lt;Object&gt; key = (ThreadLocal)e.get();</span><br><span class="line">                <span class="keyword">if</span> (key != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> key.childValue(e.value);</span><br><span class="line">                    ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry(key, value);</span><br><span class="line">                    <span class="type">int</span> h;</span><br><span class="line">                    <span class="keyword">for</span>(h = key.threadLocalHashCode &amp; len - <span class="number">1</span>; <span class="built_in">this</span>.table[h] != <span class="literal">null</span>; h = nextIndex(h, len)) &#123;&#125;</span><br><span class="line">                    <span class="built_in">this</span>.table[h] = c;</span><br><span class="line">                    ++<span class="built_in">this</span>.size;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ThreadLocalMap的一个静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="built_in">super</span>(k);</span><br><span class="line">            <span class="built_in">this</span>.value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的Entry，就是对应存储的具体值，比如说如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该代码中，Entry就是一个City</span></span><br><span class="line">ThreadLocal&lt;City&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>每一个Thread有一个变量ThreadLocalMap，在创建该变量时，需要传入首个key以及value，其中key是一个ThreadLocal。</p><p>为什么要传入这个ThreadLocal呢？</p><p>我的理解是ThreadLocal要与对应的Thread绑定。换句话说，我们在使用ThreadLocal时，一般都是在多个线程中通过ThreadLocal来获取一个本该是共享的变量，而在ThreadLocal内部，它会先获取到当前线程，然后调用该线程的ThreadLocalMap来返回线程所需要的变量。所以，创建ThreadLocalMap时就需要传入一个ThreadLocal，方便后续获取值。</p><h2 id="Get以及Set-1"><a href="#Get以及Set-1" class="headerlink" title="Get以及Set"></a>Get以及Set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里，是根据传入的key先获取到hash值，然后去table的对应下标获取元素，存在则直接返回，不存在则调用getEntryAfterMiss</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ThreadLocal.ThreadLocalMap.Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; <span class="built_in">this</span>.table.length - <span class="number">1</span>;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> <span class="built_in">this</span>.table[i];</span><br><span class="line">    <span class="keyword">return</span> e != <span class="literal">null</span> &amp;&amp; e.get() == key ? e : <span class="built_in">this</span>.getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里就是遍历table所有的元素（该ThreadLocalMap存储的所有元素），找是否有key匹配的，有就直接返回</span></span><br><span class="line"><span class="comment"> * 如果table中某一个值为空，则调用expungeStaleEntry方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ThreadLocal.ThreadLocalMap.Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, ThreadLocal.ThreadLocalMap.Entry e)</span> &#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = <span class="built_in">this</span>.table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length; e != <span class="literal">null</span>; e = tab[i]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = (ThreadLocal)e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.expungeStaleEntry(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法的主要目的是为了清除对应下标的元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = <span class="built_in">this</span>.table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">    --<span class="built_in">this</span>.size;</span><br><span class="line"></span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 这里是遍历该ThreadLocalMap的Entry数组，也就是看该ThreadLocalMap存储的所有元素</span></span><br><span class="line">    <span class="keyword">for</span>(i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = nextIndex(i, len)) &#123;</span><br><span class="line">       <span class="comment">// 获取到对应的ThreadLocal</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = (ThreadLocal)e.get();</span><br><span class="line">        <span class="comment">// 这里应该是考虑对应的ThreadLocal已经被释放了</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">            --<span class="built_in">this</span>.size;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这几步操作，就是为了调整元素位置，将他们放在合适的位置，以减小tab大小</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                <span class="comment">// 这一步是循环，断开强引用</span></span><br><span class="line">                <span class="keyword">for</span>(tab[i] = <span class="literal">null</span>; tab[h] != <span class="literal">null</span>; h = nextIndex(h, len)) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = <span class="built_in">this</span>.table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = (ThreadLocal)e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++<span class="built_in">this</span>.size;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= <span class="built_in">this</span>.threshold) &#123;</span><br><span class="line">        <span class="built_in">this</span>.rehash();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value, <span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = <span class="built_in">this</span>.table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line"></span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = prevIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = prevIndex(i, len)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = (ThreadLocal)e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot) &#123;</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.cleanSomeSlots(<span class="built_in">this</span>.expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot) &#123;</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry(key, value);</span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot) &#123;</span><br><span class="line">        <span class="built_in">this</span>.cleanSomeSlots(<span class="built_in">this</span>.expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，ThreadLocalMap是用Entry[]去保存value，而Entry继承了WeakReference，查资料得知这里Entry的key是弱引用，意味着当ThreadLocal没有外部强引用时，会被GC回收，而对应的该ThreadLocal对应的value却不会被回收，若当前线程一直没有结束，会存在一条强引用链, value也会一直累加导致内存泄露。</p><p>而<code>expungeStaleEntry</code>方法就是为了解决上述问题。主动去清理key为空的ThreadLocal对应的value。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以下源码是基于JDK11。&lt;/p&gt;
&lt;h1 id=&quot;Get以及Set&quot;&gt;&lt;a href=&quot;#Get以及Set&quot; class=&quot;headerlink&quot; title=&quot;Get以及Set&quot;&gt;&lt;/a&gt;Get以及Set&lt;/h1&gt;&lt;p&gt;一开始，一直在疑惑这个ThreadLocal到底是</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="源码分析" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>如何使用3m内存来找到1G文件中词频前100的单词</title>
    <link href="http://example.com/2023/10/17/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A81m%E5%86%85%E5%AD%98%E6%9D%A5%E6%89%BE%E5%88%B01G%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%8D%E9%A2%91%E5%89%8D100%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <id>http://example.com/2023/10/17/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A81m%E5%86%85%E5%AD%98%E6%9D%A5%E6%89%BE%E5%88%B01G%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%8D%E9%A2%91%E5%89%8D100%E7%9A%84%E5%8D%95%E8%AF%8D/</id>
    <published>2023-10-17T01:36:12.000Z</published>
    <updated>2023-10-26T02:49:01.410Z</updated>
    
    <content type="html"><![CDATA[<p>题目原场景与标题相似，只不过文件的每一行是一个单词，然后在内存只有3m空间，需要获取到1G文件中所有单词频率前100的单词。</p><p>想到了用bitmap。</p><h1 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h1><p>bitmap往往是做一个映射，来减小数原数据占用空间的大小。在Java中，一个int类型的大小是32位，也就是32bit，它占4字节，也就是4byte，现考虑如下场景：</p><p>现在要存储三个数字，比如说5，16，20，如果用一个int数组存储，那么就需要3 * 4 &#x3D; 12字节，但是我们可以换一个思路，比如说使用byte数组，1byte是8位，也就是说可以通过这8位的值位0或1，来代表是否存在数字0-7。那么原来的4字节，就可以代表数字0-31是否存在于集合当中。具体如下表所示</p><table><thead><tr><th>数组值</th><th>1</th><th>1</th><th>0</th><th>0</th><th>0</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>下标</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>说明</td><td>值为1，代表存在数字0</td><td>值为1，代表存在数字1</td><td>值为0，代表不存在数字2</td><td>值为0，代表不存在数字3</td><td>值为0，代表不存在数字4</td><td>值为0，代表不存在数字5</td><td>值为1，代表存在数字6</td><td>值为1，代表存在数字7</td></tr></tbody></table><p>通过这种转换，我们就使用了1字节存储原来需要16字节（4个数字0，1，6，7）才可以存储的集合。</p><p>在具体的实现中，我们初始化一个byte数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><p>我们在计算某一个数字是否存在时，我们要先计算该数字在byte[]数组中的下标，当计算完下标之后，我们就需要将该数字移位，计算出它在该下标在哪一位。</p><p>这里的bytes[i]就是上面表格中的样子。每一个byte的大小为2^8 - 1，可以表示0~2^8 - 1。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>1GB大小的文件，全部存储单词，我们假设平均每个单词的长度为10，查阅资料得知Java中空字符串占用40字节，我们做一个大致的估算，一个单词长度为10，那么每个单词占用空间大小就是60字节（一个char[]数组中每个字符占2字节）。那么这1GB大小的文件当中一共有1 * 1024 * 1024 &#x2F; 60 &#x3D; 17476个单词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象头（<span class="number">8</span> 字节）+ 引用 (<span class="number">4</span> 字节 )  + <span class="type">char</span> 数组（<span class="number">16</span> 字节）+ <span class="number">1</span>个 <span class="type">int</span>（<span class="number">4</span>字节）+ <span class="number">1</span>个<span class="type">long</span>（<span class="number">8</span>字节）= <span class="number">40</span> 字节</span><br></pre></td></tr></table></figure><p>一个最笼统的思路，我们可以对每一个单词做一个Hash，然后将他映射到一个bitmap上，通过这种转化，原先1G大小的单词，就可以通过该映射存储到对应的位置。</p><p>但是这种思路好像没办法解决对应的问题，因为bitmap只能存储0或者1，如果存在两个相同的单词，并不能够进行统计，并且还有Hash冲突的可能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目原场景与标题相似，只不过文件的每一行是一个单词，然后在内存只有3m空间，需要获取到1G文件中所有单词频率前100的单词。&lt;/p&gt;
&lt;p&gt;想到了用bitmap。&lt;/p&gt;
&lt;h1 id=&quot;bitmap&quot;&gt;&lt;a href=&quot;#bitmap&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="场景分析" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    
    
    <category term="场景分析" scheme="http://example.com/tags/%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码</title>
    <link href="http://example.com/2023/10/14/HashMap%E6%BA%90%E7%A0%81/"/>
    <id>http://example.com/2023/10/14/HashMap%E6%BA%90%E7%A0%81/</id>
    <published>2023-10-14T02:29:37.000Z</published>
    <updated>2023-10-21T07:05:27.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap源码"><a href="#HashMap源码" class="headerlink" title="HashMap源码"></a>HashMap源码</h1><h2 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    HashMap.Node e;</span><br><span class="line">    <span class="keyword">return</span> (e = <span class="built_in">this</span>.getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> HashMap.Node&lt;K, V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    HashMap.Node[] tab;</span><br><span class="line">    HashMap.Node first;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 这里，先把tab指向了整个类的table，也就是先获取目前存储的所有元素</span></span><br><span class="line">    <span class="comment">// 同时判断是否为空，长度是否大于0，并初始化first的值，n - 1 &amp; hash是为了保证hash值有效</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = <span class="built_in">this</span>.table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (first = tab[n - <span class="number">1</span> &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">// 这里是为了判断是否存在hash冲突，如果hash值相等，并且key也相当，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; ((k = first.key) == key || key != <span class="literal">null</span> &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap.Node e;</span><br><span class="line">        <span class="comment">// 这里是判断冲突后，是否还存在下一个元素</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断此时的结构是否为红黑树，如果是，则遍历红黑树找节点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> HashMap.TreeNode) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((HashMap.TreeNode)first).getTreeNode(hash, key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不是红黑树，那么就是一个链表，直接遍历链表到结尾，找对应元素即可。</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key != <span class="literal">null</span> &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span>((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getTreeNode"><a href="#getTreeNode" class="headerlink" title="getTreeNode"></a>getTreeNode</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap.TreeNode&lt;K, V&gt; <span class="title function_">getTreeNode</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span> ? <span class="built_in">this</span>.root() : <span class="built_in">this</span>).find(h, k, (Class)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> HashMap.TreeNode&lt;K, V&gt; <span class="title function_">find</span><span class="params">(<span class="type">int</span> h, Object k, Class&lt;?&gt; kc)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先获取到该节点的整个红黑树</span></span><br><span class="line">    HashMap.<span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        HashMap.TreeNode&lt;K, V&gt; pl = p.left;</span><br><span class="line">        HashMap.TreeNode&lt;K, V&gt; pr = p.right;</span><br><span class="line">        <span class="type">int</span> ph;</span><br><span class="line">        <span class="comment">// 首先，是因为发生hash冲突后，才会用这个红黑树来解决hash冲突，那么该树中节点的hash值不是应该全部相等吗？</span></span><br><span class="line">        <span class="comment">// 应该是没有看生成代码的原因，转变为红黑树后，应该要做一次reHash，那么他们就会有新的hash值来用于构建红黑树</span></span><br><span class="line">        <span class="comment">// 这里，就是获取到左子树和右子树的hash值，然后与传入的值进行比较，一直找到相等的</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h) &#123;</span><br><span class="line">            p = pl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) &#123;</span><br><span class="line">            p = pr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里是找到了Hash值相等的</span></span><br><span class="line">            Object pk;</span><br><span class="line">            <span class="comment">// 先判断key值是否相等，如果相等则返回</span></span><br><span class="line">            <span class="keyword">if</span> ((pk = p.key) == k || k != <span class="literal">null</span> &amp;&amp; k.equals(pk)) &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里是仍然有冲突，那么就看该节点的左右子树</span></span><br><span class="line">            <span class="keyword">if</span> (pl == <span class="literal">null</span>) &#123;</span><br><span class="line">                p = pr;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="literal">null</span>) &#123;</span><br><span class="line">                p = pl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 这里是左右子树都不为空</span></span><br><span class="line">                <span class="type">int</span> dir;</span><br><span class="line">                <span class="comment">// 这里由于没有传入比较器，所以不会走if，只会走else</span></span><br><span class="line">                <span class="keyword">if</span> ((kc != <span class="literal">null</span> || (kc = HashMap.comparableClassFor(k)) != <span class="literal">null</span>) &amp;&amp; (dir = HashMap.compareComparables(kc, k, pk)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    p = dir &lt; <span class="number">0</span> ? pl : pr;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 这里是左右子树都不为空，则递归的进行搜索即可</span></span><br><span class="line">                    HashMap.TreeNode q;</span><br><span class="line">                    <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    p = pl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(p != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HashMap源码&quot;&gt;&lt;a href=&quot;#HashMap源码&quot; class=&quot;headerlink&quot; title=&quot;HashMap源码&quot;&gt;&lt;/a&gt;HashMap源码&lt;/h1&gt;&lt;h2 id=&quot;get操作&quot;&gt;&lt;a href=&quot;#get操作&quot; class=&quot;header</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="源码分析" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL limit 1和limit 10000，1性能一样吗</title>
    <link href="http://example.com/2023/10/11/MySQL%E7%9A%84limit/"/>
    <id>http://example.com/2023/10/11/MySQL%E7%9A%84limit/</id>
    <published>2023-10-11T02:50:37.000Z</published>
    <updated>2023-10-26T03:31:19.582Z</updated>
    
    <content type="html"><![CDATA[<p> 考虑两条MySQL语句的执行，其中key1是二级索引，id是主键。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from my_table order by key1 limit 1;</span><br></pre></td></tr></table></figure><p>该条语句，key1是二级索引，本身就是有序的，那么当查询一条语句之后，它就会直接回表查询具体的数据然后返回。</p><p>但是如果SQL变为下面的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from my_table order by key1 limit 10000, 1;</span><br></pre></td></tr></table></figure><p>执行这条语句就会发现它走了全表的扫描 + filesort，它并没有像想象中的那样，扫描到10001的索引，然后回表返回结果。</p><h1 id="limit的执行"><a href="#limit的执行" class="headerlink" title="limit的执行"></a>limit的执行</h1><p>MySQL分为Server层和具体的存储引擎层，Server层是统一的，而存储引擎我们这里默认使用InnoDB。</p><p>当具体执行一个带有limit操作的SQL时，它并不会在存储引擎层进行过滤，存储引擎查询到所需要的所有数据，然后返回给Server层，Server层依据具体的查询需求来进行过滤，也就是说需要先查询10001条数据返回给Server，然后进行过滤。</p><h1 id="优化器选择"><a href="#优化器选择" class="headerlink" title="优化器选择"></a>优化器选择</h1><p>优化器在执行这个查询时会有两种选择</p><ol><li>全表扫描，然后返回，过滤掉不需要的数据。</li><li>第二种查询方案涉及到数据返回策略，InnoDB在执行查询索引时，查找到一条满足条件的数据后，会进行回表，查找完整数据，然后返回给Server层，Server层在返回给用户时发现还有limit，所以要做限制，就不能进行返回，并开始计数。直到引擎层给Server层返回了10001条数据后，才可以完成limit操作，之后再将结果返回给用户，也就是说这里需要进行10001次回表操作，并且要查询10001行数据，然后前10000行全部被Server层丢弃。</li></ol><p>这两种方案会由优化器决定走哪一种，但不管走哪一种，都需要进行大量的回表操作。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>当执行 <code>limit 1</code> 和执行 <code>limit 10000，1</code>时，性能上的差距还是很大的。并且由于MySQL内存有限，在查询前10000行数据时，难免会有数据页被移出内存，然后从磁盘中加载新的数据页，这也会消耗一定的时间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 考虑两条MySQL语句的执行，其中key1是二级索引，id是主键。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="场景分析" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    
    
    <category term="场景分析" scheme="http://example.com/tags/%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>远程调用</title>
    <link href="http://example.com/2023/10/08/%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
    <id>http://example.com/2023/10/08/%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/</id>
    <published>2023-10-08T03:14:44.000Z</published>
    <updated>2023-10-18T04:08:01.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h1><p>本地调用通常指的是，进程内函数之间的相互调用；而远程调用，是进程间函数的相互调用，是进程间通信 IPC（Inter-Process Communication）的一种方式。</p><p>根据进程是否部署在一台机器上，远程调用可以分为以下两类：</p><ol><li><strong>本地过程调用（Local Procedure Call，LPC）</strong>，是指运行在同一台机器上的进程之间 的互相通信，即在多进程操作系统中，运行的不同进程之间可以通过 LPC 进行函数调 用。</li><li><strong>远程过程调用（Remote Procedure Call，RPC）</strong>，是指不同机器中运行的进程之间的 相互通信，某一机器上运行的进程在不知道底层通信细节的情况下，就像访问本地服务 一样，去调用远程机器上的服务。</li></ol><h2 id="远程调用的原理"><a href="#远程调用的原理" class="headerlink" title="远程调用的原理"></a>远程调用的原理</h2><p>在B&#x2F;S ( Browser&#x2F;Server，浏览器 &#x2F; 服务器) 架构中，被调用方（服务器）会有一个开放的接口，然后调用方（用户）会通过Browser使用这个接口，来间接的调用相应的服务。</p><p>但是，B&#x2F;S 架构是基于 HTTP 协议实现的，每次调用接口时，都需要先进行 HTTP 请求，比较的耗时，不适合分布式中的远程调用。更为常用的是 <strong>远程过程调用 RPC(Remote Procedure Call)</strong> 和 **远程方法调用 RMI(Remote Method Invocation)**。</p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>简单地说，RPC 就是调用方采用参数传递的方式，通过调用本机器上的一个函数或方法， 去执行远程机器上的函数或方法（可以统称为服务），并返回结果。在整个过程中，RPC 会隐藏具体的通信细节。一个支付流程的网络调用如下图所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231012092420486.png" alt="image-20231012092420486" style="zoom:80%;" /><p>其中，Stub 是用于转换 RPC 过程中在订单系统和支付系统所在机器之间传递的参数。说白了，客户端的Stub用于封装参数，而服务端的Stub就是为了将收到的封装后的参数解析出来。</p><p>不难看出，机器 A 上的 Pay(Order)、 Client Stub 和网络调用之间的交互属于本地调用，机器 B 上的 Pay(Order)、Server Stub 和网络调用之间的交互也属于本地调用。而机器 A 和机器 B 之间的远程调用的核心是，发生在机器 A 上的网络调用和机器 B 上的网络调用。</p><p>RPC的目的是，将第 2 到第 8 步的几个过程封装起来，让用户看不到这些细节。 从用户的角度看，订单系统的进程只是做了一次普通的本地调用，然后就得到了结果。</p><p>订单系统进程并不需要知道底层是如何传输的，在用户眼里，远程过程调用和调用一次本地服务没什么不同。这就是 RPC 的核心。</p><h4 id="RPC与本地调用的区别"><a href="#RPC与本地调用的区别" class="headerlink" title="RPC与本地调用的区别"></a>RPC与本地调用的区别</h4><p>第一个区别是<strong>调用 ID 和函数的映射</strong>。在本地调用中，进程内可共享内存地址空间，因此程序可直接通过函数名来调用函数。函数名的本质是一个函数指针，可以看作函数在内存中的地址。而在远程调用中，只通过函数名却不行，因为不同进程的地址空间不一样，所以必须通过一个调用ID来标识，在远程调用时要附上ID。</p><p>调用方首先通过映射表，先找到调用函数的ID，传给被调用方。被调用方拿到ID后，通过ID找到具体被调用的函数。</p><p>第二个区别是，<strong>序列化和反序列化</strong>。在本地调用中，进程之间共享内存等，因此我们只需要把参数压到栈里，然后进程自己去栈 里读取就行。但是在 RPC 中，两个进程分布在不同的机器上，使用的是不同机器的内存， 因此不可能通过内存来传递参数。</p><p>而网络协议传输的内容是二进制流，无法直接传输参数的类型，因此这就需要调用方把参数 先转成一个二进制流，传到被调用方后，被调用方再把二进制流转换成自己能读取的格式。 这个过程，就叫作序列化和反序列化。</p><p>第三个区别是，<strong>网络传输协议</strong>。序列化和反序列化解决了调用方和被调用方之间的数据传输 格式问题，但要想序列化后的数据能在网络中顺利传输，还需要有相应的网络协议，比如 TCP、UDP 等，因此就需要有一个底层通信层。而大部分的RPC框架，采用的都是TCP协议。</p><h3 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h3><p>RMI 是一个基于 Java 环境的应用编程接口，能够让本地 Java 虚拟机上运行的对象，像调用本地对象一样调用远程 Java 虚拟机上的对象。RMI可以说是RPC的一种具体形式，原理与RPC基本一致，不同的是RMI 是基于对象的，充分利用了面向对象的思想去实现整个过程，其本质就是一种基于对象的 RPC 实现。</p><p>RMI 与 PRC 最大的不同在于调用方式和返回结果的形式，RMI 通 过对象作为远程接口来进行远程方法的调用，返回的结果也是对象形式，可以是 Java 对象 类型，也可以是基本数据类型。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《分布式技术原理与算法实战》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;远程调用&quot;&gt;&lt;a href=&quot;#远程调用&quot; class=&quot;headerlink&quot; title=&quot;远程调用&quot;&gt;&lt;/a&gt;远程调用&lt;/h1&gt;&lt;p&gt;本地调用通常指的是，进程内函数之间的相互调用；而远程调用，是进程间函数的相互调用，是进程间通信 IPC（Inter-Proc</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="分布式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>多主复制</title>
    <link href="http://example.com/2023/10/04/%E5%A4%9A%E4%B8%BB%E5%A4%8D%E5%88%B6/"/>
    <id>http://example.com/2023/10/04/%E5%A4%9A%E4%B8%BB%E5%A4%8D%E5%88%B6/</id>
    <published>2023-10-04T07:50:22.000Z</published>
    <updated>2023-10-04T07:56:20.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多主复制"><a href="#多主复制" class="headerlink" title="多主复制"></a>多主复制</h1><p>在主从复制的场景中，只有一个主节点，所有的写入操作都要先经过主节点，主节点压力大的问题还是没能解决。而且单主节点的容灾效果也不是很好。</p><p>为了达到好的容灾效果，各个机房的距离应该足够远，尽可能的分布在不同的地区，那么这种场景下，用户直接读写自己最近的数据中心，网络延迟最小，效果最好。因此就出现了多住复制。</p><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p>它是指在一个数据系统中，存在多个主从 复制单元，每一个主从复制单元都可以处理读写请求，一个主从复制单元的主副本处理了写请 求后，需要复制到其他的主从复制单元的主副本，具体的流程见下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231004112141400.png" alt="image-20231004112141400" style="zoom: 80%;" /><p>有几点需要注意：</p><p>首先，每一个主从复制单元内部是一个常规的主 从复制模式，这里的主副本、从副本之间的复制可以是同步的，也可以是异步的。</p><p>其次，多个主从复制单元之间，每一个主副本都会将自己的修改复制到其他的主副本，主副本 之间的复制可以是同步的，也可以是异步的。</p><p>如果主副本之间的复制是同步的，那么一个主副本的写入，需要等待复制到其他的主副本成功 后，才能返回给用户，但是，这样却失去了多主复制最重要的一个优点，即多个主副本都可以独立处理写入，这就导致整个模式 退化为主从复制的形式。所以一般来说，多主复制的主副本之间，大多采用异步模式。</p><p>但采用异步复制也会出现问题，如果多个主副本同时成功修 改一个数据，当主副本之间复制这个数据的修改时，会出现冲突，我们就不知道以哪一个主副 本的写入结果为准了，该问题在同步复制时可以让用户决定哪个为主。</p><h2 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h2><p>冲突主要由两种形式，</p><p>首先是由于更新导致的冲突，多个主副本同时更新了一个数据，导致这个数据的版本是非线性的，出现了分叉，具体见下图：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231004124557885.png" alt="image-20231004124557885">其次，由于新增导致的冲突，多个主副本同时新增了一个含有唯一性约束的数据，导致数据的唯一性约束被破坏。例如，在酒店预订业务中，一个时段内一个房间只能预订给一个用户，如 果多个用户在多个主副本上，同时发起预订操作，就可能出现同一个时段内，一个房间被多个 用户预定成功的情况。</p><h3 id="避免冲突"><a href="#避免冲突" class="headerlink" title="避免冲突"></a>避免冲突</h3><p>由上可知，冲突是多个主副本同时 修改了一个数据，或者破坏了数据的唯一性约束导致的，那么我们就对数据进行分片，让不同的主数据负责不同的数据分片，这个方式可以在一定程度上避免冲突，但是会导致两个问题：</p><p>首先，一个修改操作可能会修改多个分片数据，这样我们就没有办法通过分片来隔离修改了。</p><p>其次，由于就近接入和故障等原因，我们会将出现故障的主副本流量切换到其他的主副本，这 时也会出现写入冲突的情况。</p><p>注意：这里的分片，并不是每个主副本只保留一部分数据，而是每个主副本仍然保留全量的数据，但是只负责主动的修改某一部分，其他部分等待其他主副本进行同步。</p><h4 id="写时解决冲突"><a href="#写时解决冲突" class="headerlink" title="写时解决冲突"></a>写时解决冲突</h4><p>写时解决冲突有两种实现，预定义解决冲突和自定义解决冲突。</p><p>预定义解决冲突，是指由存储系统预先定义好规则，在冲突发生时依据预先定义好的规则，自动来解决冲突，主要有以下几种：</p><ol><li>从操作维度来处理，最后写入获胜。也就是为每一个写操作分配一个时间戳，如果发生 冲突，只保留时间戳最大的版本数据，其他的修改都丢弃，但是这个方法会导致修改丢失。</li><li>从副本维度来处理，最高优先级写入获胜。也就是为每一个副本都排好优先级，如果发 生冲突，只保留优先级最高的副本修改数据，其他的修改都丢弃。</li><li>从数据结构和算法的维度来处理，通过研究一些可以自动解决冲突的数据结构来解决问题。目前不成熟。</li></ol><p>自定义解决冲突，它是由业务系统来定义冲突的解决方式，如果发生冲突 了，存储系统就依据业务系统定义的方式执行。</p><p>自定义冲突解决的处理逻辑是，在主副本之间复制变更日志时，如果检测到冲突，就调用用户 自定义的冲突处理程序来进行处理。由于主副本之间的数据复制是异步的，所以一般都是后台 执行，不会提示用户。</p><h4 id="读时解决冲突"><a href="#读时解决冲突" class="headerlink" title="读时解决冲突"></a>读时解决冲突</h4><p>读时解决冲突的思路和写时解决冲突的思路正好相反，即在写入数据时，如果检测到冲突，不 用立即进行处理，只需要将所有冲突的写入版本都记录下来。当下一次读取数据时，会将所有的数据版本都返回给业务层，在业务层解决冲突，那么读时解决冲突的方式有下面两种：</p><ol><li>由用户来解决冲突。业务层将冲突提示给用户，让用户来解决。</li><li>自定义解决冲突。业务层先依据业务情况，自定义好解决冲突的处理程序，当检 测到冲突时，直接调用处理程序来解决。</li></ol><h2 id="多主复制的关键问题"><a href="#多主复制的关键问题" class="headerlink" title="多主复制的关键问题"></a>多主复制的关键问题</h2><p>1、正确解决冲突的难度非常大。</p><p>2、异步模式的多主复制会存在数据一致性的问题。因为多个主副本都是独立写入的，而他们之间是通过异步复制的方式。</p><p>3、多个主副本之间的复制拓扑结构问题。一般来说，多主复制的主副本之间的复制拓扑结 构主要有三种：环形拓扑、星形拓扑以及全部至全部拓扑，具体见下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231004155403956.png" alt="image-20231004155403956" style="zoom:80%;" /><p>前两种，如果一个主副本出现问题，则会导致整个副本的数据无法同步，而第三种虽然一个挂了不影响，但是他们主副本之间同步的时延却要大很多。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入浅出分布式技术原理》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多主复制&quot;&gt;&lt;a href=&quot;#多主复制&quot; class=&quot;headerlink&quot; title=&quot;多主复制&quot;&gt;&lt;/a&gt;多主复制&lt;/h1&gt;&lt;p&gt;在主从复制的场景中，只有一个主节点，所有的写入操作都要先经过主节点，主节点压力大的问题还是没能解决。而且单主节点的容灾效果也</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="分布式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据分片</title>
    <link href="http://example.com/2023/10/02/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87/"/>
    <id>http://example.com/2023/10/02/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87/</id>
    <published>2023-10-02T11:31:22.000Z</published>
    <updated>2023-10-02T11:32:46.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><p>对数据进行分片的策略，主要有三种：水平分片、垂直分片和混合分片，具体如下图所示。水平分片和垂直分片是通过数据切分的操作方向来区分的，而混合分片 是它们的组合体。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002105033499.png" alt="image-20231002105033499" style="zoom: 67%;" /><h3 id="水平分片"><a href="#水平分片" class="headerlink" title="水平分片"></a>水平分片</h3><p>水平分片有点类似于负载均衡，从流量角度来看，是负载均衡，从数据存储角度来看，是水平分片。</p><p>水平分片算法有两个最关键的因素，一是，如何对数据进行划分，即数据划分，二是，分片是 否支持动态分裂与合并，即数据平衡。</p><h4 id="数据划分"><a href="#数据划分" class="headerlink" title="数据划分"></a>数据划分</h4><p>数据划分主要有两种方案，一种是基于模运算，一种是基于范围划分。基于模运算比较简单，不再阐述。而基于范围划分，又分为基于关键词划分和基于关键词的 Hash 值划分两种方式。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002110024878.png" alt="image-20231002110024878" style="zoom:67%;" /><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002110040276.png" alt="image-20231002110040276" style="zoom:67%;" /><p>这两种分片都是给每一个分片分配一个固定的范围，两者的不同区别在于一个是直接拿关键词进行划分，另一个是利用了关键词的Hash值进行划分。看似区别不大，但是会影响数据的分布。</p><h5 id="基于关键词划分"><a href="#基于关键词划分" class="headerlink" title="基于关键词划分"></a>基于关键词划分</h5><p>基于<strong>关键词划分</strong>的好处是，分片后数据的分布依然保留了关键词的顺序，我们可以方便地进行区间查询，因为某个关键词区间的数据都是连续存储的。</p><p>但是基于关键词划分也会带来问题，即<strong>数据分布不均匀和访问的热度不均匀</strong>。比如说按照地区进行划分，那么某些省份人数多，这个分片的数据就会多，人数少，分片数据就少。而且数据分布不均时，数据多的分片被访问到的概率也会变大。</p><p>如果基于自增 ID 或者时间等关键词对数据进行分片的时候，即使数据是均匀分布的，对于一般的业务场景来说，往往新产生数据的访问热度，也是远远大于历史数据的，这也会导致访问的热度不均匀。</p><p>很明显，数据的分布与关键词的分布是一致的。</p><h5 id="基于关键词的hash值"><a href="#基于关键词的hash值" class="headerlink" title="基于关键词的hash值"></a>基于关键词的hash值</h5><p>基于关键词的 Hash 值划分就可以上述问题，它通过对关键词进行 Hash 运算，然后基于计算后的 Hash 值范围对数据进行划分，一个好的 Hash 算法可以处理数据倾斜并让它均匀分布。这样可以解决数据分布和访问热度不均的问题。</p><p>但导致的问题就是无法高效的进行范围查询。</p><h4 id="数据平衡"><a href="#数据平衡" class="headerlink" title="数据平衡"></a>数据平衡</h4><p>根据数据分片是否支持<strong>动态的分裂与合并</strong>，我们可以将水平分片的数据平衡方式分为<strong>静态分片</strong>和<strong>动态分片</strong>。</p><p>静态分片是指在系统设计之初，数据分片的数目和区间就预估好了，数据划分后不能再变化。</p><p>动态分片则可以在运行时，根据分片的负载和容量做调整。</p><p>因为动态分片在运行时分区时可以进行分裂与合并的，不需要担心数据分布的问题，所以动态分片与基于关键词的划分，往往是一个 比较好的组合方式，它避免了基于关键词划分的问题，还保留了数据基于关键词有序的优点。</p><p>但是，在基于关键词的划分中，基于自增 ID 或者时间戳等原因，导致的访问冷热不均匀的问题，即使是在动态分片中也不能很好地解决，因为数据的热点往往集中在最新的一个分片区间上。而基于关键词的 Hash 值划分的方式，则可以很方便地将最新的热点数据分布到多个分片 上，很好地解决这个问题。</p><p>动态分片存在冷启动的问题。当一个基于动态分片的存储系统启动时，通常是从一个分片开始，当数据量不断增长后，再动态进行分裂。在第一次进行分裂前，所有的读写请求都由 第一个分片来进行处理，而其他的节点则都属于空闲状态。关于这个问题，一个比较好的解决 方式是，动态分片在冷启动时，预分裂为多个分片来缓解。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002112557636.png" alt="image-20231002112557636" style="zoom:67%;" /><h3 id="垂直分片"><a href="#垂直分片" class="headerlink" title="垂直分片"></a>垂直分片</h3><p>水平分片策 略将整个数据集的条数作为划分的对象，每一个分片负责处理一定的数据条数。而垂直分片策略则是将数据 Schema 的字段集个数作为划分的对象，每一个分片负责处理一个或几个字段 的全部数据，具体如下图所示。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002164951470.png" alt="image-20231002164951470" style="zoom: 80%;" /><p>如果垂直分片策略的处理方式为一个字段一个分片，那么垂直分片策略就等价于列式存储了，所以列式存储是垂直分片策略的一种特殊情况，也是最常见的情况。</p><p>列式存储往往用于大数据分析当中，这类数据的特点是一次写入，多次查询（从不修改），而且是按列读取，每次只关心一列或者几列，每张表都很宽，比如上百列。而且查询无规律，不能索引覆盖。</p><h4 id="列式存储"><a href="#列式存储" class="headerlink" title="列式存储"></a>列式存储</h4><p>如果是行式存储，当我们只需要读取一列时，有两种方案，第一个是挨个读取每一行的数据，但是只取出自己要的那一列，这会导致读取数据的量放大很多。如果我们只读取那一列，这会导致我们读取时不是按顺序读取，会对读取造成性能影响。</p><p>读多写少的场景，会减少列式存储对写性能的影响。一般来说，数据写入存储系统是以 行的形式写入的，而列式存储会导致一行数据的写入操作，按字段拆分为多个写入操作，使写入放大。</p><p>大数据场景，采用列式存储非常适合压缩存储，比如下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002192207839.png" alt="image-20231002192207839" style="zoom:67%;" /><p>好处是使用压缩会大大减小存储成本，提高了存储效率，但是在存储和读取数据时，需要多一步，即找到数据的编码，需要消耗额外的CPU资源。</p><h3 id="混合分片策略"><a href="#混合分片策略" class="headerlink" title="混合分片策略"></a>混合分片策略</h3><p>根据水平分片和垂直分片的策略，混合分片可以分为<strong>垂直水平分片</strong>策略和<strong>水平垂直分片</strong>策略。前者先 进行垂直分片，再进行水平分片，而后者先进行水平分片，然后再进行垂直分片。具体如下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002192630321.png" alt="image-20231002192630321" style="zoom: 80%;" /><p>垂直水平分片看着不怎么滴，不过多介绍。</p><p>水平垂直分片更像是两者的结合提。先水平划分，划分完后在每一个分片内部再采用列式存储，这样可以保留水平分片和垂直分片的优点。</p><h3 id="行列存储比较"><a href="#行列存储比较" class="headerlink" title="行列存储比较"></a>行列存储比较</h3><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002193058865.png" alt="image-20231002193058865" style="zoom:80%;" /><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入浅出分布式技术原理》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分片&quot;&gt;&lt;a href=&quot;#分片&quot; class=&quot;headerlink&quot; title=&quot;分片&quot;&gt;&lt;/a&gt;分片&lt;/h2&gt;&lt;p&gt;对数据进行分片的策略，主要有三种：水平分片、垂直分片和混合分片，具体如下图所示。水平分片和垂直分片是通过数据切分的操作方向来区分的，而混合分</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="分布式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Spring的IoC</title>
    <link href="http://example.com/2023/09/30/Spring%E7%9A%84IoC/"/>
    <id>http://example.com/2023/09/30/Spring%E7%9A%84IoC/</id>
    <published>2023-09-30T06:54:11.000Z</published>
    <updated>2023-09-30T07:30:30.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h1><p>1、解析xml文件，将xml中读取到的内容利用<code>ClassPathXmlResource</code>来进行存储。</p><p>2、初始化一个工厂，该工厂可以自由选择，比如<code>SimpleBeanFactory</code>或者<code>AutowireCapableBeanFactory</code>，又或者是<code>BeanFactory</code>，取决于场景需要。</p><p>3、实例化一个<code>XmlBeanDefinitionReader</code>，该类需要传入第二步生成的工厂，它的主要作用就是解析存储在<code>ClassPathXmlResource</code>中的属性，将它封装为一个<code>BeanDefinition</code>，然后存储在一个map中，map的key为对象的名字，value就是<code>BeanDefinition</code>。用于后续创建bean时，根据名称取到<code>BeanDefinition</code>，然后<code>BeanDefinition</code>中取得属性。</p><p>4、到此为止，上面的三步是为了初始化并且存储一些对象的信息，这些信息都来自xml中的配置。之后，调用<code>refresh()</code>来进行具体的创建。</p><p>5、在单例模式下，<code>refresh()</code>会先从存放了所有bean实例的map中根据名字取该元素，如果不为空，则直接返回，如果为空，则从毛坯实例中尝试获取该元素（存储毛坯实例是为了解决循环依赖的问题，创建一个空的对象，所有属性都不赋值，用于注入），如果还是为空，则执行创建。</p><p>6、创建的流程就是获取到之前存储的<code>BeanDefinition</code>，然后先创建一个毛坯实例，这里是利用Java的反射以及<code>BeanDefinition</code>中存储的<code>getConstructorArgumentValues</code>信息，来进行创建，只创建空的类，类的所有属性都不赋值。之后将毛坯实例进行存储。</p><p>7、这一步是将上一步创建的毛坯实例属性进行赋值，从<code>BeanDefinition</code>中获取到<code>PropertyValues</code>，然后遍历，调用<code>setXXX</code>方法进行赋值。</p><p>8、创建完后，将bean存储到第五步刚开始取元素的那个map当中，并返回本次创建的实例。如果没有采用注解，到这里就已经创建结束了。</p><p>9、如果创建的元素当中有属性使用了注解，则会调用<code>AutowiredAnnotationBeanPostProcessor</code>的<code>postProcessBeforeInitialization</code>方法，该方法会遍历传入实例的所有属性，如果发现带有@Autowired注解，那么就去工厂中获取到对应的实例，并进行注入，然后返回该对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大致流程&quot;&gt;&lt;a href=&quot;#大致流程&quot; class=&quot;headerlink&quot; title=&quot;大致流程&quot;&gt;&lt;/a&gt;大致流程&lt;/h1&gt;&lt;p&gt;1、解析xml文件，将xml中读取到的内容利用&lt;code&gt;ClassPathXmlResource&lt;/code&gt;来进行存储。</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>降级</title>
    <link href="http://example.com/2023/09/27/%E9%99%8D%E7%BA%A7/"/>
    <id>http://example.com/2023/09/27/%E9%99%8D%E7%BA%A7/</id>
    <published>2023-09-27T02:16:37.000Z</published>
    <updated>2023-09-27T02:18:44.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h1><p>上面的熔断，是为了在系统过载时不发生雪崩，限流是为了流量较大时，系统不发生过载。但是这两者都不会区分该服务是核心业务还是非核心业务。而降级，则是为了减少或者停掉一些非核心业务，来确保核心业务收到的影响最小。</p><h2 id="为什么需要降级"><a href="#为什么需要降级" class="headerlink" title="为什么需要降级"></a>为什么需要降级</h2><ol><li>降级机制能从全局角度对资源进行调配，通过牺牲非核心服务来保障核心服务的稳定性。降级是主动停掉一些非核心业务，而限流则是被动的将一些请求拒绝。</li><li>降级可以提高系统的用户体验性和可用性。在一些场景中，如果正常调用出现了非业务层错误后，我们可以不返回错误，而是执行接口的B计划，进行降级，虽然可能和正常流程不太一样，但是比直接返回错误要好。</li></ol><h2 id="如何实现降级"><a href="#如何实现降级" class="headerlink" title="如何实现降级"></a>如何实现降级</h2><h3 id="手动降级"><a href="#手动降级" class="headerlink" title="手动降级"></a>手动降级</h3><p>手动降级是指在分布式系统中提前设置好降级开关，然后通过类似配置中心的集中式降级平 台，来管理降级开关的配置信息，在系统需要降级的时候，通过降级平台手动启动降级开关， 对系统进行降级处理。</p><p>该方案需要注意的是，往往服务有成千上百个，如果全部手动操作，则很麻烦。一个解决办法是：通过对降级分级，利用服务的等级信息和业务信息进行批量降级，比如一次直接把p1,p2,p3的服务全部降级。</p><h3 id="自动降级"><a href="#自动降级" class="headerlink" title="自动降级"></a>自动降级</h3><p>自动降级是指在分布式系统中，当系统的某些指标或者接口调用出现错误时，直接启动降级逻辑。一个降级的例子如下：</p><p>我们在网关中调用鉴权服务进行鉴权，每一 个调用鉴权服务的鉴权接口，需要执行如下的两个校验逻辑，不论哪一个失败，都会导致鉴权失败。</p><ol><li>校验 Token 是否合法。</li><li>校验 UID 是否被管理员封禁。</li></ol><p>在这个情况下，我们可以将 Token 设计为可以自校验的，在鉴权服务出现故障的时候，则启动降级逻辑，直接在网关中校验 Token 是否合法，如果合法就返回鉴权成功。</p><h2 id="降级机制的关键问题"><a href="#降级机制的关键问题" class="headerlink" title="降级机制的关键问题"></a>降级机制的关键问题</h2><p>一般来 说，我们使用降级都是在系统已经出现过载的场景下，这时我们需要考虑，降级的配置信息是 否能正常下发。并且，降级通常会与熔断和限流一起出现，我们应该如何处理它们三者之间的关系。</p><h3 id="配置信息下发的问题"><a href="#配置信息下发的问题" class="headerlink" title="配置信息下发的问题"></a>配置信息下发的问题</h3><p>对于熔断和限流来说，其阈值相关的配置信息在系统正常运行的时候，就已经下发到实例上了，所以在系统出现故障的时候，这些配置信息会直接生效。但是对于手动降级，我们需要在系统出问题时，通过降级平台下发配置来启动降级。</p><p>针对于配置无法正常下发的情况，我们可以考虑，由服务直接暴露出修改降级配置的 HTTP 接口，在必要的时候，可以手动通过 HTTP 接口，来启动服务的降级逻辑。</p><h3 id="熔断、限流和降级之间的关系"><a href="#熔断、限流和降级之间的关系" class="headerlink" title="熔断、限流和降级之间的关系"></a>熔断、限流和降级之间的关系</h3><p>首先，因为熔断机制是系统稳定性保障的最后一道防线，并且它是自适应的，所以我们应该在系统全局默认启用；</p><p>其次，限流是用来保障被限流服务稳定性的，一般在系统的核心链路和核心服务上，默认启用限流机制；</p><p>最后，降级是通过牺牲被降级的接口或者服务，来保障其他的接口和服务正常运行的，可以通过降级直接停用非核心服务，然后对于核心接口和服务，在必要的时候，可以提供一个“ B 计划”。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入浅出分布式技术原理》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;降级&quot;&gt;&lt;a href=&quot;#降级&quot; class=&quot;headerlink&quot; title=&quot;降级&quot;&gt;&lt;/a&gt;降级&lt;/h1&gt;&lt;p&gt;上面的熔断，是为了在系统过载时不发生雪崩，限流是为了流量较大时，系统不发生过载。但是这两者都不会区分该服务是核心业务还是非核心业务。而降级，</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="分布式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>限流</title>
    <link href="http://example.com/2023/09/26/%E9%99%90%E6%B5%81/"/>
    <id>http://example.com/2023/09/26/%E9%99%90%E6%B5%81/</id>
    <published>2023-09-26T05:48:45.000Z</published>
    <updated>2023-09-26T05:50:25.563Z</updated>
    
    <content type="html"><![CDATA[<p>如果系统只有熔断机制，当流量激增的时候，就相当于被动的等待熔断机制的触发，此时就需要另外的手段来防止系统负载过高，限流就是一个很好的方案，要主动出击，防止服务挂掉。</p><h1 id="为什么需要限流"><a href="#为什么需要限流" class="headerlink" title="为什么需要限流"></a>为什么需要限流</h1><ol><li>熔断处理的方式不够优雅。熔断是等到系统过载之后才触发的，即先发生过载，等系统故障后才会介入，让系统恢复。这样的处理方式会导致系统的不必要抖动。</li><li>熔断机制是最后的底线。虽然熔断可以解决雪崩问题，但是它应该作为系统稳定性保障的 最后一道防线，正确使用熔断的思路应该是，在其他方法用尽 之后，如果过载问题依旧存在，这时熔断才会被动触发。</li><li>在快速失败的时候，需要能考虑调用方的重要程度。熔断是调用方依据响应结果自适应来触发的，在被调用方出现过载的时候，所有的调用方都将受到影响。但是不同接口的重要程度不一样，需要保证有些接口优先处理。</li><li>在多租户的情况下，不能让一个租户的问题影响到其他的租户，我们需要对每一个租户分配一定的配额，谁超过了就对谁进行限流，保证租户之间的隔离性。</li></ol><h1 id="如何实现限流"><a href="#如何实现限流" class="headerlink" title="如何实现限流"></a>如何实现限流</h1><p>限流一般有固定的限流算法，有以下几种：</p><h2 id="固定窗口和滑动窗口"><a href="#固定窗口和滑动窗口" class="headerlink" title="固定窗口和滑动窗口"></a>固定窗口和滑动窗口</h2><p>固定窗口就是定义一个“固定”的统计周期，比如 10 秒、30 秒或者 1 分钟，然后在每个周 期里，统计当前周期中被接收到的请求数量，经过计数器累加后，如果超过设定的阈值就触发 限流，直到进入下一个周期后，计数器清零，流量接收再恢复正常状态，如下图所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230926104828548.png" alt="image-20230926104828548" style="zoom:80%;" /><p>存在的问题：</p><ol><li><p>抗抖动性差。由于流量突增使请求超过预期，导致流量可能在一个统计周期的前 10 ms 内就达到了 100 次，给服务的处理能力造成一定压力，同时后面的 1990 ms 将会触发限流。 </p><p>这个问题虽然可以通过减小统计周期来改善，但是因为统计周期变小，每个周期的阈值也会变 小，一个小的流量抖动就会导致限流的发生，所以系统的抗抖动能力就变得更差了。</p></li><li><p>如果上一个统计周期的流量集中在最后 10 ms ，而现在这个统计周期的流量集中在前 10 ms ，那么这 20 ms 的时间内会出现 200 次调用，这就超过了我们预期的 2 秒内不能超 过 100 次请求的目的了。这时候，我们就需要使用“滑动窗口”算法来改善这个问题了。</p></li></ol><p>滑动窗口就是固定窗口的优化，它对固定窗口做了进一步切分，将统计周期的粒度切分 得更细，比如 1 分钟的固定窗口，切分为 60 个 1 秒的滑动窗口，然后统计的时间范围随着时 间的推移同步后移，如下图所示。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230926110157298.png" alt="image-20230926110157298" style="zoom:80%;" /><p>但是这里要注意一个问题，如果滑动窗口的统计窗口切分得过细，会增加系统性能和资源损耗 的压力。同时，滑动窗口和固定窗口一样面临抗抖动性差的问题。</p><h2 id="漏桶"><a href="#漏桶" class="headerlink" title="漏桶"></a>漏桶</h2><p>如下图所示，“漏桶”就像一个漏斗，进来的水量就像访问流量一样，而出去的水量 就像是我们的系统处理请求一样。当访问流量过大时，这个漏斗中就会积水，如果水太多了就会溢出。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230926110501239.png" alt="image-20230926110501239"></p><p>该算法相对于滑动窗口和固定窗口做了两个改进点，第一，增加了一个桶来缓存请求，在流量突增的时候，可以先缓存起来，直到超过桶的容量才触发限流；第二，对出口的流量上限做了限制，使上游流量的抖动不会扩散到下游服务。</p><p>漏桶提供流量整形能力有一定的代价，超过漏桶流出速率的请求，需要先在漏桶中排队等待，其中流出速率是漏桶限流的防线，一般会设置得相对保守，可是这样就无法完全利用系 统的性能，就增加了请求的排队时间。</p><h2 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h2><p>令牌桶算法的核心是固定“进口”速率，限流器在一个一定容量的桶内，按照一定的速率放入 Token ，然后在处理程序去处理请求的时候，需要拿到 Token 才能处理；如果拿不到，就进行限流。</p><p>因此，当大量的流量进入时，只要令牌的生成速度大于等于请求被处理的速度，那么此时系统处理能力就是极限的。<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230926112343201.png" alt="image-20230926112343201" style="zoom:80%;" /></p><p>令牌桶算法相对于漏桶，虽然提高了系统的资源利用率，但是却放弃了一定的流量整形能力，也就是当请求流量突增的时候，上游流量的抖动可能会扩散到下游服务。</p><h1 id="单节点限流"><a href="#单节点限流" class="headerlink" title="单节点限流"></a>单节点限流</h1><p>单节点限流比较简单，可以基于内存来做，需要注意两点：</p><ol><li><p>限流机制作用的位置是客户端还是服务端，即选择客户端限流还是服务端限流。一般来说，熔断机制作用的位置是客户端，限流机制作用的位置更多是服务端，因为熔断更强调自适应，让作用点分散在客户端是没有问题的，而限流机制则更强调控制，它的作用点在服务端的控制能力会更强。</p><p>将作用点放置在服务端，会给服务端带来性能压力。如果将作用点放置在客户端，这就是一个天然的分布式模式，每一个调用方的客户端执行自己的限流逻辑，而将作用点放置在服务端时，服务端要执行所有请求的限流逻辑， 就需要更多的内存来缓存请求，以及更多的 CPU 来执行限流逻辑。</p></li><li><p>如果触发限流后，我们应该直接抛弃请求还是阻塞等待，即否决式限流和阻塞式限流。一般来说，如果我们可以控制流量产生的速率，那么阻塞式限流就是一个更好的选择，因为它既可以实现限流的目的，又不会抛弃请求；</p><p>如果我们不能控制流量产生的速率，那么阻塞式限流将会因为请求积压，出现大量系统资源占用的情况，很容易引发雪崩，这时否决式限流将是 更好的选择。</p></li></ol><h1 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h1><p>为了系统的高可用，一般每个服务都会有多个实例，所以在进行限流时，需要协调该服务的多个实例，进行统一限流。主要方案有以下几点。</p><p>1、进行集中限流。该方案可以借助一个外部存储，比如Redis，然后采用令牌桶算法。但是会带来问题，每次请求都需要先去Redis获取令牌，会导致Redis成为性能瓶颈，并且限流器故障会导致所有请求都被拒绝，而且每次请求都多了一次网络调用，增加时延。</p><p>2、将分布式限流进行本地化处理。限流器在获得一个服务限额的总阈值后， 将这个总阈值按一定的策略分配给服务的实例，每一个实例依据分配的阈值进行单节点限流。这里要考虑如果每个服务器的配置不一样，那么分配的流量就需要不同.</p><p>一个折中的方案：该方案建立在集中式限流的基础上，为了解决每次请求 都需要，通过网络访问限流器获取令牌的问题，客户端只有在令牌数不足时，才会通过限流器 获取令牌，并且一次获取一批令牌。即令牌由集中式限流器生成，但是具体的限流策略是在每个客户端本地处理。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入浅出分布式技术原理》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果系统只有熔断机制，当流量激增的时候，就相当于被动的等待熔断机制的触发，此时就需要另外的手段来防止系统负载过高，限流就是一个很好的方案，要主动出击，防止服务挂掉。&lt;/p&gt;
&lt;h1 id=&quot;为什么需要限流&quot;&gt;&lt;a href=&quot;#为什么需要限流&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="分布式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>服务熔断</title>
    <link href="http://example.com/2023/09/25/%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/"/>
    <id>http://example.com/2023/09/25/%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/</id>
    <published>2023-09-25T05:18:00.000Z</published>
    <updated>2023-09-25T05:19:15.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h1><p>熔断机制：当服务之间发起调用的时候，如果被调用方返回的 指定错误码的比例超过一定的阈值，那么后续的请求将不会真正发起，而是由调用方直接返回错误。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230925125355151.png" alt="image-20230925125355151" style="zoom:67%;" /><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230925125408532.png" alt="image-20230925125408532"></p><p>首先是闭合状态，此时可以处理请求，但是需要一个计数器，来统计调用失败的次数，如果失败的次数达到阈值，则将状态改为闭合。</p><p>在闭合状态下，可以直接拒绝后续的请求，也可以对请求做一个降级（后续介绍）。此时会启动一个超时计时器，当计时器超时后，会转变为半打开状态。</p><p>在半打开状态下，允许一定数量的请求发往被调用的服务，如果这些调用正常，则就可以认为被调用服务已经恢复正常，此时熔断器切换为闭合状态，同时重置计数器。如果仍有部分调用失败的情况，则认为被调用方仍然没有恢复，熔断器会切换到断开状态，然后重置计数器。半打开状态是为了防止恢复中的服务被大量请求再次打垮的情况。</p><h2 id="熔断的关键点"><a href="#熔断的关键点" class="headerlink" title="熔断的关键点"></a>熔断的关键点</h2><p>有以下五个关键点：粒度控制、错误类型、存活与过载的区别、重试和熔断的关系和熔断机制的适应范围。</p><h3 id="粒度控制"><a href="#粒度控制" class="headerlink" title="粒度控制"></a>粒度控制</h3><p>该问题是指我们想将监控资源过载的粒度控制在一个什么样的范围内，这个范围可以由<strong>服务、实例和接口</strong>这三个维度的组合来得到。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230925130518335.png" alt="image-20230925130518335" style="zoom: 80%;" /><p>建议使用基于实例接口的熔断，这样的粒度最小，假如说一个实例有10个接口，只有一个接口请求超时，那么熔断该接口即可，其他接口仍然可以提供服务，将熔断的错误率讲到最低。</p><h3 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h3><p>由于熔断机制是用来消除系统过载的，所以，我们需要识别出与系统过载相关的错误，来进行 熔断处理，一般来说，主要有下面两个错误类型。</p><ol><li>系统被动对外表现出来的过载错误，一般来说，如果一个接口过载了，那么它的响应时间就会变长，熔断器捕获到的错误类型就是“响应超时”之类的超时错误。</li><li>系统主动对外表现出来的过载错误，对于这种情况，一般是请求的流量触发了限流等机制返回的错误码，这个是我们在程序开发过程中主动设计的。</li></ol><h3 id="过载与存活的区别"><a href="#过载与存活的区别" class="headerlink" title="过载与存活的区别"></a>过载与存活的区别</h3><p>熔断机制关心系统是否过载，最好的判断方式为利用队列中的平均等待时间来计算服务的负载。不利用服务的处理时间是为了考虑下游任务的处理时间，有时可能是因为下游处理太慢而导致的当前服务处理时间较长。</p><p>在熔断场景中，我们对过载判断进行了简化，直接通过接口请求的结果进行判断，如果发生请求错误，并且错误为超时或者限流等错误的比例超过一定的阈值，我们就可以认为系统过载，然后进行熔断。</p><p>而存活一般是指机器或者服务是否存活，对于机器是否存活，一般是通过定期 ping 机器的 IP ，如果超过一定时间不能 ping 通，则认为该机器不存活了。</p><h3 id="熔断与重试的关系"><a href="#熔断与重试的关系" class="headerlink" title="熔断与重试的关系"></a>熔断与重试的关系</h3><p>熔断和重试都会对服务之间的调用请求进行额外的处理，不同的是，重试是指我们认为该次调用失败是因为系统临时错误导致的，所以重发一次请求。而熔断是指我们已经认为系统过载了，为了保证系统不发生雪崩，为了使接口快速处理，而直接返回失败。</p><h3 id="熔断机制的适应范围"><a href="#熔断机制的适应范围" class="headerlink" title="熔断机制的适应范围"></a>熔断机制的适应范围</h3><p>只要是过载问题的场景， 我们都可以考虑利用熔断机制来解决，不论是分布式系统中服务之间的调用，还是服务与数据 库之间等其他场景的调用</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入浅出分布式技术原理》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;熔断&quot;&gt;&lt;a href=&quot;#熔断&quot; class=&quot;headerlink&quot; title=&quot;熔断&quot;&gt;&lt;/a&gt;熔断&lt;/h1&gt;&lt;p&gt;熔断机制：当服务之间发起调用的时候，如果被调用方返回的 指定错误码的比例超过一定的阈值，那么后续的请求将不会真正发起，而是由调用方直接返回错</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="分布式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>路由选择算法</title>
    <link href="http://example.com/2023/09/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2023/09/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/</id>
    <published>2023-09-22T13:01:14.000Z</published>
    <updated>2023-09-26T07:53:24.653Z</updated>
    
    <content type="html"><![CDATA[<p>路由选择算法是为了选出从一个点发出的数据报，该如何经过各个路由器，以最小的成本或最快的速度到达目的ip的一种算法，可以理解为图中的最短路径问题。</p><p>一般而言，路由选择算法的一种分类方式是根据该算法是集中式还是分散式来划分。</p><h1 id="集中式还是分散式"><a href="#集中式还是分散式" class="headerlink" title="集中式还是分散式"></a>集中式还是分散式</h1><h2 id="集中式路由选择算法"><a href="#集中式路由选择算法" class="headerlink" title="集中式路由选择算法"></a>集中式路由选择算法</h2><p>该算法以所有节点的连通性以及所有链路的开销为输入，这就要求算法在开始之前获得这些信息。该算法可以在一个集中的控制器或者在每台路由器的路由选择组件中重复进行。</p><p>集中式算法具有关于连通性和链路开销方面的完整信息。具有全局状态信息的算法常被称作链路状态（Link State, LS）算法, 因为该算法必须知道网络中每条链路的开销。</p><h2 id="分散式路由选择算法"><a href="#分散式路由选择算法" class="headerlink" title="分散式路由选择算法"></a>分散式路由选择算法</h2><p>该算法中，路由器以迭代、分布式的方式计算出最低开销路径。没有节点拥有关于所有网络链路开销的完整信息。 相反，每个节点仅有与其直接相连链路的开销知识即可开始工作。</p><p>然后，通过迭代计算过程以及与相邻节点的信息交换，一个节点逐渐计算出到达某目的节点或一组目的节点的最低开销路径。</p><h1 id="静态的还是动态"><a href="#静态的还是动态" class="headerlink" title="静态的还是动态"></a>静态的还是动态</h1><p>路由选择算法的第二种分类是基于算法是静态的还是动态的进行分类。</p><p>在静态路由选择算法（static routing algorithm）中，路由随时间的变化非常缓慢，通常是人工进行调整。</p><p>动态路由选择算法（dynamic routing algorithm） 随着网络流量负载或拓扑发生变化而改变路由选择路径。一个动态算法可周期性地运行或 直接响应拓扑或链路开销的变化而运行。虽然动态算法易于对网络的变化做岀反应，但也 更容易受诸如路由选择循环、路由振荡之类问题的影响。</p><h1 id="负载敏感的还是负载迟钝"><a href="#负载敏感的还是负载迟钝" class="headerlink" title="负载敏感的还是负载迟钝"></a>负载敏感的还是负载迟钝</h1><p>负载敏感算法（load-sensitive algorithm）中，链路开销会动态地变化以反映出底层链路的当前拥塞水平。如果当前拥塞的一条链路与高开销相联系，则路由选择算法趋向于绕开该 拥塞链路来选择路由。</p><p>负载迟钝的并不会选择性的避开。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《计算机网络自顶向下》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;路由选择算法是为了选出从一个点发出的数据报，该如何经过各个路由器，以最小的成本或最快的速度到达目的ip的一种算法，可以理解为图中的最短路径问题。&lt;/p&gt;
&lt;p&gt;一般而言，路由选择算法的一种分类方式是根据该算法是集中式还是分散式来划分。&lt;/p&gt;
&lt;h1 id=&quot;集中式还是分散</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="网络层" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>分布式场景下的CAP理论</title>
    <link href="http://example.com/2023/09/21/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84CAP%E7%90%86%E8%AE%BA/"/>
    <id>http://example.com/2023/09/21/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84CAP%E7%90%86%E8%AE%BA/</id>
    <published>2023-09-21T06:42:13.000Z</published>
    <updated>2023-09-21T07:44:01.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h1><p>CAP理论是关于数据一致性（ C：Consistency ）、服务可用性（ A：Availability ）、分区容错性（ P：Partition-tolerance ）。</p><p>CAP 理论告诉我们，一个分布式系统不可能同时满足数据一致性、服务可用性和分区容错性 这三个基本需求，最多只能同时满足其中的两个。</p><h1 id="一致性（-C-）"><a href="#一致性（-C-）" class="headerlink" title="一致性（ C ）"></a>一致性（ C ）</h1><p>这里的一致性是指强一致性，又叫线性一致性，它要求多节点组成的分布式系统，能像单节点一样运作，如果一个写操作返回成功，那么之后的读请求都必须读到这个新数据；如果返回失败，那么所有的读操作都不能读到这个数据。</p><p>一致性中除了强一致性之外，还有其他的一致性级别，比如序列一致性（ Sequential Consistency ）和最终一致性（ Eventual Consistency ）等。</p><h1 id="可用性（-A-）"><a href="#可用性（-A-）" class="headerlink" title="可用性（ A ）"></a>可用性（ A ）</h1><p>可用性指的是要求系统提供的服务必须处于 100% 可用的状态，对于用 户的每一个操作请求，系统总能够在有限的时间内返回结果。</p><h1 id="分区容错性（-P-）"><a href="#分区容错性（-P-）" class="headerlink" title="分区容错性（ P ）"></a>分区容错性（ P ）</h1><p>分区指的是在整个分布式系统中，因为网络原因，系统被分隔成多个单独的部分，这里，不同系统之间在正常情况下应该是一个整体，因为网络原因不能通信才会被划分为不同的分区。在现实的分布式系统中，我们面对的就是一个不可靠的网络和有一定概率宕机的设备，这两个 因素都会导致分区出现，因此在分布式系统实现中，分区容错性 P 是一个必须项。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入浅出分布式技术原理》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CAP-理论&quot;&gt;&lt;a href=&quot;#CAP-理论&quot; class=&quot;headerlink&quot; title=&quot;CAP 理论&quot;&gt;&lt;/a&gt;CAP 理论&lt;/h1&gt;&lt;p&gt;CAP理论是关于数据一致性（ C：Consistency ）、服务可用性（ A：Availability ）</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="分布式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="http://example.com/2023/09/19/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://example.com/2023/09/19/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2023-09-19T07:11:08.000Z</published>
    <updated>2023-09-23T13:00:59.883Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>锁存在的意义是为了保证在多CPU，多个线程的环境中，某一个时间点上，只能由一个线程进入临界区代码，从而保证临界区操作数据的一致性。</p><p>进程内的锁，是操作系统直接提供的，对于同一台机器上的多进程，可以直接通过操作系统的锁来实现，只不过是协调了多个进程，需要将锁放在所有进程都可以访问的共享内存中，所有进程通过共享内存中的 锁来进行加锁和解锁。</p><p>但是分布式是在不同机器上，通过操作系统的锁已经无法实现。</p><h1 id="怎么实现分布式锁"><a href="#怎么实现分布式锁" class="headerlink" title="怎么实现分布式锁"></a>怎么实现分布式锁</h1><p>实现分布式锁，需要满足以下几个特性：</p><ol><li><p>互斥：保证不同节点、不同线程的互斥访问。</p></li><li><p>超时机制：即超时设置，防止死锁。因为锁服务和请求锁的服务分散在不同的机器上面，它们之间是通过网络来通信 的，所以我们需要用超时机制，来避免获得锁的节点故障或者网络异常，导致它持有的锁不能 归还，出现死锁的情况。</p><p>同时还要确保留有线程不断延长锁的时间，防止事务还没处理完，而时间到了，导致释放了锁。</p></li><li><p>完备的锁接口：比如说lock接口和trylock接口等。</p></li><li><p>可重入性：即一个节点的一个线程已经获取了锁，那么该节点持有锁的这个线程 可以再次成功获取锁。我们在加锁时，记录好当前获取锁的节点+线程组合的唯一标识，后续如果标识相同，直接返回加锁成功即可，否则按照正常流程处理。</p></li><li><p>公平性：即对于 Lock 接口获取锁失败被阻塞等待的加锁请求，在锁被释放后，如果按 先来后到的顺序，将锁颁发给等待时间最长的一个加锁请求，那么就是公平锁，否则就是非公 平锁。</p></li></ol><h1 id="分布式锁的挑战"><a href="#分布式锁的挑战" class="headerlink" title="分布式锁的挑战"></a>分布式锁的挑战</h1><p>分布式锁面临的挑战有：正确性、高可用和高性能。</p><p>首先考虑进程内的锁，如果一个线程持有锁，只要它不释放，就只有它能操作临界区的资源。同时，因为进程内锁的场景中，不会出现部分失败的情况，所以它崩溃无法释放锁时，会导致整个进程崩溃，不会出现死锁（这里不包括业务逻辑出错而导致的死锁）。</p><p>另一个方面，进程内锁的解锁操作是进程内部的函数调用，这个过程是同步的。只要发起加锁操作，就会成功（这个操作会成功，但是加锁不一定），解锁操作同样。</p><p>当存在多个进程时，加锁操作仍然是函数调用，和上边一样，但是存在一个进程获取锁后崩溃，导致无法释放锁，出现死锁。但是可以通过操作系统来判断一个进程是否存活，并查看它是否获取锁，从而解决问题。</p><p>但是在分布式场景下，发起获取锁的操作需要利用不可靠的网络，意味着发起获取锁的这个操作就有可能失败（这里称为获取锁的时延），而且获取锁后，该进程与服务器通信出现了问题，导致无法释放锁，造成死锁。这就需要设置一个超时时间，如果获取锁的进程超时，就自动释放锁。</p><p>在获取锁的时延上，如果采用超时加心跳，可能会导致服务端给客户端分发了锁，但是由于响应超时，导致客户端以为自己没有获取到锁。</p><p>为了解决这个问题，我们可以在生成锁的时候一并生成一个全局唯一且递增的版本号，当操作共享数据时，会检查版本号，如果出现版本号倒退的现象，则说明出了问题，拒绝该次请求即可。</p><h1 id="分布式锁的权衡"><a href="#分布式锁的权衡" class="headerlink" title="分布式锁的权衡"></a>分布式锁的权衡</h1><p>我们无法保证分布式锁100%的有效，而且正确性要求越高，它的性能会越低。一般来说，会在成本可接受的范围内，提供性能最好的分布式锁服务，如果性能不佳，则需要告知。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入浅出分布式技术原理》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分布式锁&quot;&gt;&lt;a href=&quot;#分布式锁&quot; class=&quot;headerlink&quot; title=&quot;分布式锁&quot;&gt;&lt;/a&gt;分布式锁&lt;/h1&gt;&lt;p&gt;锁存在的意义是为了保证在多CPU，多个线程的环境中，某一个时间点上，只能由一个线程进入临界区代码，从而保证临界区操作数据的一</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="分布式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡</title>
    <link href="http://example.com/2023/09/17/%E5%88%86%E5%B8%83%E5%BC%8F/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://example.com/2023/09/17/%E5%88%86%E5%B8%83%E5%BC%8F/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2023-09-17T06:18:17.000Z</published>
    <updated>2023-09-22T06:19:23.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>在分布式的环境下，单个模块往往会部署多个，当调用方通过注册发现组件获得了被调用方的网络地址时，会获得多个地址，这时候就要通过负载均衡组件来确定是调用哪一个具体的组件。</p><p>我们可以根据负载均衡策略是否关心请求中携带的信息，即请求是否有状态，将负载均衡策略分为无状态的负载均衡、半状态的负 载均衡和全状态的负载均衡。</p><h2 id="负载均衡的关键点"><a href="#负载均衡的关键点" class="headerlink" title="负载均衡的关键点"></a>负载均衡的关键点</h2><p>负载均衡需要考虑到各个实例性能差异的情况， 让每一个实例都能充分发挥它的能力，不要出现一些实例负载比较高，而另一些实例的负载却 非常低的情况，这样会造成资源浪费。所以负载均衡的第一个关键点是<strong>公平性</strong>。即要关注被调用服务组之间的公平性，不能旱的旱死，涝的涝死。</p><p>负载均衡需要确保外部对后端服务的请求，一定能被路由到可以提供正确服务的实例上。如果后端是有状态的，那么我们就要考虑在请求上携带状态信息，然后根据状态将请求发送到对应的路由上，所以第二个关键点是<strong>正确性</strong>，即对于有状态的服务来说，负载均 衡需要关心请求的状态，将请求调度到能处理它的后端实例上，不要出现不能处理和错误处理 的情况。</p><h2 id="无状态的负载均衡"><a href="#无状态的负载均衡" class="headerlink" title="无状态的负载均衡"></a>无状态的负载均衡</h2><p>无状态的负载均衡指的是所有后端实例都是对等的，不管请求发送到哪个实力上，都会得到正确的结果，所以无状态的负载均衡不需要关心请求的状态。</p><p>如果这些无状态的实例需要处理像存储数据这种状态，则需要将这些状态信息都交由一个中心存储负责，比如MySQL或者Redis，他们不会在本地磁盘存储任何状态信息。以下是两种具体的方案</p><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>轮询的负载均衡策略非常简单，只需要将请求按顺序分配给多个实例，不用再做其他的处理。轮询在路由时，不利用请求的状态信息，属于无状态的负载均衡策略，所以它不能用于有状态 实例的负载均衡器。</p><h3 id="权重轮询"><a href="#权重轮询" class="headerlink" title="权重轮询"></a>权重轮询</h3><p>权重轮询的负载均衡策略是将每一个后端实例分配一个权重，分配请求的数量和实例的权重成 正比轮询。例如有两个实例 A，B，假设我们设置 A 的权重为 20，B 的权重为 80，那么负载 均衡会将 20% 的请求数量分配给 A，80 % 的请求数量分配给 B。</p><h2 id="半状态的负载均衡"><a href="#半状态的负载均衡" class="headerlink" title="半状态的负载均衡"></a>半状态的负载均衡</h2><p>半状态的负载均衡指的是，虽然负载均衡策略利用请求的状态信息进行路由，但是仅仅进行简单的规则处理，比如 Hash 运算加求模来路由请求，它不保证路由的正确性，这个正确性由后端实例来保证。</p><p>一些实例会在内存中存储一些状态数据来提升系统性能，如果一个请求被分配到错误的路由中，可以通过中心存储来读取所需要的数据。</p><p>半状态的负载均衡将请求按一定的策略进行路由，后端实例可以利用路 由规则来进行优化。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash 负载均衡策略是指将请求的状态信息，按一定的 Hash 算法固定分配到一个实例上，例 如，按请求的来源 IP 地址或者用户的 ID，将同一个来源 IP 地址或者用户 ID 的请求固定到一 个实例上。</p><p>存在的问题：如果机器数量发生改变，则请求和实例的分配关系则会发生变化，影响正确性。</p><h3 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h3><p>一致性 Hash可以解决Hash模式下的问题。</p><p>假设Hash环的大小为2^32，那么我们先将0~2^32均匀的分布在Hash环上，然后将所有的实例按照唯一标识来计算他们在环上的位置。</p><p>对于每个请求，也采用同样的方式，都是对2^32取模，然后计算位置。如果该位置没有节点，那么就顺时针往下走，知道找到第一个有节点的位置，该请求就交由该节点执行。</p><p>这样的好处是始终对2^32取模，不管有多少个节点变动，始终不影响结果。</p><h2 id="全状态的负载均衡"><a href="#全状态的负载均衡" class="headerlink" title="全状态的负载均衡"></a>全状态的负载均衡</h2><p>全状态的负载均衡是指，负载均衡策略不仅利用请求的状态信息进行路由，并且在后端实例有 状态的情况下，依然会保证路由的正确性。</p><p>全状态的负载均衡一般以路由服务的形式存在，在路由服务里面，都会存储后端实例 ID 和状 态信息的索引，在进行请求路由的时候，路由服务从请求的状态信息中获得索引的标识，通过 查询索引获得后端实例的 ID，然后再进行路由。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入浅出分布式技术原理》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;负载均衡&quot;&gt;&lt;a href=&quot;#负载均衡&quot; class=&quot;headerlink&quot; title=&quot;负载均衡&quot;&gt;&lt;/a&gt;负载均衡&lt;/h1&gt;&lt;p&gt;在分布式的环境下，单个模块往往会部署多个，当调用方通过注册发现组件获得了被调用方的网络地址时，会获得多个地址，这时候就要通过</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="分布式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>路由器结构</title>
    <link href="http://example.com/2023/09/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2023/09/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%BB%93%E6%9E%84/</id>
    <published>2023-09-15T06:19:49.000Z</published>
    <updated>2023-09-21T06:41:23.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h1 id="路由器结构"><a href="#路由器结构" class="headerlink" title="路由器结构"></a>路由器结构</h1><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230511101229903.png" alt="image-20230511101229903" style="zoom:80%;" /><p>路由器由输入端口，交换结构，路由选择处理器以及输出端口组成。输入端口负责接收数据报，并且在这里决定好要怎么进行转发，然后经过交换结构，到达输出端口。即在输入端口这里已经找到了他的下一跳的地址，然后传送给交换结构，交换结构只需要根据数据去找对应的输出端口即可，可以大大减小路由表的大小。</p><p>而具体怎么找到该送往那个端口，最简单的是做一个map，包含了所有的映射，但是由于映射数量达到上百亿，不可取。另一种方案是：根据最长前缀匹配，比如说0000发网接口0，0001发网接口1，以此类推。</p><p>这里，输入端口查找的是数据报目的的ip，可能需要经过多个路由器来进行转发，才能到达目地地址。</p><h1 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h1><p>交换技术有三种，经内存的交换，经总线交换，互联网络交换。</p><h2 id="经内存的交换"><a href="#经内存的交换" class="headerlink" title="经内存的交换"></a>经内存的交换</h2><p>这种方案下，输入端口和输出端口的功能有点像传统操作系统中的I&#x2F;O，当一个分组到达端口，改端口通过中断向路由选择处理器发送信号，然后将分组复制到处理器内存当中，路由选择器从分组的首部提取到目的地址，在转发表找适当的输出端口，再将该分组复制到输出端口的缓存当中。</p><h2 id="经总线交换"><a href="#经总线交换" class="headerlink" title="经总线交换"></a>经总线交换</h2><p>这种方案下，输入端口经一根总线将分组直接发送到输出端口，不需要路由选择处理器的干预。这种方案下，输入端口需要预先计划一个交换机内部标签，指示本地输出端口，该分组可以由所有输出端口接受，但是只有标签匹配的才会保留，标签在输出端口被去除。单一总线会对性能造成影响</p><h2 id="经互联网络交换"><a href="#经互联网络交换" class="headerlink" title="经互联网络交换"></a>经互联网络交换</h2><p>这种方案是用2N条总线连接输入和输出端口，总线可以通过交换设备自由闭合，比如A发往X的数据，可以调整只打开A和X，但是如果有多个数据报都发往X，那么在X之前还是需要排队。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《计算机网络自顶向下》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; title=&quot;结构&quot;&gt;&lt;/a&gt;结构&lt;/h1&gt;&lt;h1 id=&quot;路由器结构&quot;&gt;&lt;a href=&quot;#路由器结构&quot; class=&quot;headerlink&quot; title=&quot;路由器结构&quot;&gt;&lt;/a&gt;路由器结</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="网络层" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
