<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便起个名字吧</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-07T02:55:28.177Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Guo Junhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java开发分布式系统的编码技巧</title>
    <link href="http://example.com/2023/08/07/Java%E5%BC%80%E5%8F%91%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/"/>
    <id>http://example.com/2023/08/07/Java%E5%BC%80%E5%8F%91%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/</id>
    <published>2023-08-07T01:58:48.000Z</published>
    <updated>2023-08-07T02:55:28.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PageCache-调优和-Direct-IO"><a href="#PageCache-调优和-Direct-IO" class="headerlink" title="PageCache 调优和 Direct IO"></a>PageCache 调优和 Direct IO</h1><p>应用程序读取文件，会经过应用缓存、PageCache、DISK（硬盘）三层。</p><p>Linux内核读取到文件数据后，会把它缓存一段时间，这个文件缓存就是PageCache。它会进行适当的预读，比如用户当前只需要读取1kb的文件，但是它的算法觉得读取16k或者更多更合适，那么它就会读取16kb，加载到PageCache中，下次读取先去PageCache中查找。</p><p>但是以下三种情况没法使用PageCache：</p><ol><li><p>使用 FIleChannel 读写时，底层可能走 Direct IO，不走页缓存。</p></li><li><p>在内存有限或者不够用的时候，频繁换页，导致缓存命中率低。</p></li><li><p>大量随机读的场景，导致页缓存的数据无法命中。</p></li></ol><p>一种解决思路是：<strong>通过使用Direct IO 来模拟实现PageCahce的效果</strong>。原先PageCache的底层实现，是由操作系统实现的，比如说数据加载，缓存命中，换页，刷盘等，我们无法控制。我们可以通过自定义 Cache + Direct IO 来实现自己可控的操作。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230807102215994.png" alt="image-20230807102215994"></p><h1 id="FileChannel-和-mmap"><a href="#FileChannel-和-mmap" class="headerlink" title="FileChannel 和 mmap"></a>FileChannel 和 mmap</h1><p>Java 原生的 IO 主要可以分为普通 IO、FileChannel（文件通道）、mmap（内存映射）三种。</p><p>java.io 包中的 FileWriter 和 FileReader 属于普通 IO，java.nio 包中的 FileChannel 属于 NIO 的一种，mmap 是调用 FileChannel.map() 实例出来的一种特殊读写文件的方式，被称为内存映射。</p><h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h2><p><strong>FileChannel 大多数时候是和 ByteBuffer 打交道的</strong>，ByteBiffer是byte[]的一个封装类，ByteBuffer 是在应用内存中的，它和硬盘之间还隔着一层 PageCache。从使用上看，我们通过 filechannel.write 写入数据时，会将数据从应用内存写入到 PageCache，此时便认为完成了落盘操作。但实际上，操作系统最终帮我们将 PageCache 的数据自动刷到了硬盘。</p><h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p>mmap 是一个把文件映射到内存的操作，因此可以像读写内存一样读写文件。它省去了用户空间到内核空间的数据复制过程，从而提高了读写性能。</p><p>从经验来看，mmap 在内存充足、数据文件较小且相对固定的场景下，性能比 FileChannel 高。<strong>但它有这样几个缺点：</strong></p><ol><li><p>使用时必须先指定好内存映射的大小，并且一次 Map 的大小限制在 1.5G 左右。</p></li><li><p>是由操作系统来刷盘的，手动刷盘时间不好掌握。</p></li><li><p>回收非常复杂，需要手动释放，并且代码和实现很复杂。</p></li></ol><p>在消息队列数据文件分段的场景下，因为每个段文件的大小是固定的，且大小还是可配置的，所以是可以使用 mmap 来提高性能的。</p><h1 id="直接内存（堆外）和堆内内存"><a href="#直接内存（堆外）和堆内内存" class="headerlink" title="直接内存（堆外）和堆内内存"></a>直接内存（堆外）和堆内内存</h1><p>堆内和堆外的堆是指 JVM 堆，堆内内存就是指 JVM 堆内部的内存空间，堆外就是指除了 JVM 堆以外的内存空间。堆内内存加上堆外内存等于总内存。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230807103548870.png" alt="image-20230807103548870" style="zoom:80%;" /><p>如何选择堆外内存和堆内内存：</p><ol><li>当需要申请大块的内存时，堆内内存会受到限制，可以尝试分配堆外内存</li><li>堆外内存适用于生命周期中等或较长的对象</li><li>堆内内存刷盘的过程中，还需要复制一份到堆外内存，多了一步，会降低性能</li><li>创建堆外内存的消耗要大于创建堆内内存的消耗，所以当分配了堆外内存之后，要尽可能复用它</li><li>可以使用池化 + 堆外内存的组合方式，比如代码中如果需要频繁  new byte[]，就可以研究一下 ThreadLocal 和  ThreadLocal&lt;byte[]&gt; 的使用机制。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PageCache-调优和-Direct-IO&quot;&gt;&lt;a href=&quot;#PageCache-调优和-Direct-IO&quot; class=&quot;headerlink&quot; title=&quot;PageCache 调优和 Direct IO&quot;&gt;&lt;/a&gt;PageCache 调优和 Dir</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ的设计</title>
    <link href="http://example.com/2023/07/24/RabbitMQ%E7%9A%84%E6%B6%89%E5%8F%8A/"/>
    <id>http://example.com/2023/07/24/RabbitMQ%E7%9A%84%E6%B6%89%E5%8F%8A/</id>
    <published>2023-07-24T12:16:13.000Z</published>
    <updated>2023-07-24T12:42:32.898Z</updated>
    
    <content type="html"><![CDATA[<p>下图是RabbitMQ的系统架构：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230724201809821.png" alt="image-20230724201809821"></p><p>RabbitMQ 由 Producer、Broker、Consumer 三个大模块组成。</p><p>生产者将数据发送到 Broker，Broker 接收到数据后，将数据存储到对应的 Queue 里面，消费者从不同的 Queue 消费数据。它有 Exchange、Bind、Route 这几个独有的概念。</p><p>Exchange 称为交换器，它是一个逻辑上的概念，用来做分发，本身不存储数据。流程上生产者先将消息发送到 Exchange，而不是发送到数据的实际存储单元 Queue 里面。然后 Exchange 会根据一定的规则将数据分发到实际的 Queue 里面存储。</p><p>这个分发过程就是 Route（路由），设置路由规则的过程就是 Bind（绑定）。即 Exchange 会接收客户端发送过来的 route_key，然后根据不同的路由规则，将数据发送到不同的 Queue 里面。</p><h1 id="协议和网络模块"><a href="#协议和网络模块" class="headerlink" title="协议和网络模块"></a>协议和网络模块</h1><p>在网络通信协议层面，RabbitMQ 数据流是基于四层 TCP 协议通信的，跑在 TCP 上的应用层协议是 AMQP。</p><p>RabbitMQ 的网络层有 Connectoion 和 Channel 两个概念需要注意。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230724202241340.png" alt="image-20230724202241340"></p><p>Connection 是指 TCP 连接，Channel 是 Connection 中的虚拟连接。两者的关系是：一个客户端和一个 Broker 之间只会建立一条 TCP 连接，就是指 Connection。Channel（虚拟连接）的概念在这个连接中定义，一个 Connection 中可以创建多个 Channel。</p><p><strong>客户端和服务端的实际通信都是在 Channel 维度通信的。</strong></p><p>RabbitMQ 服务端通过 tcp_listener 监听端口，tcp_acceptor 接收请求，rabbit_reader 处理和返回请求。本质上来看是也是一个多线程的网络模型。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230724202504119.png" alt="image-20230724202504119"></p><h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><p>RabbitMQ 的存储模块也包含元数据存储与消息数据存储两部分。RabbitMQ 的两类数据都是存储在 Broker 节点上的。</p><h2 id="元数据存储"><a href="#元数据存储" class="headerlink" title="元数据存储"></a>元数据存储</h2><p>RabbitMQ 的元数据都是存在于 Erlang 自带的分布式数据库 Mnesia 中的。即每台 Broker 都会起一个 Mnesia 进程，用来保存一份完整的元数据信息。Mnesia是一个分布式数据库，自带了多节点自动同步机制。</p><h2 id="消息数据存储"><a href="#消息数据存储" class="headerlink" title="消息数据存储"></a>消息数据存储</h2><p>RabbitMQ 消息数据的最小存储单元是 Queue，即消息数据是按顺序写入存储到 Queue 里面的。</p><p>在底层的数据存储方面，所有的 Queue 数据是存储在同一个“文件”里面的。这个“文件”是一个虚拟的概念，表示所有的 Queue 数据是存储在一起的意思。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230724202717072.png" alt="image-20230724202717072"></p><p>这个“文件”由队列索引（rabbit_queue_index）和消息存储（rabbitmq_msg_store）两部分组成。即在节点维度，所有 Queue 数据都是存储在 rabbit_msg_store 里面的，每个节点上只有一个 rabbit_msg_store，数据会依次顺序写入到 rabbit_msg_store 中。</p><p>rabbit_msg_store 是一个逻辑概念，底层的实际存储单元分为两个，msg_store_persistent 和 msg_store_transient，分别负责持久化消息和非持久化消息的存储。</p><p>这里所有的消息都会以追加的形式写入一个文件当中，当一个文件的大小超过了配置的最大大小，就会新开一个文件来存储。</p><p>队列索引负责存储、维护队列中落盘消息的信息，包括消息的存储位置、是否交付、是否 ACK 等等信息。队列索引是 Queue 维度的，每个 Queue 都有一个对应的队列索引。</p><p>删除消息时，不会立即删除数据，只是从 Erlang 中的 ETS 表删除指定消息的相关信息，同时更新消息对应的存储文件的相关信息。此时文件中的消息不会立即被删除，会被标记为已删除数据，直到一个文件中都是可以删除的数据时，再将这个文件删除，这个动作就是常说的延时删除。另外内核有检测机制，会检查前后两个文件中的数据是否可以合并，当符合合并规则时，会进行段文件的合并。</p><h1 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h1><p>当生产者和消费者连接到 Broker 进行生产消费的时候，是直接和 Broker 交互的，不需要客户端寻址。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230724203444673.png" alt="image-20230724203444673" style="zoom:80%;" /><p>RabbitMQ 集群部署后，为了提高容灾能力，就需要在集群前面挂一层负载均衡来进行灾备。但是一个客户端拿到负载均衡ip的时候，去对应的Broker去消费数据，可能会出现该条消息并不存储于该Broker而导致消费失败。</p><p>为了解决这个问题，每个 Broker 上会设置有转发的功能。在实现上，每台 Broker 节点都会保存集群所有的元数据信息。当 Broker 收到请求后，根据本地缓存的元数据信息判断 Queue 是否在本机上，如果不在本机，就会将请求转发到 Queue 所在的目标节点。</p><p>生产端发送数据不是直接发送到 Queue，而是直接发送到 Exchange。即发送时需要指定 Exchange 和 route_key，服务端会根据这两个信息，将消息数据分发到具体的 Queue。</p><p>在消费端，RabbitMQ 支持 Push（推）和 Pull（拉）两种模式，如果使用了 Push 模式，Broker 会不断地推送消息给消费者（如果有消息的情况下）。推送消息的个数会受到 channel.basicQos 的限制，不能无限推送，在消费端会设置一个缓冲区来缓冲这些消息。</p><p>拉模式是指客户端不断地去服务端拉取消息，RabbitMQ 的拉模式只支持拉取单条消息。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入拆解消息队列 47 讲》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下图是RabbitMQ的系统架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230724201809821.png&quot; alt=&quot;image-2023072</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="消息队列" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>消费客户端的SDK（下）</title>
    <link href="http://example.com/2023/07/22/%E6%B6%88%E8%B4%B9%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84SDK%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://example.com/2023/07/22/%E6%B6%88%E8%B4%B9%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84SDK%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2023-07-22T02:32:37.000Z</published>
    <updated>2023-07-22T03:14:35.444Z</updated>
    
    <content type="html"><![CDATA[<p>这里介绍上篇剩下的三部分，也就是消费分组（订阅）、消费确认、消费失败处理。</p><h1 id="消费分组"><a href="#消费分组" class="headerlink" title="消费分组"></a>消费分组</h1><p>消费分组是用来组织消费者、分区、消费进度关系的逻辑概念。</p><p>在没有消费分组直接消费 Topic 的场景下，如果希望不重复消费 Topic 中的数据，那么就<strong>需要有一个标识来标识当前的消费情况，比如记录进度。</strong>这个唯一标识就是消费分组。</p><p>消费分组主要有管理消费者和分区的对应关系、保存消费者的消费进度、实现消息可重复被消费三类功能。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230722104248529.png" alt="image-20230722104248529" style="zoom:80%;" /><p>因为 Topic 不存储真实数据，分区才存储消息数据，所以就需要解决消费者和分区的分配关系，即<strong>哪个分区被哪个消费者消费，这个分配的过程就叫做消费重平衡（Rebalance）</strong>。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230722104350416.png" alt="image-20230722104350416" style="zoom:80%;" /><p>由上图可以看出，当新增一个消费分组时，为了使得消费平衡，就需要重新分配消费关系。</p><h2 id="协调者"><a href="#协调者" class="headerlink" title="协调者"></a>协调者</h2><p>如果要对消费者和分区进行分配，肯定需要有一个模块拥有消费分组、所有的消费者、分区信息三部分信息，这个模块我们一般命名为<strong>协调者。</strong>协调者主要的工作就是执行消费重平衡，并记录消费分组的消费进度。</p><p>分区分配的操作可以在协调者内部或者消费者上完成。这两种，一种是协调者获得所有的信息，然后进行分配，分配完同步给其他的消费者。一种是一个消费者获取所有其他消费者和分区的信息，进行分配操作，之后同步给其他消费者。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230722105108840.png" alt="image-20230722105108840" style="zoom:80%;" /><h2 id="消费分区分配策略"><a href="#消费分区分配策略" class="headerlink" title="消费分区分配策略"></a>消费分区分配策略</h2><p>分区分配策略的制定一般遵循以下三个原则：</p><ol><li>各个分区的数据能均匀地分配给每个消费者，保证所有消费者的负载最大概率是均衡的。</li><li>在每次重新分配的时候，尽量减少分区和消费者之间的关系变动，这样有助于加快重新分配的速度，并且保持数据处理的连续性，降低处理切换成本。</li><li>可以允许灵活地根据业务特性制定分配关系</li></ol><p>所有消息队列的默认策略都是相对通用的，一般都会包含有轮询、粘性、自定义三种类型的策略。</p><p><strong>轮询</strong>就是指用轮询的方式将分区分配给各个消费者，保证每个消费者的分区数量是尽量相同的，从而保证消费者的负载最大概率上是均衡的。但是这种方案可能导致几个流量较高的分区分给了同一个消费者，为了解决这个问题，在随机的基础上，将 Topic 的不同分区尽量打散到不同的消费者，从而保证整体消费者之间的分区是均衡的（即同一个topic下的不同partition分给不同的消费者）。</p><p><strong>粘性</strong>是指尽量减少分区分配关系的变动，进而减少重平衡所耗费的时间和资源损耗。即当有新的分区加入，或者老的分区挂掉，在重新分配时，应尽可能减少变动。</p><p>自定义就是提供接口，用户自己实现。</p><h1 id="消费确认"><a href="#消费确认" class="headerlink" title="消费确认"></a>消费确认</h1><p>当消息被消费时，就必须进行消费确认，即告诉服务端这条消息已经被消费了，也就是常说的ACK。</p><p>一般情况下，消息确认分为确认后删除数据和确认后保存消费进度数据两种形式。</p><p><strong>确认后删除数据</strong>是指集群的每条消息只能被消费一次，只要数据被消费成功，就会回调服务端的 ACK 接口，服务端就会执行数据删除操作。这种方案不利于回溯，所以用的不多。</p><p><strong>消费成功保存消费进度</strong>是指当消费数据成功后，调用服务端的消费进度接口来保存消费进度。这种方式一般都是配合消费分组一起用的，服务端从消费分组维度来保存进度数据。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230722110620707.png" alt="image-20230722110620707"></p><p>为了保证消息的回溯和多次消费，一般都采用这种方案。<strong>数据的删除交由数据过期策略去执行。</strong></p><p>保存消费进度一般分为服务端保存和客户端自定义保存两种实现机制。</p><p><strong>服务端保存</strong>是指服务端提供一个接口用于保存数据，客户端调用即可。服务端一般会通过内置的 Topic 或者文件来持久保存该数据。</p><p>在提交位点信息的时候，底层一般支持自动提交和手动提交两种实现。</p><ul><li><strong>自动提交</strong>一般是根据时间批次或数据消费到客户端后就自动提交，提交过程客户无感知。</li><li><strong>手动提交</strong>是指业务根据自己的处理情况，手动提交进度信息，以避免业务处理异常导致的数据丢失。</li></ul><p>优缺点如下：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230722111121025.png" alt="image-20230722111121025" style="zoom:80%;" /><p><strong>客户端自定义保存</strong>是指当消费完成后，客户端自己管理保存消费进度。</p><h1 id="消费失败处理"><a href="#消费失败处理" class="headerlink" title="消费失败处理"></a>消费失败处理</h1><p>一个完整的消费流程包括消费数据、本地业务处理、消费进度提交三部分，那么从消费失败的角度来看，就应该分为从服务端拉取数据失败、本地业务数据处理失败、提交位点信息失败三种情况。</p><p><strong>从服务端拉取数据失败</strong>，和客户端的错误逻辑处理是一致的，根据可重试错误和不可重试错误的分类，进行重复消费或者向上抛错。</p><p><strong>本地业务数据处理失败</strong>，如果是偶尔失败，那么在业务层做好重试处理逻辑，配合手动提交消费进度的操作即可解决。如果是一直失败，即使重试多次也无法被解决，此时如果一直重试，就会出现消费卡住的情况，这就需要配合死信队列的功能，将无法被处理的数据投递到死信队列中，从而保存异常数据并保证消费进度不阻塞。</p><p><strong>提交位点信息失败</strong>，其处理方法通常是一直重试，重复提交，如果持续失败就向上抛错。因为如果提交进度失败，即使再从服务端拉取数据，还是会拉到同一批数据，出现重复消费的问题。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入拆解消息队列 47 讲》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里介绍上篇剩下的三部分，也就是消费分组（订阅）、消费确认、消费失败处理。&lt;/p&gt;
&lt;h1 id=&quot;消费分组&quot;&gt;&lt;a href=&quot;#消费分组&quot; class=&quot;headerlink&quot; title=&quot;消费分组&quot;&gt;&lt;/a&gt;消费分组&lt;/h1&gt;&lt;p&gt;消费分组是用来组织消费者、分区、消</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="消息队列" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>消费客户端的SDK（上）</title>
    <link href="http://example.com/2023/07/21/%E6%B6%88%E8%B4%B9%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84SDK%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://example.com/2023/07/21/%E6%B6%88%E8%B4%B9%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84SDK%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2023-07-21T02:46:22.000Z</published>
    <updated>2023-07-21T03:35:06.107Z</updated>
    
    <content type="html"><![CDATA[<p>从实现来看，消费相关功能包括<strong>消费模型</strong>、<strong>分区消费模式</strong>、<strong>消费分组（订阅）</strong>、<strong>消费确认</strong>、<strong>消费失败处理</strong>五个部分。</p><p>这里只涉及到前两个部分。</p><h1 id="消费模型的选择"><a href="#消费模型的选择" class="headerlink" title="消费模型的选择"></a>消费模型的选择</h1><p>为了满足不同场景的业务需求，从实现机制上来看，主流消息队列一般支持 Pull、Push、Pop 三种消费模型。</p><h2 id="Pull-模型"><a href="#Pull-模型" class="headerlink" title="Pull 模型"></a>Pull 模型</h2><p>Pull（拉）模型是指客户端通过不断轮询的方式向服务端拉取数据。它是消息队列中使用最广泛和最基本的模型，主流的消息队列都支持这个模型。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230721105121747.png" alt="image-20230721105121747"></p><p>它的好处是客户端根据自身的处理速度去拉取数据，不会对客户端和服务端造成额外的风险和负载压力。缺点是可能会出现大量无效返回的 Pull 调用（服务端没有数据可以拉去时），另外消费及时性不够。</p><p>为了提高性能，Pull是可以指定一次拉去多少条数据，然后传递给服务端，即批量拉取。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230721105516142.png" alt="image-20230721105516142" style="zoom:80%;" /><p>如上图，如果Topic1的数据已经被消费完，但是客户端还是不断的发请求拉数据，那么就会导致资源的浪费。</p><p>为了解决这个问题，一般服务端会协助处理，有如下两个思路：</p><h3 id="1-服务端-hold-住请求"><a href="#1-服务端-hold-住请求" class="headerlink" title="1. 服务端 hold 住请求"></a>1. 服务端 hold 住请求</h3><p>当客户端根据策略拉取数据时，如果没有足够的数据，就先在服务端等一段时间，等有数据后一起返回给客户端。</p><p>好处是可以尽可能提高吞吐率，而且不会有太多的空请求。</p><p>缺点是如果长时间没有消息，则会导致消费者请求超时，而且如果数据长时间不够，则会提高消费时延。</p><h3 id="2-服务端有数据的时候通知客户端"><a href="#2-服务端有数据的时候通知客户端" class="headerlink" title="2. 服务端有数据的时候通知客户端"></a>2. 服务端有数据的时候通知客户端</h3><p>当服务端不 hold 住请求，立刻返回空数据，客户端收到空数据时则不再发起请求，会等待服务端的通知。当服务端有数据的时候，再主动通知客户端来拉取。</p><p>这种方案的好处是可以及时通知客户端来拉取数据，从而降低消费延时。</p><p>缺点是因为客户端和服务端一般是半双工的通信，此时服务端是不能主动向客户端发送消息的。</p><p>所以在 Pull 模型中，比较合适的方案是客户端告诉服务端：<strong>最多需要多少数据、最少需要多少数据、未达到最小数据时可以等多久</strong>三个信息。然后服务端首先判断是否有足够的数据，有的话就立即返回，否则就根据客户端设置的等待时长 hold 住请求，如果超时，无论是否有数据，都会直接给客户端返回当前的结果。</p><h2 id="Push-模型"><a href="#Push-模型" class="headerlink" title="Push 模型"></a>Push 模型</h2><p>Push（推）模型是为了解决消费及时性而提出来的。这个模型的本意是指当服务端有数据时会主动推给客户端，让数据的消费更加及时。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230721110037813.png" alt="image-20230721110037813" style="zoom:80%;" /><p>在实际的 Push 模型的实现上，一般有 Broker 内置 Push 功能、Broker 外独立实现 Push 功能的组件、在客户端实现伪 Push 功能三种思路。</p><p><strong>第一种，Broker内置Push功能是指在 Broker 中内置标准的 Push的能力，由服务端向客户端主动推送数据。</strong></p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230721110202222.png" alt="image-20230721110202222" style="zoom:80%;" /><p>优点：Broker 自带 Push 能力，无需重复开发和部署。Broker 内部可以感知到数据堆积情况，可以保证消息被及时消费。</p><p>缺点：当消费者很多时，内核需要主动维护很多与第三方的长连接，并且需要处理各种客户端异常，推送数据，异常处理等比较耗费系统资源，可能会导致Broker不稳定。</p><p><strong>第二种，Broker 外独立实现 Push 功能的组件是指独立于 Broker 提供一个专门实现推模型的组件。</strong></p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230721110409783.png" alt="image-20230721110409783" style="zoom:80%;" /><p>好处是将push组件独立了出来，可以保证Broker的稳定。</p><p>缺点是需要先pull拉去数据，然后再push，会存在较高的时延。</p><p><strong>第三种，在客户端实现伪 Push 功能是指在客户端内部维护内存队列，SDK 底层通过 Pull 模型从服务端拉取数据存储到客户端的内存队列中。</strong>然后通过回调的方式，触发用户设置的回调函数，将数据推送给应用程序，在使用体验上看就是 Push 的效果。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230721110735383.png" alt="image-20230721110735383" style="zoom: 80%;" /><p>这种方案的好处在于通过客户端底层的封装，从用户体验看是 Push 模型的效果，解决用户代码层面的不断轮询问题。</p><p>缺点是底层依旧是 Pull 模型，还是得通过不断轮询的方式去服务端拉取数据，就会遇到 Pull 模型遇到的问题。</p><p>因为 Push 模型需要先分配分区和消费者的关系，客户端就需要感知分区分配、分区均衡等操作，从而在客户端就需要实现比较重的逻辑。并且当客户端和订阅的分区数较多时，容易出现需要很长的重平衡时间的情况。此时为了解决这个问题，业界提出了 Pop 模型。</p><h2 id="Pop-模型"><a href="#Pop-模型" class="headerlink" title="Pop 模型"></a>Pop 模型</h2><p>Pop 模型想解决的是客户端实现较重，重平衡会暂停消费并且可能时间较长，从而出现消费倾斜的问题。</p><p>它的思路是客户端不需要感知到分区，直接通过 Pop 模型提供的 get 接口去获取到数据，消费成功后 ACK 数据。就跟我们发起 HTTP 请求去服务端拉取数据一样，不感知服务端的数据分布情况，只需要拉到数据。</p><p>这种方案的好处是简化了消费模型，同时服务端可以感知到消费的堆积情况，可以根据堆积情况返回那些分区的数据给客户端，这样也简化了消息数据的分配策略。</p><p>从实现上来看，它将分区分配的工作移到了服务端，在服务端完成了消费者的分区分配、进度管理，然后暴露出了新的 Pop 和 ACK 接口。客户端调用 Pop 接口去拿取数据，消费成功后调用 ACK 去确认数据。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230721112049239.png" alt="image-20230721112049239" style="zoom:80%;" /><h1 id="分区消费模式的设计"><a href="#分区消费模式的设计" class="headerlink" title="分区消费模式的设计"></a>分区消费模式的设计</h1><p>消息队列的数据是在 Partition&#x2F;Queue 维度承载的。所以消费过程中一个重要的工作就是消费者和分区的消费模式问题，即分区的数据能不能被多个消费者并发消费，一条数据能不能被所有消费者消费到，分区的数据能不能被顺序消费等等。</p><p>从技术上看，在数据的消费模式上主要有<strong>独占消费</strong>、<strong>共享消费</strong>、<strong>广播消费</strong>、<strong>灾备消费</strong>四个思路。</p><h2 id="独占消费"><a href="#独占消费" class="headerlink" title="独占消费"></a>独占消费</h2><p><strong>独占消费是指一个分区在同一个时间只能被一个消费者消费。</strong>在消费者启动时，会分配消费者和分区之间的消费关系。当消费者数量和分区数量都没有变化的情况下，两者之间的分配关系不会变动。</p><p>如果消费者数量大于分区数量，则会有消费者被空置；</p><p>反之，如果分区数量大于消费者数量，一个消费者则可以同时消费多个分区。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230721112545785.png" alt="image-20230721112545785" style="zoom:80%;" /><p>独占消费的好处是可以保证分区维度的消费是有序的。缺点是当数据出现倾斜、单个消费者出现性能问题或 hang 住时，会导致有些分区堆积严重。</p><h2 id="共享消费"><a href="#共享消费" class="headerlink" title="共享消费"></a>共享消费</h2><p><strong>共享消费是指单个分区的数据可以同时被多个消费者消费。</strong>即分区的数据会依次投递给不同的消费者，一条数据只会投递给一个消费者。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230721112658334.png" alt="image-20230721112658334" style="zoom:80%;" /><p>这种方式的好处是，可以避免单个消费者的性能和稳定性问题导致分区的数据堆积。缺点是无法保证数据的顺序消费。这种模式一般用在对数据的有序性无要求的场景，比如日志。</p><h2 id="广播消费"><a href="#广播消费" class="headerlink" title="广播消费"></a>广播消费</h2><p><strong>广播消费是指一条数据要能够被多个消费者消费到。</strong>即分区中的一条数据可以投递给所有的消费者，这种方式是需要广播消费的场景。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230721112908668.png" alt="image-20230721112908668"></p><p>实现广播消费一般有内核实现广播消费的模型、使用不同的消费分组消费和指定分区消费三种技术思路。</p><ol><li>内核实现广播消费的模型，指在 Broker 内核中的消息投递流程实现广播消费模式，即 Broker 投递消息时，可以将一条消息吐给不同的消费者，从而实现广播消费。</li><li>使用不同的消费分组对数据进行消费，指通过创建不同的消费者组消费同一个 Topic 或分区，不同的消费分组管理自己的消费进度，消费到同一条消息，从而实现广播消费的效果。</li><li>指定分区消费，是指每个消费者指定分区进行消费，在本地记录消费位点，从而实现不同消费者消费同一条数据，达到广播消费的效果。</li></ol><p>优缺点如下：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230721113216520.png" alt="image-20230721113216520"></p><h2 id="灾备消费"><a href="#灾备消费" class="headerlink" title="灾备消费"></a>灾备消费</h2><p><strong>灾备消费是独占消费的升级版，在保持独占消费可以支持顺序消费的基础上，同时加入灾备的消费者****。</strong>当消费者出现问题的时候，灾备消费者加入工作，继续保持独占顺序消费。</p><p>好处是既能保持独占顺序消费，又能保证容灾能力。缺点是无法解决消费倾斜的性能问题，另外还需要准备一个消费者来做灾备，使用成本较高。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入拆解消息队列 47 讲》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从实现来看，消费相关功能包括&lt;strong&gt;消费模型&lt;/strong&gt;、&lt;strong&gt;分区消费模式&lt;/strong&gt;、&lt;strong&gt;消费分组（订阅）&lt;/strong&gt;、&lt;strong&gt;消费确认&lt;/strong&gt;、&lt;strong&gt;消费失败处理&lt;/strong&gt;五个部分。&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="消息队列" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>生产者的SDK需要哪些设计</title>
    <link href="http://example.com/2023/07/20/%E7%94%9F%E4%BA%A7%E8%80%85%E7%9A%84SDK%E9%9C%80%E8%A6%81%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2023/07/20/%E7%94%9F%E4%BA%A7%E8%80%85%E7%9A%84SDK%E9%9C%80%E8%A6%81%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1/</id>
    <published>2023-07-20T06:44:31.000Z</published>
    <updated>2023-07-21T02:46:59.418Z</updated>
    
    <content type="html"><![CDATA[<p>生产模块包含<strong>客户端基础功能和生产相关功能</strong>两部分，如下图：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230720144646902.png" alt="image-20230720144646902"></p><p>基础功能是蓝色部分，生产功能是黄色部分。</p><h1 id="客户端基础功能"><a href="#客户端基础功能" class="headerlink" title="客户端基础功能"></a>客户端基础功能</h1><h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p>客户端和服务端之间基本都是创建 TCP 长连接进行通信的，为了避免连接数膨胀，每个客户端实例和每台 Broker 只会维护一条 TCP 连接。</p><p>分为两种：</p><ul><li><strong>初始化创建连接</strong>，指在实例初始化时就创建到各个 Broker 的 TCP 连接，等待数据发送。这种可能会导致连接空跑，会消耗一定的资源。</li><li><strong>使用时创建链接</strong>，指在实例初始化时不建立连接，当需要发送数据时再建立。可能出现连接冷启动，会增加一点本次请求的耗时。</li></ul><h2 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a>心跳检测</h2><p>消息队列一般都是基于 TCP 协议通信的，所以客户端和服务端之间的心跳检测机制的实现，一般有基于 TCP 的 KeepAlive 保活机制和应用层主动探测两种形式。</p><p><strong>基于 TCP 的 KeepAlive 保活机制</strong>是 TCP&#x2F;IP 协议层内置的功能，需要手动打开，优点是简单，缺点是需要Server主动发出检测包，当客户端出现故障而Server没有发包时，可能会出现不可用的TCP连接占用服务器资源。</p><p><strong>应用层主动探测</strong>一般是 Client 向 Server 发起的，探测流程一般是客户端定时发送保活心跳，当服务端连续几次没收到请求，就断开连接。可以降低服务端压力。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>从请求的角度，有些错误是重试可以恢复的，比如连接断开、Leader 切换、发送偶尔超时、服务端某些异常等；有些错误是不可恢复的，比如 Topic&#x2F; 分区不存在、服务端 Broker 不存在、集群和 Broker 长时间无响应等。</p><p>所以，在客户端的处理中也会将错误分为可重试错误和不可重试错误两类。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230720145133022.png" alt="image-20230720145133022"></p><p>可重试指的是那些因为网络波动，Leader切换等异常，重试之后有可能解决的错误，不可重试的错误就是不管如何重试都无法恢复的异常。</p><h2 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h2><p>重试策略一般会支持重试次数和退避时间的概念。当消息失败，超过设置的退避时间后，会继续重试，当超过重试次数后，就会抛弃消息或者将消息投递到配置好的重试队列中。</p><p>退避策略影响的是重试的成功率，因为网络抖动正常是 ms 级，某些异常可能会抖动十几秒。此时，如果退避策略设置得太短，在退避策略和重试次数用完后，可能消息还没生产成功；如果退避时间设置太长，可能导致客户端发送堵塞消息堆积。</p><h1 id="生产相关功能"><a href="#生产相关功能" class="headerlink" title="生产相关功能"></a>生产相关功能</h1><h2 id="客户端寻址机制"><a href="#客户端寻址机制" class="headerlink" title="客户端寻址机制"></a>客户端寻址机制</h2><p>消息队列作为一个分布式系统，分区会分布在集群的不同节点上。那么客户端给服务端发送数据时，要发给哪台节点呢？</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230720145523867.png" alt="image-20230720145523867" style="zoom:80%;" /><p>一种思路是：手动指定目标 Broker 的 IP，就是说在生产者写数据到 Broker 的时候，在代码里面手动指定分区对应的对端的 Broker 地址，然后将数据写到目标 Broker。</p><p>为了解决查找分区在Broker上的对应关系，业界提出了 Metadata（元数据）寻址机制和服务端内部转发两个思路。</p><h3 id="1-Metadata（元数据）寻址机制"><a href="#1-Metadata（元数据）寻址机制" class="headerlink" title="1. Metadata（元数据）寻址机制"></a>1. Metadata（元数据）寻址机制</h3><p>服务端会提供一个获取全量的 Metadata 的接口，客户端在启动时，首先通过接口拿到集群所有的元数据信息，本地缓存这部分数据信息。然后，客户端发送数据的时候，会根据元数据信息的内容，得到服务端的地址是什么，要发送的分区在哪台节点上。最后根据这两部分信息，将数据发送到服务端。</p><p>简而言之，通过接口查到对应的数据，下次请求时带上就可以了。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230720150122612.png" alt="image-20230720150122612"></p><p>消息队列的元数据是指 Topic、分区、Group、节点、配置等集群维度的信息。比如 Topic 有几个分区，分区的 Leader 和 Follower 在哪些节点上，节点的 IP 和端口是什么，有哪些 Group 等等。</p><h3 id="2-服务端内部转发机制"><a href="#2-服务端内部转发机制" class="headerlink" title="2. 服务端内部转发机制"></a>2. 服务端内部转发机制</h3><p>另外一种服务端内部转发机制，客户端不需要经过寻址的过程，写入的时候是随机把数据写入到服务端任意一台 Broker。</p><p>具体思路是服务端的每一台 Broker 会缓存所有节点的元数据信息，生产者将数据发送给 Broker 后，Broker 如果判断分区不在当前节点上，会找到这个分区在哪个节点上，然后把数据转发到目标节点。</p><p>简单来说就是随便发到任意一个Broker中，然后他们之间有类似路由信息，Broker之间再进行转发。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230720150320170.png" alt="image-20230720150320170"></p><h2 id="生产分区分配策略"><a href="#生产分区分配策略" class="headerlink" title="生产分区分配策略"></a>生产分区分配策略</h2><p>数据可以直接写入分区或者写入 Topic。写入 Topic 时，最终数据还是要写入到某个分区。这个数据选择写入到哪个分区的过程，就是生产数据的分区分配过程。过程中的分配策略就是生产分区分配策略。</p><p>一般情况下，消息队列默认支持轮询、按 Key Hash、手动指定、自定义分区分配策略四种分区分配策略。</p><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p><strong>轮询</strong>是所有消息队列的默认选项。消息通过轮询的方式依次写入到各个分区中，这样可以保证每个分区的数据量是一样的，不会出现分区数据倾斜。</p><p>但是如果我们需要保证数据的写入是有序的，轮询就满足不了。因为在消费模型中，每个分区的消费是独立的，如果数据顺序依次写入多个分区，在消费的时候就无法保持顺序。所以为了保证数据有序，就需要保证 Topic 只有一个分区。这是另外两种分配策略的思路。</p><h3 id="按-Key-Hash"><a href="#按-Key-Hash" class="headerlink" title="按 Key Hash"></a>按 Key Hash</h3><p><strong>按 Key Hash</strong> 是指根据消息的 Key 算出一个 Hash 值，然后跟 Topic 的分区数取余数，算出一个分区号，将数据写入到这个分区中。</p><p>这种方案的好处是可以根据 Key 来保证数据的分区有序。比如某个用户的访问轨迹，以客户的 AppID 为 Key，按 Key Hash 存储，就可以确保客户维度的数据分区有序。（因为key是一样的，所以该用户的所有消息会被分到一个分区当中）</p><p>缺点是分区数量不能变化，变化后 Hash 值就会变，导致消息乱序。并且因为每个 Key 的数据量不一样，容易导致数据倾斜。</p><h3 id="手动指定"><a href="#手动指定" class="headerlink" title="手动指定"></a>手动指定</h3><p>在生产数据的时候，手动指定数据写入哪个分区。</p><h3 id="自定义分区分配策略"><a href="#自定义分区分配策略" class="headerlink" title="自定义分区分配策略"></a>自定义分区分配策略</h3><p>用户实现消息队列提供的接口，自定义分区策略。</p><h2 id="批量语义"><a href="#批量语义" class="headerlink" title="批量语义"></a>批量语义</h2><p>客户端支持批量写入数据的前提是，需要在协议层支持批量的语义。否则就只能在业务中自定义将多条消息组成一条消息。</p><p>批量发送的实现思路一般是在客户端内存中维护一个队列，数据写入的时候，先将其写到这个内存队列，然后通过某个策略从内存队列读取数据，发送到服务端。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230720150820416.png" alt="image-20230720150820416"></p><h2 id="数据发送方式"><a href="#数据发送方式" class="headerlink" title="数据发送方式"></a>数据发送方式</h2><p>消息队列一般也会提供同步发送、异步发送、发送即忘三种形式。</p><p>同步异步好理解，不再过多阐述。</p><p>发送即忘指消息发送后不关心请求返回的结果，立即发送下一条。这种方式因为不用关心发送结果，发送性能会提升很多。缺点是当数据发送失败时无法感知，可能有数据丢失的情况。</p><h1 id="集群管控操作"><a href="#集群管控操作" class="headerlink" title="集群管控操作"></a>集群管控操作</h1><p>集群管控操作一般是用来完成资源的创建、查询、修改、删除等集群管理动作。资源包括主题、分区、配置、消费分组等等。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入拆解消息队列 47 讲》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;生产模块包含&lt;strong&gt;客户端基础功能和生产相关功能&lt;/strong&gt;两部分，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-2023072014464</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="消息队列" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>消息队列如何保证存储的高性能</title>
    <link href="http://example.com/2023/07/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AD%98%E5%82%A8%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD/"/>
    <id>http://example.com/2023/07/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AD%98%E5%82%A8%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD/</id>
    <published>2023-07-19T02:39:03.000Z</published>
    <updated>2023-07-19T03:31:38.079Z</updated>
    
    <content type="html"><![CDATA[<p>存储模块的优化主要是基于以下四点：</p><ul><li>内存读写的效率高于硬盘读写</li><li>批量读写的效率高于单条读写</li><li>顺序读写的效率高于随机读写</li><li>数据复制次数越多，效率越低</li></ul><h1 id="提升写入操作的性能"><a href="#提升写入操作的性能" class="headerlink" title="提升写入操作的性能"></a>提升写入操作的性能</h1><p>数据需要先写入内存，然后才会落盘，所以写入操作的性能优化就要从内存和磁盘入手。写入性能的提高主要有缓存写、批量写、顺序写三个思路。</p><h2 id="1-缓存写和批量写"><a href="#1-缓存写和批量写" class="headerlink" title="1. 缓存写和批量写"></a>1. 缓存写和批量写</h2><p>物理硬件的写入速度如下图：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719104418089.png" alt="image-20230719104418089"></p><p>所以，写入优化的主要思路之一是：<strong>将数据写入到速度更快的内存中，等积攒了一批数据，再批量刷到硬盘中。</strong></p><p>平时可以看到的一种说法，数据先写入 PageCache，再批量刷到硬盘，就是这种思路。PageCache 指操作系统的页缓存，简单理解就是内存，通过缓存读写数据可以避免直接对硬盘进行操作，从而提高性能。</p><p>把缓存数据刷回到硬盘，一般有“按照空间占用比例”、“时间周期扫描”和“手动强制刷新”三种策略。操作系统内核提供了前两种处理策略，不需要应用程序感知。</p><p><strong>按空间占用比例刷新</strong>是指当系统内存中的“脏”数据大于某个阈值时会将数据刷新到硬盘。操作系统提供了两个配置项：</p><ul><li><p>“脏”数据在内存中的占比（dirty_background_ratio）</p></li><li><p>“脏”数据的绝对的字节数（dirty_background_bytes）</p></li></ul><p><strong>按时间周期刷新</strong>是指根据配置好的时间，周期性刷新数据到硬盘。主要通过脏页存活时间（dirty_expire_seconds) 和刷新周期（dirty_writeback_centisecs）两个参数来配置。</p><p>两个配置默认都是 1&#x2F;100，也就说时间间隔为每秒 100 次，根据刷新周期的配置周期性执行刷新，刷新会检查脏页的存活时间是否超过配置的最大存活时间，如果是则刷入硬盘。</p><p>同时，操作系统也提供了第三种方法<strong>程序手动强制刷新</strong>，你可以通过系统提供的 sync()&#x2F;msync()&#x2F;fsync() 调用来强制刷新缓存。</p><p>消息队列一般会同时提供：是否同步刷盘、刷盘的时间周期、刷盘的空间比例三个配置项，让业务根据需要调整自己的刷新策略。从性能的角度看，异步刷新肯定是性能最高的，同步刷新是可靠性最高的。</p><h2 id="2-随机写和顺序写"><a href="#2-随机写和顺序写" class="headerlink" title="2. 随机写和顺序写"></a>2. 随机写和顺序写</h2><p>首先，随机写和顺序写都是针对硬盘的，是整个操作系统和硬盘的关系，而不是单文件和硬盘的关系。搞清楚这一点，就需要考虑<strong>单文件顺序写入硬盘</strong>和<strong>多文件顺序写入硬盘</strong>，从硬盘角度看，他们都是顺序的吗？</p><p>单文件顺序写入硬盘很简单，硬盘控制器只需在连续的存储区域写入数据，对硬盘来讲，数据就是顺序写入的。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719105647355.png" alt="image-20230719105647355" style="zoom: 80%;" /><p>多文件顺序写入硬盘，系统中有很多文件同时写入，这个时候从硬盘的视角看，你会发现操作系统同时对多个不同的存储区域进行操作，硬盘控制器需要同时控制多个数据的写入，所以从硬盘的角度是随机写的。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719105709022.png" alt="image-20230719105709022"></p><p>所以，在消息队列中，实现随机写和顺序写的核心就是<strong>数据存储结构的设计</strong>。</p><p>在上一篇博客中写过，数据存储结构设计有两个思路：每个 Partition&#x2F;Queue 单独一个存储文件，每台节点上所有 Partition&#x2F;Queue 的数据都存储在同一个文件。</p><p>第一种方案，对单个文件来说读和写都是顺序的，性能最高，但当文件很多且都有读写，在硬盘层面就会退化为随机读写，性能会下降很多。</p><p>第二种方案，因为只有一个文件，不存在文件过多的情况，写入层面一直都会是顺序的，性能一直很高。所以为了提高写的性能，可以采用第二种方案。</p><h1 id="提升写入操作的可靠性"><a href="#提升写入操作的可靠性" class="headerlink" title="提升写入操作的可靠性"></a>提升写入操作的可靠性</h1><p>因为数据是先写入内存，然后刷到磁盘，那么没刷之前就有丢失的风险。</p><p>为了提高数据可靠性，在消息队列的存储模块中，一般会通过三种处理手段：同步刷盘、WAL 预写日志、多副本备份，进一步提升数据的可靠性。</p><h2 id="1-同步刷盘"><a href="#1-同步刷盘" class="headerlink" title="1. 同步刷盘"></a>1. 同步刷盘</h2><p>同步刷盘指每条数据都同步刷盘，等于回到了直接写硬盘的逻辑，一般通过写入数据后调用 force() 操作来完成数据刷盘。这种办法相当于省略了内存那一步，直接写入磁盘，效率比较低。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719110348072.png" alt="image-20230719110348072" style="zoom: 80%;" /><h2 id="2-WAL"><a href="#2-WAL" class="headerlink" title="2. WAL"></a>2. WAL</h2><p>WAL（预写日志）指在写数据之前先写日志，当出现数据丢失时通过日志来恢复数据，避免数据丢失。但是WAL 日志需要写入持久存储，业务数据也要写入缓存，多了一步，性能会不会降低呢？</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719110506254.png" alt="image-20230719110506254" style="zoom:80%;" /><p>从理论来看，WAL 机制肯定会比直接写入缓存中的性能低。但我们实际落地的时候往往可以通过一些手段来优化，降低影响，达到性能要求。</p><p>在消息队列中，消息的量很大，我们不可能采用性能很高的存储设备，但是日志的量比较小，而且可顺序存储。所以<strong>在实际落地中，我们可以采取 WAL 日志盘和实际数据盘分离的策略，提升 WAL 日志的写入速度</strong>。</p><p>具体就是让 WAL 数据盘是高性能、低容量的数据盘，存储消息的数据盘是性能较低、容量较大的数据盘，如果出现数据异常，就通过 WAL 日志进行数据恢复。</p><h2 id="3-多副本的备份"><a href="#3-多副本的备份" class="headerlink" title="3. 多副本的备份"></a>3. 多副本的备份</h2><p>多副本的备份就是将数据拷贝到多台节点，每台节点都写入到内存中，从而完成数据的可靠性存储。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719111128096.png" alt="image-20230719111128096" style="zoom:80%;" /><p>好处是可以在分布式存储的基础上做优化，通过多台缓存的手段来降低数据丢失的概率。但是如果所有节点在同一时刻重启，数据还是有可能丢失的，无法保证百分百的数据高可靠。</p><p>从消息队列业界的存储方案来看，方案一所有产品都会支持，方案二和方案三一般会选一种支持，Kakfa、RabbitMQ、RocketMQ 用的是第三种，Pulsar 用的是第二种。</p><h1 id="提升读取操作的性能"><a href="#提升读取操作的性能" class="headerlink" title="提升读取操作的性能"></a>提升读取操作的性能</h1><p>提高读取的性能主要有读热数据、顺序读、批量读、零拷贝四个思路。</p><h2 id="1-冷读和热读"><a href="#1-冷读和热读" class="headerlink" title="1. 冷读和热读"></a>1. 冷读和热读</h2><p>热读是指消息数据本身还在缓存中，读取数据是从内存中获取，此时性能最高，不需要经过硬盘。冷读是指消息数据刷到硬盘中了，并且数据已经被换页换出缓存了，此时读取数据需要从硬盘读取。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719111256980.png" alt="image-20230719111256980" style="zoom: 80%;" /><p>理想情况，肯定全部是热读最好，因为性能最高。但是在代码层面，我们是无法控制冷读或热读的，只能通过配置更大的内存，尽量保证缓存中保留更多的数据，从而提高热读的概率。</p><h2 id="2-顺序读、随机读、批量读"><a href="#2-顺序读、随机读、批量读" class="headerlink" title="2. 顺序读、随机读、批量读"></a>2. 顺序读、随机读、批量读</h2><p>为了实现大吞吐，在消费的时候服务端都会支持批量读的能力。为了能尽快返回数据给客户端，服务端都会实现数据的预读机制。在读取数据的时候，也读取客户下一步可能会用的数据，预先加载到内存中，以便更快返回数据。</p><p>数据的预读分为两种：硬盘层面预读、应用程序的预读。</p><p>硬盘层面的预读，是在连续的地址空间中读取数据。<strong>但具体实现，我们在程序中无法控制，这和数据目录存储结构设计有关。</strong></p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719111635117.png" alt="image-20230719111635117"></p><p>上图是两种数据存储结构的设计，第一种由于每个分区一个文件，读取一个分区时数据都是连续的，预读很方便，只要在硬盘上读取连续的数据块即可。而第二种设计方案，需要根据分区的索引，在具体存储文件的不同位置进行读取，预读有很大的随机成分，效率不如第一种。</p><h2 id="3-零拷贝原理和使用方式"><a href="#3-零拷贝原理和使用方式" class="headerlink" title="3. 零拷贝原理和使用方式"></a>3. 零拷贝原理和使用方式</h2><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719111938059.png" alt="image-20230719111938059" style="zoom:67%;" /><p>如上图所示，在正常读取数据的过程中，数据要经过五步，硬盘 -&gt; ReadBuffer -&gt; 应用程序 -&gt; SocketBuffer -&gt; 网卡设备，四次复制。因为数据在复制过程耗费资源和时间，会降低性能，所以优化流程最重要的是减少数据复制的次数和资源损耗。</p><p>零拷贝指的是数据在<strong>内核空间</strong>和<strong>用户空间</strong>之间的拷贝次数，即图中的第 2 步和第 3 步。</p><p>如果只有 1 和 4 两步，没有执行 2 和 3 的话，那么内核空间和用户空间之间的拷贝次数就是零，“零拷贝”的零指的是这个次数“零”，因此是零拷贝。</p><p><strong>主要思路是通过减少数据复制次数、减少上下文（内核态和用户态）切换次数、通过 DMA（直接内存）代替 CPU 完成数据读写，来解决复制和资源损耗的问题。</strong></p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719112126032.png" alt="image-20230719112126032" style="zoom:80%;" /><p>红色的线即为零拷贝优化后的结果。</p><p>优化后，数据链路赋值变为了硬盘 -&gt; ReadBuffer -&gt; 网卡设备，从4次变为了2次，而且减少用户态和核心态的切换，并且使用DMA来搬运数据，释放了CPU。</p><p>零拷贝主要用于在消费的时候提升性能，具体有两种实现方式：<strong>mmap+write 和 sendfile</strong>。</p><p>mmap 是一种内存映射文件的方法，把文件或者其他对象映射到进程的地址空间，修改内存文件也会同步修改，这样就减少了一次数据拷贝。所以，我们不需要把数据拷贝到用户空间，修改后再回写到内核空间。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719112520577.png" alt="image-20230719112520577" style="zoom:80%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 正常的“读取数据并发送”流程是通过 read + write 完成的</span><br><span class="line">read(file, tmp_buf, len);</span><br><span class="line">write(socket, tmp_buf, len);</span><br><span class="line"></span><br><span class="line"># 而操作系统层面的 read()，系统在调用的过程中，会把内核缓冲区的数据拷贝到用户的缓冲区里，为了减少这一步开销，我们可以用 mmap() # 替换 read() 系统调用函数。</span><br><span class="line">buf = mmap(file, len);</span><br><span class="line">write(sockfd, buf, len);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Java NIO 包的 FileChannel 的 map 方法</span></span><br><span class="line"><span class="type">FileChannel</span> <span class="variable">fc</span> <span class="operator">=</span> f.getChannel();</span><br><span class="line"><span class="type">MappedByteBuffer</span> <span class="variable">buf</span> <span class="operator">=</span> fc.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure><p>在 Java 中也可以使用零拷贝技术，主要是在 NIO FileChannel 类中。</p><ul><li><p>transferTo() 方法：可以将数据从 FileChannel 直接传输到另外一个 Channel。</p></li><li><p>transferFrom() 方法：可以将数据从 Channel 传输到 FileChannel。</p></li></ul><h1 id="通过硬件和系统优化提升性能"><a href="#通过硬件和系统优化提升性能" class="headerlink" title="通过硬件和系统优化提升性能"></a>通过硬件和系统优化提升性能</h1><p>从硬件和系统优化提升性能的角度，主要可以通过提升硬件配置（如内存或硬盘）、配置多盘读写、配置硬盘阵列三个手段来提高集群的性能。</p><h2 id="1-提升硬件配置"><a href="#1-提升硬件配置" class="headerlink" title="1. 提升硬件配置"></a>1. 提升硬件配置</h2><h2 id="2-配置多盘读写"><a href="#2-配置多盘读写" class="headerlink" title="2. 配置多盘读写"></a>2. 配置多盘读写</h2><p>这种方案要内核支持这个机制，在部署的时候进行相关配置才能生效。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719112927310.png" alt="image-20230719112927310" style="zoom:80%;" /><p>一般实现思路是在消息队列的内核支持多目录读写的能力，将不同的文件或者不同的数据段调度存放在不同硬盘设备对应的挂载目录中。此时在数据的写入和读取的过程中，就可以同时利用到多块盘的吞吐和存储。</p><h2 id="3-配置-RAID-和-LVM-硬盘阵列"><a href="#3-配置-RAID-和-LVM-硬盘阵列" class="headerlink" title="3. 配置 RAID 和 LVM 硬盘阵列"></a>3. 配置 RAID 和 LVM 硬盘阵列</h2><p>多目录读写的问题是多块盘之间无法共享 IO 能力和存储空间，当遇到数据倾斜时，在单机层面会出现性能和容量瓶颈。Linux 提供了 RAID 硬盘阵列和 LVM 逻辑卷管理两种方式，通过串联多块盘的读写能力和容量，提升硬盘的性能和吞吐能力。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230719113032364.png" alt="image-20230719113032364" style="zoom:80%;" /><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入拆解消息队列 47 讲》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;存储模块的优化主要是基于以下四点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存读写的效率高于硬盘读写&lt;/li&gt;
&lt;li&gt;批量读写的效率高于单条读写&lt;/li&gt;
&lt;li&gt;顺序读写的效率高于随机读写&lt;/li&gt;
&lt;li&gt;数据复制次数越多，效率越低&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;提升写入</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="消息队列" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>消息队列存储之功能实现</title>
    <link href="http://example.com/2023/07/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%98%E5%82%A8%E4%B9%8B%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2023/07/18/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%98%E5%82%A8%E4%B9%8B%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-07-18T02:54:50.000Z</published>
    <updated>2023-08-06T03:02:59.678Z</updated>
    
    <content type="html"><![CDATA[<p>存储模块的主流程是数据的写入、存储、读取、过期，因为消息队列本质是做一个缓冲，它的持久化在一定时间或者数据被消费后需要删除。</p><p>消息队列中的数据一般分为<strong>元数据和消息数据</strong>。元数据是指 Topic、Group、User、ACL、Config 等集群维度的资源数据信息，消息数据指客户端写入的用户的业务数据。</p><h1 id="元数据信息的存储"><a href="#元数据信息的存储" class="headerlink" title="元数据信息的存储"></a>元数据信息的存储</h1><p>元数据信息的特点是数据量比较小，不会经常读写，但是需要保证数据的强一致和高可靠，不允许出现数据的丢失。同时，元数据信息一般需要通知到所有的 Broker 节点，Broker 会根据元数据信息执行具体的逻辑。比如创建 Topic 并生成元数据后，就需要通知对应的 Broker 执行创建分区、创建目录等操作。</p><p>所以元数据信息的存储，一般有两个思路：</p><ul><li><p>基于第三方组件来实现元数据的存储。</p></li><li><p>在集群内部实现元数据的存储。</p></li></ul><p><strong>基于第三方组件来实现元数据的存储是目前业界的主流选择。</strong>比如 Kakfa 和 Pulsar 的元数据存储在 ZooKeeper 中，RocketMQ 存储在 NameServer 中。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230718110010031.png" alt="image-20230718110010031"></p><p>优点是集成方便，而且第三方软件已经保证了一致性，高性能等需求，可以降低开发成本。</p><p>但也有缺点。引入第三方组件会增加系统部署和运维的复杂度，而且第三方组件自身的稳定性问题会增加系统风险，第三方组件和多台 Broker 之间可能会出现数据信息不一致的情况，导致读写异常。</p><h1 id="消息数据的存储"><a href="#消息数据的存储" class="headerlink" title="消息数据的存储"></a>消息数据的存储</h1><p>消息队列的存储主要是指消息数据的存储，分为存储结构、数据分段、数据存储格式、数据清理四个部分。</p><h2 id="数据存储结构设计"><a href="#数据存储结构设计" class="headerlink" title="数据存储结构设计"></a>数据存储结构设计</h2><p>在消息队列中，跟存储有关的主要是 Topic 和分区两个维度。用户可以将数据写入 Topic 或直接写入到分区。</p><p>如果写入 Topic，数据也是分发到多个分区去存储的。所以从实际数据存储的角度来看，<strong>Topic 和 Group 不承担数据存储功能，承担的是逻辑组织的功能，实际的数据存储是在在分区维度完成的</strong>。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230718110640501.png" alt="image-20230718110640501"></p><p>而数据的罗盘也有两种思路：</p><ol><li>每个分区单独一个存储“文件”。</li><li>每个节点上所有分区的数据都存储在同一个“文件”。</li></ol><p>这里的“文件”是一个虚指，即表示所有分区的数据是存储在一起，还是每个分区的数据分开存储的意思。</p><h3 id="第一种思路"><a href="#第一种思路" class="headerlink" title="第一种思路"></a>第一种思路</h3><p>每个分区的数据对应一个文件去存储，在实现上每个分区的数据是顺序写入到同一个磁盘文件中，数据是连续的，所以读写性能上效率最高。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230718112210221.png" alt="image-20230718112210221"></p><p>但如果分区太多，会占用太多的系统 FD 资源，极端情况下有可能把节点的 FD 资源耗完，并且硬盘层面会出现大量的随机写情况，导致写入的性能下降很多，另外管理起来也相对复杂。（fd是是<strong>内核为了高效管理这些已经被打开的文件所创建的一种索引</strong>，如果太多分区，相当于很多个文件在同时读写，虽然每个分区内文件是顺序读写的，但是分区之间并不是顺序，而是随机的，所以会导致磁盘层面大量的随机读写）</p><p>具体的磁盘组织结构：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230718111845083.png" alt="image-20230718111845083"></p><h3 id="第二种思路"><a href="#第二种思路" class="headerlink" title="第二种思路"></a>第二种思路</h3><p>每个节点上所有分区的数据都存储在同一个文件中，这种方案需要为每个分区维护一个对应的索引文件，索引文件里会记录每条消息在 File 里面的位置信息，以便快速定位到具体的消息内容。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230718112137877.png" alt="image-20230718112137877"></p><p>因为<strong>所有文件都在一份文件上，管理简单，也不会占用过多的系统 FD 资源，单机上的数据写入都是顺序的，写入的性能会很高</strong>。</p><p>缺点是同一个分区的数据一般会在文件中的不同位置，或者不同的文件段中，无法利用到顺序读的优势，读取的性能会受到影响。</p><h2 id="消息数据的分段实现"><a href="#消息数据的分段实现" class="headerlink" title="消息数据的分段实现"></a>消息数据的分段实现</h2><p>数据分段的规则一般是根据大小来进行的，比如默认 1G 一个文件，同时会支持配置项调整分段数据的大小。从技术上来看，当数据段到达了规定的大小后，就会新创建一个新文件来保存数据。</p><p>如果进行了分段，消息数据可能分布在不同的文件中。所以我们在读取数据的时候，需要先定位消息数据在哪个文件中。为了满足这个需求，技术上一般有根据<strong>偏移量定位</strong>或根据<strong>索引定位</strong>两种思路。</p><h3 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h3><p>根据偏移量（Offset）来定位消息在哪个分段文件中，是指通过记录每个数据段文件的起始偏移量、中止偏移量、消息的偏移量信息，来快速定位消息在哪个文件。</p><p>当消息数据存储时，通常会用一个自增的数值型数据（比如 Long）来表示这条数据在分区或 commitlog 中的位置，这个值就是消息的偏移量。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230718112847872.png" alt="image-20230718112847872" style="zoom:80%;" /><p>在实际的编码过程中，记录文件的起始偏移量一般有两种思路：单独记录每个数据段的起始和结束偏移量，在文件名称中携带起始偏移量信息。因为数据是顺序存储的，每个文件记录了本文件的起始偏移量，那么下一个文件的起始偏移量就是上一个文件的结束偏移量。</p><h3 id="索引定位"><a href="#索引定位" class="headerlink" title="索引定位"></a>索引定位</h3><p>如果用索引定位，会直接存储消息对应的文件信息，而不是通过偏移量来定位到具体文件。</p><p>具体是通过维护一个单独的索引文件，记录消息在哪个文件和文件的哪个位置。读取消息的时候，先根据消息 ID 找到存储的信息，然后找到对应的文件和位置，读取数据。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><strong>这两种方案所面临的场景不一样。</strong></p><p>根据偏移量定位数据，通常用在每个分区各自存储一份文件的场景；根据索引定位数据，通常用在所有分区的数据存储在同一份文件的场景。</p><p>因为在前一种场景，每一份数据都属于同一个分区，那么通过位点来二分查找数据的效率是最高的。</p><p>第二种场景，这一份数据属于多个不同分区，则通过二分查找来查找数据效率很低，用哈希查找效率是最高的。</p><h2 id="消息数据存储格式"><a href="#消息数据存储格式" class="headerlink" title="消息数据存储格式"></a>消息数据存储格式</h2><p>消息数据存储格式一般包含消息写入文件的格式和消息内容的格式两个方面。</p><p><strong>消息写入文件的格式指消息是以什么格式写入到文件中的</strong>，比如 JSON 字符串或二进制。从性能和空间冗余的角度来看，消息队列中的数据基本都是以二进制的格式写入到文件的。</p><p><strong>消息内容的格式是指写入到文件中的数据都包含哪些信息。</strong>对于一个成熟的消息队列来说，消息内容格式不仅关系功能维度的扩展，还牵涉性能维度的优化。</p><h2 id="消息数据清理机制"><a href="#消息数据清理机制" class="headerlink" title="消息数据清理机制"></a>消息数据清理机制</h2><p>消息队列的数据过期机制一般有手动删除和自动删除两种形式，从实现上看主要有三种思路。</p><ul><li>消费完成执行 ACK 删除数据</li><li>根据时间和保留大小删除</li><li>ACK 机制和过期机制相结合</li></ul><h3 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h3><p><strong>消费完成执行 ACK 删除数据，技术上的实现思路一般是</strong>：当客户端成功消费数据后，回调服务端的 ACK 接口，告诉服务端数据已经消费成功，服务端就会标记删除该行数据，以确保消息不会被重复消费。ACK 的请求一般会有单条消息 ACK 和批量消息 ACK 两种形式。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230718113808956.png" alt="image-20230718113808956" style="zoom: 80%;" /><p>因为消息队列的 ACK 一般是顺序的，如果前一条消息无法被正确处理并 ACK，就无法消费下一条数据，导致消费卡住。此时就需要死信队列的功能，把这条数据先写入到死信队列，等待后续的处理。然后 ACK 这条消息，确保消费正确进行。</p><p>这个方案，优点是不会出现重复消费，一条消息只会被消费一次。缺点是 ACK 成功后消息被删除，无法满足需要消息重放的场景。</p><h3 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h3><p><strong>根据时间和保留大小删除指消息在被消费后不会被删除，只会通过提交消费位点的形式标记消费进度。</strong></p><p>实现思路一般是服务端提供偏移量提交的接口，当客户端消费成功数据后，客户端会回调偏移量提交接口，告诉服务端这个偏移量的数据已经消费成功了，让服务端把偏移量记录起来。然后服务端会根据消息保留的策略，比如保留时间或保留大小来清理数据。一般通过一个常驻的异步线程来清理数据。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230718114135696.png" alt="image-20230718114135696" style="zoom:67%;" /><p>这个方案，一条消息可以重复消费多次。不管有没有被成功消费，消息都会根据配置的时间规则或大小规则进行删除。优点是消息可以多次重放，适用于需要多次进行重放的场景。缺点是在某些情况下（比如客户端使用不当）会出现大量的重复消费。</p><h3 id="方案3"><a href="#方案3" class="headerlink" title="方案3"></a>方案3</h3><p>我们结合前两个方案，就有了 <strong>ACK 机制和过期机制相结合的方案</strong>。实现核心逻辑跟方案二很像，但保留了 ACK 的概念，不过 ACK 是相对于 Group 概念的。</p><p>当消息完成后，在 Group 维度 ACK 消息，此时消息不会被删除，只是这个 Group 也不会再重复消费到这个消息，而新的 Group 可以重新消费订阅这些数据。所以在 Group 维度避免了重复消费的情况，也可以允许重复订阅。（说白了，一条消息在一个Group消费后会发送一个ACK确认，然后此Group就不会再消费该消息了，但是其他的Group还是可以重复的消费该消息，如果超过时间，则该消息被删除，其他Group也无法订阅）</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230718114619550.png" alt="image-20230718114619550" style="zoom:67%;" /><p>我们知道消息数据是顺序存储在文件中的，会有很多分段数据，一个文件可能会有很多行数据。</p><p>那么在 ACK 或者数据删除的时候，一个文件中可能既存在可删除数据，也存在不可删除数据。</p><p>如果我们每次都立即删除数据，需要不断执行“读取文件、找到记录、删除记录、写入文件”的过程，即使批量操作，降低频率，还是得不断地重复这个过程，会导致性能明显下降。</p><p>当前主流的思路都是<strong>延时删除，以段数据为单位清理</strong>，降低频繁修改文件内容和频繁随机读写文件的操作。</p><p>只有该段里面的数据都允许删除后，才会把数据删除。而删除该段数据中的某条数据时，会先对数据进行标记删除，比如在内存或 Backlog 文件中记录待删除数据，然后在消费的时候感知这个标记，这样就不会重复消费这些数据。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/1090617-20190626173042073-147043337.jpg" alt="img"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入拆解消息队列 47 讲》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;存储模块的主流程是数据的写入、存储、读取、过期，因为消息队列本质是做一个缓冲，它的持久化在一定时间或者数据被消费后需要删除。&lt;/p&gt;
&lt;p&gt;消息队列中的数据一般分为&lt;strong&gt;元数据和消息数据&lt;/strong&gt;。元数据是指 Topic、Group、User、ACL、Co</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="消息队列" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>消息队列中如何设计高性能的网络模块</title>
    <link href="http://example.com/2023/07/17/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97/"/>
    <id>http://example.com/2023/07/17/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97/</id>
    <published>2023-07-17T12:52:46.000Z</published>
    <updated>2023-07-18T02:55:26.023Z</updated>
    
    <content type="html"><![CDATA[<p>消息队列是需要满足高吞吐、高可靠、低延时，并支持多语言访问的基础软件，网络模块最需要解决的是<strong>性能</strong>、<strong>稳定性、开发成本</strong>三个问题。</p><h1 id="网络模块的性能瓶颈分析"><a href="#网络模块的性能瓶颈分析" class="headerlink" title="网络模块的性能瓶颈分析"></a>网络模块的性能瓶颈分析</h1><p>消息队列的访问链路图如下：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717205443205.png" alt="image-20230717205443205" style="zoom: 80%;" /><p>对于<strong>单个请求</strong>来说，请求流程是：客户端构建请求，发送给服务端，服务端收到后交由业务线程处理，业务线程处理完后返回给客户端。</p><p>该流程性能消耗有三个点：</p><ul><li><strong>编解码的速度</strong>。即序列化与反序列化的速度。</li><li><strong>网络延迟</strong>。这点几乎无法优化，与网络传输有关。</li><li><strong>服务端 &#x2F; 客户端网络模块的处理速度</strong>。发送 &#x2F; 接收请求包后，包是否能及时被处理。</li></ul><p>对于<strong>并发请求</strong>来说，在单个请求维度的问题的基础上，还需要处理高并发、高 QPS、高流量等场景带来的性能问题。主要包含三个方面。</p><ul><li><strong>高效的连接管理</strong>：当客户端和服务端之间的 TCP 连接数很多，如何高效处理、管理连接。</li><li><strong>快速处理高并发请求</strong>：当客户端和服务端之间的 QPS 很高，如何快速处理（接收、返回）请求。</li><li><strong>大流量场景</strong>：当客户端和服务端之间的流量很高，如何快速吞吐（读、写）数据。</li></ul><p>大流量场景分为两类，单个请求包大，但是并发小，单个请求包小，但是并发大。</p><p>第一种的瓶颈主要在于数据拷贝、垃圾回收、CPU 占用等方面，主要依赖语言层面的编码技巧来解决。</p><p>我们这里主要看第二种。</p><h1 id="高性能网络模块的设计实现"><a href="#高性能网络模块的设计实现" class="headerlink" title="高性能网络模块的设计实现"></a>高性能网络模块的设计实现</h1><p>从技术上来看，高性能网络模块的设计可以分为如何<strong>高效管理大量的 TCP 连接</strong>、如何<strong>快速处理高并发的请求</strong>、如何<strong>提高稳定性和降低开发成本</strong>等三个方面。</p><h2 id="基于多路复用技术管理-TCP-连接"><a href="#基于多路复用技术管理-TCP-连接" class="headerlink" title="基于多路复用技术管理 TCP 连接"></a>基于多路复用技术管理 TCP 连接</h2><p>从技术原理来看，高效处理大量 TCP 连接，在消息队列中主要有<strong>单条 TCP 连接的复用</strong>和<strong>多路复用</strong>两种技术思路。</p><h3 id="1-单条-TCP-连接的复用"><a href="#1-单条-TCP-连接的复用" class="headerlink" title="1. 单条 TCP 连接的复用"></a>1. 单条 TCP 连接的复用</h3><p>如下图，在一条真实的 TCP 连接中，创建信道（channel，可以理解为虚拟连接）的概念。通过编程手段，我们把信道当做一条 TCP 连接使用，做到 TCP 连接的复用，避免创建大量 TCP 连接导致系统资源消耗过多。</p><p>缺点是在协议设计和编码实现的时候有额外开发工作量，而且近年随着异步 IO、IO 多路复用技术的发展，这种方案有点多余。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717210315458.png" alt="image-20230717210315458" style="zoom:67%;" /><h3 id="2-IO-多路复用技术"><a href="#2-IO-多路复用技术" class="headerlink" title="2. IO 多路复用技术"></a>2. IO 多路复用技术</h3><p>IO 多路复用技术，是指通过把多个 IO 的阻塞复用到同一个 selector 的阻塞上，让系统在单线程的情况下可以同时处理多个客户端请求。最大的优势是系统开销小，系统不需要创建额外的进程或者线程，降低了维护的工作量，也节省了资源。</p><p>目前支持 IO 多路复用的系统调用有 Select、Poll、Epoll 等，Java NIO 库底层就是基于 Epoll 机制实现的。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717210436640.png" alt="image-20230717210436640" style="zoom:80%;" /><p>即使用了这两种技术，<strong>单机能处理的连接数还是有上限的</strong>。</p><p>第一个上限是操作系统的 FD 上限，如果连接数超过了 FD 的数量，连接会创建失败。</p><p>第二个限制是系统资源的限制，主要是 CPU 和内存。频繁创建、删除或者创建过多连接会消耗大量的物理资源，导致系统负载过高。</p><h2 id="基于-Reactor-模型处理高并发请求"><a href="#基于-Reactor-模型处理高并发请求" class="headerlink" title="基于 Reactor 模型处理高并发请求"></a>基于 Reactor 模型处理高并发请求</h2><p><strong>对于单个请求来说</strong>，最快的处理方式就是客户端直接发出请求，服务端接收到包后，直接丢给后面的业务线程处理，当业务线程处理成功后，直接返回给客户端。但存在以下两个问题：</p><ul><li><p>如何第一时间拿到包交给后端的业务逻辑处理？</p></li><li><p>当业务逻辑处理完成后，如何立即拿到返回值返回给客户端？</p></li></ul><p>最直观的思路是阻塞等待模型，不断轮询等待请求拿到包，业务逻辑处理完后返回给客户端。但是阻塞等待模型是穿行机制，下一个请求需要等到上一个请求处理完才能处理，效率低。</p><p>所以，单个请求，最合理的方式就是<strong>异步的事件驱动模型</strong>，可以通过 Epoll 和异步编程来解决。</p><p><strong>在高并发的情况下</strong>会有很多连接、请求需要处理，核心思路就是并行、多线程处理，需要用到Reactor模型。</p><p>Reactor 模型是一种处理并发服务请求的事件设计模式，当主流程收到请求后，通过多路分离处理的方式，把请求分发给相应的请求处理器处理。</p><p>如下图所示，Reactor 模式包含 Reactor、Acceptor、Handler 三个角色。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717211239869.png" alt="image-20230717211239869" style="zoom: 80%;" /><ul><li>Reactor：负责监听和分配事件。收到事件后分派给对应的 Handler 处理，事件包括连接建立就绪、读就绪、写就绪等。</li><li>Acceptor：负责处理客户端新连接。Reactor 接收到客户端的连接事件后，会转发给 Acceptor，Acceptor 接收客户端的连接，然后创建对应的 Handler，并向 Reactor 注册此 Handler。</li><li>Handler：请求处理器，负责业务逻辑的处理，即业务处理线程。</li></ul><p><strong>从技术上看，Reactor 模型一般有三种实现模式。</strong></p><ul><li>单 Reactor 单线程模型（单 Reactor 单线程）</li><li>单 Reactor 多线程模型 （单 Reactor 多线程）</li><li>主从 Reactor 多线程模型 (多 Reactor 多线程)</li></ul><h3 id="1、单-Reactor-单线程模型"><a href="#1、单-Reactor-单线程模型" class="headerlink" title="1、单 Reactor 单线程模型"></a>1、单 Reactor 单线程模型</h3><p>特点是 Reactor 和 Handler 都是单线程的串行处理。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717212026725.png" alt="image-20230717212026725" style="zoom:80%;" /><p>优点是所有处理逻辑放在单线程中实现，没有上下文切换、线程竞争、进程通信等问题。缺点是在性能与可靠性方面存在比较严重的问题。</p><p>性能上，因为是单线程处理，无法充分利用 CPU 资源，并且业务逻辑 Handler 的处理是同步的，容易造成阻塞，出现性能瓶颈。<strong>所以单</strong> <strong>Reactor</strong> <strong>单进程模型不适用于计算密集型的场景，只适用于业务处理非常快速的场景</strong>。</p><h3 id="2、单-Reactor-多线程模型"><a href="#2、单-Reactor-多线程模型" class="headerlink" title="2、单 Reactor 多线程模型"></a>2、单 Reactor 多线程模型</h3><p>业务逻辑处理 Handler 变成了多线程，也就是说，获取到 IO 读写事件之后，业务逻辑是一批线程在处理。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717212143234.png" alt="image-20230717212143234"></p><p>优点是 Handler 收到响应后通过 send 把响应结果返回给客户端，降低 Reactor 的性能开销，提升整个应用的吞吐。而且 Handler 使用多线程模式，可以充分利用 CPU 的性能，提高了业务逻辑的处理速度。</p><p>缺点是 Handler 使用多线程模式，带来了多线程竞争资源的开销，同时涉及共享数据的互斥和保护机制，实现比较复杂。另外，单个 Reactor 承担所有事件的监听、分发和响应，对于高并发场景，容易造成性能瓶颈。</p><h3 id="3、主从-Reactor-多线程模型"><a href="#3、主从-Reactor-多线程模型" class="headerlink" title="3、主从 Reactor 多线程模型"></a>3、主从 Reactor 多线程模型</h3><p>该模型让 Reactor 也变为了多线程。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717212515159.png" alt="image-20230717212515159"  /><p>这种方案，优点是 Reactor 的主线程和子线程分工明确，主线程只负责接收新连接，子线程负责完成后续的业务处理。主线程接收到主线程的连接后，只需要交由后续业务处理即可，不需要关注主线程，可以直接在子线程把处理结果返回给客户端。</p><p>缺点是Acceptor 是一个单线程，如果挂了，如何处理客户端新连接是一个风险点。</p><p>优化后，将Acceptor改为多线程</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717212849187.png" alt="image-20230717212849187"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入拆解消息队列 47 讲》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;消息队列是需要满足高吞吐、高可靠、低延时，并支持多语言访问的基础软件，网络模块最需要解决的是&lt;strong&gt;性能&lt;/strong&gt;、&lt;strong&gt;稳定性、开发成本&lt;/strong&gt;三个问题。&lt;/p&gt;
&lt;h1 id=&quot;网络模块的性能瓶颈分析&quot;&gt;&lt;a href=&quot;#网络模块的</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="消息队列" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>主流消息队列的网络模型</title>
    <link href="http://example.com/2023/07/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E4%B8%BB%E6%B5%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2023/07/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E4%B8%BB%E6%B5%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</id>
    <published>2023-07-16T13:35:28.000Z</published>
    <updated>2023-07-18T02:55:16.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kafka-网络模型"><a href="#Kafka-网络模型" class="headerlink" title="Kafka 网络模型"></a>Kafka 网络模型</h1><p>Kafka 的网络层没有用 Netty 作为底层的通信库，而是直接采用 Java NIO 实现网络通信。在网络模型中，也是参照 Reactor 多线程模型，采用多线程、多 Selector 的设计。</p><p>Processor 线程和 Handler 线程之间通过 RequestChannel 传递数据，RequestChannel 中包含一个 RequestQueue 队列和多个 ResponseQueues 队列。每个 Processor 线程对应一个 ResponseQueue。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717213627999.png" alt="image-20230717213627999"></p><p>具体流程上：</p><ul><li><p>一个 Acceptor 接收客户端建立连接的请求，创建 Socket 连接并分配给 Processor 处理。</p></li><li><p>Processor 线程把读取到的请求存入 RequestQueue 中，Handler 线程从 RequestQueue 队列中取出请求进行处理。</p></li><li><p>Handler 线程处理请求产生的响应，会存放到 Processor 对应的 ResponseQueue 中，Processor 线程从其对应的 ResponseQueue 中取出响应信息，并返回给客户端。</p></li></ul><h1 id="RocketMQ-网络模型"><a href="#RocketMQ-网络模型" class="headerlink" title="RocketMQ 网络模型"></a>RocketMQ 网络模型</h1><p>RocketMQ 采用 Netty 组件作为底层通信库，遵循 Reactor 多线程模型，同时又在 Reactor 模型上做了一些扩展和优化。</p><p>所以它的网络模型是 Netty 的网络模型，Netty 底层采用的是主从 Reactor 多线程模型，模型的原理逻辑跟前面讲到的主从 Reactor 多线程模型是一样的。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717213829623.png" alt="image-20230717213829623"></p><p>具体流程上：</p><ul><li><p>一个 Reactor 主线程负责监听 TCP 网络连接请求，建立好连接，创建 SocketChannel，并注册到 Selector 上。RocketMQ 的源码中会自动根据 OS 的类型选择 NIO 和 Epoll，也可以通过参数配置，监听真正的网络数据。</p></li><li><p>接收到网络数据后，会把数据传递给 Reactor 线程池处理。</p></li><li><p>真正执行业务逻辑之前，会进行 SSL 验证、编解码、空闲检查、网络连接管理，这些工作在 Worker 线程池处理（defaultEventExecutorGroup）。</p></li><li><p>处理业务操作，放在业务 Processor 线程池中执行。</p></li></ul><h1 id="NIO-编程和-RPC-框架"><a href="#NIO-编程和-RPC-框架" class="headerlink" title="NIO 编程和 RPC 框架"></a>NIO 编程和 RPC 框架</h1><p>因为 RPC 调用的是一个远端对象，调用者和被调用者处于不同的节点上，想完成调用，必须实现 4 个能力。</p><ul><li><p><strong>网络传输协议</strong>：远端调用底层需要经过网络传输，所以需要选择网络通信协议，比如 TCP。</p></li><li><p><strong>应用通信协议</strong>：网络传输需要设计好应用层的通信协议，比如 HTTP2 或自定义协议。</p></li><li><p><strong>服务发现</strong>：调用的是远端对象，需要可以定位到调用的服务器地址以及调用的具体方法。</p></li><li><p><strong>序列化和反序列化：</strong>网络传输的是二进制数据，因此 RPC 框架需要自带序列化和反序列化的能力。</p></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入拆解消息队列 47 讲》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Kafka-网络模型&quot;&gt;&lt;a href=&quot;#Kafka-网络模型&quot; class=&quot;headerlink&quot; title=&quot;Kafka 网络模型&quot;&gt;&lt;/a&gt;Kafka 网络模型&lt;/h1&gt;&lt;p&gt;Kafka 的网络层没有用 Netty 作为底层的通信库，而是直接采用 Ja</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="消息队列" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>并发场景下的幂等问题--分布式锁详解</title>
    <link href="http://example.com/2023/07/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%B9%82%E7%AD%89%E9%97%AE%E9%A2%98-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/07/14/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%B9%82%E7%AD%89%E9%97%AE%E9%A2%98-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-07-14T02:38:21.000Z</published>
    <updated>2023-07-14T03:23:01.689Z</updated>
    
    <content type="html"><![CDATA[<p>业务流程：</p><p>1）用户选择实人认证后会在服务端初始化一条记录；<br>2）用户在钉钉移动端按照指示完成人脸比对；<br>3）比对完成后访问服务端修改数据库状态。</p><p>问题现象：数据库一个人有两条认证记录。</p><p>原因：并发导致了不幂等。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/640" alt="图片"></p><p>如果依赖的组件天然幂等，比如说数据库唯一键的约束，那么不需要做太多的处理，否则，可以采用以下方法来保证幂等。</p><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>如何实现一个分布式锁？</p><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>分布式系统中常见有两个问题：</p><p>1）单点故障问题，即当持有锁的应用发生单点故障时，锁将被长期无效占有；</p><p>2）网络超时问题，即当客户端发生网络超时但实际上锁成功时，我们无法再次正确的获取锁。</p><p>要解决问题1，一个简单的方案是引入过期时间（lease time），对锁的持有将是有时效的，当应用发生单点故障时，被其持有的锁可以自动释放。</p><p>要解决问题2，一个简单的方案是支持可重入，我们为每个获取锁的客户端都配置一个不会重复的身份标识（通常是UUID），上锁成功后锁将带有该客户端的身份标识。当实际上锁成功而客户端超时重试时，我们可以判断锁已被该客户端持有而返回成功。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MdbDistributeLock</span> <span class="keyword">implements</span> <span class="title class_">DistributeLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的命名空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> namespace;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁对应的缓存key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lockName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的唯一标识，保证可重入，以应对put成功，但是返回超时的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lockId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否持有锁。true：是</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> locked;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TairManager tairManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MdbDistributeLock</span><span class="params">(TairManager tairManager, <span class="type">int</span> namespace, String lockCacheKey)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.tairManager = tairManager;</span><br><span class="line">        <span class="built_in">this</span>.namespace = namespace;</span><br><span class="line">        <span class="built_in">this</span>.lockName = lockCacheKey;</span><br><span class="line">        <span class="built_in">this</span>.lockId = UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取锁状态</span></span><br><span class="line">            Result&lt;DataEntry&gt; getResult = <span class="literal">null</span>;</span><br><span class="line">            <span class="type">ResultCode</span> <span class="variable">getResultCode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>; cnt &lt; DEFAULT_RETRY_TIMES; cnt++) &#123;</span><br><span class="line">                getResult = tairManager.get(namespace, lockName);</span><br><span class="line">                getResultCode = getResult == <span class="literal">null</span> ? <span class="literal">null</span> : getResult.getRc();</span><br><span class="line">                <span class="keyword">if</span> (noNeedRetry(getResultCode)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重入，已持有锁，返回成功</span></span><br><span class="line">            <span class="keyword">if</span> (ResultCode.SUCCESS.equals(getResultCode)</span><br><span class="line">                &amp;&amp; getResult.getValue() != <span class="literal">null</span> &amp;&amp; lockId.equals(getResult.getValue().getValue())) &#123;</span><br><span class="line">                locked = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不可获取锁，返回失败</span></span><br><span class="line">            <span class="keyword">if</span> (!ResultCode.DATANOTEXSITS.equals(getResultCode)) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;tryLock fail code=&#123;&#125; lock=&#123;&#125; traceId=&#123;&#125;&quot;</span>, getResultCode, <span class="built_in">this</span>, EagleEye.getTraceId());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//尝试获取锁</span></span><br><span class="line">            <span class="type">ResultCode</span> <span class="variable">putResultCode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>; cnt &lt; DEFAULT_RETRY_TIMES; cnt++) &#123;</span><br><span class="line">                putResultCode = tairManager.put(namespace, lockName, lockId, MDB_CACHE_VERSION,</span><br><span class="line">                    DEFAULT_EXPIRE_TIME_SEC);</span><br><span class="line">                <span class="keyword">if</span> (noNeedRetry(putResultCode)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!ResultCode.SUCCESS.equals(putResultCode)) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;tryLock fail code=&#123;&#125; lock=&#123;&#125; traceId=&#123;&#125;&quot;</span>, getResultCode, <span class="built_in">this</span>, EagleEye.getTraceId());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            locked = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;DistributedLock.tryLock fail lock=&#123;&#125;&quot;</span>, <span class="built_in">this</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!locked) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ResultCode</span> <span class="variable">resultCode</span> <span class="operator">=</span> tairManager.invalid(namespace, lockName);</span><br><span class="line">        <span class="keyword">if</span> (!resultCode.isSuccess()) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;DistributedLock.unlock fail lock=&#123;&#125; resultCode=&#123;&#125; traceId=&#123;&#125;&quot;</span>, <span class="built_in">this</span>, resultCode,</span><br><span class="line">                EagleEye.getTraceId());</span><br><span class="line">        &#125;</span><br><span class="line">        locked = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否需要重试</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultCode 缓存的返回码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true：不用重试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">noNeedRetry</span><span class="params">(ResultCode resultCode)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> resultCode != <span class="literal">null</span> &amp;&amp; !ResultCode.CONNERROR.equals(resultCode) &amp;&amp; !ResultCode.TIMEOUT.equals(</span><br><span class="line">            resultCode) &amp;&amp; !ResultCode.UNKNOW.equals(resultCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分布式锁工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MdbDistributeLockFactory</span> <span class="keyword">implements</span> <span class="title class_">DistributeLockFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存的命名空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> namespace;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> MultiClusterTairManager mtairManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DistributeLock <span class="title function_">getLock</span><span class="params">(String lockName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MdbDistributeLock</span>(mtairManager, namespace, lockName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分布式锁的一般使用方式如下：</p><ul><li>初始化分布式锁的工厂</li><li>利用工厂生成一个分布式锁实例</li><li>使用该分布式实例上锁和解锁操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTryLock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化工厂</span></span><br><span class="line">    <span class="type">MdbDistributeLockFactory</span> <span class="variable">mdbDistributeLockFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MdbDistributeLockFactory</span>();</span><br><span class="line">    mdbDistributeLockFactory.setNamespace(<span class="number">603</span>);</span><br><span class="line">    mdbDistributeLockFactory.setMtairManager(<span class="keyword">new</span> <span class="title class_">MultiClusterTairManager</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得锁</span></span><br><span class="line">    <span class="type">DistributeLock</span> <span class="variable">lock</span> <span class="operator">=</span> mdbDistributeLockFactory.getLock(<span class="string">&quot;TestLock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上锁解锁操作</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="keyword">if</span> (!locked) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do something </span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样实现简单，但是也存在问题：释放锁的时候只是简单的将缓存中的key失效，所以存在错误释放他人已持有锁问题。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKg8iaeq9DENh4Ow1NmjvfqmapX7ERkKOhIS0Rz8ibzwVWxH4j8tJ7gGkytBrhvEW3Vns3hPfviboWwg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>设想一种情况，当占有锁的Client 1在释放锁之前，锁就已经到期了，Client 2将获取锁，此时锁被Client 2持有，但是Client 1可能会错误的将其释放。只要锁的租期设置的足够长，该问题出现几率就足够小。</p><p>一个更优秀的方案，我们给每个锁都设置一个身份标识，在释放锁的时候，1）首先查询锁是否是自己的，2）如果是自己的则释放锁。</p><p>受限于实现方式，步骤1和步骤2不是原子操作，在步骤1和步骤2之间，如果锁到期被其他客户端获取，此时也会错误的释放他人的锁。</p><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>借助Redis的Lua脚本，可以完美的解决存在错误释放他人已持有锁问题的。</p><p>当我们想要获取锁时，我们可以执行如下方法：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET resource_name my_random_value NX PX <span class="number">30000</span></span><br></pre></td></tr></table></figure><p>当我们想要释放锁时，我们可以执行如下的Lua脚本</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h2><p>在方案一和方案二的讨论过程中，有一个问题被我们反复提及：锁的自动释放。</p><p>他的好处以及坏处如下：</p><p>1）一方面它很好的解决了持有锁的客户端单点故障的问题</p><p>2）另一方面，如果锁提前释放，就会出现锁的错误持有状态</p><p>这个时候，我们可以引入Watch Dog自动续租机制，参考以下Redisson是如何实现的。</p><p>在上锁成功后，Redisson会调用renewExpiration()方法开启一个Watch Dog线程，为锁自动续期。每过1&#x2F;3时间续一次，成功则继续下一次续期，失败取消续期操作。</p><p>以下是Redisson的续期操作，Redisson也是使用Lua脚本进行锁续租的：1）判断锁是否存在；2）如果存在则重置过期时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager().newTimeout(timeout -&gt; &#123;</span><br><span class="line">        <span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">        <span class="keyword">if</span> (ent == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">        <span class="keyword">if</span> (threadId == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">        future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getRawName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                EXPIRATION_RENEWAL_MAP.remove(getEntryName());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                <span class="comment">// reschedule itself</span></span><br><span class="line">                renewExpiration();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cancelExpirationRenewal(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title function_">renewExpirationAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">                          <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;return 0;&quot;</span>,</span><br><span class="line">                          Collections.singletonList(getRawName()),</span><br><span class="line">                          internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h2><p>借助Redisson的自动续期机制，我们无需再担心锁的自动释放。但是讨论到这里，我还是不得不面对一个问题：分布式锁本身不是一个分布式应用。当Redis服务器故障无法正常工作时，整个分布式锁也就无法提供服务。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《阿里博客》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;业务流程：&lt;/p&gt;
&lt;p&gt;1）用户选择实人认证后会在服务端初始化一条记录；&lt;br&gt;2）用户在钉钉移动端按照指示完成人脸比对；&lt;br&gt;3）比对完成后访问服务端修改数据库状态。&lt;/p&gt;
&lt;p&gt;问题现象：数据库一个人有两条认证记录。&lt;/p&gt;
&lt;p&gt;原因：并发导致了不幂等。&lt;/p&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>并发编程实践之公平有界阻塞队列实现（下）</title>
    <link href="http://example.com/2023/07/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%85%AC%E5%B9%B3%E6%9C%89%E7%95%8C%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://example.com/2023/07/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%85%AC%E5%B9%B3%E6%9C%89%E7%95%8C%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2023-07-13T02:54:58.000Z</published>
    <updated>2023-07-13T03:30:41.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4、状态追踪解除竞争"><a href="#4、状态追踪解除竞争" class="headerlink" title="4、状态追踪解除竞争"></a>4、状态追踪解除竞争</h1><p>此处可以通过状态追踪，解除读与读之间和写与写之间的竞争问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FairnessBoundedBlockingQueue</span> <span class="keyword">implements</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头指针，empty: head.next == tail == null</span></span><br><span class="line">    <span class="keyword">protected</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾指针</span></span><br><span class="line">    <span class="keyword">protected</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canPollCount, head</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">pollLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canPollCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> waitPollCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canOfferCount, tail</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">offerLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canOfferCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> waitOfferCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FairnessBoundedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.canPollCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.canOfferCount = capacity;</span><br><span class="line">        <span class="built_in">this</span>.waitPollCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.waitOfferCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，通过返回值标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            <span class="keyword">while</span>(canOfferCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                waitOfferCount++;</span><br><span class="line">                offerLock.wait();</span><br><span class="line">                waitOfferCount--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(obj);</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            canOfferCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            ++canPollCount;</span><br><span class="line">            <span class="keyword">if</span> (waitPollCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pollLock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，阻塞等待</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            <span class="keyword">while</span>(canPollCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                waitPollCount++;</span><br><span class="line">                pollLock.wait();</span><br><span class="line">                waitPollCount--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = head.next.value;</span><br><span class="line">            head.next.value = <span class="literal">null</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            canPollCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            canOfferCount++;</span><br><span class="line">            <span class="keyword">if</span> (waitOfferCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                offerLock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        Node next;</span><br><span class="line">        Node(Object obj) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = obj;</span><br><span class="line">            next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上</p><ol><li>通过 waitOfferCount 和 waitPollCount 的状态追踪解决 读写内部的竞争问题；</li><li>当队列变更时，根据追踪的状态，决定是否派发消息，触发线程阻塞状态解除；</li></ol><p>但，上述的实现在某些场景下会运行失败，面临活性问题，考虑</p><p>情况一：</p><ol><li>初始状态队列为空 线程 A 执行出队动作，被阻塞在 pollLock , 此时 waitPollCount&#x3D;&#x3D;1；</li><li>此时线程 A 在执行 wait 时被中断，抛出异常， waitPollCount&#x3D;&#x3D;1 并未被重置；</li><li>阻塞队列为空，但 waitPollCount&#x3D;&#x3D;1 类状态异常；</li></ol><p>情况二：</p><ol><li>初始状态队列为空 线程 A B 执行出队动作，被阻塞在 pollLock , 此时 waitPollCount&#x3D;&#x3D;2；</li><li>线程 C 执行入队动作，可以立即执行，执行完成后，触发 pollLock 解除一个线程等待 notify；</li><li><strong>触发的线程在 JVM 实现中是随机的</strong>，假设线程 A 被解除阻塞；</li><li>假设线程 A 在阻塞过程中已被中断，阻塞解除后 JVM 检查 interrupted 状态，抛出 InterruptedException 异常；（线程A在阻塞时被中断，那么它的状态是interrupted，但是还处在被阻塞状态，此时去唤醒该线程，则会报错，而此次唤醒操作则丢失。线程A等中断结束后还会进入阻塞状态。）</li><li>此时队列中有一个元素，但线程 A 仍阻塞在 pollLock 中，且一直阻塞下去；</li></ol><p>以上为解除阻塞消息丢失的例子，问题的根源在与异常处理。</p><h1 id="5、解决异常问题"><a href="#5、解决异常问题" class="headerlink" title="5、解决异常问题"></a>5、解决异常问题</h1><p>解决线程中断退出的问题，线程校验中断状态的场景</p><ol><li>JVM 通常只会在有限的几个场景检测线程的中断状态， wait, Thread.join, Thread.sleep；</li><li>JVM 在检测到线程中断状态 Thread.interrupted() 后，会清除中断标志，抛出 InterruptedException；</li><li>通常为了保证线程对中断及时响应， run 方法中需要自主检测中断标志，中断线程，特别是对中断比较敏感需要保持类的不变式的场景；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FairnessBoundedBlockingQueue</span> <span class="keyword">implements</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头指针，empty: head.next == tail == null</span></span><br><span class="line">    <span class="keyword">protected</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾指针</span></span><br><span class="line">    <span class="keyword">protected</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canPollCount, head, waitPollCount</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">pollLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canPollCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> waitPollCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canOfferCount, tail, waitOfferCount</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">offerLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canOfferCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> waitOfferCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FairnessBoundedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.canPollCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.canOfferCount = capacity;</span><br><span class="line">        <span class="built_in">this</span>.waitPollCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.waitOfferCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，通过返回值标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>(); <span class="comment">// 线程已中断，直接退出即可，防止中断线程竞争锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            <span class="keyword">while</span>(canOfferCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                waitOfferCount++;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    offerLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 触发其他线程</span></span><br><span class="line">                    offerLock.notify();</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    waitOfferCount--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(obj);</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            canOfferCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            ++canPollCount;</span><br><span class="line">            <span class="keyword">if</span> (waitPollCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pollLock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，阻塞等待</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            <span class="keyword">while</span>(canPollCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                waitPollCount++;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    pollLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    pollLock.notify();</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    waitPollCount--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = head.next.value;</span><br><span class="line">            head.next.value = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// ignore head;</span></span><br><span class="line">            head = head.next;</span><br><span class="line">            canPollCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            canOfferCount++;</span><br><span class="line">            <span class="keyword">if</span> (waitOfferCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                offerLock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 Node 的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上</p><ol><li>当等待线程中断退出时，捕获中断异常，通过 pollLock.notify 和 offerLock.notify 转发消息；</li><li>通过在 finally 中恢复状态追踪变量；</li></ol><p>通过状态变量追踪可以解决读与读之间和写与写之间的锁竞争问题。</p><h1 id="6、解决公平性"><a href="#6、解决公平性" class="headerlink" title="6、解决公平性"></a>6、解决公平性</h1><p>公平性的问题的解决需要将状态变量的追踪转换为：<strong>请求监视器追踪</strong>。</p><ol><li>每个请求对应一个监视器；</li><li>通过内部维护一个 FIFO 队列，实现公平性；</li><li>在队列状态变更时，释放队列中的监视器；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> needToWait;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">    needToWait = calculateNeedToWait();</span><br><span class="line">    <span class="keyword">if</span> (needToWait) &#123;</span><br><span class="line">        enqueue(monitor); <span class="comment">// 请求对应的monitor</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needToWait) &#123;</span><br><span class="line">    monitor.doWait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意</p><ol><li>monitor.doWait() 需要在 this 的卫式语句之外，因为如果在内部， monitor.doWait 并不会释放 this锁；</li><li>calculateNeedToWait() 需要在 this 的守卫之内完成，避免同步问题；</li><li>需要考虑中断异常的问题；</li></ol><p>基于以上的逻辑抽象，实现公平队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略接口定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FairnessBoundedBlockingQueue</span> <span class="keyword">implements</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头指针，empty: head.next == tail == null</span></span><br><span class="line">    <span class="keyword">protected</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾指针</span></span><br><span class="line">    <span class="keyword">protected</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canPollCount, head, pollQueue</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">pollLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canPollCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canOfferCount, tail, offerQueue</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">offerLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canOfferCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">WaitQueue</span> <span class="variable">pollQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitQueue</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">WaitQueue</span> <span class="variable">offerQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FairnessBoundedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.canOfferCount = capacity;</span><br><span class="line">        <span class="built_in">this</span>.canPollCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，通过返回值标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>(); <span class="comment">// 线程已中断，直接退出即可，防止中断线程竞争锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">WaitNode</span> <span class="variable">wait</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            <span class="comment">// 在有阻塞请求或者队列为空时，阻塞等待</span></span><br><span class="line">            <span class="keyword">if</span> (canOfferCount &lt;= <span class="number">0</span> || !offerQueue.isEmpty()) &#123;</span><br><span class="line">                wait = <span class="keyword">new</span> <span class="title class_">WaitNode</span>();</span><br><span class="line">                offerQueue.enq(wait);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// continue.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (wait != <span class="literal">null</span>) &#123;</span><br><span class="line">                wait.doWait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            offerQueue.doNotify();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保此时线程状态正常，以下不会校验中断</span></span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(obj);</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            canOfferCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            ++canPollCount;</span><br><span class="line">            pollQueue.doNotify();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，阻塞等待</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">WaitNode</span> <span class="variable">wait</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            <span class="comment">// 在有阻塞请求或者队列为空时，阻塞等待</span></span><br><span class="line">            <span class="keyword">if</span> (canPollCount &lt;= <span class="number">0</span> || !pollQueue.isEmpty()) &#123;</span><br><span class="line">                wait = <span class="keyword">new</span> <span class="title class_">WaitNode</span>();</span><br><span class="line">                pollQueue.enq(wait);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (wait != <span class="literal">null</span>) &#123;</span><br><span class="line">                wait.doWait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 传递消息</span></span><br><span class="line">            pollQueue.doNotify();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下不会检测线程中断状态</span></span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            result = head.next.value;</span><br><span class="line">            head.next.value = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// ignore head;</span></span><br><span class="line">            head = head.next;</span><br><span class="line">            canPollCount--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            canOfferCount++;</span><br><span class="line">            offerQueue.doNotify();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WaitQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">        WaitNode head;</span><br><span class="line">        WaitNode tail;</span><br><span class="line"></span><br><span class="line">        WaitQueue() &#123;</span><br><span class="line">            head = <span class="keyword">new</span> <span class="title class_">WaitNode</span>();</span><br><span class="line">            tail = head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doNotify</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">                <span class="type">WaitNode</span> <span class="variable">node</span> <span class="operator">=</span> deq();</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.doNotify()) &#123;</span><br><span class="line">                    <span class="comment">// 此处确保NOTIFY成功</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// ignore, and retry.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> head.next == <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">enq</span><span class="params">(WaitNode node)</span> &#123;</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> WaitNode <span class="title function_">deq</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">WaitNode</span> <span class="variable">res</span> <span class="operator">=</span> head.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                tail = head; <span class="comment">// 为空，迁移tail节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WaitNode</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> released;</span><br><span class="line">        WaitNode next;</span><br><span class="line">        WaitNode() &#123;</span><br><span class="line">            released = <span class="literal">false</span>;</span><br><span class="line">            next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doWait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!released) &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125;             </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!released) &#123;</span><br><span class="line">                    released = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果是NOTIFY之后收到中断的信号，不能抛出异常；需要做RELAY处理</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">doNotify</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!released) &#123;</span><br><span class="line">                released = <span class="literal">true</span>;</span><br><span class="line">                notify();</span><br><span class="line">                <span class="comment">// 明确释放了一个线程，返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有释放新的线程，返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 Node 的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上</p><ol><li>核心是替换状态追踪变量为同步节点， WaitNode；</li><li>WaitNode 通过简单的同步队列组织实现 FIFO 协议，每个线程等待各自的 WaitNode 监视器；</li><li>WaitNode 内部维持 released 状态，标识线程阻塞状态是否被释放，主要是为了处理中断的问题；</li><li>WaitQueue 本身是全同步的，由于已解决了读写竞争已经读写内部竞争的问题， WaitQueue 同步并不会造成问题；</li><li>WaitQueue 是无界队列，是一个潜在的问题；但由于其只做同步的追踪，而且追踪的通常是线程，通常并不是问题；</li><li>最终的公平有界队列实现，无论是入队还是出队，首先卫式语句判定是否需要入队等待，如果入队等待，通过公平性协议等待;<br>当信号释放时，借助读写锁同步更新队列；最后同样借助读写锁，触发队列更新消息；</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《阿里技术博客》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;4、状态追踪解除竞争&quot;&gt;&lt;a href=&quot;#4、状态追踪解除竞争&quot; class=&quot;headerlink&quot; title=&quot;4、状态追踪解除竞争&quot;&gt;&lt;/a&gt;4、状态追踪解除竞争&lt;/h1&gt;&lt;p&gt;此处可以通过状态追踪，解除读与读之间和写与写之间的竞争问题。&lt;/p&gt;
&lt;fi</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程实践之公平有界阻塞队列实现（上）</title>
    <link href="http://example.com/2023/07/12/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%85%AC%E5%B9%B3%E6%9C%89%E7%95%8C%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2023/07/12/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%85%AC%E5%B9%B3%E6%9C%89%E7%95%8C%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-07-12T03:34:31.000Z</published>
    <updated>2023-07-13T02:54:37.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、基础版本"><a href="#1、基础版本" class="headerlink" title="1、基础版本"></a>1、基础版本</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span>;</span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">poll</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FairnessBoundedBlockingQueue</span> <span class="keyword">implements</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="comment">// 当前大小</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头指针，empty: head.next == tail == null</span></span><br><span class="line">    <span class="keyword">protected</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾指针</span></span><br><span class="line">    <span class="keyword">protected</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FairnessBoundedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = head;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，通过返回值标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; capacity) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(obj);</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，head.next == null；返回空元素</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> head.next.value;</span><br><span class="line">            head.next.value = <span class="literal">null</span>;</span><br><span class="line">            head = head.next; <span class="comment">// 丢弃头结点</span></span><br><span class="line">            --size;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        Node next;</span><br><span class="line">        Node(Object obj) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = obj;</span><br><span class="line">            next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>定义支持队列的两个基础接口， poll 和 offer；</li><li>队列的实现，采用经典实现；</li><li>考虑在队列空的情况下， poll 返回为空，非阻塞；</li><li>队列在满的情况下， offer 返回 false ，入队不成功，无异常；</li></ol><h1 id="2、并发版本"><a href="#2、并发版本" class="headerlink" title="2、并发版本"></a>2、并发版本</h1><p>如果在并发场景下，上述的实现面临一些问题，同时未实现给定的一些需求。通过添加 synchronized ，保证并发条件下的线程安全问题。注意此处做同步的原因是为了保证类的不变式。</p><p>以上，简单粗暴的加 synchronized 可以解决问题，但会引入新的问题：系统活性问题（此问题下文会解决）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoundedBlockingQueue</span> <span class="keyword">implements</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前大小</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头指针，empty: head.next == tail == null</span></span><br><span class="line">    <span class="keyword">protected</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾指针</span></span><br><span class="line">    <span class="keyword">protected</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BoundedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = head;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，通过返回值标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; capacity) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(obj);</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，head.next == null；返回空元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> head.next.value;</span><br><span class="line">            head.next.value = <span class="literal">null</span>;</span><br><span class="line">            head = head.next; <span class="comment">// 丢弃头结点</span></span><br><span class="line">            --size;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        BoundedBlockingQueue.Node next;</span><br><span class="line">        Node(Object obj) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = obj;</span><br><span class="line">            next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，简单加 synchronized 同步是无法实现阻塞等待；即</p><ol><li>如果队列为空，那么出队的动作还是会立即返回，返回为空；</li><li>如果队列已满，那么入队动作还是会立即返回，返回操作不成功；</li></ol><h2 id="卫式方法"><a href="#卫式方法" class="headerlink" title="卫式方法"></a>卫式方法</h2><p>阻塞等待，可以通过简单的卫式方法来实现，此问题本质上可以抽象为：</p><ol><li>任何一个方法都需要在满足一定条件下才可以执行；</li><li>执行方法前需要首先校验不变式，然后执行变更；</li><li>在执行完成后，校验是否满足后验不变式；</li></ol><p>代码逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 当前线程</span></span><br><span class="line"><span class="keyword">synchronized</span> Object <span class="title function_">action</span><span class="params">(Object arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(!condition) &#123;</span><br><span class="line">        wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前置条件，不变式</span></span><br><span class="line">    checkPreCondition();</span><br><span class="line">    doAction();</span><br><span class="line">    <span class="comment">// 后置条件，不变式</span></span><br><span class="line">    checkPostCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他线程</span></span><br><span class="line"><span class="keyword">synchronized</span> Object <span class="title function_">notifyAction</span><span class="params">(Object arg)</span> &#123;</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意：</p><ol><li>通常会采用 notifyAll 发送通知，而非 notify ；因为如果当前线程收到 notify 通知后被中断，那么系统将一直等待下去。</li><li>如果使用了 notifyAll 那么卫式语句必须放在 while 循环中；因为线程唤醒后，执行条件已经不满足，虽然当前线程持有互斥锁。</li><li>卫式条件的所有变量，有任何变更都需要发送 notifyAll 不然面临系统活性问题。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FairnessBoundedBlockingQueue</span> <span class="keyword">implements</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="comment">// 当前大小</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头指针，empty: head.next == tail == null</span></span><br><span class="line">    <span class="keyword">protected</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾指针</span></span><br><span class="line">    <span class="keyword">protected</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FairnessBoundedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = head;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，通过返回值标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        size&gt;=capacity &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(obj);</span><br><span class="line">        tail.next = node;</span><br><span class="line">        tail = node;</span><br><span class="line">        ++size;</span><br><span class="line">        notifyAll(); <span class="comment">// 可以出队</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，阻塞等待</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> head.next.value;</span><br><span class="line">        head.next.value = <span class="literal">null</span>;</span><br><span class="line">        head = head.next; <span class="comment">// 丢弃头结点</span></span><br><span class="line">        --size;</span><br><span class="line">        notifyAll(); <span class="comment">// 可以入队</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 Node 的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，实现了阻塞等待，但也引入了更大的性能问题</p><ol><li>入队和出队动作阻塞等待同一把锁，恶性竞争；（这里不管入队还是出队操作的都是同一个队列，入队还是出队都操作了size，所以不能同时进行）</li><li>当队列变更时，所有阻塞线程被唤醒，大量的线程上下文切换，竞争同步锁，最终可能只有一个线程能执行；</li></ol><p>需要注意的点：</p><ol><li>阻塞等待 wait 会抛出中断异常。关于异常的问题下文会处理；</li><li>接口需要支持抛出中断异常；</li><li>队里变更需要 notifyAll 避免线程中断或异常，丢失消息；</li></ol><h1 id="3、锁拆分优化"><a href="#3、锁拆分优化" class="headerlink" title="3、锁拆分优化"></a>3、锁拆分优化</h1><p>以上第一个问题，可以通过锁拆分来解决，即：定义两把锁，读锁和写锁；读写分离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 省略接口定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FairnessBoundedBlockingQueue</span> <span class="keyword">implements</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头指针，empty: head.next == tail == null</span></span><br><span class="line">    <span class="keyword">protected</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾指针</span></span><br><span class="line">    <span class="keyword">protected</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canPollCount, head</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">pollLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canPollCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canOfferCount, tail</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">offerLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canOfferCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FairnessBoundedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.canPollCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.canOfferCount = capacity;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，通过返回值标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            <span class="keyword">while</span>(canOfferCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                offerLock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(obj);</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            canOfferCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            ++canPollCount;</span><br><span class="line">            pollLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，阻塞等待</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            <span class="keyword">while</span>(canPollCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                pollLock.wait();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = head.next.value;</span><br><span class="line">            head.next.value = <span class="literal">null</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            canPollCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            canOfferCount++;</span><br><span class="line">            offerLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 Node 定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上</p><ol><li>定义了两把锁， pollLock 和 offerLock 拆分出队和入队竞争；</li><li>入队锁同步的变量为：callOfferCount 和 tail；</li><li>出队锁同步的变量为：canPollCount 和 head；</li><li>出队的动作：首先拿到 pollLock 卫式等待后，完成出队动作；然后拿到 offerLock 发送通知，解除入队的等待线程。</li><li>入队的动作：首先拿到 offerLock 卫式等待后，完成入队的动作；然后拿到 pollLock 发送通知，解除出队的等待线程。</li></ol><p>以上实现</p><ol><li>确保通过入队锁和出队锁，分别保证入队和出队的原子性；</li><li>出队动作，通过特别的实现，确保出队只会变更 head ，避免获取 offerLock；</li><li>通过 offerLock.notifyAll 和 pollLock.notifyAll 解决读写竞争的问题；</li></ol><p>问题：当有多个入队线程等待时，一次出队的动作会触发所有入队线程竞争，大量的线程上下文切换，最终只有一个线程能执行。<br>即，还有 <strong>读与读</strong> 和 <strong>写与写</strong> 之间的竞争问题。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《阿里技术博客》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、基础版本&quot;&gt;&lt;a href=&quot;#1、基础版本&quot; class=&quot;headerlink&quot; title=&quot;1、基础版本&quot;&gt;&lt;/a&gt;1、基础版本&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件单例服务优化</title>
    <link href="http://example.com/2023/07/09/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8D%95%E4%BE%8B%E6%9C%8D%E5%8A%A1%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2023/07/09/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8D%95%E4%BE%8B%E6%9C%8D%E5%8A%A1%E4%BC%98%E5%8C%96/</id>
    <published>2023-07-09T03:14:06.000Z</published>
    <updated>2023-07-09T06:16:03.232Z</updated>
    
    <content type="html"><![CDATA[<p>几乎所有串行化理论真正解决的问题只有一个：性能。 所以，在性能允许的前提下，对于消费者角色，建议采用单实例部署。通过单实例部署，有序性、串行化、完整性和一致性问题自动获得了解决。另外，单实例部署的消费者拥有全部所需信息，它可以在频次控制上采取很多优化策略。</p><p>单实例部署并非没有代价，它意味着系统可用性的降低，解决可用性问题的最直接的思路就是冗余（Redundancy）。最常用的冗余方案是Master-slave架构，不过大部分的Master-slave架构都是Active&#x2F;active模式，即主从服务器都提供服务。</p><p>大部分基于负载均衡设计的Master-slave集群中，主服务器和从服务器同时提供相同的服务。这显然不满足单例服务优化需求。有序性和串行化需要Active&#x2F;passive架构，即在某一时刻只有主实例提供服务，其他的从服务等待主实例失效。这是典型的领导人选举架构，即只有获得领导权的实例才能充当实际消费者，其他实例都在等待下一次选举。采用领导人选举的Active&#x2F;passive架构可以大大缓解纯粹的单实例部署所带来的可用性问题。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《美团博客》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;几乎所有串行化理论真正解决的问题只有一个：性能。 所以，在性能允许的前提下，对于消费者角色，建议采用单实例部署。通过单实例部署，有序性、串行化、完整性和一致性问题自动获得了解决。另外，单实例部署的消费者拥有全部所需信息，它可以在频次控制上采取很多优化策略。&lt;/p&gt;
&lt;p&gt;单</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="消息队列" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件选型标准</title>
    <link href="http://example.com/2023/07/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%80%89%E5%9E%8B%E6%A0%87%E5%87%86/"/>
    <id>http://example.com/2023/07/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%80%89%E5%9E%8B%E6%A0%87%E5%87%86/</id>
    <published>2023-07-07T02:52:20.000Z</published>
    <updated>2023-07-09T03:21:17.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中间件的功能"><a href="#中间件的功能" class="headerlink" title="中间件的功能"></a>中间件的功能</h1><p>典型的消息中间件主要包含如下几个功能： </p><ul><li><p>消息接收 </p></li><li><p>消息分发 </p></li><li><p>消息存储 </p></li><li><p>消息读取</p></li></ul><h1 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h1><p>抽象的消息中间件模型包含如下几个角色：</p><ol><li>发送者和接收者客户端（Sender&#x2F;Receiver Client）；</li><li>代理服务器（Broker Server），它们是与客户端代码直接交互的服务端代码；</li><li>消息交换机（Exchanger），接收到的消息一般需要通过消息交换机（Exchanger）分发到具体的消息队列中；</li><li>消息队列，一般是一块内存数据结构或持久化数据。</li></ol><p>如下图所示：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230709105627284.png" alt="image-20230709105627284"></p><h1 id="选型标准"><a href="#选型标准" class="headerlink" title="选型标准"></a>选型标准</h1><p>大致有以下几点</p><h2 id="1、性能"><a href="#1、性能" class="headerlink" title="1、性能"></a>1、性能</h2><p>性能主要有两个方面需要考虑：吞吐量（Throughput）和响应时间（Latency）。 不同的消息队列中间件的吞吐量和响应时间相差甚远，对于同一种中间件，不同的配置方式也会影响性能。</p><p>配置主要有以下几种：</p><ul><li>是否需要确认机制，即写入队列后，或从队列读取后，是否需要进行确认。确认机制对响应时间的影响往往很大。</li><li>能否批处理，即消息能否批量读取或者写入。批量操作可以大大减少应用程序与消息中间件的交互次数和消息传递量，大大提高吞吐量。</li><li>能否进行分区（Partition）。将某一主题消息队列进行分区，同一主题消息可以有多台机器并行处理。这不仅仅能影响消息中间件的吞吐量，还决定着消息中间件是否具备良好的可伸缩性（Scalability）。</li><li>是否需要进行持久化。将消息进行持久化往往会同时影响吞吐量和响应时间。</li></ul><h2 id="2、可靠性"><a href="#2、可靠性" class="headerlink" title="2、可靠性"></a>2、可靠性</h2><p>可靠性主要包含：可用性、持久化、确认机制等。高可用性的消息中间件应该具备如下特征：</p><ul><li>消息中间件代理服务器（Broker）具有主从备份。即当一台代理服务宕机之后，备用服务器能接管相关的服务。</li><li>消息中间件中缓存的消息是否有备份、并持久化。高可用、高一致性以及网络分裂不可兼得，大部分中间件在面临网络分裂情况下都很难保证高可用和一致性，而且可用性和一致性之间也不可兼得。</li></ul><p>高可靠的消息中间件应该确保从发送者接收到的消息不会丢失。中间件代理服务器的宕机并不是小概率事件，所以大部分消息中间件都提供持久化，将消息写入磁盘中。但仍有两个问题需要考虑：</p><ul><li>磁盘损坏问题。长时间来看，磁盘出问题的概率仍然存在。</li><li>性能问题。与操作内存相比，磁盘I&#x2F;O的操作性能要慢几个数量级。频繁持久化不仅会增加响应时间，也会降低吞吐量。</li></ul><p>解决方案：多机确认，定期持久化。即消息被缓存在多台机器的内存中，只有每台机器都确认收到消息，才跟发送者确认（很多消息中间件都会提供相应的配置选项，让用户设置最少需要多少台机器接收到消息）。</p><p>确认机制本质上是通讯的握手机制（Handshaking）。如果没有该机制，消息在传输过程中丢失将不会被发现。当然如果没有接收到消息中间件确认完成的指令，应用程序需要决定如何处理。典型的做法有两个： </p><ol><li>多次重试。 </li><li>暂存到本地磁盘或其它持久化媒介。</li></ol><h2 id="3、投递策略（Delivery-policies）"><a href="#3、投递策略（Delivery-policies）" class="headerlink" title="3、投递策略（Delivery policies）"></a>3、投递策略（Delivery policies）</h2><p>投递策略指的是一个消息会被发送几次。主要包含三种策略：</p><ol><li>最多一次（At most Once ）</li><li>最少一次（At least Once）</li><li>仅有一次（Exactly Once）。</li></ol><p>在实际应用中，只考虑消息中间件的投递策略并不能保证业务的投递策略，因为接收者在确认收到消息和处理完消息并持久化之间存在一个时间窗口。</p><p>例如，即使消息中间件保证仅有一次（Exactly Once），如果接收者先确认消息，在持久化之前宕机，则该消息并未被处理。从应用的角度，这就是最多一次（At most Once）。反之，接收者先处理消息并完成持久化，但在确认之前宕机，消息就要被再次发送，这就是最少一次（At least Once）。</p><h1 id="面临的挑战"><a href="#面临的挑战" class="headerlink" title="面临的挑战"></a>面临的挑战</h1><p>消费者是分布式队列编程中真正的数据处理方，数据处理方最常见的挑战包括：有序性、串行化（Serializability）、频次控制、完整性和一致性等。</p><h2 id="1、有序性"><a href="#1、有序性" class="headerlink" title="1、有序性"></a>1、有序性</h2><p>如下图，假定分布式队列保证请求严格有序，请求ri2和ri1都是针对同一数据记录的不同状态，ri2的状态比ri1的状态新。T1、T2、T3和T4代表各个操作发生的时间，并且 T1 &lt; T2 &lt; T3 &lt; T4（”&lt;“代表早于）。</p><p>采用多消费者架构，这两条记录被两个消费者（Consumer1和Consumer2）处理后更新到数据库里面。Consumer1虽然先读取ri1但是却后写入数据库，这就导致，新的状态被老的状态覆盖，所以多消费者不保证数据的有序性。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230709111658723.png" alt="image-20230709111658723"></p><h2 id="2、串行化"><a href="#2、串行化" class="headerlink" title="2、串行化"></a>2、串行化</h2><p>很多场景下，串行化是数据处理的一个基本需求，这是保证数据完整性、可恢复性、事务原子性等的基础。对于分布式队列编程架构，要在在多台消费者实现串行化非常复杂。</p><h2 id="3、频次控制"><a href="#3、频次控制" class="headerlink" title="3、频次控制"></a>3、频次控制</h2><p>有时候，消费者的消费频次需要被控制，可能的原因包括：</p><ul><li>费用问题。如果每次消费所引起的操作都需要收费，而同一个请求消息在队列中保存多份，不进行频次控制，就会导致无谓的浪费。 </li><li>性能问题。每次消费可能会引起对其他服务的调用，被调用服务希望对调用量有所控制，对同一个请求消息的多次访问就需要有所控制。</li></ul><h2 id="4、完整性和一致性"><a href="#4、完整性和一致性" class="headerlink" title="4、完整性和一致性"></a>4、完整性和一致性</h2><p>完整性和一致性是所有多线程和多进程的代码都面临的问题。在多线程或者多进程的系统中考虑完整性和一致性往往会大大地增加代码的复杂度和系统出错的概率。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《美团博客》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;中间件的功能&quot;&gt;&lt;a href=&quot;#中间件的功能&quot; class=&quot;headerlink&quot; title=&quot;中间件的功能&quot;&gt;&lt;/a&gt;中间件的功能&lt;/h1&gt;&lt;p&gt;典型的消息中间件主要包含如下几个功能： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;消息接收 &lt;/p&gt;
&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="消息队列" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>分布式队列编程优化</title>
    <link href="http://example.com/2023/07/06/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E5%88%86%E5%B8%83%E5%BC%8F%E9%98%9F%E5%88%97%E7%BC%96%E7%A8%8B%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2023/07/06/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E5%88%86%E5%B8%83%E5%BC%8F%E9%98%9F%E5%88%97%E7%BC%96%E7%A8%8B%E4%BC%98%E5%8C%96/</id>
    <published>2023-07-06T02:38:48.000Z</published>
    <updated>2023-07-09T03:13:09.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存优化（接收请求和处理之间）"><a href="#缓存优化（接收请求和处理之间）" class="headerlink" title="缓存优化（接收请求和处理之间）"></a>缓存优化（接收请求和处理之间）</h1><p>处于“处理－转发”模式下运行的生产者往往被设计成请求驱动型的服务，即每个请求都会触发一个处理线程，线程处理完后将结果写入分布式队列。但是如果队列不可用，那么生产者的处理线程就会产生堆积，则会导致以下两个问题：</p><ul><li>系统可用性降低。由于每个线程都需要一定的内存开销，线程过多会使系统内存耗尽，甚至可能产生雪崩效应导致最终完全不可用。</li><li>信息丢失。为了避免系统崩溃，一般会给请求驱动型服务设置一个处理线程池，设置最大处理线程数量。这是一种典型的降级策略，目的是为了防止系统崩溃。但是，后续的请求会因为没有处理线程而被迫阻塞，最终可能产生信息丢失。</li></ul><p>解决思路来自CAP理论，即通过降低<strong>一致性</strong>来保证<strong>可用性</strong>。具体如下：</p><p>生产者接收线程在收到请求之后第一时间不去处理，直接将请求缓存在内存中（牺牲一致性），而在后台启动多个处理线程从缓存中读取请求、进行处理并写入分布式队列。</p><p>与线程所占用的内存开销相比，大部分的请求所占内存几乎可以忽略。通过在接收请求和处理请求之间增加一层内存缓存，可以大大提高系统的处理吞吐量和可扩展性。这个方案本质上是一个内存生产者消费者模型。</p><h1 id="批量写入优化（处理请求和写入队列之间）"><a href="#批量写入优化（处理请求和写入队列之间）" class="headerlink" title="批量写入优化（处理请求和写入队列之间）"></a>批量写入优化（处理请求和写入队列之间）</h1><p>如果生产者请求过大，写入分布式队列则会成为瓶颈，有以下几点原因：</p><ul><li>队列自身性能不高；</li><li>分布式队列编程模型往往被应用在跨机房的系统里面，跨机房的网络开销往往容易成为系统瓶颈；</li><li>消息确认机制往往会大大降低队列的吞吐量以及响应时间。</li></ul><p>如果在<strong>处理请求和写队列之间</strong>添加一层缓存，消息写入程序批量将消息写入队列，可以大大提高系统的吞吐量。原因如下：</p><ul><li>批量写队列可以大大减少生产者和分布式队列的交互次数和消息传输量。特别是对于高吞吐小载荷的消息实体，批量写可以显著降低网络传输量；</li><li>对于需要确认机制的消息，确认机制往往会大大降低队列的吞吐量以及响应时间，某些高敏感的消息需要多个消息中间件代理同时确认，这近一步恶化性能。在生产者的应用层将多条消息批量组合成一个消息体，消息中间件就只需要对批量消息进行一次确认，这可能会数量级的提高消息传输性能。</li></ul><h1 id="持久化优化"><a href="#持久化优化" class="headerlink" title="持久化优化"></a>持久化优化</h1><p>添加缓存可以提高吞吐行，但是也会导致新的问题，内存数据丢失。对于敏感数据，要考虑以下问题：</p><ul><li>如果内存中存在未处理完的请求，而某些原因导致生产者服务宕机，内存数据就会丢失而可能无法恢复；</li><li>如果分布式队列长时间不可用，随着请求数量的不断增加，最终系统内存可能会耗尽而崩溃，内存的消息也可能丢失。</li></ul><p>所以缓存中的数据要定时持久化到磁盘中。主要有两种 ：</p><ul><li>定期触发，即每隔一段时间进行一次持久化；</li><li>定量触发，即每当缓存中的请求数量达到一定阈值后进行持久化。</li></ul><p>是否需要持久化优化，以及持久化策略应该由请求数据的敏感度、请求量、持久化性能等因素共同决定。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《美团博客》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;缓存优化（接收请求和处理之间）&quot;&gt;&lt;a href=&quot;#缓存优化（接收请求和处理之间）&quot; class=&quot;headerlink&quot; title=&quot;缓存优化（接收请求和处理之间）&quot;&gt;&lt;/a&gt;缓存优化（接收请求和处理之间）&lt;/h1&gt;&lt;p&gt;处于“处理－转发”模式下运行的生产者</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="消息队列" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Java的NIO</title>
    <link href="http://example.com/2023/07/04/Java/Java%E7%9A%84NIO/"/>
    <id>http://example.com/2023/07/04/Java/Java%E7%9A%84NIO/</id>
    <published>2023-07-04T03:10:11.000Z</published>
    <updated>2023-07-04T06:50:06.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见I-x2F-O模型对比"><a href="#常见I-x2F-O模型对比" class="headerlink" title="常见I&#x2F;O模型对比"></a>常见I&#x2F;O模型对比</h1><p>所有的系统I&#x2F;O都分为两个阶段：等待就绪和操作。</p><p>比如读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。</p><p>其中，<strong>等待就绪的阻塞</strong>是不使用CPU的，是在“空等”；而真正的读写操作的阻塞是使用CPU的，真正在”干活”，而且这个过程非常快，属于memory copy，可以理解为基本不耗时。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230704111300465.png" alt="image-20230704111300465" style="zoom:67%;" /><h2 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h2><p>以socket.read()为例子：</p><p>传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。</p><p>对于NIO，如果TCP RecvBuffer有数据，就把数据从网卡读到内存，并且返回给用户；反之则直接返回0，永远不会阻塞。</p><p>最新的AIO(Async I&#x2F;O)里面会更进一步：不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。</p><p>BIO里用户最关心“我要读”，NIO里用户最关心”我可以读了”，在AIO模型里用户更需要关注的是“读完了”。</p><p>NIO一个重要的特点是：socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I&#x2F;O操作是同步阻塞的（消耗CPU但性能非常高）。</p><h1 id="结合事件模型使用NIO同步非阻塞特性"><a href="#结合事件模型使用NIO同步非阻塞特性" class="headerlink" title="结合事件模型使用NIO同步非阻塞特性"></a>结合事件模型使用NIO同步非阻塞特性</h1><p>BIO中，之所以需要多线程，是因为在进行I&#x2F;O操作时，无法估计什么时候完成，只能等待，即使通过估算算出来一个大概的时间，也无法通过socket.read()和socket.write()进行返回，所以另外开启一个新的线程是最好的解决办法。</p><p><strong>NIO的读写函数可以立刻返回</strong>，这就给了我们不开线程利用CPU的最好机会：如果一个连接不能读写（socket.read()返回0或者socket.write()返回0），我们可以把这件事记下来，<strong>记录的方式通常是在Selector上注册标记位</strong>，然后切换到其它就绪的连接（channel）继续进行读写。</p><h2 id="如何使用单线程处理所有I-x2F-O"><a href="#如何使用单线程处理所有I-x2F-O" class="headerlink" title="如何使用单线程处理所有I&#x2F;O"></a>如何使用单线程处理所有I&#x2F;O</h2><p>NIO的主要事件有几个：读就绪、写就绪、有新连接到来。</p><p>首先需要注册当这几个事件到来的时候所对应的处理器，然后在合适的时机告诉事件选择器：我对这个事件感兴趣。例如，对于写操作，就是写不出去的时候对写事件感兴趣；对于读操作，就是完成连接和系统没有办法承载新读入的数据的时；对于accept，一般是服务器刚启动的时候；而对于connect，一般是connect失败需要重连或者直接异步调用connect的时候。</p><p>其次，用一个死循环选择就绪的事件，会执行系统调用（Linux 2.6之前是select、poll，2.6之后是epoll，Windows是IOCP），<strong>还会阻塞的等待新事件的到来</strong>。新事件到来的时候，会在selector上注册标记位，标示可读、可写或者有连接到来。</p><p>注意，<strong>select是阻塞的</strong>，无论是通过操作系统的通知（epoll）还是不停的轮询(select，poll)，这个函数是阻塞的。所以你可以放心大胆地在一个while(true)里面调用这个函数而不用担心CPU空转。</p><p>一个最简单的Reactor模式的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ChannelHandler</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelReadable</span><span class="params">(Channel channel)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelWritable</span><span class="params">(Channel channel)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line">    Socket socket;</span><br><span class="line">    Event event;<span class="comment">//读，写或者连接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IO线程主循环:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IoThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        Channel channel;</span><br><span class="line">        <span class="keyword">while</span> (channel = Selector.select()) &#123;<span class="comment">//选择就绪的事件和对应的连接</span></span><br><span class="line">            <span class="keyword">if</span> (channel.event == accept) &#123;</span><br><span class="line">                registerNewChannelHandler(channel);<span class="comment">//如果是新连接，则注册一个新的读写处理器</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (channel.event == write) &#123;</span><br><span class="line">                getChannelHandler(channel).channelWritable(channel);<span class="comment">//如果可以写，则执行写事件</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (channel.event == read) &#123;</span><br><span class="line">                getChannelHandler(channel).channelReadable(channel);<span class="comment">//如果可以读，则执行读事件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Channel，ChannelHandler&gt; handlerMap;<span class="comment">//所有channel的对应事件处理器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优化线程模型"><a href="#优化线程模型" class="headerlink" title="优化线程模型"></a>优化线程模型</h1><p>NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I&#x2F;O操作都是纯CPU操作，没有必要开启多线程。</p><p>而且不开多线程，连接数大的时候减少了线程切换。</p><p>真正需要的线程：</p><ol><li>事件分发器，单线程选择就绪的事件。 </li><li>I&#x2F;O处理器，包括connect、read、write等，这种纯CPU操作，一般开启CPU核心个线程就可以。 </li><li>业务线程，在处理完I&#x2F;O后，业务一般还会有自己的业务逻辑，有的还会有其他的阻塞I&#x2F;O，如DB操作，RPC等。只要有阻塞，就需要单独的线程。</li></ol><p>Java的Selector对于Linux系统来说，有一个致命限制：同一个channel的select不能被并发的调用。因此，如果有多个I&#x2F;O线程，必须保证：一个socket只能属于一个IoThread，而一个IoThread可以管理多个socket。</p><p>另外连接的处理和读写的处理通常可以选择分开，这样对于海量连接的注册和读写就可以分发。虽然read()和write()是比较高效无阻塞的函数，但毕竟会占用CPU，如果面对更高的并发则无能为力。</p><p>NIO在服务端对于解放线程，优化I&#x2F;O和处理海量连接方面有一定的优势。</p><p>常见的客户端BIO+连接池模型，可以建立n个连接，然后当某一个连接被I&#x2F;O占用的时候，可以使用其他连接来提高性能。</p><p>但多线程的模型面临和服务端相同的问题：如果指望增加连接数来提高性能，则连接数又受制于线程数、线程很贵、无法建立很多线程，则性能遇到瓶颈。</p><h1 id="连接顺序请求的Redis"><a href="#连接顺序请求的Redis" class="headerlink" title="连接顺序请求的Redis"></a>连接顺序请求的Redis</h1><p>对于Redis来说，由于服务端是全局串行的，能够保证同一连接的所有请求与返回顺序一致。这样可以使用单线程＋队列，把请求数据缓冲。然后pipeline发送，返回future，然后channel可读时，直接在队列中把future取回来，done()就可以了。</p><h1 id="Proactor与Reactor"><a href="#Proactor与Reactor" class="headerlink" title="Proactor与Reactor"></a>Proactor与Reactor</h1><p>一般情况下，I&#x2F;O 复用机制需要事件分发器（event dispatcher）。事件分发器的作用，即将那些读写事件源分发给各读写事件的处理者,开发人员在开始的时候需要在分发器那里注册感兴趣的事件，并提供相应的处理者（event handler)，或者是回调函数；事件分发器在适当的时候，会将请求的事件分发给这些handler或者回调函数。</p><p>涉及到事件分发器的两种模式称为：Reactor和Proactor。 Reactor模式是基于同步I&#x2F;O的，而Proactor模式是和异步I&#x2F;O相关的。</p><p>在Reactor模式中，事件分发器等待某个事件或者可应用或某个操作的状态发生（比如文件描述符可读写，或者是socket可读写），事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。</p><p>而在Proactor模式中，事件处理者（或者代由事件分发器发起）直接发起一个异步读写操作（相当于请求），而实际的工作是由操作系统来完成的。发起时，需要提供的参数包括用于存放读到数据的缓存区、读的数据大小或用于存放外发数据的缓存区，以及这个请求完后的回调函数等信息。事件分发器得知了这个请求，它默默等待这个请求的完成，然后转发完成事件给相应的事件处理者或者回调。</p><p>举例来说，在Windows上事件处理者投递了一个异步IO操作（称为overlapped技术），事件分发器等IO Complete事件完成。这种异步模式的典型实现是基于操作系统底层异步API的，所以我们可称之为“系统级别”的或者“真正意义上”的异步，因为具体的读写是由操作系统代劳的。</p><h2 id="Reactor中实现读"><a href="#Reactor中实现读" class="headerlink" title="Reactor中实现读"></a>Reactor中实现读</h2><ul><li>注册读就绪事件和相应的事件处理器。</li><li>事件分发器等待事件。</li><li>事件到来，激活分发器，分发器调用事件对应的处理器。</li><li>事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li></ul><h2 id="Proactor中实现读"><a href="#Proactor中实现读" class="headerlink" title="Proactor中实现读"></a>Proactor中实现读</h2><ul><li>处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。</li><li>事件分发器等待操作完成事件。</li><li>在分发器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分发器读操作完成。</li><li>事件分发器呼唤处理器。</li><li>事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分发器。</li></ul><p>两个模式的相同点，都是对某个I&#x2F;O事件的事件通知（即告诉某个模块，这个I&#x2F;O操作可以进行或已经完成)。在结构上，两者也有相同点：事件分发器负责提交IO操作（异步)、查询设备是否可操作（同步)，然后当条件满足时，就回调handler；不同点在于，异步情况下（Proactor)，当回调handler时，表示I&#x2F;O操作已经完成；同步情况下（Reactor)，回调handler时，表示I&#x2F;O设备可以进行某个操作（can read 或 can write)。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《美团技术团队》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常见I-x2F-O模型对比&quot;&gt;&lt;a href=&quot;#常见I-x2F-O模型对比&quot; class=&quot;headerlink&quot; title=&quot;常见I&amp;#x2F;O模型对比&quot;&gt;&lt;/a&gt;常见I&amp;#x2F;O模型对比&lt;/h1&gt;&lt;p&gt;所有的系统I&amp;#x2F;O都分为两个阶段：等待就</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    
    <category term="I/O" scheme="http://example.com/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="http://example.com/2023/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-30T02:00:26.000Z</published>
    <updated>2023-06-30T02:10:39.396Z</updated>
    
    <content type="html"><![CDATA[<p>命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不 同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等 （附加控制）功能。</p><p>一些编程语言不支持传递函数，但是我们将函数封装在对象中，然后传递对象，就可以达到同样的效果。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不 同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等 （附加控制）功能。&lt;/p&gt;
&lt;p&gt;一些编程语言不支持传递函数，但是我们将函数封装在对象中，然后传递对象，就可以</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>备忘录模式</title>
    <link href="http://example.com/2023/06/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-28T03:03:51.000Z</published>
    <updated>2023-06-28T03:25:33.301Z</updated>
    
    <content type="html"><![CDATA[<p>备忘录模式，也叫快照（Snapshot）模式，在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外 保存这个状态，以便之后恢复对象为先前的状态。</p><p>这个模式包含两部分：一部分是，存储副本以便后期恢复。另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。</p><p>一个demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputText</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringBuilder</span> <span class="variable">text</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getText</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> text.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        text.append(input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Snapshot <span class="title function_">createSnapshot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Snapshot</span>(text.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreSnapshot</span><span class="params">(Snapshot snapshot)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.text.replace(<span class="number">0</span>, <span class="built_in">this</span>.text.length(), snapshot.getText());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Snapshot</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Snapshot</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getText</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnapshotHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Snapshot&gt; snapshots = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> Snapshot <span class="title function_">popSnapshot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> snapshots.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushSnapshot</span><span class="params">(Snapshot snapshot)</span> &#123;</span><br><span class="line">        snapshots.push(snapshot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InputText</span> <span class="variable">inputText</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputText</span>();</span><br><span class="line">        <span class="type">SnapshotHolder</span> <span class="variable">snapshotsHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SnapshotHolder</span>();</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="keyword">if</span> (input.equals(<span class="string">&quot;:list&quot;</span>)) &#123;</span><br><span class="line">                System.out.println(inputText.toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input.equals(<span class="string">&quot;:undo&quot;</span>)) &#123;</span><br><span class="line">                <span class="type">Snapshot</span> <span class="variable">snapshot</span> <span class="operator">=</span> snapshotsHolder.popSnapshot();</span><br><span class="line">                inputText.restoreSnapshot(snapshot);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                snapshotsHolder.pushSnapshot(inputText.createSnapshot());</span><br><span class="line">                inputText.append(input);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;备忘录模式，也叫快照（Snapshot）模式，在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外 保存这个状态，以便之后恢复对象为先前的状态。&lt;/p&gt;
&lt;p&gt;这个模式包含两部分：一部分是，存储副本以便后期恢复。另一部分是，要在不违背封装原则的前提下，进行对象的</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>访问者模式</title>
    <link href="http://example.com/2023/06/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-27T02:07:18.000Z</published>
    <updated>2023-06-27T03:32:24.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>访问者模式：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>一般来说，访问者模式针对的是一组类型不同的对象（PdfFile、PPTFile、WordFile）。不 过，尽管这组对象的类型是不同的，但是，它们继承相同的父类（ResourceFile）或者实 现相同的接口。在不同的应用场景下，我们需要对这组对象进行一系列不相关的业务操作 （抽取文本、压缩等），但为了避免不断添加功能导致类（PdfFile、PPTFile、WordFile） 不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致的频繁代码修改，我们使用访问者模式，将<strong>对象</strong>与<strong>操作</strong>解耦，将这些业务操作抽离出来，定义在独立细分的访问者类 （Extractor、Compressor）中。</p><h1 id="为什么支持双分派的语言不需要访问者模式？"><a href="#为什么支持双分派的语言不需要访问者模式？" class="headerlink" title="为什么支持双分派的语言不需要访问者模式？"></a>为什么支持双分派的语言不需要访问者模式？</h1><h2 id="Single-Dispatch，"><a href="#Single-Dispatch，" class="headerlink" title="Single Dispatch，"></a>Single Dispatch，</h2><p>指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的<strong>编译时类型</strong>来决定。</p><h2 id="Double-Dispatch"><a href="#Double-Dispatch" class="headerlink" title="Double Dispatch"></a>Double Dispatch</h2><p>指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的<strong>运行时类型</strong>来决定。</p><h2 id="Single-和-Double"><a href="#Single-和-Double" class="headerlink" title="Single 和 Double"></a>Single 和 Double</h2><p>Single Dispatch 之所以称为“Single”，是因为执行哪个对象的哪个方法，<strong>只跟“对象”的运行时类型有关</strong>。Double Dispatch 之所以称为“Double”，是因为执行哪个对象的哪个方法，跟“对象”和“方法参数”两者的运行时类型有关。</p><h2 id="Java的Single-Dispatch"><a href="#Java的Single-Dispatch" class="headerlink" title="Java的Single Dispatch"></a>Java的Single Dispatch</h2><p>Java 支持多态特性，代码可以在运行时获得对象的实际类型（也就是前面提到的运行时类 型），然后根据实际类型决定调用哪个方法。尽管 Java 支持函数重载，但 Java 设计的函数重载的语法规则是，<strong>并不是在运行时，根据传递进函数的参数的实际类型，来决定调用哪个重载函数</strong>，<strong>而是在编译时，根据传递进函数的参数的声明类型（也就是前面提到的编译时 类型），来决定调用哪个重载函数</strong>。也就是说，具体执行哪个对象的哪个方法，只跟<strong>对象的运行时类型</strong>有关，跟参数的运行时类型无关。所以，Java 语言只支持 Single Dispatch。</p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am ParentClass&#x27;s f().&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildClass</span> <span class="keyword">extends</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am ChildClass&#x27;s f().&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleDispatchClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">polymorphismFunction</span><span class="params">(ParentClass p)</span> &#123;</span><br><span class="line">        p.f();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">overloadFunction</span><span class="params">(ParentClass p)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am overloadFunction(ParentClass p).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">overloadFunction</span><span class="params">(ChildClass c)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am overloadFunction(ChildClass c).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SingleDispatchClass</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleDispatchClass</span>();</span><br><span class="line">        <span class="type">ParentClass</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChildClass</span>();</span><br><span class="line">        <span class="comment">// 执行哪个对象的方法，由对象的实际类型决定。</span></span><br><span class="line">        <span class="comment">// 这里对象p的实例化是ChildClass，所以调用了child的f方法。</span></span><br><span class="line">        demo.polymorphismFunction(p);</span><br><span class="line">        <span class="comment">// 执行对象的哪个方法，由参数对象的声明类型决定</span></span><br><span class="line">        <span class="comment">// 这里指的是执行SingleDispatchClass的哪一个overloadFunction方法</span></span><br><span class="line">        <span class="comment">// 他取决于参数p声明的类型，即ParentClass</span></span><br><span class="line">        demo.overloadFunction(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230627112245628.png" alt="image-20230627112245628"></p><p>注：Java作为Single Dispatch，执行重载方法的时候，只会根据执行方法时传递的参数<strong>声明时的类型</strong>来执行，并不会关注他到底实例化了哪一个对象。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;访问者模式：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。&lt;/p&gt;
&lt;h1 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; </summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>迭代器模式（下）</title>
    <link href="http://example.com/2023/06/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://example.com/2023/06/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2023-06-26T02:33:49.000Z</published>
    <updated>2023-06-26T04:29:21.316Z</updated>
    
    <content type="html"><![CDATA[<p>如何实现一个支持“快照”功能的迭代器？</p><p>所谓“快照”，指我们为容器创建迭代器的 时候，相当于给容器拍了一张快照（Snapshot）。之后即便我们增删容器中的元素，快照 中的元素并不会做相应的改动。而迭代器遍历的对象是快照而非容器，这样就避免了在使用 迭代器遍历的过程中，增删容器中的元素，导致的不可预期的结果或者报错。</p><h1 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h1><p>在迭代器类中定义一个成员变量 snapshot 来存储快 照。每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这 个迭代器自己持有的快照来进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnapshotArrayIterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cursor;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;E&gt; snapshot;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SnapshotArrayIterator</span><span class="params">(ArrayList&lt;E&gt; arrayList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cursor = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.snapshot = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.snapshot.addAll(arrayList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">currentItem</span> <span class="operator">=</span> snapshot.get(cursor);</span><br><span class="line">        cursor++;</span><br><span class="line">        <span class="keyword">return</span> currentItem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：这个解决方案虽然简单，但代价也有点高。每次创建迭代器的时候，都要拷贝一份数据到快 照中，会增加内存的消耗。如果一个容器同时有多个迭代器在遍历元素，就会导致数据在内 存中重复存储多份。不过，庆幸的是，Java 中的拷贝属于浅拷贝，也就是说，容器中的对 象并非真的拷贝了多份，而只是拷贝了对象的引用而已。</p><h1 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h1><p>我们可以在容器中，为每个元素保存两个时间戳，一个是添加时间戳 addTimestamp，一 个是删除时间戳 delTimestamp。</p><p>当元素被加入到集合中的时候，我们将 addTimestamp 设置为当前时间，将 delTimestamp 设置成最大长整型值。当元素被删除时，我们将 delTimestamp 更新为当前时间，表示已经被删除。</p><p>这里只是标记删除，而非真正将它从容器中删除。</p><p>同时，每个迭代器也保存一个迭代器创建时间戳 snapshotTimestamp，也就是迭代器对应 的快照的创建时间戳。当使用迭代器来遍历容器的时候，只有满足 addTimestamp&lt;snapshotTimestamp&lt;delTimestamp的元素，才是属于这个迭代器的快照。</p><p>可以将元素删除时间以及创建时间与迭代器的创建时间进行比较，来判断该元素是否是当前快照中的元素，这样就在不复制的情况下做到了快照，同时因为删除是标记删除，也不会造成影响，而且添加新的元素也不会被遍历到。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如何实现一个支持“快照”功能的迭代器？&lt;/p&gt;
&lt;p&gt;所谓“快照”，指我们为容器创建迭代器的 时候，相当于给容器拍了一张快照（Snapshot）。之后即便我们增删容器中的元素，快照 中的元素并不会做相应的改动。而迭代器遍历的对象是快照而非容器，这样就避免了在使用 迭代器遍历</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
