<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便起个名字吧</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-06-07T08:20:25.757Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Guo Junhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单例模式（下）</title>
    <link href="http://example.com/2023/06/07/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://example.com/2023/06/07/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2023-06-07T07:21:16.000Z</published>
    <updated>2023-06-07T08:20:25.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何理解单例模式中的唯一性"><a href="#如何理解单例模式中的唯一性" class="headerlink" title="如何理解单例模式中的唯一性"></a>如何理解单例模式中的唯一性</h1><p>这个唯一性指的是进程内只允许创建一个对象。</p><h1 id="如何实现线程唯一的单例"><a href="#如何实现线程唯一的单例" class="headerlink" title="如何实现线程唯一的单例"></a>如何实现线程唯一的单例</h1><p>“进程唯一”指的是进程内唯一，进程间不唯一。“线程唯一”指的是线程内唯 一，线程间可以不唯一。</p><p>我们通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以 做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本 身提供了 ThreadLocal 工具类，可以更加轻松地实现线程唯一单例。不过，ThreadLocal 底层实现原理也是基于下面代码中所示的 HashMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Long, IdGenerator&gt; instances</span><br><span class="line">        = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">currentThreadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">        instances.putIfAbsent(currentThreadId, <span class="keyword">new</span> <span class="title class_">IdGenerator</span>());</span><br><span class="line">        <span class="keyword">return</span> instances.get(currentThreadId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何实现集群环境下的单例"><a href="#如何实现集群环境下的单例" class="headerlink" title="如何实现集群环境下的单例"></a>如何实现集群环境下的单例</h1><p>集群相当于多个进程构成的 一个集合，“集群唯一”就相当于是进程内唯一、进程间也唯一。也就是说，不同的进程间 共享同一个对象，不能创建同一个类的多个对象。</p><p>具体来说，我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在 使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对 象，然后再使用，使用完成之后还需要再存储回外部共享存储区。</p><p>为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对 象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内 存中删除，并且释放对对象的加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IdGenerator instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SharedObjectStorage</span> <span class="variable">storage</span> <span class="operator">=</span> FileSharedObjectStorage();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DistributedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DistributedLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            instance = storage.load(IdGenerator.class);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> synchroinzed <span class="keyword">void</span> <span class="title function_">freeInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        storage.save(<span class="built_in">this</span>, IdGeneator.class);</span><br><span class="line">        instance = <span class="literal">null</span>; <span class="comment">//释放对象</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// IdGenerator使用举例</span></span><br><span class="line"><span class="type">IdGenerator</span> <span class="variable">idGeneator</span> <span class="operator">=</span> IdGenerator.getInstance();</span><br><span class="line"><span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> idGenerator.getId();</span><br><span class="line">IdGenerator.freeInstance();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何理解单例模式中的唯一性&quot;&gt;&lt;a href=&quot;#如何理解单例模式中的唯一性&quot; class=&quot;headerlink&quot; title=&quot;如何理解单例模式中的唯一性&quot;&gt;&lt;/a&gt;如何理解单例模式中的唯一性&lt;/h1&gt;&lt;p&gt;这个唯一性指的是进程内只允许创建一个对象。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式（中）</title>
    <link href="http://example.com/2023/06/07/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
    <id>http://example.com/2023/06/07/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%AD%EF%BC%89/</id>
    <published>2023-06-07T06:40:38.000Z</published>
    <updated>2023-06-07T07:20:22.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例存在的问题"><a href="#单例存在的问题" class="headerlink" title="单例存在的问题"></a>单例存在的问题</h1><p>我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息 类、连接池类、ID 生成器类，但 是，这种使用方法有点类似硬编码（hard code），会带来诸多问题。</p><h2 id="1、对-OOP-特性的支持不友好"><a href="#1、对-OOP-特性的支持不友好" class="headerlink" title="1、对 OOP 特性的支持不友好"></a>1、对 OOP 特性的支持不友好</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(...)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> IdGenerator.getInstance().getId();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(...)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> IdGenerator.getInstance().getId();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种涉及违背了基于接口而非实现的设计原则，如果未来某一天，我们希望针对不同的业务采用不同的 ID 生成算法。 比如，订单 ID 和用户 ID 采用不同的 ID 生成器来生成。为了应对这个需求变化，我们需要修改所有用到 IdGenerator 类的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(...)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> IdGenerator.getInstance().getId();</span><br><span class="line">        <span class="comment">// 需要将上面一行代码，替换为下面一行代码</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> OrderIdGenerator.getIntance().getId();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(...)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> IdGenerator.getInstance().getId();</span><br><span class="line">        <span class="comment">// 需要将上面一行代码，替换为下面一行代码</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> UserIdGenerator.getIntance().getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，单例对继承、多态特性的支持也不友好。</p><h2 id="2、单例会隐藏类之间的依赖关系"><a href="#2、单例会隐藏类之间的依赖关系" class="headerlink" title="2、单例会隐藏类之间的依赖关系"></a>2、单例会隐藏类之间的依赖关系</h2><p>通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能 很容易识别出来。但是，单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用 就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。</p><h2 id="3、单例对代码的扩展性不友好"><a href="#3、单例对代码的扩展性不友好" class="headerlink" title="3、单例对代码的扩展性不友好"></a>3、单例对代码的扩展性不友好</h2><p>比如，在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据 库连接资源的消耗。所以，我们把数据库连接池类设计成了单例类。</p><p>但之后我们发现，系统 中有些 SQL 语句运行得非常慢。这些 SQL 语句在执行的时候，长时间占用数据库连接资源，导致其他 SQL 请求无法响应。为了解决这个问题，我们希望将慢 SQL 与其他 SQL 隔 离开来执行。</p><p>为了实现这样的目的，我们可以在系统中创建两个数据库连接池，慢 SQL 独 享一个数据库连接池，其他 SQL 独享另外一个数据库连接池，这样就能避免慢 SQL 影响到 其他 SQL 的执行。</p><h2 id="4、单例对代码的可测试性不友好"><a href="#4、单例对代码的可测试性不友好" class="headerlink" title="4、单例对代码的可测试性不友好"></a>4、单例对代码的可测试性不友好</h2><p>如果单例类依赖比较重的外部资源，比如 DB， 我们在写单元测试的时候，希望能通过 mock 的方式将它替换掉。而单例类这种硬编码式 的使用方式，导致无法实现 mock 替换。</p><p>而且单例往往可以理解为一个全局唯一的变量，在编写单元测试时，需要注意不同测试用例之间修改了单例的值，对测试结果的影响。</p><h2 id="5、单例不支持有参数的构造函数"><a href="#5、单例不支持有参数的构造函数" class="headerlink" title="5、单例不支持有参数的构造函数"></a>5、单例不支持有参数的构造函数</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单例存在的问题&quot;&gt;&lt;a href=&quot;#单例存在的问题&quot; class=&quot;headerlink&quot; title=&quot;单例存在的问题&quot;&gt;&lt;/a&gt;单例存在的问题&lt;/h1&gt;&lt;p&gt;我们在项目中使用单例，都是用它来表示一些全局唯一类，比如配置信息 类、连接池类、ID 生成器类，但 </summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式（上）</title>
    <link href="http://example.com/2023/06/06/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://example.com/2023/06/06/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2023-06-06T02:18:00.000Z</published>
    <updated>2023-06-06T03:24:44.153Z</updated>
    
    <content type="html"><![CDATA[<p>单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p><h1 id="案例1：处理资源访问冲突"><a href="#案例1：处理资源访问冲突" class="headerlink" title="案例1：处理资源访问冲突"></a>案例1：处理资源访问冲突</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class="line">        writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>); <span class="comment">//true表示追加写入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        writer.write(mesasge);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Logger类的应用示例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">        logger.log(username + <span class="string">&quot; logined!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(OrderVo order)</span> &#123;</span><br><span class="line">        <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">        logger.log(<span class="string">&quot;Created an order: &quot;</span> + order.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的例子可以看出，我们在两个controller中创建了两个Logger对象，在多线程环境下，如果两个 Servlet 线程同时分别执行 login() 和 create() 两个函数，同时写入日志文件，则可能会导致日志互相覆盖的情况。</p><h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><h3 id="1、加锁"><a href="#1、加锁" class="headerlink" title="1、加锁"></a>1、加锁</h3><p>我们可以给Logger对象加一把类级别的锁，同一时刻只有一个线程可以访问Logger对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class="line">        writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>); <span class="comment">//true表示追加写入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Logger.class) &#123; <span class="comment">// 类级别的锁</span></span><br><span class="line">            writer.write(mesasge);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，分布式锁以及并发队列也可以解决这个问题。</p><h3 id="2、单例模式"><a href="#2、单例模式" class="headerlink" title="2、单例模式"></a>2、单例模式</h3><p>我们将 Logger 设计成一个单例类，程序中只允许创建一个 Logger 对象，所有的线程共享 使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线 程安全的，也就避免了多线程情况下写日志会互相覆盖的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Logger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/wangzheng/log.txt&quot;</span>);</span><br><span class="line">        writer = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file, <span class="literal">true</span>); <span class="comment">//true表示追加写入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        writer.write(mesasge);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Logger类的应用示例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">        Logger.getInstance().log(username + <span class="string">&quot; logined!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(OrderVo order)</span> &#123;</span><br><span class="line">        <span class="comment">// ...省略业务逻辑代码...</span></span><br><span class="line">        Logger.getInstance().log(<span class="string">&quot;Created a order: &quot;</span> + order.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="案例2：表示全局唯一类"><a href="#案例2：表示全局唯一类" class="headerlink" title="案例2：表示全局唯一类"></a>案例2：表示全局唯一类</h1><p>从业务概念上，如果有些数据在系统中只应保存一份，那就比较适合设计为单例类，比如配置信息类，全局唯一id的生成器类等。</p><p>此处省略代码。</p><h1 id="如何实现一个单例？"><a href="#如何实现一个单例？" class="headerlink" title="如何实现一个单例？"></a>如何实现一个单例？</h1><p>实现单例需要关注以下几个点：</p><ul><li>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；</li><li>考虑对象创建时的线程安全问题；</li><li>考虑是否支持延迟加载；</li><li>考虑 getInstance() 性能是否高（是否加锁）。</li></ul><h2 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1. 饿汉式"></a>1. 饿汉式</h2><p>饿汉式的实现方式比较简单。在类加载的时候，instance 静态实例就已经创建并初始化好 了，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式不支持延迟加 载（在真正用到 IdGenerator 的时候，再创建实例）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">IdGenerator</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdGenerator</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2. 懒汉式"></a>2. 懒汉式</h2><p>懒汉式相对于饿汉式的优势是支持延迟加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IdGenerator instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">IdGenerator</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点也很明显，我们加了锁，导致并发度之有1，即串行操作，如果频繁的被用到，则会影响性能。</p><h2 id="3-双重检测"><a href="#3-双重检测" class="headerlink" title="3. 双重检测"></a>3. 双重检测</h2><p>该方法既支持延迟 加载、又支持高并发的单例实现方式。该方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再 进入到加锁逻辑中了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IdGenerator instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(IdGenerator.class) &#123; <span class="comment">// 此处为类级别的锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">IdGenerator</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现在低版本的jdk中，会因指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。我们需要给 instance 成员变量加上 volatile 关键字，禁止指令重排序才 行。</p><p>但是在高版本的jdk不存在这个问题。</p><h2 id="4-静态内部类"><a href="#4-静态内部类" class="headerlink" title="4. 静态内部类"></a>4. 静态内部类</h2><p>它有点 类似饿汉式，但又能做到了延迟加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IdGenerator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">id</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IdGenerator</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">IdGenerator</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdGenerator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会 被加载，这个时候才会创建 instance。insance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;单例设计模式（Singleton Design Pattern）理解起来非常简单。一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。&lt;/p&gt;
&lt;h1 id=&quot;案例1：处理资源访问冲突&quot;&gt;&lt;a href=&quot;#案例1：处</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>NIO优化实现原理</title>
    <link href="http://example.com/2023/05/29/Java/NIO%E4%BC%98%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2023/05/29/Java/NIO%E4%BC%98%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2023-05-29T06:53:42.000Z</published>
    <updated>2023-05-29T12:03:22.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络-I-x2F-O-模型优化"><a href="#网络-I-x2F-O-模型优化" class="headerlink" title="网络 I&#x2F;O 模型优化"></a>网络 I&#x2F;O 模型优化</h1><p>最开始的阻塞式 I&#x2F;O，它在每一个连接创建时，都需要一个用户线程来处理，并且在 I&#x2F;O 操作 没有就绪或结束时，线程会被挂起，进入阻塞等待状态，阻塞式 I&#x2F;O 就成为了导致性能瓶颈的 根本原因。</p><p>首先是一次简单的TCP数据传输：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529150511602.png" alt="image-20230529150511602" style="zoom:67%;" /><p>首先，应用程序通过系统调用 socket 创建一个套接字，它是系统分配给应用程序的一个文件描述符；</p><p>其次，应用程序会通过系统调用 bind，绑定地址和端口号，给套接字命名一个名称； </p><p>然后，系统会调用 listen 创建一个队列用于存放客户端进来的连接； </p><p>最后，应用服务会通过系统调用 accept 来监听客户端的连接请求。</p><h2 id="1-阻塞式-I-x2F-O"><a href="#1-阻塞式-I-x2F-O" class="headerlink" title="1. 阻塞式 I&#x2F;O"></a>1. 阻塞式 I&#x2F;O</h2><p>在整个 socket 通信工作流程中，socket 的默认状态是阻塞的。也就是说，当发出一个不能立 即完成的套接字调用时，其进程将被阻塞，被系统挂起，进入睡眠状态，一直等待相应的操作 响应。从上图中，我们可以发现，可能存在的阻塞主要包括以下三种。</p><p><strong>connect阻塞：</strong></p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529153114099.png" alt="image-20230529153114099" style="zoom:67%;" /><p><strong>accept阻塞：</strong></p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529153138808.png" alt="image-20230529153138808" style="zoom:67%;" /><p><strong>read、write 阻塞：</strong></p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529153200868.png" alt="image-20230529153200868" style="zoom:67%;" /><h2 id="2-非阻塞式-I-x2F-O"><a href="#2-非阻塞式-I-x2F-O" class="headerlink" title="2. 非阻塞式 I&#x2F;O"></a>2. 非阻塞式 I&#x2F;O</h2><p>当我们把以上操作设置为了非阻塞状态，我们需要设置一个线程对该操作进行轮询检查，这也是最传统的非阻塞 I&#x2F;O 模型。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529153340669.png" alt="image-20230529153340669" style="zoom:67%;" /><h2 id="3-I-x2F-O-复用"><a href="#3-I-x2F-O-复用" class="headerlink" title="3. I&#x2F;O 复用"></a>3. I&#x2F;O 复用</h2><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529160244459.png" alt="image-20230529160244459" style="zoom:67%;" /><h2 id="4-信号驱动式-I-x2F-O"><a href="#4-信号驱动式-I-x2F-O" class="headerlink" title="4. 信号驱动式 I&#x2F;O"></a>4. 信号驱动式 I&#x2F;O</h2><p>信号驱动式 I&#x2F;O 类似观察者模式，内核就是一个观察者，信号回调则是通知。用户进程发起一 个 I&#x2F;O 请求操作，会通过系统调用 sigaction 函数，给对应的套接字注册一个信号回调，此时 不阻塞用户进程，进程会继续工作。当内核数据就绪时，内核就为该进程生成一个 SIGIO 信 号，通过信号回调通知进程进行相关 I&#x2F;O 操作。</p><p>信号驱动式 I&#x2F;O 相比于前三种 I&#x2F;O 模式，实现了在等待数据就绪时，进程不被阻塞，主循环可以继续工作，所以性能更佳。</p><h2 id="5-异步-I-x2F-O"><a href="#5-异步-I-x2F-O" class="headerlink" title="5. 异步 I&#x2F;O"></a>5. 异步 I&#x2F;O</h2><p>信号驱动式 I&#x2F;O 虽然在等待数据就绪时，没有阻塞进程，但在被通知后进行的 I&#x2F;O 操作还是 阻塞的，进程会等待数据从内核空间复制到用户空间中。而异步 I&#x2F;O 则是实现了真正的非阻塞 I&#x2F;O。</p><p>当用户进程发起一个 I&#x2F;O 请求操作，系统会告知内核启动某个操作，并让内核在整个操作完成 后通知进程。这个操作包括等待数据就绪和数据从内核复制到用户空间。</p><p>linux不支持，比较少见。</p><p>在 NIO 服务端通信编程中，首先会创建一个 Channel，用于监听客户端连接；接着，创建多 路复用器 Selector，并将 Channel 注册到 Selector，程序会通过 Selector 来轮询注册在其 上的 Channel，当发现一个或多个 Channel 处于就绪状态时，返回就绪的监听事件，最后程 序匹配到监听事件，进行相关的 I&#x2F;O 操作。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529175854015.png" alt="image-20230529175854015" style="zoom:67%;" /><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>零拷贝是一种避免多次内存复制的技术，用来优化读写 I&#x2F;O 操作。</p><p>在网络编程中，通常由 read、write 来完成一次 I&#x2F;O 读写操作。每一次 I&#x2F;O 读写操作都需要 完成四次内存拷贝，路径是 I&#x2F;O 设备 -&gt; 内核空间 -&gt; 用户空间 -&gt; 内核空间 -&gt; 其它 I&#x2F;O 设 备。</p><p>Linux 内核中的 mmap 函数可以代替 read、write 的 I&#x2F;O 读写操作，实现用户空间和内核空间共享一个缓存数据。mmap 将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址，不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射 到物理内存地址。这种方式避免了内核空间与用户空间的数据交换。I&#x2F;O 复用中的 epoll 函数 中就是使用了 mmap 减少了内存拷贝。</p><h2 id="线程模型优化"><a href="#线程模型优化" class="headerlink" title="线程模型优化"></a>线程模型优化</h2><p>NIO 是基于事件驱动模型 来实现的 I&#x2F;O 操作。Reactor 模型是同步 I&#x2F;O 事件处理的一种常见模型，其核心思想是将 I&#x2F;O 事件注册到多路复用器上，一旦有 I&#x2F;O 事件触发，多路复用器就会将事件分发到事件处理器 中，执行就绪的 I&#x2F;O 事件操作。</p><p>该模型有以下三个主要组件：</p><p>事件接收器 Acceptor：主要负责接收请求连接； </p><p>事件分离器 Reactor：接收请求后，会将建立的连接注册到分离器中，依赖于循环监听多路 复用器 Selector，一旦监听到事件，就会将事件 dispatch 到事件处理器； </p><p>事件处理器 Handlers：事件处理器主要是完成相关的事件处理，比如读写 I&#x2F;O 操作。</p><h3 id="1-单线程-Reactor-线程模型"><a href="#1-单线程-Reactor-线程模型" class="headerlink" title="1. 单线程 Reactor 线程模型"></a>1. 单线程 Reactor 线程模型</h3><p>最开始 NIO 是基于单线程实现的，所有的 I&#x2F;O 操作都是在一个 NIO 线程上完成。由于 NIO 是非阻塞 I&#x2F;O，理论上一个线程可以完成所有的 I&#x2F;O 操作。</p><p>但 NIO 其实还不算真正地实现了非阻塞 I&#x2F;O 操作，因为读写 I&#x2F;O 操作时用户进程还是处于阻 塞状态，这种方式在高负载、高并发的场景下会存在性能瓶颈，一个 NIO 线程如果同时处理 上万连接的 I&#x2F;O 操作，系统是无法支撑这种量级的请求的。</p><h3 id="2-多线程-Reactor-线程模型"><a href="#2-多线程-Reactor-线程模型" class="headerlink" title="2. 多线程 Reactor 线程模型"></a>2. 多线程 Reactor 线程模型</h3><p>为了解决这种单线程的 NIO 在高负载、高并发场景下的性能瓶颈，后来使用了线程池。</p><p>在 Tomcat 和 Netty 中都使用了一个 Acceptor 线程来监听连接请求事件，当连接成功之 后，会将建立的连接注册到多路复用器中，一旦监听到事件，将交给 Worker 线程池来负责处理。</p><h3 id="3-主从-Reactor-线程模型"><a href="#3-主从-Reactor-线程模型" class="headerlink" title="3. 主从 Reactor 线程模型"></a>3. 主从 Reactor 线程模型</h3><p>现在主流通信框架中的 NIO 通信框架都是基于主从 Reactor 线程模型来实现的。在这个模型 中，Acceptor 不再是一个单独的 NIO 线程，而是一个线程池。Acceptor 接收到客户端的 TCP 连接请求，建立连接之后，后续的 I&#x2F;O 操作将交给 Worker I&#x2F;O 线程。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230529200317906.png" alt="image-20230529200317906" style="zoom:67%;" /><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Java性能调优实战》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络-I-x2F-O-模型优化&quot;&gt;&lt;a href=&quot;#网络-I-x2F-O-模型优化&quot; class=&quot;headerlink&quot; title=&quot;网络 I&amp;#x2F;O 模型优化&quot;&gt;&lt;/a&gt;网络 I&amp;#x2F;O 模型优化&lt;/h1&gt;&lt;p&gt;最开始的阻塞式 I&amp;#x2F;O</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="其他" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="调优" scheme="http://example.com/tags/%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>Java的I/O</title>
    <link href="http://example.com/2023/05/26/Java/Java%E7%9A%84I-O/"/>
    <id>http://example.com/2023/05/26/Java/Java%E7%9A%84I-O/</id>
    <published>2023-05-26T02:57:20.000Z</published>
    <updated>2023-05-26T05:07:27.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是I-x2F-O流"><a href="#什么是I-x2F-O流" class="headerlink" title="什么是I&#x2F;O流"></a>什么是I&#x2F;O流</h1><p>我们通常把机器或者应用程序接收外界的信息称为输入流（InputStream），从机器或者应用程 序向外输出的信息称为输出流（OutputStream），合称为输入 &#x2F; 输出流（I&#x2F;O Streams）。</p><p>Java 的 I&#x2F;O 分为以下两类：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230526110237837.png" alt="image-20230526110237837" style="zoom:67%;" /><p>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么还要存在字符流呢？</p><p>字符到字节必须经过转码，这个过程非常耗时，如果我们不知道编码类型就很容易出现乱码问题，所以提供了直接操作字符的接口。</p><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230526110336147.png" alt="image-20230526110336147" style="zoom:67%;" /><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230526110352335.png" alt="image-20230526110352335" style="zoom:67%;" /><h1 id="传统I-x2F-O的性能问题"><a href="#传统I-x2F-O的性能问题" class="headerlink" title="传统I&#x2F;O的性能问题"></a>传统I&#x2F;O的性能问题</h1><h2 id="1-多次内存复制"><a href="#1-多次内存复制" class="headerlink" title="1. 多次内存复制"></a>1. 多次内存复制</h2><p>在传统 I&#x2F;O 中，我们可以通过 InputStream 从源数据中读取数据流输入到缓冲区里，通过 OutputStream 将数据输出到外部设备（包括磁盘、网络），输入操作在操作系统中的具体流程如下：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230526110921118.png" alt="image-20230526110921118" style="zoom:67%;" /><p>JVM 会发出 read() 系统调用，并通过 read 系统调用向内核发起读请求； </p><p>内核向硬件发送读指令，并等待读就绪； </p><p>内核把将要读取的数据复制到指向的内核缓存中；</p><p>操作系统内核将数据复制到用户空间缓冲区，然后 read 系统调用返回。</p><p>数据先从外部设备复制到内核空间，再从内核空间复制到用户空间，这就发生 了两次内存复制操作。</p><h2 id="2-阻塞"><a href="#2-阻塞" class="headerlink" title="2. 阻塞"></a>2. 阻塞</h2><p>在传统 I&#x2F;O 中，InputStream 的 read() 是一个 while 循环操作，它会一直等待数据读取，直到数据就绪才会返回。这就意味着如果没有数据就绪，这个读取操作将会一直被挂起，用户线程将会处于阻塞状态。</p><p>这种处理方式在少量连接没问题，但在发生大量连接请求时，就需要创建大量监听线程，这时如果线程没有数据就绪就会被挂起，然后进入阻塞状态。 一旦发生线程阻塞，这些线程将会不断地抢夺 CPU 资源，从而导致大量的 CPU 上下文切换，增加系统的性能开销。</p><h1 id="如何优化-I-x2F-O-操作"><a href="#如何优化-I-x2F-O-操作" class="headerlink" title="如何优化 I&#x2F;O 操作"></a>如何优化 I&#x2F;O 操作</h1><p>NIO 的发布优化了内存复制以及阻塞导致的 严重性能问题，NIO2提出了从操作系统层面实现的异步 I&#x2F;O。</p><h2 id="1-使用缓冲区优化读写流操作"><a href="#1-使用缓冲区优化读写流操作" class="headerlink" title="1. 使用缓冲区优化读写流操作"></a>1. 使用缓冲区优化读写流操作</h2><p>NIO是基于块的，在 NIO 中， 最为重要的两个组件是缓冲区（Buffer）和通道（Channel）。Buffer 是一块连续的内存块， 是 NIO 读写数据的中转地。Channel 表示缓冲数据的源头或者目的地，它用于读取缓冲或者写入数据，是访问缓冲的接口。</p><p>NIO 是面向 Buffer。Buffer 可以将文 件一次性读入内存再做后续处理，而传统的方式是边读文件边处理数据。</p><h2 id="2-使用-DirectBuffer-减少内存复制"><a href="#2-使用-DirectBuffer-减少内存复制" class="headerlink" title="2. 使用 DirectBuffer 减少内存复制"></a>2. 使用 DirectBuffer 减少内存复制</h2><p>NIO 的 Buffer 除了做了缓冲块优化之外，还提供了一个可以直接访问物理内存的类 DirectBuffer。普通的 Buffer 分配的是 JVM 堆内存，而 DirectBuffer 是直接分配物理内存 (非堆内存)。</p><p>数据要输出到外部设备，必须先从用户空间复制到内核空间，再复制到输出设备，而在 Java 中，在用户空间中又存在一个拷贝，那就是从 <strong>Java 堆内存中拷贝到临时的直接内存中</strong>，通过<strong>临时的直接内存拷贝到内存空间中</strong>去。此时的直接内存和堆内存都是属于用户空间。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230526112218554.png" alt="image-20230526112218554" style="zoom:67%;" /><p>如果单纯使用 Java 堆内存进行数据拷贝，当拷贝的数据量比较大的情况下，Java 堆的 GC 压力会比较大，而使用非堆内存可以减低 GC 的压力。</p><p>DirectBuffer 则是直接将步骤简化为数据直接保存到非堆内存，从而减少了一次数据拷贝。</p><p>由于 DirectBuffer 申请的是非 JVM 的物理内存，所以创建和销毁的代价很 高。DirectBuffer 申请的内存并不是直接由 JVM 负责垃圾回收，但在 DirectBuffer 包装类被 回收时，会通过 Java Reference 机制来释放该内存块。</p><p>MappedByteBuffer 是通过本 地类调用 mmap 进行文件内存映射的，map() 系统调用方法会直接将文件从硬盘拷贝到用户 空间，只进行一次数据拷贝，从而减少了传统的 read() 方法从硬盘拷贝到内核空间这一步。</p><h2 id="3-避免阻塞，优化-I-x2F-O-操作"><a href="#3-避免阻塞，优化-I-x2F-O-操作" class="headerlink" title="3. 避免阻塞，优化 I&#x2F;O 操作"></a>3. 避免阻塞，优化 I&#x2F;O 操作</h2><p>传统的 I&#x2F;O 即使使用了缓冲块，依然存在阻塞问题。由于线程池线程数量有限，一旦发生大量 并发请求，超过最大数量的线程就只能等待，直到线程池中有空闲的线程可以被复用。而对 Socket 的输入流进行读取时，读取流会一直阻塞，直到发生以下三种情况的任意一种才会解 除阻塞：</p><p>1、有数据可读； </p><p>2、连接释放； </p><p>3、空指针或 I&#x2F;O 异常。</p><p>NIO 发布后，通道和多路复用器这两个基本组件实现 了 NIO 的非阻塞</p><h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>最开始，在应用程序调用操作系统 I&#x2F;O 接口时，是由 CPU 完成分配，这种方式最大的问题是 “发生大量 I&#x2F;O 请求时，非常消耗 CPU“；之后，操作系统引入了 DMA（直接存储器存 储），内核空间与磁盘之间的存取完全由 DMA 负责，但这种方式依然需要向 CPU 申请权 限，且需要借助 DMA 总线来完成数据的复制操作，如果 DMA 总线过多，就会造成总线冲突。</p><p>Channel 有自己的处理器，可以完成内核空间和磁盘之间的 I&#x2F;O 操作。在 NIO 中，我们读取和写入数据都要通过 Channel，由于 Channel 是双向的，所以 读、写可以同时进行。</p><h3 id="多路复用器（Selector）"><a href="#多路复用器（Selector）" class="headerlink" title="多路复用器（Selector）"></a>多路复用器（Selector）</h3><p>Selector 是 Java NIO 编程的基础。用于检查一个或多个 NIO Channel 的状态是否处于可 读、可写。</p><p>Selector 是基于事件驱动实现的，我们可以在 Selector 中注册 accpet、read 监听事件， Selector 会不断轮询注册在其上的 Channel，如果某个 Channel 上面发生监听事件，这个 Channel 就处于就绪状态，然后进行 I&#x2F;O 操作。</p><p>一个线程使用一个 Selector，通过轮询的方式，可以监听多个 Channel 上的事件。我们可以 在注册 Channel 时设置该通道为非阻塞，当 Channel 上没有 I&#x2F;O 操作时，该线程就不会一直 等待了，而是会不断轮询所有 Channel，从而避免发生阻塞。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Java性能调优实战》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是I-x2F-O流&quot;&gt;&lt;a href=&quot;#什么是I-x2F-O流&quot; class=&quot;headerlink&quot; title=&quot;什么是I&amp;#x2F;O流&quot;&gt;&lt;/a&gt;什么是I&amp;#x2F;O流&lt;/h1&gt;&lt;p&gt;我们通常把机器或者应用程序接收外界的信息称为输入流（InputS</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="其他" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="调优" scheme="http://example.com/tags/%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>Java的Stream</title>
    <link href="http://example.com/2023/05/24/Java/Java%E7%9A%84Stream/"/>
    <id>http://example.com/2023/05/24/Java/Java%E7%9A%84Stream/</id>
    <published>2023-05-24T14:18:39.000Z</published>
    <updated>2023-05-26T02:57:48.067Z</updated>
    
    <content type="html"><![CDATA[<p> 需求：过滤分组一所中学里身高在 160cm 以上的男女同学</p><p>之前的代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; stuMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;Student&gt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Student stu: studentsList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stu.getHeight() &gt; <span class="number">160</span>) &#123; <span class="comment">//如果身高大于160</span></span><br><span class="line">        <span class="keyword">if</span> (stuMap.get(stu.getSex()) == <span class="literal">null</span>) &#123; <span class="comment">//该性别还没分类</span></span><br><span class="line">            List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;(); <span class="comment">//新建该性别学生的</span></span><br><span class="line">            list.add(stu);<span class="comment">//将学生放进去列表</span></span><br><span class="line">            stuMap.put(stu.getSex(), list);<span class="comment">//将列表放到map中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//该性别分类已存在</span></span><br><span class="line">            stuMap.get(stu.getSex()).add(stu);<span class="comment">//该性别分类已存在，则直接放进去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Stream API实现：</p><p>串行实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; stuMap = stuList.stream().filter((Student s) -&gt; s.getHeight() &gt; <span class="number">160</span>) .collect(Collectors.groupingBy(Student ::getSex)); </span><br></pre></td></tr></table></figure><p>并行实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; stuMap = stuList.parallelStream().filter((Student s) -&gt; s.getHeight() &gt; <span class="number">160</span>) .collect(Collectors.groupingBy(Student ::getSex)); </span><br></pre></td></tr></table></figure><h1 id="Stream-如何优化遍历"><a href="#Stream-如何优化遍历" class="headerlink" title="Stream 如何优化遍历"></a>Stream 如何优化遍历</h1><p>官方将 Stream 中的操作分为两大类：中间操作（Intermediate operations）和终结操作（Terminal operations）</p><p>中间操作只对操作进行了记录，即只会返回一个流，不会进行计算操作，而终结操作是实现了计算操作。</p><p>中间操作又可以分为无状态（Stateless）与有状态（Stateful）操作，前者是指元素的处理不受之前元素的影响，后者是指该操作只有拿到所有元素之后才能继续下去。</p><p>终结操作又可以分为短路（Short-circuiting）与非短路（Unshort-circuiting）操作，前者是指遇到某些符合条件的元素就可以得到最终结果，后者是指必须处理完所有元素才能得到最终结果。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230524223653374.png" alt="image-20230524223653374"></p><p>Stream如何迭代大数据集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王老五&quot;</span>, <span class="string">&quot;李三&quot;</span>, <span class="string">&quot;刘老四&quot;</span>, <span class="string">&quot;王小二&quot;</span>, <span class="string">&quot;张四&quot;</span>, <span class="string">&quot;张五六七&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">maxLenStartWithZ</span> <span class="operator">=</span> names.stream()</span><br><span class="line">                  .filter(name -&gt; name.startsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">                  .mapToInt(String::length)</span><br><span class="line">                  .max()</span><br><span class="line">                  .toString();</span><br></pre></td></tr></table></figure><p>Stream 并行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王老五&quot;</span>, <span class="string">&quot;李三&quot;</span>, <span class="string">&quot;刘老四&quot;</span>, <span class="string">&quot;王小二&quot;</span>, <span class="string">&quot;张四&quot;</span>, <span class="string">&quot;张五六七&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">maxLenStartWithZ</span> <span class="operator">=</span> names.stream()</span><br><span class="line">                  .parallel()</span><br><span class="line">                  .filter(name -&gt; name.startsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">                  .mapToInt(String::length)</span><br><span class="line">                  .max()</span><br><span class="line">                  .toString();</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Java性能调优实战》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 需求：过滤分组一所中学里身高在 160cm 以上的男女同学&lt;/p&gt;
&lt;p&gt;之前的代码实现如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    
    <category term="Stream" scheme="http://example.com/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>接口和抽象类</title>
    <link href="http://example.com/2023/05/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>http://example.com/2023/05/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</id>
    <published>2023-05-24T06:48:59.000Z</published>
    <updated>2023-05-26T02:58:24.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="抽象类的例子"><a href="#抽象类的例子" class="headerlink" title="抽象类的例子"></a>抽象类的例子</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> enabled;</span><br><span class="line">    <span class="keyword">private</span> Level minPermittedLevel;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.enabled = enabled;</span><br><span class="line">        <span class="built_in">this</span>.minPermittedLevel = minPermittedLevel;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loggable</span> <span class="operator">=</span> enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intVal)</span><br><span class="line">            <span class="keyword">if</span> (!loggable) <span class="keyword">return</span>;</span><br><span class="line">        doLog(level, message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">(Level level, String message)</span>;                    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类的子类：输出日志到文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Writer fileWriter;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel, String filepath)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">        <span class="built_in">this</span>.fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(filepath);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">(Level level, String mesage)</span> &#123;</span><br><span class="line">        <span class="comment">// 格式化 level 和 message, 输出到日志文件</span></span><br><span class="line">        fileWriter.write(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类的子类: 输出日志到消息中间件 (比如 kafka)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageQueueLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MessageQueueClient msgQueueClient;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageQueueLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled,</span></span><br><span class="line"><span class="params">                              Level minPermittedLevel, MessageQueueClient msgQueueClient)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">    <span class="built_in">this</span>.msgQueueClient = msgQueueClient;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">(Level level, String mesage)</span> &#123;</span><br><span class="line">        <span class="comment">// 格式化 level 和 message, 输出到消息中间件</span></span><br><span class="line">        msgQueueClient.send(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类不允许被实例化，只能被继承。也就是说，你不能 new 一个抽象类的对象出来 （Logger logger &#x3D; new Logger(…); 会报编译错误）。 </p><p>抽象类可以包含属性和方法。方法既可以包含代码实现（比如 Logger 中的 log() 方 法），也可以不包含代码实现（比如 Logger 中的 doLog() 方法）。不包含代码实现的 方法叫作抽象方法。 </p><p>子类继承抽象类，必须实现抽象类中的所有抽象方法。对应到例子代码中就是，所有继 承 Logger 抽象类的子类，都必须重写 doLog() 方法。</p><h1 id="接口的例子"><a href="#接口的例子" class="headerlink" title="接口的例子"></a>接口的例子</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现类：鉴权过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthencationFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="comment">//... 鉴权逻辑..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现类：限流过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimitFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="comment">//... 限流逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 过滤器使用 demo</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="comment">// filters.add(new AuthencationFilter());</span></span><br><span class="line">    <span class="comment">// filters.add(new RateLimitFilter());</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Filter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRpcRequest</span><span class="params">(RpcRequest req)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Filter filter : fitlers) &#123;</span><br><span class="line">                filter.doFilter(req);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(RpcException e) &#123;</span><br><span class="line">            <span class="comment">// ... 处理过滤结果...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... 省略其他处理逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口不能包含属性（也就是成员变量）。 </p><p>接口只能声明方法，方法不能包含代码实现。 </p><p>类实现接口的时候，必须实现接口中声明的所有方法.</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>接口和抽象类，他们要解决的问题不一样 ，首先接口是为了解耦，而抽象类是为了减少编写重复的代码。</p><p>比如说类A和类B都要写一个方法doSomething，那么就可以写一个抽象类，然后A和B都继承该抽象类，而且类A和B可以各自添加各自的功能。</p><p>而接口的解耦体现在，我们定义一个接口之后，他可以有多个实现，我们基于他不同的实现来达到对于模块的划分，隔离接口和具体的实现，提高代码的扩展性。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;抽象类的例子&quot;&gt;&lt;a href=&quot;#抽象类的例子&quot; class=&quot;headerlink&quot; title=&quot;抽象类的例子&quot;&gt;&lt;/a&gt;抽象类的例子&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="http://example.com/2023/05/23/Java/ThreadLocal/"/>
    <id>http://example.com/2023/05/23/Java/ThreadLocal/</id>
    <published>2023-05-23T08:05:22.000Z</published>
    <updated>2023-05-23T08:46:10.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal-的使用方法"><a href="#ThreadLocal-的使用方法" class="headerlink" title="ThreadLocal 的使用方法"></a>ThreadLocal 的使用方法</h1><p>下面这个静态类 ThreadId 会为每个线程分配一个唯一的线程 Id，如果<strong>一个线程</strong>前后两次调用 ThreadId 的 get() 方法，两次 get() 方法的返回值是相同的。但如果是<strong>两个线程</strong>分别调用 ThreadId 的 get() 方法，那么两个线程看到的 get() 方法的返回值是不同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadId</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">nextId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 定义ThreadLocal变量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; tl = ThreadLocal.withInitial(() -&gt; nextId.getAndIncrement());</span><br><span class="line">  <span class="comment">//此方法会为每个线程分配一个唯一的Id</span></span><br><span class="line">  <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tl.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个使用场景：</p><p>SimpleDateFormat 不是线程安全的，那如果需要在并发场景下使用它，就可以使用ThreadLocal 来解决。不同线程调用 SafeDateFormat 的 get() 方法将返回不同的 SimpleDateFormat 对象实例，由于不同线程并不共享 SimpleDateFormat，所以就像局部变量一样，是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SafeDateFormat</span> &#123;</span><br><span class="line">  <span class="comment">// 定义ThreadLocal变量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; tl = ThreadLocal.withInitial(()-&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(</span><br><span class="line">      <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> DateFormat <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tl.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不同线程执行下面代码</span></span><br><span class="line"><span class="comment">// 返回的df是不同的</span></span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> SafeDateFormat.get()；</span><br></pre></td></tr></table></figure><h1 id="ThreadLocal-的工作原理"><a href="#ThreadLocal-的工作原理" class="headerlink" title="ThreadLocal 的工作原理"></a>ThreadLocal 的工作原理</h1><p>Java对于ThreadLocal 的实现，也有一个Map，叫做 ThreadLocalMap，不过持有 ThreadLocalMap 的不是 ThreadLocal，而是 Thread。Thread 这个类内部有一个私有属性 threadLocals，其类型就是 ThreadLocalMap，ThreadLocalMap 的 Key 是 ThreadLocal。如下图所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230523162923334.png" alt="image-20230523162923334" style="zoom:80%;" /><h2 id="另一种设计方案"><a href="#另一种设计方案" class="headerlink" title="另一种设计方案"></a>另一种设计方案</h2><p>如果我们仅仅是简单的用一个Map来保存，即Map的key是线程id，value是每个线程拥有的变量V。这样会导致一个问题，那就是线程的id一直被引用，导致线程资源无法被回收。</p><h1 id="ThreadLocal-与内存泄露"><a href="#ThreadLocal-与内存泄露" class="headerlink" title="ThreadLocal 与内存泄露"></a>ThreadLocal 与内存泄露</h1><p>在线程池中使用 ThreadLocal 为什么可能导致内存泄露呢？原因就出在线程池中线程的存活时间太长，往往都是和程序同生共死的，这就意味着 Thread 持有的 ThreadLocalMap 一直都不会被回收，再加上 ThreadLocalMap 中的 Entry 对 ThreadLocal 是弱引用（WeakReference），所以只要 ThreadLocal 结束了自己的生命周期是可以被回收掉的。但是 Entry 中的 Value 却是被 Entry 强引用的，所以即便 Value 的生命周期结束了，Value 也是无法被回收的，从而导致内存泄露。</p><p>所以我们要手动释放，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es;</span><br><span class="line">ThreadLocal tl;</span><br><span class="line">es.execute(()-&gt;&#123;</span><br><span class="line">  <span class="comment">//ThreadLocal增加变量</span></span><br><span class="line">  tl.set(obj);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 省略业务逻辑代码</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//手动清理ThreadLocal </span></span><br><span class="line">    tl.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ThreadLocal-的使用方法&quot;&gt;&lt;a href=&quot;#ThreadLocal-的使用方法&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal 的使用方法&quot;&gt;&lt;/a&gt;ThreadLocal 的使用方法&lt;/h1&gt;&lt;p&gt;下面这个静态类 Th</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Copy-on-Write模式</title>
    <link href="http://example.com/2023/05/22/Java/Copy-on-Write/"/>
    <id>http://example.com/2023/05/22/Java/Copy-on-Write/</id>
    <published>2023-05-22T06:19:56.000Z</published>
    <updated>2023-05-22T06:36:19.561Z</updated>
    
    <content type="html"><![CDATA[<p>Copy-on-Write顾名思义就是<strong>写时复制</strong>。比如String的replace()方法就采用了写时复制，即不修改原字符串，而是创建了一个新的，对于不可变对象的写操作往往都是Copy-on-Write方法解决的。</p><h1 id="Copy-on-Write-模式的应用领域"><a href="#Copy-on-Write-模式的应用领域" class="headerlink" title="Copy-on-Write 模式的应用领域"></a>Copy-on-Write 模式的应用领域</h1><p>类 Unix 的操作系统中创建进程的 API 是 fork()，传统的 fork() 函数会创建父进程的一个完整副本，例如父进程的地址空间现在用到了 1G 的内存，那么 fork() 子进程的时候要复制父进程整个进程的地址空间（占有 1G 内存）给子进程，这是比较耗时的。</p><p>而 Linux 中 fork() 子进程的时候，并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间；只用在<strong>父进程或者子进程需要写入</strong>的时候才会复制地址空间，从而使父子进程拥有各自的地址空间。</p><p>本质上来讲，父子进程的地址空间以及数据都是要隔离的，使用 Copy-on-Write 更多地体现的是一种<strong>延时策略，只有在真正需要复制的时候才复制，而不是提前复制好</strong>，同时 Copy-on-Write 还支持按需复制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Copy-on-Write顾名思义就是&lt;strong&gt;写时复制&lt;/strong&gt;。比如String的replace()方法就采用了写时复制，即不修改原字符串，而是创建了一个新的，对于不可变对象的写操作往往都是Copy-on-Write方法解决的。&lt;/p&gt;
&lt;h1 id=&quot;C</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>设计模式实战</title>
    <link href="http://example.com/2023/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98/"/>
    <id>http://example.com/2023/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98/</id>
    <published>2023-05-20T08:43:39.000Z</published>
    <updated>2023-05-22T07:11:59.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h1><p>代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 奖励服务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RewardService</span> &#123;</span><br><span class="line">    <span class="comment">// 外部服务</span></span><br><span class="line">    <span class="keyword">private</span> WaimaiService waimaiService;</span><br><span class="line">    <span class="keyword">private</span> HotelService hotelService;</span><br><span class="line">    <span class="keyword">private</span> FoodService foodService;</span><br><span class="line">    <span class="comment">// 使用对入参的条件判断进行发奖</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issueReward</span><span class="params">(String rewardType, Object ... params)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (“Waimai”.equals(rewardType)) &#123;</span><br><span class="line">            <span class="type">WaimaiRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaimaiRequest</span>();</span><br><span class="line">            <span class="comment">// 构建入参</span></span><br><span class="line">            request.setWaimaiReq(params);</span><br><span class="line">            waimaiService.issueWaimai(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (“Hotel”.equals(rewardType)) &#123;</span><br><span class="line">            <span class="type">HotelRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelRequest</span>();</span><br><span class="line">            request.addHotelReq(params);</span><br><span class="line">            hotelService.sendPrize(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (“Food”.equals(rewardType)) &#123;</span><br><span class="line">            <span class="type">FoodRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodRequest</span>(params);</span><br><span class="line">            foodService.getCoupon(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(“rewardType error!”);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样设计，如果说需要新添加一个服务，就需要添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> NewService newService;</span><br><span class="line"><span class="comment">// else if下面添加新的</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;new&quot;</span>.equals(rewardType)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过第一次修改后，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 策略接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">issue</span><span class="params">(Object ... params)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外卖策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Waimai</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> WaimaiService waimaiService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issue</span><span class="params">(Object... params)</span> &#123;</span><br><span class="line">        <span class="type">WaimaiRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaimaiRequest</span>();</span><br><span class="line">        <span class="comment">// 构建入参</span></span><br><span class="line">        request.setWaimaiReq(params);</span><br><span class="line">        waimaiService.issueWaimai(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 酒旅策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hotel</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HotelService hotelService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issue</span><span class="params">(Object... params)</span> &#123;</span><br><span class="line">        <span class="type">HotelRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelRequest</span>();</span><br><span class="line">        request.addHotelReq(params);</span><br><span class="line">        hotelService.sendPrize(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 美食策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Food</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> FoodService foodService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issue</span><span class="params">(Object... params)</span> &#123;</span><br><span class="line">        <span class="type">FoodRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodRequest</span>(params);</span><br><span class="line">        foodService.payCoupon(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用分支判断获取的策略上下文</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrategyContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title function_">getStrategy</span><span class="params">(String rewardType)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (rewardType) &#123;</span><br><span class="line">            <span class="keyword">case</span>“Waimai”:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Waimai</span>();</span><br><span class="line">            <span class="keyword">case</span>“Hotel”:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Hotel</span>();</span><br><span class="line">            <span class="keyword">case</span>“Food”:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Food</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(“rewardType error!”);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后的策略服务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RewardService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issueReward</span><span class="params">(String rewardType, Object ... params)</span> &#123;</span><br><span class="line">        <span class="type">Strategy</span> <span class="variable">strategy</span> <span class="operator">=</span> StrategyContext.getStrategy(rewardType);</span><br><span class="line">        strategy.issue(params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种优化，使用了一个接口，没当需要新添加服务时，只需要实现该接口</p><p>这次优化后，还有一个问题，那就是策略类，可以改为单例模式，如果之前有，就不需要新创建，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 策略上下文，用于管理策略的注册和获取</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrategyContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Strategy&gt; registerMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 注册策略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerStrategy</span><span class="params">(String rewardType, Strategy strategy)</span> &#123;</span><br><span class="line">        registerMap.putIfAbsent(rewardType, strategy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取策略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title function_">getStrategy</span><span class="params">(String rewardType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> registerMap.get(rewardType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象策略类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="comment">// 类注册方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> &#123;</span><br><span class="line">        StrategyContext.registerStrategy(getClass().getSimpleName(), <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单例外卖策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Waimai</span> <span class="keyword">extends</span> <span class="title class_">AbstractStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Waimai</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Waimai</span>();</span><br><span class="line">    <span class="keyword">private</span> WaimaiService waimaiService;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Waimai</span><span class="params">()</span> &#123;</span><br><span class="line">        register();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Waimai <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issue</span><span class="params">(Object... params)</span> &#123;</span><br><span class="line">        <span class="type">WaimaiRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaimaiRequest</span>();</span><br><span class="line">        <span class="comment">// 构建入参</span></span><br><span class="line">        request.setWaimaiReq(params);</span><br><span class="line">        waimaiService.issueWaimai(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单例酒旅策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hotel</span> <span class="keyword">extends</span> <span class="title class_">AbstractStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Hotel</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hotel</span>();</span><br><span class="line">    <span class="keyword">private</span> HotelService hotelService;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Hotel</span><span class="params">()</span> &#123;</span><br><span class="line">        register();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Hotel <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issue</span><span class="params">(Object... params)</span> &#123;</span><br><span class="line">        <span class="type">HotelRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelRequest</span>();</span><br><span class="line">        request.addHotelReq(params);</span><br><span class="line">        hotelService.sendPrize(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单例美食策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Food</span> <span class="keyword">extends</span> <span class="title class_">AbstractStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Food</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Food</span>();</span><br><span class="line">    <span class="keyword">private</span> FoodService foodService;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Food</span><span class="params">()</span> &#123;</span><br><span class="line">        register();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Food <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issue</span><span class="params">(Object... params)</span> &#123;</span><br><span class="line">        <span class="type">FoodRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodRequest</span>(params);</span><br><span class="line">        foodService.payCoupon(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>这次优化后，每次注册完成后，map中会有一个该对象，下次使用时就不需要创建，直接拿之前已经有的即可。</p><h1 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务状态枚举</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">TaskState</span> &#123;</span><br><span class="line">    INIT(“初始化”),</span><br><span class="line">    ONGOING( “进行中”),</span><br><span class="line">    PAUSED(“暂停中”),</span><br><span class="line">    FINISHED(“已完成”),</span><br><span class="line">    EXPIRED(“已过期”);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 行为枚举</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ActionType</span> &#123;</span><br><span class="line">    START(<span class="number">1</span>, “开始”),</span><br><span class="line">    STOP(<span class="number">2</span>, “暂停”),</span><br><span class="line">    ACHIEVE(<span class="number">3</span>, “完成”),</span><br><span class="line">    EXPIRE(<span class="number">4</span>, “过期”);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long taskId;</span><br><span class="line">    <span class="comment">// 任务的默认状态为初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TaskState</span> <span class="variable">state</span> <span class="operator">=</span> TaskState.INIT;</span><br><span class="line">    <span class="comment">// 活动服务</span></span><br><span class="line">    <span class="keyword">private</span> ActivityService activityService;</span><br><span class="line">    <span class="comment">// 任务管理器</span></span><br><span class="line">    <span class="keyword">private</span> TaskManager taskManager;</span><br><span class="line">    <span class="comment">// 使用条件分支进行任务更新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateState</span><span class="params">(ActionType actionType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (state == TaskState.INIT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (actionType == ActionType.START) &#123;</span><br><span class="line">                state = TaskState.ONGOING;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == TaskState.ONGOING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (actionType == ActionType.ACHIEVE) &#123;</span><br><span class="line">                state = TaskState.FINISHED;</span><br><span class="line">                <span class="comment">// 任务完成后进对外部服务进行通知</span></span><br><span class="line">                activityService.notifyFinished(taskId);</span><br><span class="line">                taskManager.release(taskId);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.STOP) &#123;</span><br><span class="line">                state = TaskState.PAUSED;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.EXPIRE) &#123;</span><br><span class="line">                state = TaskState.EXPIRED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == TaskState.PAUSED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (actionType == ActionType.START) &#123;</span><br><span class="line">                state = TaskState.ONGOING;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.EXPIRE) &#123;</span><br><span class="line">                state = TaskState.EXPIRED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的问题是if-else判断太多，如果新添加状态还需要添加新的if-else，这里可以用状态模式。而且Task类中冗余了TaskManager类。</p><p>修改后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务状态抽象接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">// 默认实现，不做任何处理</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Task task, ActionType actionType)</span> &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务初始状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskInit</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Task task, ActionType actionType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (actionType == ActionType.START) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskOngoing</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务进行状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskOngoing</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ActivityService activityService;</span><br><span class="line">    <span class="keyword">private</span> TaskManager taskManager;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Task task, ActionType actionType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (actionType == ActionType.ACHIEVE) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskFinished</span>());</span><br><span class="line">            <span class="comment">// 通知</span></span><br><span class="line">            activityService.notifyFinished(taskId);</span><br><span class="line">            taskManager.release(taskId);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.STOP) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskPaused</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.EXPIRE) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskExpired</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务暂停状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskPaused</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Task task, ActionType actionType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (actionType == ActionType.START) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskOngoing</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.EXPIRE) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskExpired</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务完成状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskFinished</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务过期状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskExpired</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long taskId;</span><br><span class="line">    <span class="comment">// 初始化为初始态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskInit</span>();</span><br><span class="line">    <span class="comment">// 更新状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateState</span><span class="params">(ActionType actionType)</span> &#123;</span><br><span class="line">        state.update(<span class="built_in">this</span>, actionType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用观察者模式后，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象观察者</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">response</span><span class="params">(Long taskId)</span>; <span class="comment">// 反应</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象目标</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line">    <span class="comment">// 增加观察者方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除观察者方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知观察者方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">(Long taskId)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.response(taskId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 活动观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActivityObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ActivityService activityService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">response</span><span class="params">(Long taskId)</span> &#123;</span><br><span class="line">        activityService.notifyFinished(taskId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务管理观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskManageObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TaskManager taskManager;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">response</span><span class="params">(Long taskId)</span> &#123;</span><br><span class="line">        taskManager.release(taskId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务进行状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskOngoing</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Task task, ActionType actionType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (actionType == ActionType.ACHIEVE) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskFinished</span>());</span><br><span class="line">            <span class="comment">// 通知</span></span><br><span class="line">            notifyObserver(task.getTaskId());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.STOP) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskPaused</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.EXPIRE) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskExpired</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务初始状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskInit</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Task task, ActionType actionType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (actionType == ActionType.START) &#123;</span><br><span class="line">            <span class="type">TaskOngoing</span> <span class="variable">taskOngoing</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskOngoing</span>();</span><br><span class="line">            taskOngoing.add(<span class="keyword">new</span> <span class="title class_">ActivityObserver</span>());</span><br><span class="line">            taskOngoing.add(<span class="keyword">new</span> <span class="title class_">TaskManageObserver</span>());</span><br><span class="line">            task.setState(taskOngoing);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《美团博客》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;demo1&quot;&gt;&lt;a href=&quot;#demo1&quot; class=&quot;headerlink&quot; title=&quot;demo1&quot;&gt;&lt;/a&gt;demo1&lt;/h1&gt;&lt;p&gt;代码片段&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式下如何排查慢请求</title>
    <link href="http://example.com/2023/05/17/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8B%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E6%85%A2%E8%AF%B7%E6%B1%82/"/>
    <id>http://example.com/2023/05/17/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8B%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E6%85%A2%E8%AF%B7%E6%B1%82/</id>
    <published>2023-05-17T09:53:02.000Z</published>
    <updated>2023-05-22T07:05:38.749Z</updated>
    
    <content type="html"><![CDATA[<p>在引入了注册中心后，微服务项目的架构会变成下图：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514175352625.png" alt="image-20230514175352625"></p><p>但是，如果此时有一个请求的响应速度比较慢，而这个请求调用了多个RPC服务，该如何去排查呢？</p><h1 id="一体化架构中的慢请求排查如何做"><a href="#一体化架构中的慢请求排查如何做" class="headerlink" title="一体化架构中的慢请求排查如何做"></a>一体化架构中的慢请求排查如何做</h1><p>最简单的办法，就是像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">processA();</span><br><span class="line"><span class="comment">// 打印A步骤的耗时</span></span><br><span class="line">Logs.info(<span class="string">&quot;process A cost &quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line">processB();</span><br><span class="line"><span class="comment">// 打印B步骤的耗时</span></span><br><span class="line">Logs.info(<span class="string">&quot;process B cost &quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line">processC();</span><br><span class="line"><span class="comment">// 打印C步骤的耗时</span></span><br><span class="line">Logs.info(<span class="string">&quot;process C cost &quot;</span> + (System.currentTimeMillis() - start));</span><br></pre></td></tr></table></figure><p>但是这样会有一个问题，如果多个用户同时下单，那么日志的打印是穿插进行的，无法判断。</p><p>一个简单的解决办法是，给每个请求每一行日志加一个id，用于区分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">requestId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">ThreadLocal&lt;String&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> requestId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; <span class="comment">//requestId存储在线程上下文中</span></span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">processA();</span><br><span class="line">Logs.info(<span class="string">&quot;rid : &quot;</span> + tl.get() + <span class="string">&quot;, process A cost &quot;</span> + (System.currentTimeMillis() - start)); <span class="comment">// 日志中增加requestId</span></span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line">processB();</span><br><span class="line">Logs.info(<span class="string">&quot;rid : &quot;</span> + tl.get() + <span class="string">&quot;, process B cost &quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line">processC();</span><br><span class="line">Logs.info(<span class="string">&quot;rid : &quot;</span> + tl.get() + <span class="string">&quot;, process C cost &quot;</span> + (System.currentTimeMillis() - start));</span><br></pre></td></tr></table></figure><h1 id="利用切面编程"><a href="#利用切面编程" class="headerlink" title="利用切面编程"></a>利用切面编程</h1><p>一般来说，切面分为两类：</p><ul><li><p>一类是静态代理，典型的代表是 AspectJ，它的特点是在编译期做切面代码注入；</p></li><li><p>另一类是动态代理，典型的代表是 Spring AOP，它的特点是在运行期做切面代码注入</p></li></ul><p>区别：</p><p>静态代理是在编译期插入代码，增加了编译的时间，给你的直观感觉就是启动的时间变长了，但是一旦在编译期插入代码完毕之后在运行期就基本对于性能没有影响。</p><p>而动态代理不会去修改生成的 Class 文件，而是会在运行期生成一个代理对象，这个代理对象对源对象做了字节码增强，来完成切面所要执行的操作。由于在运行期需要生成代理对象，所以动态代理的性能要比静态代理要差。</p><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><p>为了避免打印过多的日志，我们可以根据id进行采样，比如说只打印id % 10 &#x3D;&#x3D; 0的，这样就只统计局部的 也可以实现需求。</p><p>但是还有一个问题，如果这样的话，拿到一个id我们并不知道它是属于哪个服务器的，我们还需要去服务器查询。解决办法就是将日志通过消息队列插入Elasticsearch，这样搜索也比较简单。如下图：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514183317870.png" alt="image-20230514183317870"></p><h1 id="如何来做分布式-Trace"><a href="#如何来做分布式-Trace" class="headerlink" title="如何来做分布式 Trace"></a>如何来做分布式 Trace</h1><p>采用traceId + spanId</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514184244939.png" alt="image-20230514184244939"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在引入了注册中心后，微服务项目的架构会变成下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514175352625.png&quot; alt=&quot;image-</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="高并发系统设计" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="微服务架构" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>java并发容器</title>
    <link href="http://example.com/2023/05/16/Java/java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    <id>http://example.com/2023/05/16/Java/java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</id>
    <published>2023-05-16T14:38:17.000Z</published>
    <updated>2023-05-22T07:04:35.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>List 里面只有一个实现类就是 <strong>CopyOnWriteArrayList</strong>。</p><p>CopyOnWrite，顾名思义就是写的时候会将共享变量新复制一份出来，这样做的好处是读操作完全无锁。</p><p>CopyOnWriteArrayList 内部维护了一个数组，成员变量 array 就指向这个内部数组，所有的读操作都是基于 array 进行的，迭代器 Iterator 遍历的就是 array 数组。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230515224227570.png" alt="image-20230515224227570"></p><p>如果在遍历时，还有写入时，CopyOnWriteArrayList 会将 array 复制一份，然后在新复制处理的数组上执行增加元素的操作，执行完之后再将 array 指向这个新的数组。遍历操作一直都是基于原 array 执行，而写操作则是基于新 array 进行。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230515224431375.png" alt="image-20230515224431375" style="zoom: 80%;" /><p>注意：CopyOnWriteArrayList 仅适用于写操作非常少的场景，而且能够容忍读写的短暂不一致。因为遍历时，写入的新元素并不能第一之间被遍历到。</p><p>CopyOnWriteArrayList 迭代器是只读的，不支持增删改。因为迭代器遍历的仅仅是一个快照，而对快照进行增删改是没有意义的。</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map 接口的两个实现是 ConcurrentHashMap 和 ConcurrentSkipListMap，它们从应用的角度来看，主要区别在于 <strong>ConcurrentHashMap 的 key 是无序的，而 ConcurrentSkipListMap 的 key 是有序的</strong>。而且他们的key和value都不能为空。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230515224643521.png" alt="image-20230515224643521" style="zoom:80%;" /><p>ConcurrentSkipListMap 里面的 SkipList 本身就是一种数据结构，中文一般都翻译为“跳表”。</p><p>跳表插入、删除、查询操作平均的时间复杂度是 O(log n)，理论上和并发线程数没有关系，所以在并发度非常高的情况下，若你对 ConcurrentHashMap 的性能还不满意，可以尝试一下 ConcurrentSkipListMap。</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set 接口的两个实现是 CopyOnWriteArraySet 和 ConcurrentSkipListSet，使用场景可以参考前面讲述的 CopyOnWriteArrayList 和 ConcurrentSkipListMap。</p><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>队列可以从以下两个维度来分：</p><p>一个维度是<strong>阻塞与非阻塞</strong>，所谓阻塞指的是当队列已满时，入队操作阻塞；当队列已空时，出队操作阻塞。</p><p>另一个维度是<strong>单端与双端</strong>，单端指的是只能队尾入队，队首出队；而双端指的是队首队尾皆可入队出队。</p><p>可以将Queue分为4大类</p><p>1、<strong>单端阻塞队列</strong>：其实现有 ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、LinkedTransferQueue、PriorityBlockingQueue 和 DelayQueue。</p><p>内部一般会持有一个队列，这个队列可以是数组（其实现是 ArrayBlockingQueue）也可以是链表（其实现是 LinkedBlockingQueue）；甚至还可以不持有队列（其实现是 SynchronousQueue），此时生产者线程的入队操作必须等待消费者线程的出队操作。</p><p>而 LinkedTransferQueue 融合 LinkedBlockingQueue 和 SynchronousQueue 的功能，性能比 LinkedBlockingQueue 更好；PriorityBlockingQueue 支持按照优先级出队；DelayQueue 支持延时出队。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230515225105664.png" alt="image-20230515225105664" style="zoom:67%;" /><p>2.<strong>双端阻塞队列</strong>：其实现是 LinkedBlockingDeque。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230515225129204.png" alt="image-20230515225129204" style="zoom:67%;" /><p>3.<strong>单端非阻塞队列</strong>：其实现是 ConcurrentLinkedQueue。</p><p>4.<strong>双端非阻塞队列</strong>：其实现是 ConcurrentLinkedDeque。</p><p>在使用队列时，要注意队列是否是有界的，在使用无界队列时，要注意是否会导致OOM异常。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Java并发编程实战》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;List&quot;&gt;&lt;a href=&quot;#List&quot; class=&quot;headerlink&quot; title=&quot;List&quot;&gt;&lt;/a&gt;List&lt;/h1&gt;&lt;p&gt;List 里面只有一个实现类就是 &lt;strong&gt;CopyOnWriteArrayList&lt;/strong&gt;。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Api网关</title>
    <link href="http://example.com/2023/05/16/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Api%E7%BD%91%E5%85%B3/"/>
    <id>http://example.com/2023/05/16/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Api%E7%BD%91%E5%85%B3/</id>
    <published>2023-05-16T06:08:58.000Z</published>
    <updated>2023-05-16T07:15:51.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="API-网关起到的作用"><a href="#API-网关起到的作用" class="headerlink" title="API 网关起到的作用"></a>API 网关起到的作用</h1><p>API 网关可以分为两类：<strong>一类叫做入口网关，一类叫做出口网关。</strong></p><h2 id="入口网关"><a href="#入口网关" class="headerlink" title="入口网关"></a>入口网关</h2><p>入口网关部署在负载均衡服务器和应用服务器之间，<strong>主要有几方面的作用。</strong></p><p>1、它提供客户端一个统一的接入地址，API 网关可以将用户的请求动态路由到不同的业务服务上，并且做一些必要的协议转换工作。这里有一点需要注意，<strong>你部署的微服务对外暴露的协议可能不同</strong>，有些可能是RPC，有些可能是Http，这些细节都可以在网关中处理。</p><p>2、另一方面，在 API 网关中，我们可以植入一些服务治理的策略，比如服务的熔断、降级、流量控制和分流等等。</p><p>3、客户端的认证和授权的实现，也可以放在 API 网关中。</p><p>4、另外，API 网关还可以做一些与黑白名单相关的事情，比如针对设备 ID、用户 IP、用户 ID 等维度的黑白名单。</p><p>5、最后，在 API 网关中也可以做一些日志记录的事情。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230516142313124.png" alt="image-20230516142313124" style="zoom:67%;" /><h2 id="出口网关"><a href="#出口网关" class="headerlink" title="出口网关"></a>出口网关</h2><p>我们在系统开发中，会依赖很多外部的第三方系统，典型的例子：第三方账户登录、使用第三方工具支付等等。我们可以在应用服务器和第三方系统之间，部署出口网关，在出口网关中，对调用外部的 API 做统一的认证、授权、审计以及访问控制。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230516142531792.png" alt="image-20230516142531792" style="zoom:67%;" /><h1 id="网关实现"><a href="#网关实现" class="headerlink" title="网关实现"></a>网关实现</h1><p>在实现网关时，需要注意一点：为了提升网关对于请求的并行处理能力，我们一般会使用线程池来并行的执行请求。</p><p>但是这样设计也同样会带来一些问题：假如一个服务出现问题导致响应过慢，那么调用该服务的模块也会被阻塞，其他服务也会级联受到影响，导致无法线程池中的线程无法释放，对整个系统造成影响。</p><p>因此，我们需要针对不同的服务做线程隔离或者保护。<strong>有两种思路：</strong></p><ul><li>如果你后端的服务拆分得不多，可以针对不同的服务，采用不同的线程池，这样一个服务的故障就不会影响到其他服务；</li><li>在线程池内部可以针对不同的服务甚至不同的接口做线程的保护。比如说，线程池的最大线程数是 1000，那么可以给每个服务设置一个最多可以使用的配额。</li></ul><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230516151544806.png" alt="image-20230516151544806"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;API-网关起到的作用&quot;&gt;&lt;a href=&quot;#API-网关起到的作用&quot; class=&quot;headerlink&quot; title=&quot;API 网关起到的作用&quot;&gt;&lt;/a&gt;API 网关起到的作用&lt;/h1&gt;&lt;p&gt;API 网关可以分为两类：&lt;strong&gt;一类叫做入口网关，一类叫做</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="高并发系统设计" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="微服务架构" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡</title>
    <link href="http://example.com/2023/05/15/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://example.com/2023/05/15/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2023-05-15T09:24:59.000Z</published>
    <updated>2023-05-15T11:58:59.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="负载均衡服务器的种类"><a href="#负载均衡服务器的种类" class="headerlink" title="负载均衡服务器的种类"></a>负载均衡服务器的种类</h1><p><strong>负载均衡的含义是：</strong>将负载（访问的请求）“均衡”地分配到多个处理节点上。这样可以减少单个处理节点的请求量，提升整体系统的性能。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230515172635623.png" alt="image-20230515172635623" style="zoom:67%;" /><p>在项目的架构中，我们一般会同时部署 LVS 和 Nginx 来做 HTTP 应用服务的负载均衡。也就是说，在入口处部署 LVS 将流量分发到多个 Nginx 服务器上，再由 Nginx 服务器分发到应用服务器上。</p><p>不过这两个负载均衡服务适用于普通的 Web 服务，对于微服务架构来说，它们是不合适的。</p><p>因为微服务架构中的服务节点存储在注册中心里，使用 LVS 就很难和注册中心交互获取全量的服务节点列表。另外，一般微服务架构中，使用的是 RPC 协议而不是 HTTP 协议，所以 Nginx 也不能满足要求。</p><p><strong>所以，我们会使用另一类的负载均衡服务，客户端负载均衡服务，也就是把负载均衡的服务内嵌在 RPC 客户端中。</strong></p><p>这类服务一般会结合注册中心来使用，注册中心提供服务节点的完整列表，客户端拿到列表之后使用负载均衡服务的策略选取一个合适的节点，然后将请求发到这个节点上。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230515194359296.png" alt="image-20230515194359296"></p><h2 id="常见的负载均衡策略有哪些"><a href="#常见的负载均衡策略有哪些" class="headerlink" title="常见的负载均衡策略有哪些"></a>常见的负载均衡策略有哪些</h2><ul><li><p>一类是静态策略，也就是说负载均衡服务器在选择服务节点时，不会参考后端服务的实际运行的状态；</p></li><li><p>一类是动态策略，也就是说负载均衡服务器会依据后端服务的一些负载特性，来决定要选择哪一个服务节点。</p></li></ul><p>静态的又有以下几种策略：</p><ul><li><strong>轮询的策略</strong>：如果服务器性能不一样，则不能很好的发挥作用</li><li><strong>带有权重的轮询策略</strong></li></ul><p>动态策略：</p><ul><li>Dubbo 提供的 LeastAcive 策略，就是优先选择活跃连接数最少的服务；</li><li>Spring Cloud 全家桶中的 Ribbon 提供了 WeightedResponseTimeRule 是使用响应时间给每个服务节点计算一个权重，然后依据这个权重，来给调用方分配服务节点。</li></ul><p><strong>这些策略的思考点</strong>是从调用方的角度出发，选择负载最小、资源最空闲的服务来调用，以期望能得到更高的服务调用性能</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;负载均衡服务器的种类&quot;&gt;&lt;a href=&quot;#负载均衡服务器的种类&quot; class=&quot;headerlink&quot; title=&quot;负载均衡服务器的种类&quot;&gt;&lt;/a&gt;负载均衡服务器的种类&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;负载均衡的含义是：&lt;/strong&gt;将负载（访问的请求）“均</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="高并发系统设计" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="微服务架构" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch和CyclicBarrier：如何让多线程步调一致</title>
    <link href="http://example.com/2023/05/14/Java/CountDownLatch%E5%92%8CCyclicBarrier%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%A9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%A5%E8%B0%83%E4%B8%80%E8%87%B4/"/>
    <id>http://example.com/2023/05/14/Java/CountDownLatch%E5%92%8CCyclicBarrier%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%A9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%A5%E8%B0%83%E4%B8%80%E8%87%B4/</id>
    <published>2023-05-14T11:02:59.000Z</published>
    <updated>2023-05-14T11:45:12.442Z</updated>
    
    <content type="html"><![CDATA[<p> 假如我们要实现一下功能：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514190414839.png" alt="image-20230514190414839" style="zoom:67%;" /><p>如果单线程处理，那么执行图如下：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514190537547.png" alt="image-20230514190537547" style="zoom:67%;" /><p>如果想要优化，则可以将获取order的操作并行执行，如下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514190619676.png" alt="image-20230514190619676" style="zoom:67%;" /><p>大致的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (存在未对账订单) &#123;</span><br><span class="line">    <span class="comment">// 查询未对账订单</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">T1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        pos = getPOrders();</span><br><span class="line">    &#125;);</span><br><span class="line">    T1.start();</span><br><span class="line">    <span class="comment">// 查询派送单</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">T2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        dos = getDOrders();</span><br><span class="line">    &#125;);</span><br><span class="line">    T2.start();</span><br><span class="line">    <span class="comment">// 等待T1、T2结束</span></span><br><span class="line">    T1.join();</span><br><span class="line">    T2.join();</span><br><span class="line">    <span class="comment">// 执行对账操作</span></span><br><span class="line">    diff = check(pos, dos);</span><br><span class="line">    <span class="comment">// 差异写入差异库</span></span><br><span class="line">    save(diff);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>但是这样写有一个缺点，就是while循环每次都要创建线程，而创建线程开销又比较的大，所以我们可以用线程池有优化。</p><h1 id="用-CountDownLatch-实现线程等待"><a href="#用-CountDownLatch-实现线程等待" class="headerlink" title="用 CountDownLatch 实现线程等待"></a>用 CountDownLatch 实现线程等待</h1><p>因为没有手动创建线程，所以没有join方法，那么如何通知主线程两个子线程已经执行完成了呢？我们可以使用<strong>CountDownLatch</strong></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建2个线程的线程池</span></span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span> (存在未对账订单) &#123;</span><br><span class="line">    <span class="comment">// 计数器初始化为2</span></span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 查询未对账订单</span></span><br><span class="line">    executor.execute(()-&gt; &#123;</span><br><span class="line">        pos = getPOrders();</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 查询派送单</span></span><br><span class="line">    executor.execute(()-&gt; &#123;</span><br><span class="line">        dos = getDOrders();</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待两个查询操作结束</span></span><br><span class="line">    latch.await();</span><br><span class="line">    <span class="comment">// 执行对账操作</span></span><br><span class="line">    diff = check(pos, dos);</span><br><span class="line">    <span class="comment">// 差异写入差异库</span></span><br><span class="line">    save(diff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h1><p>在查询完第一次后进行对比时，可以进行第二次查询，如下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514191455335.png" alt="image-20230514191455335" style="zoom:67%;" /><p>这里有点生产者-消费者的意思了，查询 可以当作生产者，查询玩的计算可以当作消费者。既然是生产者 - 消费者模型，那就需要有个队列，来保存生产者生产的数据，而消费者则从这个队列消费数据。</p><p>我们可以用两个队列，一个存储查询订单，一个存储派送订单，然后两个线程，当每个线程都查询一条数据时，通知第三个线程去执行计算。但是这样需要保证查询线程速度一样。</p><h2 id="用-CyclicBarrier-实现线程同步"><a href="#用-CyclicBarrier-实现线程同步" class="headerlink" title="用 CyclicBarrier 实现线程同步"></a>用 CyclicBarrier 实现线程同步</h2><p>线程 T1 负责查询订单，当查出一条时，调用 barrier.await() 来将计数器减 1，同时等待计数器变成 0；线程 T2 负责查询派送单，当查出一条时，也调用 barrier.await() 来将计数器减 1，同时等待计数器变成 0；当 T1 和 T2 都调用 barrier.await() 的时候，计数器会减到 0，此时 T1 和 T2 就可以执行下一条语句了，同时会调用 barrier 的回调函数来执行对账操作。</p><p>CyclicBarrier 的计数器有自动重置的功能，当减到 0 的时候，会自动重置你设置的初始值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订单队列</span></span><br><span class="line">Vector&lt;P&gt; pos;</span><br><span class="line"><span class="comment">// 派送单队列</span></span><br><span class="line">Vector&lt;D&gt; dos;</span><br><span class="line"><span class="comment">// 执行回调的线程池， 这里好像必须为1</span></span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 计数器的值为2</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>, ()-&gt;&#123;</span><br><span class="line">    executor.execute(()-&gt;check());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断时，将队列中的元素移除</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">P</span> <span class="variable">p</span> <span class="operator">=</span> pos.remove(<span class="number">0</span>);</span><br><span class="line">    <span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> dos.remove(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 执行对账操作</span></span><br><span class="line">    diff = check(p, d);</span><br><span class="line">    <span class="comment">// 差异写入差异库</span></span><br><span class="line">    save(diff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">checkAll</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 循环查询订单库</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">T1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(存在未对账订单)&#123;</span><br><span class="line">            <span class="comment">// 查询订单库</span></span><br><span class="line">            pos.add(getPOrders());</span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    T1.start();  </span><br><span class="line">    <span class="comment">// 循环查询运单库</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">T2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(存在未对账订单)&#123;</span><br><span class="line">            <span class="comment">// 查询运单库</span></span><br><span class="line">            dos.add(getDOrders());</span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    T2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>CountDownLatch 主要用来解决一个线程等待多个线程的场景</strong></p><p><strong>CyclicBarrier 是一组线程之间互相等待</strong></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Java并发编程实战》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 假如我们要实现一下功能：&lt;/p&gt;
&lt;img src=&quot;https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514190414839.png&quot; alt=&quot;image-20230514190414</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>注册中心</title>
    <link href="http://example.com/2023/05/13/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    <id>http://example.com/2023/05/13/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</id>
    <published>2023-05-13T10:27:15.000Z</published>
    <updated>2023-05-14T09:50:29.412Z</updated>
    
    <content type="html"><![CDATA[<p> 当一个项目拆分成微服务之后，接口之间的调用就需要跨网络来完成，这时候就需要知道另外一个接口的ip地址以及端口号，如果把这些内容全部在代码里面写死，那么如果ip发生变动，就需要重启服务，还需要修改代码。注册中心的诞生就解决了这个问题。</p><p>注册中心的基本功能有两点：</p><ul><li><p>一是提供了服务地址的存储；</p></li><li><p>二是当存储内容发生变化时，可以将变更的内容推送给客户端。</p></li></ul><p>使用了注册中心组件之后，RPC 的通信过程就变成了下面这个样子：</p><ul><li><p>客户端会与注册中心建立连接，并且告诉注册中心，它对哪一组服务感兴趣；</p></li><li><p>服务端向注册中心注册服务后，注册中心会将最新的服务注册信息通知给客户端；</p></li><li><p>客户端拿到服务端的地址之后就可以向服务端发起调用请求了。</p></li></ul><h1 id="服务状态管理如何来做"><a href="#服务状态管理如何来做" class="headerlink" title="服务状态管理如何来做"></a>服务状态管理如何来做</h1><p>服务的上线和下线是由服务端主动向注册中心注册和取消注册来实现的，这在正常的流程中是没有问题的。<strong>可是，如果某一个服务端意外故障，</strong>比如说机器掉电，网络不通等情况，服务端就没有办法向注册中心通信，将自己从服务列表中删除，就会导致客户端请求一个无法响应的服务。</p><h2 id="主动探测"><a href="#主动探测" class="headerlink" title="主动探测"></a>主动探测</h2><p>你的 RPC 服务要打开一个端口，然后由注册中心每隔一段时间（比如 30 秒）探测这些端口是否可用，如果可用就认为服务仍然是正常的，否则就可以认为服务不可用，那么注册中心就可以把服务从列表里面删除了。</p><p>这样做的如果服务比较多的话，成本就会比较的高。</p><h2 id="心跳模式"><a href="#心跳模式" class="headerlink" title="心跳模式"></a>心跳模式</h2><p>注册中心为每一个连接上来的 RPC 服务节点记录最近续约的时间，RPC 服务节点在启动注册到注册中心后，就按照一定的时间间隔（比如 30 秒），向注册中心发送心跳包。注册中心在接收到心跳包之后，会更新这个节点的最近续约时间。然后，注册中心会启动一个定时器定期检测当前时间和节点最近续约时间的差值，如果达到一个阈值（比如说 90 秒），那么认为这个服务节点不可用。</p><h2 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h2><p>要避免注册中心因为监测不到心跳而摘除所有的服务，要设置一定的警报，如果摘除超过一定比例的服务后，要发起警告。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 当一个项目拆分成微服务之后，接口之间的调用就需要跨网络来完成，这时候就需要知道另外一个接口的ip地址以及端口号，如果把这些内容全部在代码里面写死，那么如果ip发生变动，就需要重启服务，还需要修改代码。注册中心的诞生就解决了这个问题。&lt;/p&gt;
&lt;p&gt;注册中心的基本功能有两点</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="高并发系统设计" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="微服务架构" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Redis的I/O多路复用</title>
    <link href="http://example.com/2023/05/12/Redis/Redis%E7%9A%84I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>http://example.com/2023/05/12/Redis/Redis%E7%9A%84I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2023-05-12T12:36:26.000Z</published>
    <updated>2023-05-11T13:52:45.058Z</updated>
    
    <content type="html"><![CDATA[<p>在Redis6.0之前，它的网络I&#x2F;O模型是单线程的，那么它是怎么处理多个客户端的连接的呢？这里就涉及到Redis的I&#x2F;O模型，基于多路复用的高性能 I&#x2F;O 模型。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230511204107493.png" alt="image-20230511204107493"></p><p>我个人对它的理解如下：</p><p>它的模型需要用到操作系统的epoll机制，也就是说需要内核来监控Redis建立的多个Socket，这也就是为什么Windows操作系统发挥不了Redis的最大性能，因为它只支持Select模式，不支持epoll模式。</p><p>Redis的一个线程只需要来处理客户端的请求，为它建立一个Socket。epoll机制允许内核一次监听多个socket，每当这些socket变得可读或者可写，就通知Redis的线程，然后Redis的线程会为对应的Socket注册对应的事件，之后将他们放入事件处理队列。这是事件在出队后，会调用对应事件绑定的函数，来处理对应的事件。</p><p>比如说，现在有两个客户端，这两个客户端都发起了请求，分别对应accept事件和read事件。Redis 分别对这两个事件注册 accept 和 get 回调函数。当 Linux 内核监听到有连接请求或读数据请求时，就会触发 Accept 事件和 Read 事件，此时，内核就会回调 Redis 相应的 accept 和 get 函数进行处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Redis6.0之前，它的网络I&amp;#x2F;O模型是单线程的，那么它是怎么处理多个客户端的连接的呢？这里就涉及到Redis的I&amp;#x2F;O模型，基于多路复用的高性能 I&amp;#x2F;O 模型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image-13142383</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Redis" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis/"/>
    
    <category term="设计" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis/%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Redis设计与实现" scheme="http://example.com/tags/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何提高服务调用速度</title>
    <link href="http://example.com/2023/05/11/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E9%80%9F%E5%BA%A6/"/>
    <id>http://example.com/2023/05/11/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E9%80%9F%E5%BA%A6/</id>
    <published>2023-05-11T03:35:59.000Z</published>
    <updated>2023-05-11T11:09:32.190Z</updated>
    
    <content type="html"><![CDATA[<p>假如电商系统的 QPS 已经达到了每秒 2 万次，在做了服务化拆分之后，由于我们把业务逻辑都拆分到了单独部署的服务中，那么假设你在完成一次完整的请求时需要调用 4～5 次服务，计算下来，RPC 服务需要承载大概每秒 10 万次的请求。</p><p>所以RPC框架的选型要：</p><p>1、选择合适的网络模型，有针对性地调整网络参数优化网络传输性能；</p><p>2、选择合适的序列化方式，以提升封包、解包的性能。</p><h1 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h1><p>RPC指的是通过网络调用另一台计算机上部署服务的技术。而 RPC 框架就封装了网络调用的细节，让你像调用本地服务一样调用远程部署的服务。</p><h1 id="在引入RPC框架后会出现的问题"><a href="#在引入RPC框架后会出现的问题" class="headerlink" title="在引入RPC框架后会出现的问题"></a>在引入RPC框架后会出现的问题</h1><p>假设一个电商系统的商品详情页面需要商品数据、评论数据还有店铺数据。如果是一体化的项目，只需要从商品库、评论库和店铺库获取数据就可以了，不考虑缓存的情况下有三次网络请求。</p><p>但是如果独立出商品服务、评论服务和店铺服务之后，那么就需要分别调用这三个服务，而这三个服务又会分别调用各自的数据库，这就是六次网络请求。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230511184337555.png" alt="image-20230511184337555"></p><p>想要优化RPC调用，那么就要了解RPC调用的步骤都有哪些：</p><ul><li>客户端首先会将调用的类名、方法名、参数名、参数值等信息，序列化成二进制流；</li><li>然后客户端将二进制流通过网络发送给服务端；</li><li>服务端接收到二进制流之后将它反序列化，得到需要调用的类名、方法名、参数名和参数值，再通过动态代理的方式调用对应的方法得到返回值；</li><li>服务端将返回值序列化，再通过网络发送给客户端；</li><li>客户端对结果反序列化之后，就可以得到调用的结果了。</li></ul><p>如下图：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230511184610250.png" alt="image-20230511184610250"></p><p>不难看出，想要优化RPC调用，需要从<strong>网络传输和序列化</strong>入手。</p><h2 id="如何提升网络传输性能"><a href="#如何提升网络传输性能" class="headerlink" title="如何提升网络传输性能"></a>如何提升网络传输性能</h2><p>在网络传输优化中，首先要做的是选择一种高性能的 I&#x2F;O 模型，即我们处理I&#x2F;O的方式。而单次I&#x2F;O请求会分为两个节点。</p><p><strong>首先，I&#x2F;O 会经历一个等待资源的阶段，</strong>比方说，等待网络传输数据可用。这里有两种处理方式：</p><ul><li><p>阻塞。指的是在数据不可用时 I&#x2F;O 请求一直阻塞，直到数据返回；</p></li><li><p>非阻塞。指的是数据不可用时 I&#x2F;O 请求立即返回，直到被通知资源可用为止。</p></li></ul><p><strong>然后是使用资源的阶段，</strong>比如说从网络上接收到数据，并且拷贝到应用程序的缓冲区里面。也有两种处理方式：</p><ul><li><p>同步处理。指的是 I&#x2F;O 请求在读取或者写入数据时会阻塞，直到读取或者写入数据完成；</p></li><li><p>异步处理。指的是 I&#x2F;O 请求在读取或者写入数据时立即返回，当操作系统处理完成 I&#x2F;O 请求并且将数据拷贝到用户提供的缓冲区后，再通知应用 I&#x2F;O 请求执行完成。</p></li></ul><p>将这两个阶段的四种处理方式做一些排列组合，再做一些补充，就得到了我们常见的五种 I&#x2F;O 模型：</p><ul><li><p>同步阻塞 I&#x2F;O；</p></li><li><p>同步非阻塞 I&#x2F;O；</p></li><li><p>同步多路 I&#x2F;O 复用；</p></li><li><p>信号驱动 I&#x2F;O；</p></li><li><p>异步 I&#x2F;O。</p></li></ul><h2 id="选择合适的序列化方式"><a href="#选择合适的序列化方式" class="headerlink" title="选择合适的序列化方式"></a>选择合适的序列化方式</h2><p><strong>在对网络数据传输完成调优之后，另外一个需要关注的点就是数据的序列化和反序列化。</strong></p><p>这里要考虑序列化和反序列化的速度，以及序列化完成后的大小，因为要在网络上传输。</p><p>可以有以下几种方案：</p><ul><li>JSON，性能要求不高可以选</li><li><strong>Thrift</strong> 是 Facebook 开源的高性能的序列化协议</li><li><strong>Protobuf</strong> 是谷歌开源的序列化协议。</li></ul><p>如果性能要求比较高，Thrift 或者 Protobuf 都可以。</p><p>一些存储的场景下，比如说缓存中存储的数据占用空间较大，那么你可以考虑使用 Protobuf。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;假如电商系统的 QPS 已经达到了每秒 2 万次，在做了服务化拆分之后，由于我们把业务逻辑都拆分到了单独部署的服务中，那么假设你在完成一次完整的请求时需要调用 4～5 次服务，计算下来，RPC 服务需要承载大概每秒 10 万次的请求。&lt;/p&gt;
&lt;p&gt;所以RPC框架的选型要：</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="高并发系统设计" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="微服务架构" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>路由器结构</title>
    <link href="http://example.com/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2023-05-11T02:05:50.000Z</published>
    <updated>2023-05-15T01:53:53.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路由器结构"><a href="#路由器结构" class="headerlink" title="路由器结构"></a>路由器结构</h1><p>一个路由器的体系结构如下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230511101229903.png" alt="image-20230511101229903" style="zoom:80%;" /><p><strong>输入端口作用</strong>：</p><p>1、接收数据链路层的数据。</p><p>2、查询转发表，决定数据的输出端口。到达的分组通过路由器的交换结构转发到输出端口。</p><p><strong>交换结构</strong>：交换结构将路由器的输入端口连接到它的输岀端口。这种交换结构完全包含在路由器之中，即它是一个网络路由器中的网络!</p><p><strong>输出端口：</strong>输出端口存储从交换结构接收的分组，并通过执行必要的链路层和物理层功能在输出链路上传输这些分组。</p><p><strong>路由选择处理器</strong>：路由选择处理器执行<strong>控制平面</strong>功能。</p><p>在传统的路由器中，它执行路由选择协议，维护路由选择表与关联链路状态信息，并为该路由器计算转发表。</p><p>在SDN路由器中，路由选择处理器（在其他活动中）负责与远程控制器通信，目的是接收由远程控制器计算的转发表项，并在该路由器的输入端口安装这些表项。路由选择处理器还执行网络管理功能。</p><p>以上仅仅是每个部分大致功能的描述，后续会有更为详细的介绍。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《计算机网络自顶向下》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;路由器结构&quot;&gt;&lt;a href=&quot;#路由器结构&quot; class=&quot;headerlink&quot; title=&quot;路由器结构&quot;&gt;&lt;/a&gt;路由器结构&lt;/h1&gt;&lt;p&gt;一个路由器的体系结构如下图：&lt;/p&gt;
&lt;img src=&quot;https://image-1314238346.cos.</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="网络层" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
    <category term="网络层" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>微服务后系统要如何改造</title>
    <link href="http://example.com/2023/05/10/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%90%8E%E7%B3%BB%E7%BB%9F%E8%A6%81%E5%A6%82%E4%BD%95%E6%94%B9%E9%80%A0/"/>
    <id>http://example.com/2023/05/10/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%90%8E%E7%B3%BB%E7%BB%9F%E8%A6%81%E5%A6%82%E4%BD%95%E6%94%B9%E9%80%A0/</id>
    <published>2023-05-10T14:20:11.000Z</published>
    <updated>2023-05-10T14:40:28.264Z</updated>
    
    <content type="html"><![CDATA[<p> 微服务化后，一个项目的架构图如下所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230510222409851.png" alt="image-20230510222409851" style="zoom: 80%;" /><h1 id="微服务拆分的原则"><a href="#微服务拆分的原则" class="headerlink" title="微服务拆分的原则"></a>微服务拆分的原则</h1><p>单体化的项目就像一个大的蜘蛛网，不同模块交织在一起，调用比较复杂，一个问题出bug可能会导致连锁的问题。所以要对架构进行拆分。而进行拆分则需要遵循以下原则：</p><h2 id="1、做到单一服务内部功能的高内聚和低耦合"><a href="#1、做到单一服务内部功能的高内聚和低耦合" class="headerlink" title="1、做到单一服务内部功能的高内聚和低耦合"></a>1、做到单一服务内部功能的高内聚和低耦合</h2><p>也就是说每个服务只完成自己职责之内的任务，对于不是自己职责的功能交给其它服务来完成。</p><h2 id="2、需要关注服务拆分的粒度，先粗略拆分再逐渐细化"><a href="#2、需要关注服务拆分的粒度，先粗略拆分再逐渐细化" class="headerlink" title="2、需要关注服务拆分的粒度，先粗略拆分再逐渐细化"></a>2、需要关注服务拆分的粒度，先粗略拆分再逐渐细化</h2><p>拆分初期可以把服务粒度拆得粗一些，后面随着团队对于业务和微服务理解的加深，再考虑把服务粒度细化。</p><h2 id="3、拆分的过程，要尽量避免影响产品的日常功能迭代"><a href="#3、拆分的过程，要尽量避免影响产品的日常功能迭代" class="headerlink" title="3、拆分的过程，要尽量避免影响产品的日常功能迭代"></a>3、拆分的过程，要尽量避免影响产品的日常功能迭代</h2><p>要一边做产品功能迭代，一边完成服务化拆分。拆分只能在现有一体化系统的基础上不断剥离业务独立部署，<strong>剥离的顺序你可以参考以下几点：</strong></p><ol><li><p>优先剥离比较独立的边界服务（比如短信服务、地理位置服务），从非核心的服务出发减少拆分对现有业务的影响</p></li><li><p>当两个服务存在依赖关系时优先拆分被依赖的服务。比如内容服务依赖于用户服务获取用户的基本信息，那么如果先把内容服务拆分出来，内容服务就会依赖于一体化架构中的用户模块，这样还是无法保证内容服务的快速部署能力。</p></li></ol><h2 id="4、服务接口的定义要具备可扩展性"><a href="#4、服务接口的定义要具备可扩展性" class="headerlink" title="4、服务接口的定义要具备可扩展性"></a>4、服务接口的定义要具备可扩展性</h2><p>服务拆分之后，由于服务是以独立进程的方式部署，所以服务之间通信就不再是进程内部的方法调用而是跨进程的网络通信了。在这种通信模型下服务接口的定义要具备可扩展性，否则在服务变更时会造成意想不到的错误。</p><h1 id="微服务化带来的问题和解决思路"><a href="#微服务化带来的问题和解决思路" class="headerlink" title="微服务化带来的问题和解决思路"></a>微服务化带来的问题和解决思路</h1><p>微服务会引入一定的复杂度：</p><p>1、服务接口调用不再是同一进程内的方法调用，而是跨进程的网络调用，这会增加时延，同时接口调用方需要知道服务部署在哪些机器的哪个端口上，这些信息需要存储在一个分布式一致性的存储中，<strong>于是就需要引入服务注册中心</strong>。</p><p>2、多个服务之间有着错综复杂的依赖关系。一个服务会依赖多个其它服务也会被多个服务所依赖，那么一旦被依赖的服务的性能出现问题产生大量的慢请求，就会导致依赖服务的工作线程池中的线程被占满，依赖的服务也会出现性能问题，有可能会导致整个服务崩溃。</p><p>为了避免发生这种情况，我们需要引入服务治理体系针对出问题的服务采用熔断、降级、限流、超时控制的方法，使问题被限制在单一服务中，保护服务网络中的其它服务不受影响。</p><p>3、服务拆分到多个进程后，一条请求的调用链路上涉及多个服务，那么一旦这个请求的响应时间增长或者是出现错误，我们就很难知道是哪一个服务出现的问题。</p><p>另外，整体系统一旦出现故障，很可能外在的表现是所有服务在同一时间都出现了问题，你在问题定位时很难确认哪一个服务是源头，<strong>这就需要引入分布式追踪工具，以及更细致的服务端监控报表。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 微服务化后，一个项目的架构图如下所示：&lt;/p&gt;
&lt;img src=&quot;https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230510222409851.png&quot; alt=&quot;image-2023051</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="高并发系统设计" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="微服务架构" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
</feed>
