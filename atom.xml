<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便起个名字吧</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-05-24T14:51:02.002Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Guo Junhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java的Stream</title>
    <link href="http://example.com/2023/05/24/Java%E7%9A%84Stream/"/>
    <id>http://example.com/2023/05/24/Java%E7%9A%84Stream/</id>
    <published>2023-05-24T14:18:39.000Z</published>
    <updated>2023-05-24T14:51:02.002Z</updated>
    
    <content type="html"><![CDATA[<p> 需求：过滤分组一所中学里身高在 160cm 以上的男女同学</p><p>之前的代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; stuMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, List&lt;Student&gt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Student stu: studentsList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stu.getHeight() &gt; <span class="number">160</span>) &#123; <span class="comment">//如果身高大于160</span></span><br><span class="line">        <span class="keyword">if</span> (stuMap.get(stu.getSex()) == <span class="literal">null</span>) &#123; <span class="comment">//该性别还没分类</span></span><br><span class="line">            List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;(); <span class="comment">//新建该性别学生的</span></span><br><span class="line">            list.add(stu);<span class="comment">//将学生放进去列表</span></span><br><span class="line">            stuMap.put(stu.getSex(), list);<span class="comment">//将列表放到map中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//该性别分类已存在</span></span><br><span class="line">            stuMap.get(stu.getSex()).add(stu);<span class="comment">//该性别分类已存在，则直接放进去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Stream API实现：</p><p>串行实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; stuMap = stuList.stream().filter((Student s) -&gt; s.getHeight() &gt; <span class="number">160</span>) .collect(Collectors.groupingBy(Student ::getSex)); </span><br></pre></td></tr></table></figure><p>并行实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; stuMap = stuList.parallelStream().filter((Student s) -&gt; s.getHeight() &gt; <span class="number">160</span>) .collect(Collectors.groupingBy(Student ::getSex)); </span><br></pre></td></tr></table></figure><h1 id="Stream-如何优化遍历"><a href="#Stream-如何优化遍历" class="headerlink" title="Stream 如何优化遍历"></a>Stream 如何优化遍历</h1><p>官方将 Stream 中的操作分为两大类：中间操作（Intermediate operations）和终结操作（Terminal operations）</p><p>中间操作只对操作进行了记录，即只会返回一个流，不会进行计算操作，而终结操作是实现了计算操作。</p><p>中间操作又可以分为无状态（Stateless）与有状态（Stateful）操作，前者是指元素的处理不受之前元素的影响，后者是指该操作只有拿到所有元素之后才能继续下去。</p><p>终结操作又可以分为短路（Short-circuiting）与非短路（Unshort-circuiting）操作，前者是指遇到某些符合条件的元素就可以得到最终结果，后者是指必须处理完所有元素才能得到最终结果。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230524223653374.png" alt="image-20230524223653374"></p><p>Stream如何迭代大数据集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王老五&quot;</span>, <span class="string">&quot;李三&quot;</span>, <span class="string">&quot;刘老四&quot;</span>, <span class="string">&quot;王小二&quot;</span>, <span class="string">&quot;张四&quot;</span>, <span class="string">&quot;张五六七&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">maxLenStartWithZ</span> <span class="operator">=</span> names.stream()</span><br><span class="line">                  .filter(name -&gt; name.startsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">                  .mapToInt(String::length)</span><br><span class="line">                  .max()</span><br><span class="line">                  .toString();</span><br></pre></td></tr></table></figure><p>Stream 并行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王老五&quot;</span>, <span class="string">&quot;李三&quot;</span>, <span class="string">&quot;刘老四&quot;</span>, <span class="string">&quot;王小二&quot;</span>, <span class="string">&quot;张四&quot;</span>, <span class="string">&quot;张五六七&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">maxLenStartWithZ</span> <span class="operator">=</span> names.stream()</span><br><span class="line">                  .parallel()</span><br><span class="line">                  .filter(name -&gt; name.startsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">                  .mapToInt(String::length)</span><br><span class="line">                  .max()</span><br><span class="line">                  .toString();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 需求：过滤分组一所中学里身高在 160cm 以上的男女同学&lt;/p&gt;
&lt;p&gt;之前的代码实现如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    
    <category term="Stream" scheme="http://example.com/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>接口和抽象类</title>
    <link href="http://example.com/2023/05/24/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>http://example.com/2023/05/24/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</id>
    <published>2023-05-24T06:48:59.000Z</published>
    <updated>2023-05-24T07:04:09.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="抽象类的例子"><a href="#抽象类的例子" class="headerlink" title="抽象类的例子"></a>抽象类的例子</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> enabled;</span><br><span class="line">    <span class="keyword">private</span> Level minPermittedLevel;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Logger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.enabled = enabled;</span><br><span class="line">        <span class="built_in">this</span>.minPermittedLevel = minPermittedLevel;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(Level level, String message)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loggable</span> <span class="operator">=</span> enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intVal)</span><br><span class="line">            <span class="keyword">if</span> (!loggable) <span class="keyword">return</span>;</span><br><span class="line">        doLog(level, message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">(Level level, String message)</span>;                    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类的子类：输出日志到文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Writer fileWriter;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled, Level minPermittedLevel, String filepath)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">        <span class="built_in">this</span>.fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(filepath);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">(Level level, String mesage)</span> &#123;</span><br><span class="line">        <span class="comment">// 格式化 level 和 message, 输出到日志文件</span></span><br><span class="line">        fileWriter.write(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类的子类: 输出日志到消息中间件 (比如 kafka)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageQueueLogger</span> <span class="keyword">extends</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MessageQueueClient msgQueueClient;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageQueueLogger</span><span class="params">(String name, <span class="type">boolean</span> enabled,</span></span><br><span class="line"><span class="params">                              Level minPermittedLevel, MessageQueueClient msgQueueClient)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">    <span class="built_in">this</span>.msgQueueClient = msgQueueClient;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">(Level level, String mesage)</span> &#123;</span><br><span class="line">        <span class="comment">// 格式化 level 和 message, 输出到消息中间件</span></span><br><span class="line">        msgQueueClient.send(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类不允许被实例化，只能被继承。也就是说，你不能 new 一个抽象类的对象出来 （Logger logger &#x3D; new Logger(…); 会报编译错误）。 </p><p>抽象类可以包含属性和方法。方法既可以包含代码实现（比如 Logger 中的 log() 方 法），也可以不包含代码实现（比如 Logger 中的 doLog() 方法）。不包含代码实现的 方法叫作抽象方法。 </p><p>子类继承抽象类，必须实现抽象类中的所有抽象方法。对应到例子代码中就是，所有继 承 Logger 抽象类的子类，都必须重写 doLog() 方法。</p><h1 id="接口的例子"><a href="#接口的例子" class="headerlink" title="接口的例子"></a>接口的例子</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现类：鉴权过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthencationFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="comment">//... 鉴权逻辑..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现类：限流过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimitFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="comment">//... 限流逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 过滤器使用 demo</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="comment">// filters.add(new AuthencationFilter());</span></span><br><span class="line">    <span class="comment">// filters.add(new RateLimitFilter());</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Filter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRpcRequest</span><span class="params">(RpcRequest req)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Filter filter : fitlers) &#123;</span><br><span class="line">                filter.doFilter(req);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(RpcException e) &#123;</span><br><span class="line">            <span class="comment">// ... 处理过滤结果...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... 省略其他处理逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口不能包含属性（也就是成员变量）。 </p><p>接口只能声明方法，方法不能包含代码实现。 </p><p>类实现接口的时候，必须实现接口中声明的所有方法.</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>接口和抽象类，他们要解决的问题不一样 ，首先接口是为了解耦，而抽象类是为了减少编写重复的代码。</p><p>比如说类A和类B都要写一个方法doSomething，那么就可以写一个抽象类，然后A和B都继承该抽象类，而且类A和B可以各自添加各自的功能。</p><p>而接口的解耦体现在，我们定义一个接口之后，他可以有多个实现，我们基于他不同的实现来达到对于模块的划分，隔离接口和具体的实现，提高代码的扩展性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;抽象类的例子&quot;&gt;&lt;a href=&quot;#抽象类的例子&quot; class=&quot;headerlink&quot; title=&quot;抽象类的例子&quot;&gt;&lt;/a&gt;抽象类的例子&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="http://example.com/2023/05/23/Java/ThreadLocal/"/>
    <id>http://example.com/2023/05/23/Java/ThreadLocal/</id>
    <published>2023-05-23T08:05:22.000Z</published>
    <updated>2023-05-23T08:46:10.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal-的使用方法"><a href="#ThreadLocal-的使用方法" class="headerlink" title="ThreadLocal 的使用方法"></a>ThreadLocal 的使用方法</h1><p>下面这个静态类 ThreadId 会为每个线程分配一个唯一的线程 Id，如果<strong>一个线程</strong>前后两次调用 ThreadId 的 get() 方法，两次 get() 方法的返回值是相同的。但如果是<strong>两个线程</strong>分别调用 ThreadId 的 get() 方法，那么两个线程看到的 get() 方法的返回值是不同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadId</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">nextId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 定义ThreadLocal变量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Long&gt; tl = ThreadLocal.withInitial(() -&gt; nextId.getAndIncrement());</span><br><span class="line">  <span class="comment">//此方法会为每个线程分配一个唯一的Id</span></span><br><span class="line">  <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tl.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个使用场景：</p><p>SimpleDateFormat 不是线程安全的，那如果需要在并发场景下使用它，就可以使用ThreadLocal 来解决。不同线程调用 SafeDateFormat 的 get() 方法将返回不同的 SimpleDateFormat 对象实例，由于不同线程并不共享 SimpleDateFormat，所以就像局部变量一样，是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SafeDateFormat</span> &#123;</span><br><span class="line">  <span class="comment">// 定义ThreadLocal变量</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; tl = ThreadLocal.withInitial(()-&gt; <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(</span><br><span class="line">      <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> DateFormat <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tl.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不同线程执行下面代码</span></span><br><span class="line"><span class="comment">// 返回的df是不同的</span></span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> SafeDateFormat.get()；</span><br></pre></td></tr></table></figure><h1 id="ThreadLocal-的工作原理"><a href="#ThreadLocal-的工作原理" class="headerlink" title="ThreadLocal 的工作原理"></a>ThreadLocal 的工作原理</h1><p>Java对于ThreadLocal 的实现，也有一个Map，叫做 ThreadLocalMap，不过持有 ThreadLocalMap 的不是 ThreadLocal，而是 Thread。Thread 这个类内部有一个私有属性 threadLocals，其类型就是 ThreadLocalMap，ThreadLocalMap 的 Key 是 ThreadLocal。如下图所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230523162923334.png" alt="image-20230523162923334" style="zoom:80%;" /><h2 id="另一种设计方案"><a href="#另一种设计方案" class="headerlink" title="另一种设计方案"></a>另一种设计方案</h2><p>如果我们仅仅是简单的用一个Map来保存，即Map的key是线程id，value是每个线程拥有的变量V。这样会导致一个问题，那就是线程的id一直被引用，导致线程资源无法被回收。</p><h1 id="ThreadLocal-与内存泄露"><a href="#ThreadLocal-与内存泄露" class="headerlink" title="ThreadLocal 与内存泄露"></a>ThreadLocal 与内存泄露</h1><p>在线程池中使用 ThreadLocal 为什么可能导致内存泄露呢？原因就出在线程池中线程的存活时间太长，往往都是和程序同生共死的，这就意味着 Thread 持有的 ThreadLocalMap 一直都不会被回收，再加上 ThreadLocalMap 中的 Entry 对 ThreadLocal 是弱引用（WeakReference），所以只要 ThreadLocal 结束了自己的生命周期是可以被回收掉的。但是 Entry 中的 Value 却是被 Entry 强引用的，所以即便 Value 的生命周期结束了，Value 也是无法被回收的，从而导致内存泄露。</p><p>所以我们要手动释放，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService es;</span><br><span class="line">ThreadLocal tl;</span><br><span class="line">es.execute(()-&gt;&#123;</span><br><span class="line">  <span class="comment">//ThreadLocal增加变量</span></span><br><span class="line">  tl.set(obj);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 省略业务逻辑代码</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//手动清理ThreadLocal </span></span><br><span class="line">    tl.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ThreadLocal-的使用方法&quot;&gt;&lt;a href=&quot;#ThreadLocal-的使用方法&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal 的使用方法&quot;&gt;&lt;/a&gt;ThreadLocal 的使用方法&lt;/h1&gt;&lt;p&gt;下面这个静态类 Th</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Copy-on-Write模式</title>
    <link href="http://example.com/2023/05/22/Java/Copy-on-Write/"/>
    <id>http://example.com/2023/05/22/Java/Copy-on-Write/</id>
    <published>2023-05-22T06:19:56.000Z</published>
    <updated>2023-05-22T06:36:19.561Z</updated>
    
    <content type="html"><![CDATA[<p>Copy-on-Write顾名思义就是<strong>写时复制</strong>。比如String的replace()方法就采用了写时复制，即不修改原字符串，而是创建了一个新的，对于不可变对象的写操作往往都是Copy-on-Write方法解决的。</p><h1 id="Copy-on-Write-模式的应用领域"><a href="#Copy-on-Write-模式的应用领域" class="headerlink" title="Copy-on-Write 模式的应用领域"></a>Copy-on-Write 模式的应用领域</h1><p>类 Unix 的操作系统中创建进程的 API 是 fork()，传统的 fork() 函数会创建父进程的一个完整副本，例如父进程的地址空间现在用到了 1G 的内存，那么 fork() 子进程的时候要复制父进程整个进程的地址空间（占有 1G 内存）给子进程，这是比较耗时的。</p><p>而 Linux 中 fork() 子进程的时候，并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间；只用在<strong>父进程或者子进程需要写入</strong>的时候才会复制地址空间，从而使父子进程拥有各自的地址空间。</p><p>本质上来讲，父子进程的地址空间以及数据都是要隔离的，使用 Copy-on-Write 更多地体现的是一种<strong>延时策略，只有在真正需要复制的时候才复制，而不是提前复制好</strong>，同时 Copy-on-Write 还支持按需复制。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Copy-on-Write顾名思义就是&lt;strong&gt;写时复制&lt;/strong&gt;。比如String的replace()方法就采用了写时复制，即不修改原字符串，而是创建了一个新的，对于不可变对象的写操作往往都是Copy-on-Write方法解决的。&lt;/p&gt;
&lt;h1 id=&quot;C</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>设计模式实战</title>
    <link href="http://example.com/2023/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98/"/>
    <id>http://example.com/2023/05/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98/</id>
    <published>2023-05-20T08:43:39.000Z</published>
    <updated>2023-05-22T07:11:59.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h1><p>代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 奖励服务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RewardService</span> &#123;</span><br><span class="line">    <span class="comment">// 外部服务</span></span><br><span class="line">    <span class="keyword">private</span> WaimaiService waimaiService;</span><br><span class="line">    <span class="keyword">private</span> HotelService hotelService;</span><br><span class="line">    <span class="keyword">private</span> FoodService foodService;</span><br><span class="line">    <span class="comment">// 使用对入参的条件判断进行发奖</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issueReward</span><span class="params">(String rewardType, Object ... params)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (“Waimai”.equals(rewardType)) &#123;</span><br><span class="line">            <span class="type">WaimaiRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaimaiRequest</span>();</span><br><span class="line">            <span class="comment">// 构建入参</span></span><br><span class="line">            request.setWaimaiReq(params);</span><br><span class="line">            waimaiService.issueWaimai(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (“Hotel”.equals(rewardType)) &#123;</span><br><span class="line">            <span class="type">HotelRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelRequest</span>();</span><br><span class="line">            request.addHotelReq(params);</span><br><span class="line">            hotelService.sendPrize(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (“Food”.equals(rewardType)) &#123;</span><br><span class="line">            <span class="type">FoodRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodRequest</span>(params);</span><br><span class="line">            foodService.getCoupon(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(“rewardType error!”);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样设计，如果说需要新添加一个服务，就需要添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> NewService newService;</span><br><span class="line"><span class="comment">// else if下面添加新的</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;new&quot;</span>.equals(rewardType)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过第一次修改后，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 策略接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">issue</span><span class="params">(Object ... params)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外卖策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Waimai</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> WaimaiService waimaiService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issue</span><span class="params">(Object... params)</span> &#123;</span><br><span class="line">        <span class="type">WaimaiRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaimaiRequest</span>();</span><br><span class="line">        <span class="comment">// 构建入参</span></span><br><span class="line">        request.setWaimaiReq(params);</span><br><span class="line">        waimaiService.issueWaimai(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 酒旅策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hotel</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HotelService hotelService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issue</span><span class="params">(Object... params)</span> &#123;</span><br><span class="line">        <span class="type">HotelRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelRequest</span>();</span><br><span class="line">        request.addHotelReq(params);</span><br><span class="line">        hotelService.sendPrize(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 美食策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Food</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> FoodService foodService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issue</span><span class="params">(Object... params)</span> &#123;</span><br><span class="line">        <span class="type">FoodRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodRequest</span>(params);</span><br><span class="line">        foodService.payCoupon(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用分支判断获取的策略上下文</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrategyContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title function_">getStrategy</span><span class="params">(String rewardType)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (rewardType) &#123;</span><br><span class="line">            <span class="keyword">case</span>“Waimai”:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Waimai</span>();</span><br><span class="line">            <span class="keyword">case</span>“Hotel”:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Hotel</span>();</span><br><span class="line">            <span class="keyword">case</span>“Food”:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Food</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(“rewardType error!”);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后的策略服务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RewardService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issueReward</span><span class="params">(String rewardType, Object ... params)</span> &#123;</span><br><span class="line">        <span class="type">Strategy</span> <span class="variable">strategy</span> <span class="operator">=</span> StrategyContext.getStrategy(rewardType);</span><br><span class="line">        strategy.issue(params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种优化，使用了一个接口，没当需要新添加服务时，只需要实现该接口</p><p>这次优化后，还有一个问题，那就是策略类，可以改为单例模式，如果之前有，就不需要新创建，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 策略上下文，用于管理策略的注册和获取</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrategyContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Strategy&gt; registerMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 注册策略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerStrategy</span><span class="params">(String rewardType, Strategy strategy)</span> &#123;</span><br><span class="line">        registerMap.putIfAbsent(rewardType, strategy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取策略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title function_">getStrategy</span><span class="params">(String rewardType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> registerMap.get(rewardType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象策略类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="comment">// 类注册方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> &#123;</span><br><span class="line">        StrategyContext.registerStrategy(getClass().getSimpleName(), <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单例外卖策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Waimai</span> <span class="keyword">extends</span> <span class="title class_">AbstractStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Waimai</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Waimai</span>();</span><br><span class="line">    <span class="keyword">private</span> WaimaiService waimaiService;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Waimai</span><span class="params">()</span> &#123;</span><br><span class="line">        register();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Waimai <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issue</span><span class="params">(Object... params)</span> &#123;</span><br><span class="line">        <span class="type">WaimaiRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaimaiRequest</span>();</span><br><span class="line">        <span class="comment">// 构建入参</span></span><br><span class="line">        request.setWaimaiReq(params);</span><br><span class="line">        waimaiService.issueWaimai(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单例酒旅策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hotel</span> <span class="keyword">extends</span> <span class="title class_">AbstractStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Hotel</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hotel</span>();</span><br><span class="line">    <span class="keyword">private</span> HotelService hotelService;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Hotel</span><span class="params">()</span> &#123;</span><br><span class="line">        register();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Hotel <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issue</span><span class="params">(Object... params)</span> &#123;</span><br><span class="line">        <span class="type">HotelRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelRequest</span>();</span><br><span class="line">        request.addHotelReq(params);</span><br><span class="line">        hotelService.sendPrize(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单例美食策略</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Food</span> <span class="keyword">extends</span> <span class="title class_">AbstractStrategy</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Food</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Food</span>();</span><br><span class="line">    <span class="keyword">private</span> FoodService foodService;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Food</span><span class="params">()</span> &#123;</span><br><span class="line">        register();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Food <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">issue</span><span class="params">(Object... params)</span> &#123;</span><br><span class="line">        <span class="type">FoodRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FoodRequest</span>(params);</span><br><span class="line">        foodService.payCoupon(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>这次优化后，每次注册完成后，map中会有一个该对象，下次使用时就不需要创建，直接拿之前已经有的即可。</p><h1 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务状态枚举</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">TaskState</span> &#123;</span><br><span class="line">    INIT(“初始化”),</span><br><span class="line">    ONGOING( “进行中”),</span><br><span class="line">    PAUSED(“暂停中”),</span><br><span class="line">    FINISHED(“已完成”),</span><br><span class="line">    EXPIRED(“已过期”);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 行为枚举</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">ActionType</span> &#123;</span><br><span class="line">    START(<span class="number">1</span>, “开始”),</span><br><span class="line">    STOP(<span class="number">2</span>, “暂停”),</span><br><span class="line">    ACHIEVE(<span class="number">3</span>, “完成”),</span><br><span class="line">    EXPIRE(<span class="number">4</span>, “过期”);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long taskId;</span><br><span class="line">    <span class="comment">// 任务的默认状态为初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TaskState</span> <span class="variable">state</span> <span class="operator">=</span> TaskState.INIT;</span><br><span class="line">    <span class="comment">// 活动服务</span></span><br><span class="line">    <span class="keyword">private</span> ActivityService activityService;</span><br><span class="line">    <span class="comment">// 任务管理器</span></span><br><span class="line">    <span class="keyword">private</span> TaskManager taskManager;</span><br><span class="line">    <span class="comment">// 使用条件分支进行任务更新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateState</span><span class="params">(ActionType actionType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (state == TaskState.INIT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (actionType == ActionType.START) &#123;</span><br><span class="line">                state = TaskState.ONGOING;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == TaskState.ONGOING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (actionType == ActionType.ACHIEVE) &#123;</span><br><span class="line">                state = TaskState.FINISHED;</span><br><span class="line">                <span class="comment">// 任务完成后进对外部服务进行通知</span></span><br><span class="line">                activityService.notifyFinished(taskId);</span><br><span class="line">                taskManager.release(taskId);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.STOP) &#123;</span><br><span class="line">                state = TaskState.PAUSED;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.EXPIRE) &#123;</span><br><span class="line">                state = TaskState.EXPIRED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == TaskState.PAUSED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (actionType == ActionType.START) &#123;</span><br><span class="line">                state = TaskState.ONGOING;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.EXPIRE) &#123;</span><br><span class="line">                state = TaskState.EXPIRED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的问题是if-else判断太多，如果新添加状态还需要添加新的if-else，这里可以用状态模式。而且Task类中冗余了TaskManager类。</p><p>修改后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务状态抽象接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">// 默认实现，不做任何处理</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Task task, ActionType actionType)</span> &#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务初始状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskInit</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Task task, ActionType actionType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (actionType == ActionType.START) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskOngoing</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务进行状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskOngoing</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ActivityService activityService;</span><br><span class="line">    <span class="keyword">private</span> TaskManager taskManager;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Task task, ActionType actionType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (actionType == ActionType.ACHIEVE) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskFinished</span>());</span><br><span class="line">            <span class="comment">// 通知</span></span><br><span class="line">            activityService.notifyFinished(taskId);</span><br><span class="line">            taskManager.release(taskId);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.STOP) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskPaused</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.EXPIRE) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskExpired</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务暂停状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskPaused</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Task task, ActionType actionType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (actionType == ActionType.START) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskOngoing</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.EXPIRE) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskExpired</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务完成状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskFinished</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务过期状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskExpired</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long taskId;</span><br><span class="line">    <span class="comment">// 初始化为初始态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskInit</span>();</span><br><span class="line">    <span class="comment">// 更新状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateState</span><span class="params">(ActionType actionType)</span> &#123;</span><br><span class="line">        state.update(<span class="built_in">this</span>, actionType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用观察者模式后，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象观察者</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">response</span><span class="params">(Long taskId)</span>; <span class="comment">// 反应</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象目标</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line">    <span class="comment">// 增加观察者方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除观察者方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知观察者方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObserver</span><span class="params">(Long taskId)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.response(taskId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 活动观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActivityObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ActivityService activityService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">response</span><span class="params">(Long taskId)</span> &#123;</span><br><span class="line">        activityService.notifyFinished(taskId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务管理观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskManageObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TaskManager taskManager;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">response</span><span class="params">(Long taskId)</span> &#123;</span><br><span class="line">        taskManager.release(taskId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务进行状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskOngoing</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Task task, ActionType actionType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (actionType == ActionType.ACHIEVE) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskFinished</span>());</span><br><span class="line">            <span class="comment">// 通知</span></span><br><span class="line">            notifyObserver(task.getTaskId());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.STOP) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskPaused</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionType == ActionType.EXPIRE) &#123;</span><br><span class="line">            task.setState(<span class="keyword">new</span> <span class="title class_">TaskExpired</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任务初始状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskInit</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Task task, ActionType actionType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (actionType == ActionType.START) &#123;</span><br><span class="line">            <span class="type">TaskOngoing</span> <span class="variable">taskOngoing</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskOngoing</span>();</span><br><span class="line">            taskOngoing.add(<span class="keyword">new</span> <span class="title class_">ActivityObserver</span>());</span><br><span class="line">            taskOngoing.add(<span class="keyword">new</span> <span class="title class_">TaskManageObserver</span>());</span><br><span class="line">            task.setState(taskOngoing);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《美团博客》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;demo1&quot;&gt;&lt;a href=&quot;#demo1&quot; class=&quot;headerlink&quot; title=&quot;demo1&quot;&gt;&lt;/a&gt;demo1&lt;/h1&gt;&lt;p&gt;代码片段&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式下如何排查慢请求</title>
    <link href="http://example.com/2023/05/17/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8B%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E6%85%A2%E8%AF%B7%E6%B1%82/"/>
    <id>http://example.com/2023/05/17/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8B%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E6%85%A2%E8%AF%B7%E6%B1%82/</id>
    <published>2023-05-17T09:53:02.000Z</published>
    <updated>2023-05-22T07:05:38.749Z</updated>
    
    <content type="html"><![CDATA[<p>在引入了注册中心后，微服务项目的架构会变成下图：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514175352625.png" alt="image-20230514175352625"></p><p>但是，如果此时有一个请求的响应速度比较慢，而这个请求调用了多个RPC服务，该如何去排查呢？</p><h1 id="一体化架构中的慢请求排查如何做"><a href="#一体化架构中的慢请求排查如何做" class="headerlink" title="一体化架构中的慢请求排查如何做"></a>一体化架构中的慢请求排查如何做</h1><p>最简单的办法，就是像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">processA();</span><br><span class="line"><span class="comment">// 打印A步骤的耗时</span></span><br><span class="line">Logs.info(<span class="string">&quot;process A cost &quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line">processB();</span><br><span class="line"><span class="comment">// 打印B步骤的耗时</span></span><br><span class="line">Logs.info(<span class="string">&quot;process B cost &quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line">processC();</span><br><span class="line"><span class="comment">// 打印C步骤的耗时</span></span><br><span class="line">Logs.info(<span class="string">&quot;process C cost &quot;</span> + (System.currentTimeMillis() - start));</span><br></pre></td></tr></table></figure><p>但是这样会有一个问题，如果多个用户同时下单，那么日志的打印是穿插进行的，无法判断。</p><p>一个简单的解决办法是，给每个请求每一行日志加一个id，用于区分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">requestId</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">ThreadLocal&lt;String&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> requestId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; <span class="comment">//requestId存储在线程上下文中</span></span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">processA();</span><br><span class="line">Logs.info(<span class="string">&quot;rid : &quot;</span> + tl.get() + <span class="string">&quot;, process A cost &quot;</span> + (System.currentTimeMillis() - start)); <span class="comment">// 日志中增加requestId</span></span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line">processB();</span><br><span class="line">Logs.info(<span class="string">&quot;rid : &quot;</span> + tl.get() + <span class="string">&quot;, process B cost &quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">start = System.currentTimeMillis();</span><br><span class="line">processC();</span><br><span class="line">Logs.info(<span class="string">&quot;rid : &quot;</span> + tl.get() + <span class="string">&quot;, process C cost &quot;</span> + (System.currentTimeMillis() - start));</span><br></pre></td></tr></table></figure><h1 id="利用切面编程"><a href="#利用切面编程" class="headerlink" title="利用切面编程"></a>利用切面编程</h1><p>一般来说，切面分为两类：</p><ul><li><p>一类是静态代理，典型的代表是 AspectJ，它的特点是在编译期做切面代码注入；</p></li><li><p>另一类是动态代理，典型的代表是 Spring AOP，它的特点是在运行期做切面代码注入</p></li></ul><p>区别：</p><p>静态代理是在编译期插入代码，增加了编译的时间，给你的直观感觉就是启动的时间变长了，但是一旦在编译期插入代码完毕之后在运行期就基本对于性能没有影响。</p><p>而动态代理不会去修改生成的 Class 文件，而是会在运行期生成一个代理对象，这个代理对象对源对象做了字节码增强，来完成切面所要执行的操作。由于在运行期需要生成代理对象，所以动态代理的性能要比静态代理要差。</p><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><p>为了避免打印过多的日志，我们可以根据id进行采样，比如说只打印id % 10 &#x3D;&#x3D; 0的，这样就只统计局部的 也可以实现需求。</p><p>但是还有一个问题，如果这样的话，拿到一个id我们并不知道它是属于哪个服务器的，我们还需要去服务器查询。解决办法就是将日志通过消息队列插入Elasticsearch，这样搜索也比较简单。如下图：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514183317870.png" alt="image-20230514183317870"></p><h1 id="如何来做分布式-Trace"><a href="#如何来做分布式-Trace" class="headerlink" title="如何来做分布式 Trace"></a>如何来做分布式 Trace</h1><p>采用traceId + spanId</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514184244939.png" alt="image-20230514184244939"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在引入了注册中心后，微服务项目的架构会变成下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514175352625.png&quot; alt=&quot;image-</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="高并发系统设计" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="微服务架构" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>java并发容器</title>
    <link href="http://example.com/2023/05/16/Java/java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    <id>http://example.com/2023/05/16/Java/java%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</id>
    <published>2023-05-16T14:38:17.000Z</published>
    <updated>2023-05-22T07:04:35.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>List 里面只有一个实现类就是 <strong>CopyOnWriteArrayList</strong>。</p><p>CopyOnWrite，顾名思义就是写的时候会将共享变量新复制一份出来，这样做的好处是读操作完全无锁。</p><p>CopyOnWriteArrayList 内部维护了一个数组，成员变量 array 就指向这个内部数组，所有的读操作都是基于 array 进行的，迭代器 Iterator 遍历的就是 array 数组。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230515224227570.png" alt="image-20230515224227570"></p><p>如果在遍历时，还有写入时，CopyOnWriteArrayList 会将 array 复制一份，然后在新复制处理的数组上执行增加元素的操作，执行完之后再将 array 指向这个新的数组。遍历操作一直都是基于原 array 执行，而写操作则是基于新 array 进行。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230515224431375.png" alt="image-20230515224431375" style="zoom: 80%;" /><p>注意：CopyOnWriteArrayList 仅适用于写操作非常少的场景，而且能够容忍读写的短暂不一致。因为遍历时，写入的新元素并不能第一之间被遍历到。</p><p>CopyOnWriteArrayList 迭代器是只读的，不支持增删改。因为迭代器遍历的仅仅是一个快照，而对快照进行增删改是没有意义的。</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>Map 接口的两个实现是 ConcurrentHashMap 和 ConcurrentSkipListMap，它们从应用的角度来看，主要区别在于 <strong>ConcurrentHashMap 的 key 是无序的，而 ConcurrentSkipListMap 的 key 是有序的</strong>。而且他们的key和value都不能为空。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230515224643521.png" alt="image-20230515224643521" style="zoom:80%;" /><p>ConcurrentSkipListMap 里面的 SkipList 本身就是一种数据结构，中文一般都翻译为“跳表”。</p><p>跳表插入、删除、查询操作平均的时间复杂度是 O(log n)，理论上和并发线程数没有关系，所以在并发度非常高的情况下，若你对 ConcurrentHashMap 的性能还不满意，可以尝试一下 ConcurrentSkipListMap。</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>Set 接口的两个实现是 CopyOnWriteArraySet 和 ConcurrentSkipListSet，使用场景可以参考前面讲述的 CopyOnWriteArrayList 和 ConcurrentSkipListMap。</p><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p>队列可以从以下两个维度来分：</p><p>一个维度是<strong>阻塞与非阻塞</strong>，所谓阻塞指的是当队列已满时，入队操作阻塞；当队列已空时，出队操作阻塞。</p><p>另一个维度是<strong>单端与双端</strong>，单端指的是只能队尾入队，队首出队；而双端指的是队首队尾皆可入队出队。</p><p>可以将Queue分为4大类</p><p>1、<strong>单端阻塞队列</strong>：其实现有 ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、LinkedTransferQueue、PriorityBlockingQueue 和 DelayQueue。</p><p>内部一般会持有一个队列，这个队列可以是数组（其实现是 ArrayBlockingQueue）也可以是链表（其实现是 LinkedBlockingQueue）；甚至还可以不持有队列（其实现是 SynchronousQueue），此时生产者线程的入队操作必须等待消费者线程的出队操作。</p><p>而 LinkedTransferQueue 融合 LinkedBlockingQueue 和 SynchronousQueue 的功能，性能比 LinkedBlockingQueue 更好；PriorityBlockingQueue 支持按照优先级出队；DelayQueue 支持延时出队。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230515225105664.png" alt="image-20230515225105664" style="zoom:67%;" /><p>2.<strong>双端阻塞队列</strong>：其实现是 LinkedBlockingDeque。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230515225129204.png" alt="image-20230515225129204" style="zoom:67%;" /><p>3.<strong>单端非阻塞队列</strong>：其实现是 ConcurrentLinkedQueue。</p><p>4.<strong>双端非阻塞队列</strong>：其实现是 ConcurrentLinkedDeque。</p><p>在使用队列时，要注意队列是否是有界的，在使用无界队列时，要注意是否会导致OOM异常。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Java并发编程实战》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;List&quot;&gt;&lt;a href=&quot;#List&quot; class=&quot;headerlink&quot; title=&quot;List&quot;&gt;&lt;/a&gt;List&lt;/h1&gt;&lt;p&gt;List 里面只有一个实现类就是 &lt;strong&gt;CopyOnWriteArrayList&lt;/strong&gt;。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Api网关</title>
    <link href="http://example.com/2023/05/16/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Api%E7%BD%91%E5%85%B3/"/>
    <id>http://example.com/2023/05/16/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Api%E7%BD%91%E5%85%B3/</id>
    <published>2023-05-16T06:08:58.000Z</published>
    <updated>2023-05-16T07:15:51.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="API-网关起到的作用"><a href="#API-网关起到的作用" class="headerlink" title="API 网关起到的作用"></a>API 网关起到的作用</h1><p>API 网关可以分为两类：<strong>一类叫做入口网关，一类叫做出口网关。</strong></p><h2 id="入口网关"><a href="#入口网关" class="headerlink" title="入口网关"></a>入口网关</h2><p>入口网关部署在负载均衡服务器和应用服务器之间，<strong>主要有几方面的作用。</strong></p><p>1、它提供客户端一个统一的接入地址，API 网关可以将用户的请求动态路由到不同的业务服务上，并且做一些必要的协议转换工作。这里有一点需要注意，<strong>你部署的微服务对外暴露的协议可能不同</strong>，有些可能是RPC，有些可能是Http，这些细节都可以在网关中处理。</p><p>2、另一方面，在 API 网关中，我们可以植入一些服务治理的策略，比如服务的熔断、降级、流量控制和分流等等。</p><p>3、客户端的认证和授权的实现，也可以放在 API 网关中。</p><p>4、另外，API 网关还可以做一些与黑白名单相关的事情，比如针对设备 ID、用户 IP、用户 ID 等维度的黑白名单。</p><p>5、最后，在 API 网关中也可以做一些日志记录的事情。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230516142313124.png" alt="image-20230516142313124" style="zoom:67%;" /><h2 id="出口网关"><a href="#出口网关" class="headerlink" title="出口网关"></a>出口网关</h2><p>我们在系统开发中，会依赖很多外部的第三方系统，典型的例子：第三方账户登录、使用第三方工具支付等等。我们可以在应用服务器和第三方系统之间，部署出口网关，在出口网关中，对调用外部的 API 做统一的认证、授权、审计以及访问控制。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230516142531792.png" alt="image-20230516142531792" style="zoom:67%;" /><h1 id="网关实现"><a href="#网关实现" class="headerlink" title="网关实现"></a>网关实现</h1><p>在实现网关时，需要注意一点：为了提升网关对于请求的并行处理能力，我们一般会使用线程池来并行的执行请求。</p><p>但是这样设计也同样会带来一些问题：假如一个服务出现问题导致响应过慢，那么调用该服务的模块也会被阻塞，其他服务也会级联受到影响，导致无法线程池中的线程无法释放，对整个系统造成影响。</p><p>因此，我们需要针对不同的服务做线程隔离或者保护。<strong>有两种思路：</strong></p><ul><li>如果你后端的服务拆分得不多，可以针对不同的服务，采用不同的线程池，这样一个服务的故障就不会影响到其他服务；</li><li>在线程池内部可以针对不同的服务甚至不同的接口做线程的保护。比如说，线程池的最大线程数是 1000，那么可以给每个服务设置一个最多可以使用的配额。</li></ul><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230516151544806.png" alt="image-20230516151544806"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;API-网关起到的作用&quot;&gt;&lt;a href=&quot;#API-网关起到的作用&quot; class=&quot;headerlink&quot; title=&quot;API 网关起到的作用&quot;&gt;&lt;/a&gt;API 网关起到的作用&lt;/h1&gt;&lt;p&gt;API 网关可以分为两类：&lt;strong&gt;一类叫做入口网关，一类叫做</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="高并发系统设计" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="微服务架构" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡</title>
    <link href="http://example.com/2023/05/15/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://example.com/2023/05/15/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2023-05-15T09:24:59.000Z</published>
    <updated>2023-05-15T11:58:59.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="负载均衡服务器的种类"><a href="#负载均衡服务器的种类" class="headerlink" title="负载均衡服务器的种类"></a>负载均衡服务器的种类</h1><p><strong>负载均衡的含义是：</strong>将负载（访问的请求）“均衡”地分配到多个处理节点上。这样可以减少单个处理节点的请求量，提升整体系统的性能。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230515172635623.png" alt="image-20230515172635623" style="zoom:67%;" /><p>在项目的架构中，我们一般会同时部署 LVS 和 Nginx 来做 HTTP 应用服务的负载均衡。也就是说，在入口处部署 LVS 将流量分发到多个 Nginx 服务器上，再由 Nginx 服务器分发到应用服务器上。</p><p>不过这两个负载均衡服务适用于普通的 Web 服务，对于微服务架构来说，它们是不合适的。</p><p>因为微服务架构中的服务节点存储在注册中心里，使用 LVS 就很难和注册中心交互获取全量的服务节点列表。另外，一般微服务架构中，使用的是 RPC 协议而不是 HTTP 协议，所以 Nginx 也不能满足要求。</p><p><strong>所以，我们会使用另一类的负载均衡服务，客户端负载均衡服务，也就是把负载均衡的服务内嵌在 RPC 客户端中。</strong></p><p>这类服务一般会结合注册中心来使用，注册中心提供服务节点的完整列表，客户端拿到列表之后使用负载均衡服务的策略选取一个合适的节点，然后将请求发到这个节点上。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230515194359296.png" alt="image-20230515194359296"></p><h2 id="常见的负载均衡策略有哪些"><a href="#常见的负载均衡策略有哪些" class="headerlink" title="常见的负载均衡策略有哪些"></a>常见的负载均衡策略有哪些</h2><ul><li><p>一类是静态策略，也就是说负载均衡服务器在选择服务节点时，不会参考后端服务的实际运行的状态；</p></li><li><p>一类是动态策略，也就是说负载均衡服务器会依据后端服务的一些负载特性，来决定要选择哪一个服务节点。</p></li></ul><p>静态的又有以下几种策略：</p><ul><li><strong>轮询的策略</strong>：如果服务器性能不一样，则不能很好的发挥作用</li><li><strong>带有权重的轮询策略</strong></li></ul><p>动态策略：</p><ul><li>Dubbo 提供的 LeastAcive 策略，就是优先选择活跃连接数最少的服务；</li><li>Spring Cloud 全家桶中的 Ribbon 提供了 WeightedResponseTimeRule 是使用响应时间给每个服务节点计算一个权重，然后依据这个权重，来给调用方分配服务节点。</li></ul><p><strong>这些策略的思考点</strong>是从调用方的角度出发，选择负载最小、资源最空闲的服务来调用，以期望能得到更高的服务调用性能</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;负载均衡服务器的种类&quot;&gt;&lt;a href=&quot;#负载均衡服务器的种类&quot; class=&quot;headerlink&quot; title=&quot;负载均衡服务器的种类&quot;&gt;&lt;/a&gt;负载均衡服务器的种类&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;负载均衡的含义是：&lt;/strong&gt;将负载（访问的请求）“均</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="高并发系统设计" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="微服务架构" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch和CyclicBarrier：如何让多线程步调一致</title>
    <link href="http://example.com/2023/05/14/Java/CountDownLatch%E5%92%8CCyclicBarrier%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%A9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%A5%E8%B0%83%E4%B8%80%E8%87%B4/"/>
    <id>http://example.com/2023/05/14/Java/CountDownLatch%E5%92%8CCyclicBarrier%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%A9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%A5%E8%B0%83%E4%B8%80%E8%87%B4/</id>
    <published>2023-05-14T11:02:59.000Z</published>
    <updated>2023-05-14T11:45:12.442Z</updated>
    
    <content type="html"><![CDATA[<p> 假如我们要实现一下功能：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514190414839.png" alt="image-20230514190414839" style="zoom:67%;" /><p>如果单线程处理，那么执行图如下：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514190537547.png" alt="image-20230514190537547" style="zoom:67%;" /><p>如果想要优化，则可以将获取order的操作并行执行，如下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514190619676.png" alt="image-20230514190619676" style="zoom:67%;" /><p>大致的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (存在未对账订单) &#123;</span><br><span class="line">    <span class="comment">// 查询未对账订单</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">T1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        pos = getPOrders();</span><br><span class="line">    &#125;);</span><br><span class="line">    T1.start();</span><br><span class="line">    <span class="comment">// 查询派送单</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">T2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        dos = getDOrders();</span><br><span class="line">    &#125;);</span><br><span class="line">    T2.start();</span><br><span class="line">    <span class="comment">// 等待T1、T2结束</span></span><br><span class="line">    T1.join();</span><br><span class="line">    T2.join();</span><br><span class="line">    <span class="comment">// 执行对账操作</span></span><br><span class="line">    diff = check(pos, dos);</span><br><span class="line">    <span class="comment">// 差异写入差异库</span></span><br><span class="line">    save(diff);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>但是这样写有一个缺点，就是while循环每次都要创建线程，而创建线程开销又比较的大，所以我们可以用线程池有优化。</p><h1 id="用-CountDownLatch-实现线程等待"><a href="#用-CountDownLatch-实现线程等待" class="headerlink" title="用 CountDownLatch 实现线程等待"></a>用 CountDownLatch 实现线程等待</h1><p>因为没有手动创建线程，所以没有join方法，那么如何通知主线程两个子线程已经执行完成了呢？我们可以使用<strong>CountDownLatch</strong></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建2个线程的线程池</span></span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span> (存在未对账订单) &#123;</span><br><span class="line">    <span class="comment">// 计数器初始化为2</span></span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 查询未对账订单</span></span><br><span class="line">    executor.execute(()-&gt; &#123;</span><br><span class="line">        pos = getPOrders();</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 查询派送单</span></span><br><span class="line">    executor.execute(()-&gt; &#123;</span><br><span class="line">        dos = getDOrders();</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待两个查询操作结束</span></span><br><span class="line">    latch.await();</span><br><span class="line">    <span class="comment">// 执行对账操作</span></span><br><span class="line">    diff = check(pos, dos);</span><br><span class="line">    <span class="comment">// 差异写入差异库</span></span><br><span class="line">    save(diff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h1><p>在查询完第一次后进行对比时，可以进行第二次查询，如下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514191455335.png" alt="image-20230514191455335" style="zoom:67%;" /><p>这里有点生产者-消费者的意思了，查询 可以当作生产者，查询玩的计算可以当作消费者。既然是生产者 - 消费者模型，那就需要有个队列，来保存生产者生产的数据，而消费者则从这个队列消费数据。</p><p>我们可以用两个队列，一个存储查询订单，一个存储派送订单，然后两个线程，当每个线程都查询一条数据时，通知第三个线程去执行计算。但是这样需要保证查询线程速度一样。</p><h2 id="用-CyclicBarrier-实现线程同步"><a href="#用-CyclicBarrier-实现线程同步" class="headerlink" title="用 CyclicBarrier 实现线程同步"></a>用 CyclicBarrier 实现线程同步</h2><p>线程 T1 负责查询订单，当查出一条时，调用 barrier.await() 来将计数器减 1，同时等待计数器变成 0；线程 T2 负责查询派送单，当查出一条时，也调用 barrier.await() 来将计数器减 1，同时等待计数器变成 0；当 T1 和 T2 都调用 barrier.await() 的时候，计数器会减到 0，此时 T1 和 T2 就可以执行下一条语句了，同时会调用 barrier 的回调函数来执行对账操作。</p><p>CyclicBarrier 的计数器有自动重置的功能，当减到 0 的时候，会自动重置你设置的初始值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订单队列</span></span><br><span class="line">Vector&lt;P&gt; pos;</span><br><span class="line"><span class="comment">// 派送单队列</span></span><br><span class="line">Vector&lt;D&gt; dos;</span><br><span class="line"><span class="comment">// 执行回调的线程池， 这里好像必须为1</span></span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 计数器的值为2</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>, ()-&gt;&#123;</span><br><span class="line">    executor.execute(()-&gt;check());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断时，将队列中的元素移除</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">P</span> <span class="variable">p</span> <span class="operator">=</span> pos.remove(<span class="number">0</span>);</span><br><span class="line">    <span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> dos.remove(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 执行对账操作</span></span><br><span class="line">    diff = check(p, d);</span><br><span class="line">    <span class="comment">// 差异写入差异库</span></span><br><span class="line">    save(diff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">checkAll</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 循环查询订单库</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">T1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(存在未对账订单)&#123;</span><br><span class="line">            <span class="comment">// 查询订单库</span></span><br><span class="line">            pos.add(getPOrders());</span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    T1.start();  </span><br><span class="line">    <span class="comment">// 循环查询运单库</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">T2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(存在未对账订单)&#123;</span><br><span class="line">            <span class="comment">// 查询运单库</span></span><br><span class="line">            dos.add(getDOrders());</span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    T2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>CountDownLatch 主要用来解决一个线程等待多个线程的场景</strong></p><p><strong>CyclicBarrier 是一组线程之间互相等待</strong></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Java并发编程实战》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 假如我们要实现一下功能：&lt;/p&gt;
&lt;img src=&quot;https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230514190414839.png&quot; alt=&quot;image-20230514190414</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>注册中心</title>
    <link href="http://example.com/2023/05/13/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    <id>http://example.com/2023/05/13/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</id>
    <published>2023-05-13T10:27:15.000Z</published>
    <updated>2023-05-14T09:50:29.412Z</updated>
    
    <content type="html"><![CDATA[<p> 当一个项目拆分成微服务之后，接口之间的调用就需要跨网络来完成，这时候就需要知道另外一个接口的ip地址以及端口号，如果把这些内容全部在代码里面写死，那么如果ip发生变动，就需要重启服务，还需要修改代码。注册中心的诞生就解决了这个问题。</p><p>注册中心的基本功能有两点：</p><ul><li><p>一是提供了服务地址的存储；</p></li><li><p>二是当存储内容发生变化时，可以将变更的内容推送给客户端。</p></li></ul><p>使用了注册中心组件之后，RPC 的通信过程就变成了下面这个样子：</p><ul><li><p>客户端会与注册中心建立连接，并且告诉注册中心，它对哪一组服务感兴趣；</p></li><li><p>服务端向注册中心注册服务后，注册中心会将最新的服务注册信息通知给客户端；</p></li><li><p>客户端拿到服务端的地址之后就可以向服务端发起调用请求了。</p></li></ul><h1 id="服务状态管理如何来做"><a href="#服务状态管理如何来做" class="headerlink" title="服务状态管理如何来做"></a>服务状态管理如何来做</h1><p>服务的上线和下线是由服务端主动向注册中心注册和取消注册来实现的，这在正常的流程中是没有问题的。<strong>可是，如果某一个服务端意外故障，</strong>比如说机器掉电，网络不通等情况，服务端就没有办法向注册中心通信，将自己从服务列表中删除，就会导致客户端请求一个无法响应的服务。</p><h2 id="主动探测"><a href="#主动探测" class="headerlink" title="主动探测"></a>主动探测</h2><p>你的 RPC 服务要打开一个端口，然后由注册中心每隔一段时间（比如 30 秒）探测这些端口是否可用，如果可用就认为服务仍然是正常的，否则就可以认为服务不可用，那么注册中心就可以把服务从列表里面删除了。</p><p>这样做的如果服务比较多的话，成本就会比较的高。</p><h2 id="心跳模式"><a href="#心跳模式" class="headerlink" title="心跳模式"></a>心跳模式</h2><p>注册中心为每一个连接上来的 RPC 服务节点记录最近续约的时间，RPC 服务节点在启动注册到注册中心后，就按照一定的时间间隔（比如 30 秒），向注册中心发送心跳包。注册中心在接收到心跳包之后，会更新这个节点的最近续约时间。然后，注册中心会启动一个定时器定期检测当前时间和节点最近续约时间的差值，如果达到一个阈值（比如说 90 秒），那么认为这个服务节点不可用。</p><h2 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h2><p>要避免注册中心因为监测不到心跳而摘除所有的服务，要设置一定的警报，如果摘除超过一定比例的服务后，要发起警告。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 当一个项目拆分成微服务之后，接口之间的调用就需要跨网络来完成，这时候就需要知道另外一个接口的ip地址以及端口号，如果把这些内容全部在代码里面写死，那么如果ip发生变动，就需要重启服务，还需要修改代码。注册中心的诞生就解决了这个问题。&lt;/p&gt;
&lt;p&gt;注册中心的基本功能有两点</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="高并发系统设计" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="微服务架构" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Redis的I/O多路复用</title>
    <link href="http://example.com/2023/05/12/Redis/Redis%E7%9A%84I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>http://example.com/2023/05/12/Redis/Redis%E7%9A%84I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2023-05-12T12:36:26.000Z</published>
    <updated>2023-05-11T13:52:45.058Z</updated>
    
    <content type="html"><![CDATA[<p>在Redis6.0之前，它的网络I&#x2F;O模型是单线程的，那么它是怎么处理多个客户端的连接的呢？这里就涉及到Redis的I&#x2F;O模型，基于多路复用的高性能 I&#x2F;O 模型。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230511204107493.png" alt="image-20230511204107493"></p><p>我个人对它的理解如下：</p><p>它的模型需要用到操作系统的epoll机制，也就是说需要内核来监控Redis建立的多个Socket，这也就是为什么Windows操作系统发挥不了Redis的最大性能，因为它只支持Select模式，不支持epoll模式。</p><p>Redis的一个线程只需要来处理客户端的请求，为它建立一个Socket。epoll机制允许内核一次监听多个socket，每当这些socket变得可读或者可写，就通知Redis的线程，然后Redis的线程会为对应的Socket注册对应的事件，之后将他们放入事件处理队列。这是事件在出队后，会调用对应事件绑定的函数，来处理对应的事件。</p><p>比如说，现在有两个客户端，这两个客户端都发起了请求，分别对应accept事件和read事件。Redis 分别对这两个事件注册 accept 和 get 回调函数。当 Linux 内核监听到有连接请求或读数据请求时，就会触发 Accept 事件和 Read 事件，此时，内核就会回调 Redis 相应的 accept 和 get 函数进行处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Redis6.0之前，它的网络I&amp;#x2F;O模型是单线程的，那么它是怎么处理多个客户端的连接的呢？这里就涉及到Redis的I&amp;#x2F;O模型，基于多路复用的高性能 I&amp;#x2F;O 模型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image-13142383</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Redis" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis/"/>
    
    <category term="设计" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis/%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="Redis设计与实现" scheme="http://example.com/tags/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何提高服务调用速度</title>
    <link href="http://example.com/2023/05/11/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E9%80%9F%E5%BA%A6/"/>
    <id>http://example.com/2023/05/11/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E9%80%9F%E5%BA%A6/</id>
    <published>2023-05-11T03:35:59.000Z</published>
    <updated>2023-05-11T11:09:32.190Z</updated>
    
    <content type="html"><![CDATA[<p>假如电商系统的 QPS 已经达到了每秒 2 万次，在做了服务化拆分之后，由于我们把业务逻辑都拆分到了单独部署的服务中，那么假设你在完成一次完整的请求时需要调用 4～5 次服务，计算下来，RPC 服务需要承载大概每秒 10 万次的请求。</p><p>所以RPC框架的选型要：</p><p>1、选择合适的网络模型，有针对性地调整网络参数优化网络传输性能；</p><p>2、选择合适的序列化方式，以提升封包、解包的性能。</p><h1 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h1><p>RPC指的是通过网络调用另一台计算机上部署服务的技术。而 RPC 框架就封装了网络调用的细节，让你像调用本地服务一样调用远程部署的服务。</p><h1 id="在引入RPC框架后会出现的问题"><a href="#在引入RPC框架后会出现的问题" class="headerlink" title="在引入RPC框架后会出现的问题"></a>在引入RPC框架后会出现的问题</h1><p>假设一个电商系统的商品详情页面需要商品数据、评论数据还有店铺数据。如果是一体化的项目，只需要从商品库、评论库和店铺库获取数据就可以了，不考虑缓存的情况下有三次网络请求。</p><p>但是如果独立出商品服务、评论服务和店铺服务之后，那么就需要分别调用这三个服务，而这三个服务又会分别调用各自的数据库，这就是六次网络请求。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230511184337555.png" alt="image-20230511184337555"></p><p>想要优化RPC调用，那么就要了解RPC调用的步骤都有哪些：</p><ul><li>客户端首先会将调用的类名、方法名、参数名、参数值等信息，序列化成二进制流；</li><li>然后客户端将二进制流通过网络发送给服务端；</li><li>服务端接收到二进制流之后将它反序列化，得到需要调用的类名、方法名、参数名和参数值，再通过动态代理的方式调用对应的方法得到返回值；</li><li>服务端将返回值序列化，再通过网络发送给客户端；</li><li>客户端对结果反序列化之后，就可以得到调用的结果了。</li></ul><p>如下图：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230511184610250.png" alt="image-20230511184610250"></p><p>不难看出，想要优化RPC调用，需要从<strong>网络传输和序列化</strong>入手。</p><h2 id="如何提升网络传输性能"><a href="#如何提升网络传输性能" class="headerlink" title="如何提升网络传输性能"></a>如何提升网络传输性能</h2><p>在网络传输优化中，首先要做的是选择一种高性能的 I&#x2F;O 模型，即我们处理I&#x2F;O的方式。而单次I&#x2F;O请求会分为两个节点。</p><p><strong>首先，I&#x2F;O 会经历一个等待资源的阶段，</strong>比方说，等待网络传输数据可用。这里有两种处理方式：</p><ul><li><p>阻塞。指的是在数据不可用时 I&#x2F;O 请求一直阻塞，直到数据返回；</p></li><li><p>非阻塞。指的是数据不可用时 I&#x2F;O 请求立即返回，直到被通知资源可用为止。</p></li></ul><p><strong>然后是使用资源的阶段，</strong>比如说从网络上接收到数据，并且拷贝到应用程序的缓冲区里面。也有两种处理方式：</p><ul><li><p>同步处理。指的是 I&#x2F;O 请求在读取或者写入数据时会阻塞，直到读取或者写入数据完成；</p></li><li><p>异步处理。指的是 I&#x2F;O 请求在读取或者写入数据时立即返回，当操作系统处理完成 I&#x2F;O 请求并且将数据拷贝到用户提供的缓冲区后，再通知应用 I&#x2F;O 请求执行完成。</p></li></ul><p>将这两个阶段的四种处理方式做一些排列组合，再做一些补充，就得到了我们常见的五种 I&#x2F;O 模型：</p><ul><li><p>同步阻塞 I&#x2F;O；</p></li><li><p>同步非阻塞 I&#x2F;O；</p></li><li><p>同步多路 I&#x2F;O 复用；</p></li><li><p>信号驱动 I&#x2F;O；</p></li><li><p>异步 I&#x2F;O。</p></li></ul><h2 id="选择合适的序列化方式"><a href="#选择合适的序列化方式" class="headerlink" title="选择合适的序列化方式"></a>选择合适的序列化方式</h2><p><strong>在对网络数据传输完成调优之后，另外一个需要关注的点就是数据的序列化和反序列化。</strong></p><p>这里要考虑序列化和反序列化的速度，以及序列化完成后的大小，因为要在网络上传输。</p><p>可以有以下几种方案：</p><ul><li>JSON，性能要求不高可以选</li><li><strong>Thrift</strong> 是 Facebook 开源的高性能的序列化协议</li><li><strong>Protobuf</strong> 是谷歌开源的序列化协议。</li></ul><p>如果性能要求比较高，Thrift 或者 Protobuf 都可以。</p><p>一些存储的场景下，比如说缓存中存储的数据占用空间较大，那么你可以考虑使用 Protobuf。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;假如电商系统的 QPS 已经达到了每秒 2 万次，在做了服务化拆分之后，由于我们把业务逻辑都拆分到了单独部署的服务中，那么假设你在完成一次完整的请求时需要调用 4～5 次服务，计算下来，RPC 服务需要承载大概每秒 10 万次的请求。&lt;/p&gt;
&lt;p&gt;所以RPC框架的选型要：</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="高并发系统设计" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="微服务架构" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>路由器结构</title>
    <link href="http://example.com/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2023/05/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2023-05-11T02:05:50.000Z</published>
    <updated>2023-05-15T01:53:53.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="路由器结构"><a href="#路由器结构" class="headerlink" title="路由器结构"></a>路由器结构</h1><p>一个路由器的体系结构如下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230511101229903.png" alt="image-20230511101229903" style="zoom:80%;" /><p><strong>输入端口作用</strong>：</p><p>1、接收数据链路层的数据。</p><p>2、查询转发表，决定数据的输出端口。到达的分组通过路由器的交换结构转发到输出端口。</p><p><strong>交换结构</strong>：交换结构将路由器的输入端口连接到它的输岀端口。这种交换结构完全包含在路由器之中，即它是一个网络路由器中的网络!</p><p><strong>输出端口：</strong>输出端口存储从交换结构接收的分组，并通过执行必要的链路层和物理层功能在输出链路上传输这些分组。</p><p><strong>路由选择处理器</strong>：路由选择处理器执行<strong>控制平面</strong>功能。</p><p>在传统的路由器中，它执行路由选择协议，维护路由选择表与关联链路状态信息，并为该路由器计算转发表。</p><p>在SDN路由器中，路由选择处理器（在其他活动中）负责与远程控制器通信，目的是接收由远程控制器计算的转发表项，并在该路由器的输入端口安装这些表项。路由选择处理器还执行网络管理功能。</p><p>以上仅仅是每个部分大致功能的描述，后续会有更为详细的介绍。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《计算机网络自顶向下》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;路由器结构&quot;&gt;&lt;a href=&quot;#路由器结构&quot; class=&quot;headerlink&quot; title=&quot;路由器结构&quot;&gt;&lt;/a&gt;路由器结构&lt;/h1&gt;&lt;p&gt;一个路由器的体系结构如下图：&lt;/p&gt;
&lt;img src=&quot;https://image-1314238346.cos.</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="网络层" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
    <category term="网络层" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>微服务后系统要如何改造</title>
    <link href="http://example.com/2023/05/10/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%90%8E%E7%B3%BB%E7%BB%9F%E8%A6%81%E5%A6%82%E4%BD%95%E6%94%B9%E9%80%A0/"/>
    <id>http://example.com/2023/05/10/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%90%8E%E7%B3%BB%E7%BB%9F%E8%A6%81%E5%A6%82%E4%BD%95%E6%94%B9%E9%80%A0/</id>
    <published>2023-05-10T14:20:11.000Z</published>
    <updated>2023-05-10T14:40:28.264Z</updated>
    
    <content type="html"><![CDATA[<p> 微服务化后，一个项目的架构图如下所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230510222409851.png" alt="image-20230510222409851" style="zoom: 80%;" /><h1 id="微服务拆分的原则"><a href="#微服务拆分的原则" class="headerlink" title="微服务拆分的原则"></a>微服务拆分的原则</h1><p>单体化的项目就像一个大的蜘蛛网，不同模块交织在一起，调用比较复杂，一个问题出bug可能会导致连锁的问题。所以要对架构进行拆分。而进行拆分则需要遵循以下原则：</p><h2 id="1、做到单一服务内部功能的高内聚和低耦合"><a href="#1、做到单一服务内部功能的高内聚和低耦合" class="headerlink" title="1、做到单一服务内部功能的高内聚和低耦合"></a>1、做到单一服务内部功能的高内聚和低耦合</h2><p>也就是说每个服务只完成自己职责之内的任务，对于不是自己职责的功能交给其它服务来完成。</p><h2 id="2、需要关注服务拆分的粒度，先粗略拆分再逐渐细化"><a href="#2、需要关注服务拆分的粒度，先粗略拆分再逐渐细化" class="headerlink" title="2、需要关注服务拆分的粒度，先粗略拆分再逐渐细化"></a>2、需要关注服务拆分的粒度，先粗略拆分再逐渐细化</h2><p>拆分初期可以把服务粒度拆得粗一些，后面随着团队对于业务和微服务理解的加深，再考虑把服务粒度细化。</p><h2 id="3、拆分的过程，要尽量避免影响产品的日常功能迭代"><a href="#3、拆分的过程，要尽量避免影响产品的日常功能迭代" class="headerlink" title="3、拆分的过程，要尽量避免影响产品的日常功能迭代"></a>3、拆分的过程，要尽量避免影响产品的日常功能迭代</h2><p>要一边做产品功能迭代，一边完成服务化拆分。拆分只能在现有一体化系统的基础上不断剥离业务独立部署，<strong>剥离的顺序你可以参考以下几点：</strong></p><ol><li><p>优先剥离比较独立的边界服务（比如短信服务、地理位置服务），从非核心的服务出发减少拆分对现有业务的影响</p></li><li><p>当两个服务存在依赖关系时优先拆分被依赖的服务。比如内容服务依赖于用户服务获取用户的基本信息，那么如果先把内容服务拆分出来，内容服务就会依赖于一体化架构中的用户模块，这样还是无法保证内容服务的快速部署能力。</p></li></ol><h2 id="4、服务接口的定义要具备可扩展性"><a href="#4、服务接口的定义要具备可扩展性" class="headerlink" title="4、服务接口的定义要具备可扩展性"></a>4、服务接口的定义要具备可扩展性</h2><p>服务拆分之后，由于服务是以独立进程的方式部署，所以服务之间通信就不再是进程内部的方法调用而是跨进程的网络通信了。在这种通信模型下服务接口的定义要具备可扩展性，否则在服务变更时会造成意想不到的错误。</p><h1 id="微服务化带来的问题和解决思路"><a href="#微服务化带来的问题和解决思路" class="headerlink" title="微服务化带来的问题和解决思路"></a>微服务化带来的问题和解决思路</h1><p>微服务会引入一定的复杂度：</p><p>1、服务接口调用不再是同一进程内的方法调用，而是跨进程的网络调用，这会增加时延，同时接口调用方需要知道服务部署在哪些机器的哪个端口上，这些信息需要存储在一个分布式一致性的存储中，<strong>于是就需要引入服务注册中心</strong>。</p><p>2、多个服务之间有着错综复杂的依赖关系。一个服务会依赖多个其它服务也会被多个服务所依赖，那么一旦被依赖的服务的性能出现问题产生大量的慢请求，就会导致依赖服务的工作线程池中的线程被占满，依赖的服务也会出现性能问题，有可能会导致整个服务崩溃。</p><p>为了避免发生这种情况，我们需要引入服务治理体系针对出问题的服务采用熔断、降级、限流、超时控制的方法，使问题被限制在单一服务中，保护服务网络中的其它服务不受影响。</p><p>3、服务拆分到多个进程后，一条请求的调用链路上涉及多个服务，那么一旦这个请求的响应时间增长或者是出现错误，我们就很难知道是哪一个服务出现的问题。</p><p>另外，整体系统一旦出现故障，很可能外在的表现是所有服务在同一时间都出现了问题，你在问题定位时很难确认哪一个服务是源头，<strong>这就需要引入分布式追踪工具，以及更细致的服务端监控报表。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 微服务化后，一个项目的架构图如下所示：&lt;/p&gt;
&lt;img src=&quot;https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230510222409851.png&quot; alt=&quot;image-2023051</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="高并发系统设计" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="微服务架构" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>网络层概述</title>
    <link href="http://example.com/2023/05/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2023/05/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0/</id>
    <published>2023-05-09T01:38:36.000Z</published>
    <updated>2023-05-10T14:18:26.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="转发和路由选择：数据平面和控制平面"><a href="#转发和路由选择：数据平面和控制平面" class="headerlink" title="转发和路由选择：数据平面和控制平面"></a>转发和路由选择：数据平面和控制平面</h1><p><strong>转发</strong>：当一个分组到达某路由器的一条输入链路时，该路由器必须将该分组移动到适当的输出链路。如果分组来自一个已知的恶意注意，那么它会被路由器阻挡。</p><p><strong>路由选择</strong>：当分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由或路径。计算这些路径的算法被称为路由选择算法。</p><p>每台路由器中都有一个转发表。路由器检査到达分组首部的一个或多个字段值，这些值对应存储在转发表项中的值，指出了该分组将被转发的路由器的输出链路接口。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230509111658565.png" alt="image-20230509111658565" style="zoom:67%;" /><p>说白了，就是通过这个路由表，找到应该将数据发送到哪一个出口。</p><h1 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h1><p>网络层能提供的某些可能的服务：</p><ul><li>确保交付。该服务确保分组将最终到达目的地。</li><li>具有时延上界的确保交付。该服务不仅确保分组的交付，而且在特定的主机到主机时延上界内（例如在100ms内）交付。</li><li>有序分组交付。该服务确保分组以它们发送的顺序到达目的地。</li><li>确保最小带宽。这种网络层服务模仿在发送和接收主机之间一条特定比特率（例如1 Mbps）的传输链路的行为。只要发送主机以低于特定比特率的速率传输比特（作为分组的组成部分），则所有分组最终会交付到目的主机。</li><li>安全性。网络层能够在源加密所有数据报并在目的地解密这些分组，从而对所有运输层报文段提供机密性。</li></ul><p>因特网实际提供的：</p><p>因特网的网络层提供了单一的服务，称为尽力而为服务（best effort service）。使用尽力而为服务，传送的分组既不能保证以它们发送的顺序被接收，也不能保证它们最终交付；既不能保证端到端时延，也不能保证有最小的带宽。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;转发和路由选择：数据平面和控制平面&quot;&gt;&lt;a href=&quot;#转发和路由选择：数据平面和控制平面&quot; class=&quot;headerlink&quot; title=&quot;转发和路由选择：数据平面和控制平面&quot;&gt;&lt;/a&gt;转发和路由选择：数据平面和控制平面&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;转发</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="网络层" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
    
    <category term="网络层" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个完备的缓存</title>
    <link href="http://example.com/2023/05/08/Java/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%A4%87%E7%9A%84%E7%BC%93%E5%AD%98/"/>
    <id>http://example.com/2023/05/08/Java/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%A4%87%E7%9A%84%E7%BC%93%E5%AD%98/</id>
    <published>2023-05-08T13:23:50.000Z</published>
    <updated>2023-05-08T14:41:19.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><p>1、允许多个线程同时读共享变量；</p><p>2、只允许一个线程写共享变量；</p><p>3、如果一个写线程正在执行写操作，此时禁止读线程读共享变量。</p><h1 id="实现一个缓存"><a href="#实现一个缓存" class="headerlink" title="实现一个缓存"></a>实现一个缓存</h1><p>我们声明一个Cache类，然后里面用HashMap来实现存储，但是它并不是线程安全的，我们采用ReadWriteLock来保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;K, V&gt; m = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">// 读锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">r</span> <span class="operator">=</span> rwl.readLock();</span><br><span class="line">    <span class="comment">// 写锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">w</span> <span class="operator">=</span> rwl.writeLock();</span><br><span class="line">    <span class="comment">// 读缓存</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> m.get(key); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123; </span><br><span class="line">            r.unlock(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写缓存</span></span><br><span class="line">    V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">return</span> m.put(key, v); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123; </span><br><span class="line">            w.unlock(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在并发的场景下，写缓存时，可能会存在缓存的覆盖</p><h1 id="实现缓存的按需加载"><a href="#实现缓存的按需加载" class="headerlink" title="实现缓存的按需加载"></a>实现缓存的按需加载</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;K, V&gt; m = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">r</span> <span class="operator">=</span> rwl.readLock();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">w</span> <span class="operator">=</span> rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 读缓存</span></span><br><span class="line">        r.lock();         ①</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            v = m.get(key); ②</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            r.unlock();     ③</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 缓存中存在，返回</span></span><br><span class="line">        <span class="keyword">if</span> (v != <span class="literal">null</span>) &#123;   ④</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 缓存中不存在，查询数据库</span></span><br><span class="line">        w.lock();         ⑤</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 再次验证</span></span><br><span class="line">            <span class="comment">// 其他线程可能已经查询过数据库</span></span><br><span class="line">            v = m.get(key); ⑥</span><br><span class="line">            <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;  ⑦</span><br><span class="line">               <span class="comment">//查询数据库</span></span><br><span class="line">               v = 省略代码无数</span><br><span class="line">               m.put(key, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="读写锁的升级与降级"><a href="#读写锁的升级与降级" class="headerlink" title="读写锁的升级与降级"></a>读写锁的升级与降级</h1><p>上面按需加载的示例代码中，在①处获取读锁，在③处释放读锁，那是否可以在②处的下面增加验证缓存并更新缓存的逻辑呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读缓存</span></span><br><span class="line"><span class="comment">// 获取读锁</span></span><br><span class="line">r.lock();         ①</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  v = m.get(key); ②</span><br><span class="line">  <span class="comment">// 没有数据，要去数据库查询</span></span><br><span class="line">  <span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里升级锁是读锁没有释放，然后加了写锁</span></span><br><span class="line">    <span class="comment">// 升级为写锁</span></span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 再次验证并更新缓存</span></span><br><span class="line">      <span class="comment">// 省略详细代码</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      w.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  r.unlock();     ③</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样看上去好像是没有问题的，先是获取读锁，然后再升级为写锁，对此还有个专业的名字，叫<strong>锁的升级</strong>。可惜 ReadWriteLock 并不支持这种升级。在上面的代码示例中，读锁还没有释放，此时获取写锁，会导致写锁永久等待，最终导致相关线程都被阻塞，永远也没有机会被唤醒。</p><p><strong>锁的降级</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CachedData</span> &#123;</span><br><span class="line">    Object data;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> cacheValid;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="comment">// 读锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">r</span> <span class="operator">=</span> rwl.readLock();</span><br><span class="line">    <span class="comment">// 写锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">w</span> <span class="operator">=</span> rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">processCachedData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取读锁</span></span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">            <span class="comment">// 释放读锁，因为不允许读锁的升级</span></span><br><span class="line">            r.unlock();</span><br><span class="line">            <span class="comment">// 获取写锁</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 再次检查状态</span></span><br><span class="line">                <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">                    data = ...</span><br><span class="line">                    cacheValid = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 释放写锁前，降级为读锁</span></span><br><span class="line">                <span class="comment">// 降级是可以的</span></span><br><span class="line">                r.lock(); ①</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放写锁</span></span><br><span class="line">                w.unlock(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此处仍然持有读锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            use(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;读写锁&quot;&gt;&lt;a href=&quot;#读写锁&quot; class=&quot;headerlink&quot; title=&quot;读写锁&quot;&gt;&lt;/a&gt;读写锁&lt;/h1&gt;&lt;p&gt;1、允许多个线程同时读共享变量；&lt;/p&gt;
&lt;p&gt;2、只允许一个线程写共享变量；&lt;/p&gt;
&lt;p&gt;3、如果一个写线程正在执行写操作，此时</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>数据该如何迁移</title>
    <link href="http://example.com/2023/05/07/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%95%B0%E6%8D%AE%E8%AF%A5%E5%A6%82%E4%BD%95%E8%BF%81%E7%A7%BB/"/>
    <id>http://example.com/2023/05/07/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%95%B0%E6%8D%AE%E8%AF%A5%E5%A6%82%E4%BD%95%E8%BF%81%E7%A7%BB/</id>
    <published>2023-05-07T08:23:49.000Z</published>
    <updated>2023-05-07T09:14:26.518Z</updated>
    
    <content type="html"><![CDATA[<p> 数据迁移需要满足以下几点：</p><ul><li>迁移的过程中，要保证新数据可以写入</li><li>迁移后，新旧数据库数据要一致</li><li>迁移过程中可以回滚</li></ul><p>下面给出几个具体的迁移方案。</p><h1 id="“双写”方案"><a href="#“双写”方案" class="headerlink" title="“双写”方案"></a>“双写”方案</h1><p>1、将新的库配置为源库的从库用来同步数据</p><p>2、改造业务代码，在数据写入的时候不仅要写入旧库也要写入新库。同时要保证在写入新库失败的数据被单独记录，以便后续添加。</p><p>3、校验数据了，这里只抽取部分数据。</p><p>4、将流量切换到新库，最好采用灰度的方式，即先切10%的流量过去，然后50%，慢慢加到100。</p><p>5、如果有问题，要将流量切回之前的库。</p><p>6、如果没有问题，将双写改为只写新库。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230507163056086.png" alt="image-20230507163056086" style="zoom:67%;" /><h1 id="级联同步方案"><a href="#级联同步方案" class="headerlink" title="级联同步方案"></a>级联同步方案</h1><p>1、先将新库配置为旧库的从库，用作数据同步</p><p>2、再将一个备库配置为新库的从库，用作数据的备份</p><p>3、等到三个库的写入一致后，将数据库的读流量切换到新库</p><p>4、然后暂停应用的写入，将业务的写入流量切换到新库</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230507163310998.png" alt="image-20230507163310998" style="zoom:67%;" /><p>但是这里的一个缺点是，切换时要暂停应用的使用，所以要选择低峰期来执行。</p><h1 id="数据迁移时如何预热缓存"><a href="#数据迁移时如何预热缓存" class="headerlink" title="数据迁移时如何预热缓存"></a>数据迁移时如何预热缓存</h1><p>上述的两种方案也可以在迁移缓存时使用，但是需要注意，直接在新的服务上加一个空的缓存，有可能会导致数据库宕机，<strong>所以，缓存迁移的重点是保持缓存的热度。</strong></p><h2 id="使用副本组预热缓存"><a href="#使用副本组预热缓存" class="headerlink" title="使用副本组预热缓存"></a>使用副本组预热缓存</h2><p>一般的数据写入流程是写入 Master、Slave 和所有的副本组，而在读取数据的时候，会先读副本组的数据，如果读取不到再到 Master 和 Slave 里面加载数据，再写入到副本组中。</p><p>这样，我们可以直接在云上部署一个副本组，如果查不到就去旧的机房去查询缓存，然后写入副本组。当副本组数据足够多时，缓存的迁移也就完成了。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230507171235231.png" alt="image-20230507171235231" style="zoom: 80%;" /><p>不过这里要注意，存在跨网络的调用，可能接口的速度会受到影响。</p><h2 id="改造副本组方案预热缓存"><a href="#改造副本组方案预热缓存" class="headerlink" title="改造副本组方案预热缓存"></a>改造副本组方案预热缓存</h2><p>1、在云上部署多组缓存的副本组，自建机房在接收到写入请求时，会优先写入自建机房的缓存节点，异步写入云上部署的缓存节点；</p><p>2、在处理自建机房的读请求时，会指定一定的流量（比如 10%）优先走云上的缓存节点，这样虽然也会走专线穿透回自建机房的缓存节点，但是流量是可控的；</p><p>3、当云上缓存节点的命中率达到 90% 以上时，就可以在云上部署应用服务器，让云上的应用服务器完全走云上的缓存节点就可以了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《高并发系统设计》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 数据迁移需要满足以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;迁移的过程中，要保证新数据可以写入&lt;/li&gt;
&lt;li&gt;迁移后，新旧数据库数据要一致&lt;/li&gt;
&lt;li&gt;迁移过程中可以回滚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面给出几个具体的迁移方案。&lt;/p&gt;
&lt;h1 id=&quot;“双写”方案&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="高并发系统设计" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="缓存篇" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%BC%93%E5%AD%98%E7%AF%87/"/>
    
    
    <category term="缓存" scheme="http://example.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个限流器</title>
    <link href="http://example.com/2023/05/06/Java/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%99%90%E6%B5%81%E5%99%A8/"/>
    <id>http://example.com/2023/05/06/Java/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%99%90%E6%B5%81%E5%99%A8/</id>
    <published>2023-05-06T13:49:15.000Z</published>
    <updated>2023-05-06T14:32:41.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信号量模型"><a href="#信号量模型" class="headerlink" title="信号量模型"></a>信号量模型</h1><p>信号量模型可以简单概括为：<strong>一个计数器，一个等待队列，三个方法</strong>。</p><p>在信号量模型里，计数器和等待队列对外是透明的，所以只能通过信号量模型提供的三个方法来访问它们，这三个方法分别是：init()、down() 和 up()。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230506215117555.png" alt="image-20230506215117555" style="zoom:67%;" /><ul><li><p>init()：设置计数器的初始值。</p></li><li><p>down()：计数器的值减 1；如果此时计数器的值小于 0，则当前线程将被阻塞，否则当前线程可以继续执行。</p></li><li><p>up()：计数器的值加 1；如果此时计数器的值小于或者等于 0，则唤醒等待队列中的一个线程，并将其从等待队列中移除。</p></li></ul><p>这里的 init()、down() 和 up() 三个方法都是原子性的，并且这个原子性是由信号量模型的实现方保证的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Semaphore</span> &#123;</span><br><span class="line">  <span class="comment">// 计数器</span></span><br><span class="line">  <span class="type">int</span> count;</span><br><span class="line">  <span class="comment">// 等待队列</span></span><br><span class="line">  Queue queue;</span><br><span class="line">  <span class="comment">// 初始化操作</span></span><br><span class="line">  Semaphore(<span class="type">int</span> c) &#123;</span><br><span class="line">    <span class="built_in">this</span>.count = c;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">down</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.count--;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 将当前线程插入等待队列</span></span><br><span class="line">      <span class="comment">// 阻塞当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">up</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.count++;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 移除等待队列中的某个线程T</span></span><br><span class="line">      <span class="comment">// 唤醒线程T</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何使用信号量"><a href="#如何使用信号量" class="headerlink" title="如何使用信号量"></a>如何使用信号量</h2><p>信号量其实就是一个标记，可以理解为红绿灯。每次通过路口时，要先检测红绿灯，是绿灯才可以同行，否则不能通过。而上面的信号量可以理解为，每次进入这里时，要先检测以下count是否大于0，如果大于0，才可以执行，否则不能执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line"><span class="comment">//初始化信号量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//用信号量保证互斥    </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这里就相当于调用上面的down，来将count--，如果count &lt; 0,线程就会被阻塞，无法执行。</span></span><br><span class="line">    s.acquire();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 这里相当于调用up，相当于释放资源，将count++。</span></span><br><span class="line">        s.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里的acquire和release是原子性的。</p><h1 id="快速实现一个限流器"><a href="#快速实现一个限流器" class="headerlink" title="快速实现一个限流器"></a>快速实现一个限流器</h1><p>这里的限流器的场景是：需要一个对象池，里面有N个对象可以被重复使用。当一个线程使用了其中的对象式时，该线程释放该对象之前，其他线程不允许使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObjPool</span>&lt;T, R&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;T&gt; pool;</span><br><span class="line">    <span class="comment">// 用信号量实现限流器</span></span><br><span class="line">    <span class="keyword">final</span> Semaphore sem;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    ObjPool(<span class="type">int</span> size, T t)&#123;</span><br><span class="line">        pool = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;T&gt;()&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            pool.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        sem = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用对象池的对象，调用func</span></span><br><span class="line">    R <span class="title function_">exec</span><span class="params">(Function&lt;T,R&gt; func)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 获取信号量，相当于进入临界资源的访问</span></span><br><span class="line">        sem.acquire();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用对象池中的对象</span></span><br><span class="line">            t = pool.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> func.apply(t);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 使用完之后将对象归还</span></span><br><span class="line">            pool.add(t);</span><br><span class="line">            sem.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建对象池</span></span><br><span class="line">ObjPool&lt;Long, String&gt; pool = <span class="keyword">new</span> <span class="title class_">ObjPool</span>&lt;Long, String&gt;(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 通过对象池获取t，之后执行  </span></span><br><span class="line">pool.exec(t -&gt; &#123;</span><br><span class="line">    System.out.println(t);</span><br><span class="line">    <span class="keyword">return</span> t.toString();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>信号量可以允许多个线程同时访问临界资源，它的并发度相对于使用Lock来说要好一点。但是它无法同时唤醒多个线程去争抢锁，只能唤醒阻塞线程中的一个。</p><p>因为信号量模型是没有Condition的概念的，即阻塞线程被醒了直接就运行了而不会去检查此时临界条件是否已经不满足了，所以一次只能唤醒一个。即满足进去临界区域之后，就从所有阻塞的线程中选一个进去，如果选多个，这几个线程都会认为此时已经满足，并开始执行。事实是，唤醒多个之后，有一个线程开始执行后，其他的线程就不满足条件了，但由于不检查条件，他们还是会执行。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Java 并发编程实战》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;信号量模型&quot;&gt;&lt;a href=&quot;#信号量模型&quot; class=&quot;headerlink&quot; title=&quot;信号量模型&quot;&gt;&lt;/a&gt;信号量模型&lt;/h1&gt;&lt;p&gt;信号量模型可以简单概括为：&lt;strong&gt;一个计数器，一个等待队列，三个方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在信</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Lock和Condition</title>
    <link href="http://example.com/2023/05/05/Java/Lock%E5%92%8CCondition/"/>
    <id>http://example.com/2023/05/05/Java/Lock%E5%92%8CCondition/</id>
    <published>2023-05-05T13:56:41.000Z</published>
    <updated>2023-05-05T14:43:15.340Z</updated>
    
    <content type="html"><![CDATA[<p> Java当中，Lock和Condition一起使用的时候，可以实现多条件的并发，一个最简单的例子就是阻塞队列，它的实现需要两个条件变量，一个是队列不为空，另一个是队列不能满。</p><p>一个简单的例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockedQueue</span>&lt;T&gt;&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="comment">// 条件变量：队列不满</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">  <span class="comment">// 条件变量：队列不空</span></span><br><span class="line">  <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">enq</span><span class="params">(T x)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (队列已满) &#123;</span><br><span class="line">        <span class="comment">// 等待队列不满，这里就是阻塞线程</span></span><br><span class="line">        notFull.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 省略入队操作...</span></span><br><span class="line">      <span class="comment">// 入队后,通知可出队，这里是有元素入队后，满足条件，然后唤醒线程</span></span><br><span class="line">      notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">deq</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (队列已空) &#123;</span><br><span class="line">        <span class="comment">// 等待队列不空</span></span><br><span class="line">        notEmpty.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 省略出队操作...</span></span><br><span class="line">      <span class="comment">// 出队后，通知可入队</span></span><br><span class="line">      notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h1><p><strong>通俗点来讲就是调用方是否需要等待结果，如果需要等待结果，就是同步；如果不需要等待结果，就是异步</strong>。</p><p>异步实现的方法：</p><p>1、调用方创建一个子线程，在子线程中执行方法调用，这种调用我们称为异步调用；</p><p>2、方法实现的时候，创建一个新的线程执行主要逻辑，主线程直接 return，这种方法我们一般称为异步方法。</p><h1 id="Dubbo的异步实现逻辑"><a href="#Dubbo的异步实现逻辑" class="headerlink" title="Dubbo的异步实现逻辑"></a>Dubbo的异步实现逻辑</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建锁与条件变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">done</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="comment">// 调用方通过该方法等待结果</span></span><br><span class="line">Object <span class="title function_">get</span><span class="params">(<span class="type">int</span> timeout)</span> &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (!isDone()) &#123;</span><br><span class="line">        done.await(timeout);</span><br><span class="line">        <span class="type">long</span> <span class="variable">cur</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="keyword">if</span> (isDone() || cur - start &gt; timeout) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> returnFromResponse();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RPC结果是否已经返回</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> response != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RPC结果返回时调用该方法   </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReceived</span><span class="params">(Response res)</span> &#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    response = res;</span><br><span class="line">    <span class="keyword">if</span> (done != <span class="literal">null</span>) &#123;</span><br><span class="line">      done.signal();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; Java当中，Lock和Condition一起使用的时候，可以实现多条件的并发，一个最简单的例子就是阻塞队列，它的实现需要两个条件变量，一个是队列不为空，另一个是队列不能满。&lt;/p&gt;
&lt;p&gt;一个简单的例子如下：&lt;/p&gt;
&lt;figure class=&quot;highlight j</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
</feed>
