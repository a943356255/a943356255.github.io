<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便起个名字吧</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-11-02T02:47:28.431Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Guo Junhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL驱动加载</title>
    <link href="http://example.com/2023/11/02/MySQL%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD/"/>
    <id>http://example.com/2023/11/02/MySQL%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD/</id>
    <published>2023-11-02T01:40:52.000Z</published>
    <updated>2023-11-02T02:47:28.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h1><p>使用Java代码连接MySQL需要走以下流程（使用框架也要做对应的配置）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">driverClassName</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="comment">// 注册驱动</span></span><br><span class="line">    Class.forName(driverClassName);</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里边涉及到一个问题，为什么一定要写一句<code>Class.forName(driverClassName)</code>？</p><blockquote><p>这里首先涉及到Java的类加载机制</p><p>想要使用一个类，则必须要求该类已经被加载到JVM中，加载的过程实际上就是<strong>通过类的全限定名来获取定义该类二进制字节流</strong>，然后将这个字节流所表示的静态存储结构转换为方法去的动态运行时数据结构。同时在在内存中实例化一个java.lang.Class对象，作为方法区中该类的数据访问入口(供我们使用)。</p><p>​—— 出自《深入理解Java虚拟机》</p></blockquote><p>其实在一开始，我并不了解<code>Class.forName()</code>是干嘛的，后边了解到它用作加载类，官方解释为：在运行时动态的加载一个类，返回值为生成的Class对象。所以这行代码的目的，就是将<code>com.mysql.cj.jdbc.Driver</code>类加载到Jvm中了。</p><p>这里，<code>forName</code>方法的具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">// 注意这个true，该参数用来标识在将该类加载后是否进行初始化操作。</span></span><br><span class="line">    <span class="keyword">return</span> forName0(className, <span class="literal">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; forName0(String name, <span class="type">boolean</span> initialize,ClassLoader loader,Class&lt;?&gt; caller);</span><br></pre></td></tr></table></figure><p>到这里，也就是说这一行代码不仅加载了对应的类，也做了初始化操作。</p><p>至于说后续为什么可以直接在<code>DriverManager</code>使用，就要看Driver类里面实现了什么。</p><p>MySQL的驱动实现了Java官方提供的Driver接口，这也是每一个数据库厂商所必须要做的事情。而且他们都需要以下这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title class_">java</span>.sql.Driver &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里也是规范的一种，要求每个厂商都把自己的驱动注册到驱动管理里面</span></span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类中定义了一个静态代码块，静态代码快中创建了一个驱动类实例注册给了DriverManager，而静态代码块的内容会在初始化的过程中执行，所以才能通过<code>DriverManager.getConnection</code>直接获取一个连接。</p><h1 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h1><p>在jdbc4.0之后，使用了spi机制，破坏了双亲委派机制。也就是说我们不再需要写哪一行<code>Class.forName(driverClassName);</code></p><p>我们只需要将对应的驱动类的jar包放到工程的<code>class path</code>下，驱动类会 自动被加载。</p><blockquote><p>SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。</p><p>SPI的目的是为了提前使用某些未被实现的方法。定义一组接口，然后直接通过接口使用它的方法，但是这些方法还未被实现，留给第三方去实现，这就是spi的目的。</p><p>还有一种说法，SPI，为了解耦，从配置里获取某个接口的具体实现类。</p></blockquote><p>为了支持这个新特性，各个数据库厂商的jar包都有一个<code>META-INF/services</code>目录，里面有一个<code>java.sql.Driver</code>，这里指定了driver的全限定名。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231102102705989.png" alt="image-20231102102705989" style="zoom:80%;" /><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>JDBC的driver接口是定义在JDK中的，但是它的实现类，确在一个jar包中，放在classpath下。就存在以下问题：</p><ul><li><code>DriverManager</code>类会加载每个Driver接口的实现类并管理它们，但是<code>DriverManager</code>类自身是 <code>jre/lib/rt.jar</code> 里的类，是由<code>bootstrap classloader</code>加载的。</li><li>根据类加载机制，<strong>某个类需要引用其它类的时候，虚拟机将会用这个类的classloader去加载被引用的类</strong>，但是<code>bootstrap classloader</code>是无法加载这个driver的（<code>bootstrap classloader</code>只能加载Java 的核心类库包）。</li><li>因此只能在DriverManager里强行指定下层classloader来加载Driver实现类，而这就会打破双亲委派模型。</li></ul><p>具体的做法是，添加了一个线程上下文类加载器<code>Thread Context ClassLoader</code>，在启动类加载器中获取应用程序类加载器。<strong>Thread.setContextClassLoaser()</strong> 设置线程上下文类加载器，如果创建线程的时候没有设置，会从父类继承一个，默认应用程序类加载器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;传统方法&quot;&gt;&lt;a href=&quot;#传统方法&quot; class=&quot;headerlink&quot; title=&quot;传统方法&quot;&gt;&lt;/a&gt;传统方法&lt;/h1&gt;&lt;p&gt;使用Java代码连接MySQL需要走以下流程（使用框架也要做对应的配置）：&lt;/p&gt;
&lt;figure class=&quot;highl</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring事务失效场景</title>
    <link href="http://example.com/2023/10/31/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF/"/>
    <id>http://example.com/2023/10/31/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF/</id>
    <published>2023-10-31T02:13:30.000Z</published>
    <updated>2023-10-31T02:15:26.166Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务失效"><a href="#事务失效" class="headerlink" title="事务失效"></a>事务失效</h3><blockquote><p>写在前面</p><p><strong>Spring的事务是通过AOP这种代理的方式实现的。</strong></p></blockquote><p>事务失效的场景有以下几个</p><h4 id="1-访问权限问题"><a href="#1-访问权限问题" class="headerlink" title="1.访问权限问题"></a>1.访问权限问题</h4><p>java的访问权限主要有四种：private、default、protected、public，如果我们加注解的方法不是public，那么事务就会返回空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="comment">// 这里，方法不是public修饰，而spring要求被代理的方法必须是public</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">         saveData(userModel);</span><br><span class="line">         updateData(userModel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-方法用final修饰"><a href="#2-方法用final修饰" class="headerlink" title="2.方法用final修饰"></a>2.方法用final修饰</h4><p>一般用final修饰的方法，都是在该方法不想被子类重写，但是如果将事务方法定义为final，则会导致问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span>&#123;</span><br><span class="line">        saveData(userModel);</span><br><span class="line">        updateData(userModel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring的事务，是通过AOP实现的，而AOP则是通过jdk动态代理或者cglib动态代理，来帮我们生成一个代理类，然后重写对应的方法。final修饰的方法没有办法被重写，所以无法使用事务。</p><h4 id="3-方法内部调用"><a href="#3-方法内部调用" class="headerlink" title="3.方法内部调用"></a>3.方法内部调用</h4><p>在某个Service类的某个方法里，调用另一个事务方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        updateStatus(userModel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateStatus</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">        doSameThing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法，调用的是该方法本身，想要事务生效，要走spring的调用。即需要调用<code>UserService.add()</code>, <code>userService.updateStatus()</code>，spring才能为其生成代理对象，然后事务才能生效，直接调用该方法事务无法生效。</p><p>如何解决：</p><p><strong>1、新增Service类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Servcie</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    prvate ServiceB serviceB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        queryData1();</span><br><span class="line">        queryData2();</span><br><span class="line">        serviceB.doSave(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Servcie</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSave</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        addData1();</span><br><span class="line">        updateData2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、在Service中注入自己（spring三级缓存会解决循环依赖问题）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Servcie</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    prvate ServiceA serviceA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        queryData1();</span><br><span class="line">        queryData2();</span><br><span class="line">        serviceA.doSave(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSave</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        addData1();</span><br><span class="line">        updateData2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、通过AopContent类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Servcie</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        queryData1();</span><br><span class="line">        queryData2();</span><br><span class="line">        ((ServiceA)AopContext.currentProxy()).doSave(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSave</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        addData1();</span><br><span class="line">        updateData2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-未被spring管理"><a href="#4-未被spring管理" class="headerlink" title="4.未被spring管理"></a>4.未被spring管理</h4><p>只有该bean被spring管理的情况下，才能生成代理对象，事务才可以生效。通过@Controller、@Service、@Component、@Repository等注解，可以自动实现bean实例化和依赖注入的功能，如果类没有这类注解，事务无法生效。</p><h4 id="5-多线程调用"><a href="#5-多线程调用" class="headerlink" title="5.多线程调用"></a>5.多线程调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RoleService roleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            roleService.doOtherThing();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOtherThing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存role表数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述案例中，<code>add</code>方法在调用另一个事务方法<code>doOtherThing</code>的时候，开启了一个新的线程，这会导致一个问题，即两个方法不是在同一个线程里面调用的，那么他们两个获取到的数据库连接就不是同一个，那他们就是两个事务。</p><p>原因：<strong>spring的事务是通过数据库连接来实现的，当前线程中保存一个map，key是数据源，value是数据库连接。</strong>通常所说的事务，指的是同一个数据库连接，同一个数据库连接才能同时提交和回滚，不同的线程无法实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;事务失效&quot;&gt;&lt;a href=&quot;#事务失效&quot; class=&quot;headerlink&quot; title=&quot;事务失效&quot;&gt;&lt;/a&gt;事务失效&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;写在前面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring的事务是通过AOP这种代理的方式实现的。&lt;/s</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Spring" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>可重复读隔离级别会出现幻读吗</title>
    <link href="http://example.com/2023/10/30/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%B9%BB%E8%AF%BB%E5%90%97/"/>
    <id>http://example.com/2023/10/30/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%B9%BB%E8%AF%BB%E5%90%97/</id>
    <published>2023-10-30T01:10:16.000Z</published>
    <updated>2023-10-30T01:12:09.965Z</updated>
    
    <content type="html"><![CDATA[<p>放在最前面：<strong>InnoDB的默认事务隔离级别是可重复读</strong></p><h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><p>MySQL的隔离级别包括四种：<strong>读未提交</strong>（read uncommitted）、<strong>读提交</strong>（read committed）、<strong>可重复读</strong>（repeatable read）和<strong>串行化</strong>（serializable ）。</p><ul><li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化，对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><p>前两种隔离级别，是一定会出现幻读。而<strong>可重复读隔离级</strong>别是采用MVCC，即一致性视图来解决<strong>不可重复读的问题</strong>。具体而言，就是采用快照的方式，事务开启的时候会有一个版本号，然后数据是否可见都是基于版本号来判断的，低于该版本号的数据可见，高于的都不可见。</p><p>而可重复读隔离级别下，如果事务A开启后，事务B做了一定的修改并提交事务，在事务A还未提交的时候，对事务B提交的数据做了修改，这个修改是在事务B提交数据的基础上进行修改的，因为不这样的话会导致事务B提交的数据丢失。那也就意味着此次修改会修改数据的事务版本号，后续进行查询的时候，该版本号就可能会导致幻读的问题，以及查询结果与认为中的不一致问题。这也是为什么在可重复读隔离级别下仍然会出现幻读的问题。</p><p>上述问题有一个原因：<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong>当前读意味着会读取最新的数据。</p><p>其实除了Update语句外，select语句如果加了锁，即<code>for share</code>或者<code>for update </code>也是当前读。</p><p>实现可重复读的核心是<strong>一致性读</strong>，而更新数据必须使用<strong>当前读</strong>，这也是为什么会失效的原因。</p><h1 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h1><p>在可重复读的隔离级别下，普通读都是<strong>快照读</strong>，是看不见其他事务修改的数据的，幻读的问题只会发生在<strong>当前读</strong>。即<code>select for update</code>  或者<code>select for share</code>这种。</p><p>幻读是指在一个事务（假定事务A）的两次查询中，第二次查询查到了第一次没有的数据。发生幻读的根本原因是另外的事务（假定事务B）添加或修改了数据，该数据正好满足事务A的查询条件。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>可重复读的隔离级别，在某些场景下是无法防止幻读的问题，需要用到间隙锁来解决。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;放在最前面：&lt;strong&gt;InnoDB的默认事务隔离级别是可重复读&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;隔离级别&quot;&gt;&lt;a href=&quot;#隔离级别&quot; class=&quot;headerlink&quot; title=&quot;隔离级别&quot;&gt;&lt;/a&gt;隔离级别&lt;/h1&gt;&lt;p&gt;MySQL的隔离级别包</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="场景分析" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    
    
    <category term="场景分析" scheme="http://example.com/tags/%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码简单解读</title>
    <link href="http://example.com/2023/10/29/Java/Netty%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%A7%A3%E8%AF%BB/"/>
    <id>http://example.com/2023/10/29/Java/Netty%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E8%A7%A3%E8%AF%BB/</id>
    <published>2023-10-29T01:56:54.000Z</published>
    <updated>2023-10-29T03:27:38.060Z</updated>
    
    <content type="html"><![CDATA[<p>注：仅仅是尝试看源码，锻炼一下看源码能力，理解并不一定正确。</p><h1 id="Netty的服务端创建"><a href="#Netty的服务端创建" class="headerlink" title="Netty的服务端创建"></a>Netty的服务端创建</h1><p>创建代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">    <span class="comment">// 接收新连接线程，创建新的连接</span></span><br><span class="line">    <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    <span class="comment">// 对应读取数据的线程，用于处理数据读取以及业务逻辑处理</span></span><br><span class="line">    <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">    serverBootstrap</span><br><span class="line">        .group(boss, worker)</span><br><span class="line">        <span class="comment">// 这里是接收一个Channel的类型，然后通过反射创建一个工厂类</span></span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        <span class="comment">// 这个NioSocketChannel是Netty设计的</span></span><br><span class="line">        .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        System.out.println(s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).bind(<span class="number">8000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="group-boss-worker"><a href="#group-boss-worker" class="headerlink" title="group(boss, worker)"></a>group(boss, worker)</h2><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerBootstrap</span> <span class="keyword">extends</span> <span class="title class_">AbstractBootstrap</span>&lt;ServerBootstrap, ServerChannel&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> EventLoopGroup childGroup;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ServerBootstrap <span class="title function_">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.group(parentGroup);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.childGroup != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;childGroup set already&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.childGroup = (EventLoopGroup)ObjectUtil.checkNotNull(childGroup, <span class="string">&quot;childGroup&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，将boss也就是parentGroup传递给了父类的<code>group</code>方法，即<code>AbstractBootstrap</code>，而将worker传递给了<code>ServerBootstrap</code> ，并将ServerBootstrap返回。</p><p>父类的group方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBootstrap</span>&lt;B <span class="keyword">extends</span> <span class="title class_">AbstractBootstrap</span>&lt;B, C&gt;, C <span class="keyword">extends</span> <span class="title class_">Channel</span>&gt; <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> EventLoopGroup group;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> B <span class="title function_">group</span><span class="params">(EventLoopGroup group)</span> &#123;</span><br><span class="line">        ObjectUtil.checkNotNull(group, <span class="string">&quot;group&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.group != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;group set already&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.group = group;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.self();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对于这个group方法，做的事情比较简单，将两个<code>NioEventLoopGroup</code>传递给<code>ServerBootstrap</code>，然后将赋值后的<code>ServerBootstrap</code>返回。</p><h2 id="channel-NioServerSocketChannel-class"><a href="#channel-NioServerSocketChannel-class" class="headerlink" title="channel(NioServerSocketChannel.class)"></a>channel(NioServerSocketChannel.class)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> B <span class="title function_">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.channelFactory((io.netty.channel.ChannelFactory)(<span class="keyword">new</span> <span class="title class_">ReflectiveChannelFactory</span>((Class)ObjectUtil.checkNotNull(channelClass, <span class="string">&quot;channelClass&quot;</span>))));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码涉及到一个工厂类的创建<code>new ReflectiveChannelFactory()</code>，该工厂类的创建需要接收传入的<code>channelClass</code></p><p>工厂类的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectiveChannelFactory</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Channel</span>&gt; <span class="keyword">implements</span> <span class="title class_">ChannelFactory</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Constructor&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; constructor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReflectiveChannelFactory</span><span class="params">(Class&lt;? extends T&gt; clazz)</span> &#123;</span><br><span class="line">        ObjectUtil.checkNotNull(clazz, <span class="string">&quot;clazz&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.constructor = clazz.getConstructor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Class &quot;</span> + StringUtil.simpleClassName(clazz) + <span class="string">&quot; does not have a public non-arg constructor&quot;</span>, var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是通过反射，获取了传入类的构造方法。</p><p>另一个方法就是<code>this.channelFactory()</code>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> B <span class="title function_">channelFactory</span><span class="params">(io.netty.channel.ChannelFactory&lt;? extends C&gt; channelFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.channelFactory((ChannelFactory)channelFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> B <span class="title function_">channelFactory</span><span class="params">(ChannelFactory&lt;? extends C&gt; channelFactory)</span> &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(channelFactory, <span class="string">&quot;channelFactory&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.channelFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;channelFactory set already&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.channelFactory = channelFactory;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.self();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做的事情就是将上一步创建的<code>ReflectiveChannelFactory</code>赋值给<code>AbstractBootstrap</code>的<code>ChannelFactory</code>。</p><p>因为在创建<code>ReflectiveChannelFactory</code>时，获取到了传入class的构造方法，就可以创建对应的对象。</p><h2 id="childHandler-new-ChannelInitializer"><a href="#childHandler-new-ChannelInitializer" class="headerlink" title="childHandler(new ChannelInitializer(){}"></a>childHandler(new ChannelInitializer<NioSocketChannel>(){}</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerBootstrap</span> <span class="keyword">extends</span> <span class="title class_">AbstractBootstrap</span>&lt;ServerBootstrap, ServerChannel&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ChannelHandler childHandler;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略其他方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ServerBootstrap <span class="title function_">childHandler</span><span class="params">(ChannelHandler childHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.childHandler = (ChannelHandler)ObjectUtil.checkNotNull(childHandler, <span class="string">&quot;childHandler&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是一个成员属性的赋值，主要看创建<code>ChannelHandler</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ChannelInitializer</span>&lt;C <span class="keyword">extends</span> <span class="title class_">Channel</span>&gt; <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 这是一个抽象方法，必须实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(C var1)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 案例中重写的代码如下：</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">    nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="comment">// 重写的这个方法就是我们要做的业务逻辑处理</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">// 这个方法，客户端传递数据时应该会调用</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, String s)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 案例中方法重写的代码如下</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;I&gt; <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext var1, I var2)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Netty客户端创建"><a href="#Netty客户端创建" class="headerlink" title="Netty客户端创建"></a>Netty客户端创建</h1><p>创建代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">    <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">    bootstrap.group(group)</span><br><span class="line">        .channel(NioSocketChannel.class)</span><br><span class="line">        .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                channel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8000</span>).channel();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: hello world&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就存在了第一个区别<code> ServerBootstrap</code> 和 <code>Bootstrap</code></p><p><code>Bootstrap</code>并没有自己的group方法，它是直接调用了父类的group，也就是说传入的group直接赋值给了<code>AbstractBootstrap</code>的<code>EventLoopGroup</code>。</p><p>其他的代码与服务端差不多，主要看<code>writeAndFlush</code>和<code>connect</code></p><h2 id="writeAndFlush"><a href="#writeAndFlush" class="headerlink" title="writeAndFlush"></a>writeAndFlush</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractChannel</span> <span class="keyword">extends</span> <span class="title class_">DefaultAttributeMap</span> <span class="keyword">implements</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line">    <span class="comment">// 默认的管道</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultChannelPipeline pipeline;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ChannelFuture <span class="title function_">writeAndFlush</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.pipeline.writeAndFlush(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultChannelPipeline</span> <span class="keyword">implements</span> <span class="title class_">ChannelPipeline</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext tail;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title function_">writeAndFlush</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.tail.writeAndFlush(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractChannelHandlerContext</span> <span class="keyword">implements</span> <span class="title class_">ChannelHandlerContext</span>, ResourceLeakHint &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> EventExecutor executor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultChannelPipeline pipeline;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ChannelFuture <span class="title function_">writeAndFlush</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.writeAndFlush(msg, <span class="built_in">this</span>.newPromise());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ChannelPromise <span class="title function_">newPromise</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(<span class="built_in">this</span>.channel(), <span class="built_in">this</span>.executor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Channel <span class="title function_">channel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.pipeline.channel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EventExecutor <span class="title function_">executor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (EventExecutor)(<span class="built_in">this</span>.executor == <span class="literal">null</span> ? <span class="built_in">this</span>.channel().eventLoop() : <span class="built_in">this</span>.executor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ChannelFuture <span class="title function_">writeAndFlush</span><span class="params">(Object msg, ChannelPromise promise)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.write(msg, <span class="literal">true</span>, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(Object msg, <span class="type">boolean</span> flush, ChannelPromise promise)</span> &#123;</span><br><span class="line">        ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里，如果promise不可用，那么就释放消息</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.isNotValidPromise(promise, <span class="literal">true</span>)) &#123;</span><br><span class="line">                ReferenceCountUtil.release(msg);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException var8) &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">            <span class="keyword">throw</span> var8;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">AbstractChannelHandlerContext</span> <span class="variable">next</span> <span class="operator">=</span> <span class="built_in">this</span>.findContextOutbound(flush ? <span class="number">98304</span> : <span class="string">&#x27;耀&#x27;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> <span class="built_in">this</span>.pipeline.touch(msg, next);</span><br><span class="line">        <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">        <span class="comment">// 这里是判断当前的任务是否在循环当中</span></span><br><span class="line">        <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">                next.invokeWriteAndFlush(m, promise);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next.invokeWrite(m, promise);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AbstractChannelHandlerContext.<span class="type">WriteTask</span> <span class="variable">task</span> <span class="operator">=</span> AbstractChannelHandlerContext.WriteTask.newInstance(next, m, promise, flush);</span><br><span class="line">            <span class="keyword">if</span> (!safeExecute(executor, task, promise, m, !flush)) &#123;</span><br><span class="line">                task.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;注：仅仅是尝试看源码，锻炼一下看源码能力，理解并不一定正确。&lt;/p&gt;
&lt;h1 id=&quot;Netty的服务端创建&quot;&gt;&lt;a href=&quot;#Netty的服务端创建&quot; class=&quot;headerlink&quot; title=&quot;Netty的服务端创建&quot;&gt;&lt;/a&gt;Netty的服务端创建&lt;/h1</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="源码分析" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>传统网络编程与NIO编程</title>
    <link href="http://example.com/2023/10/26/Java/%E4%BC%A0%E7%BB%9F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2023/10/26/Java/%E4%BC%A0%E7%BB%9F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8ENIO%E7%BC%96%E7%A8%8B/</id>
    <published>2023-10-26T02:47:23.000Z</published>
    <updated>2023-10-28T03:38:02.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传统网络编程"><a href="#传统网络编程" class="headerlink" title="传统网络编程"></a>传统网络编程</h1><p>首先看一段最传统的Java网络编程。</p><p>服务端代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8000</span>);</span><br><span class="line">        <span class="comment">// 接收新连接的线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 阻塞方法获取新的连接</span></span><br><span class="line">                    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 每一个新的连接都创建一个线程，负责读取数据</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                        <span class="type">int</span> len;</span><br><span class="line">                        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">                            <span class="comment">// 按字节流读取数据</span></span><br><span class="line">                            <span class="keyword">while</span> ((len = inputStream.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, len));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).start();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 我自己运行时，这里只创建了一次连接，然后没3s发送一次数据</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8000</span>);</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 网络传输都是传输的字节</span></span><br><span class="line">                    socket.getOutputStream().write((<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot; hello world&quot;</span>).getBytes());</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，服务端启动时创建了一个线程，建立了<code>ServerSocket</code>，循环的等待客户端的连接。客户端每次连接，服务端都会创建一个新的线程去处理请求，然后读取数据。</p><p>这种模型在客户端数量比较小的时候是没问题的，但是如果客户端数量较多，服务端就需要创建很多的线程，线程的创建比较消耗成本，而且线程数过多时，CPU调度导致的线程切换也会影响性能。</p><p>主要有以下三个问题：</p><ol><li>创建太多线程，而线程是很宝贵的资源，同一时刻大量线程处于阻塞会浪费资源。</li><li>线程切换效率低下。</li><li>IO编程中，数据传输都是以字节为单位。</li></ol><p>为了解决上述问题，引入了NIO，即同步非阻塞IO。</p><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p>在NIO中，只会创建一个线程去进行while循环，该线程监控所有的客户端连接，而不会像传统的有多少个客户端连接就创建多少个线程去进行while循环。</p><p>传统的模型中，在每一时刻，只有少数线程会有数据读写需求，而没有数据需要读写的就白白浪费了CPU资源。NIO中，通过将所有的客户端连接都注册到selector上，通过检测selector上是否有数据数据需要读写，就可以达到批量读取数据的目的。</p><p>这样，就解决了创建太多线程浪费资源和CPU频繁切换线程导致的性能问题。而传统IO是面向字节流，读取数据后需要自己缓存，流中就不存在该数据。而NIO的读写是面向Buffer的，解决了数据只能用字节传输的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">serverSelector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">clientSelector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 对应IO编程中服务端启动</span></span><br><span class="line">                <span class="type">ServerSocketChannel</span> <span class="variable">listenerChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">                listenerChannel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8000</span>));</span><br><span class="line">                listenerChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                listenerChannel.register(serverSelector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 检测是否有新的连接，1指的是阻塞时间为1ms</span></span><br><span class="line">                    <span class="keyword">if</span> (serverSelector.select(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Set&lt;SelectionKey&gt; set = serverSelector.selectedKeys();</span><br><span class="line">                        Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();</span><br><span class="line">                        <span class="comment">// 遍历所有有数据的SelectionKey</span></span><br><span class="line">                        <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                            <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">                            <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="comment">// 这里就是区别，当有一个新的连接请求到来时，不再创建一个线程，而是直接注册到clientSelector</span></span><br><span class="line">                                    <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> ((ServerSocketChannel) selectionKey.channel()).accept();</span><br><span class="line">                                    clientChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                                    clientChannel.register(clientSelector, SelectionKey.OP_READ);</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    <span class="comment">// 每个客户端只注册一次就可以了</span></span><br><span class="line">                                    keyIterator.remove();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 批量轮询是否有哪些连接的数据可读，1同样为阻塞时间</span></span><br><span class="line">                    <span class="keyword">if</span> (clientSelector.select(<span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Set&lt;SelectionKey&gt; set = clientSelector.selectedKeys();</span><br><span class="line">                        Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();</span><br><span class="line">                        <span class="comment">// 轮询所有已经注册了的客户端，然后判断哪一个可读</span></span><br><span class="line">                        <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                            <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> keyIterator.next();</span><br><span class="line">                            <span class="comment">// 这里是判断可读</span></span><br><span class="line">                            <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                                    <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                                    <span class="comment">// 面向buffer</span></span><br><span class="line">                                    clientChannel.read(byteBuffer);</span><br><span class="line">                                    byteBuffer.flip();</span><br><span class="line">                                    System.out.println(Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    <span class="comment">// 这里为什么移除，是否是因为每个客户端传输一次数据后，就从注册中移除</span></span><br><span class="line">                                    keyIterator.remove();</span><br><span class="line">                                    key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NIO编程的核心思路：</p><ol><li>NIO 模型中通常会有两个线程，每个线程绑定一个轮询器 selector ，在上面的例子中 serverSelector负责轮询是否有新的连接，clientSelector负责轮询连接是否有数据可读。</li><li>服务端监测到新的连接之后，不再创建一个新的线程，而是直接将新连接绑定到clientSelector上， 这样就不用 IO 模型中 每个连接一个while循环。</li><li>clientSelector被一个 while 死循环包裹着，如果在某一时刻有多条连接有数据可读，那么通过 clientSelector.select(1)方法可以轮询出来，进而批量处理。</li><li>数据读写面向Buffer。</li></ol><p>但是不难看出，整个编码变得极其复杂。所有，就有了Netty。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;传统网络编程&quot;&gt;&lt;a href=&quot;#传统网络编程&quot; class=&quot;headerlink&quot; title=&quot;传统网络编程&quot;&gt;&lt;/a&gt;传统网络编程&lt;/h1&gt;&lt;p&gt;首先看一段最传统的Java网络编程。&lt;/p&gt;
&lt;p&gt;服务端代码如下：&lt;/p&gt;
&lt;figure class=&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/"/>
    
    <category term="netty" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/java/netty/"/>
    
    
    <category term="网络编程" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>单例模式的双重锁检查</title>
    <link href="http://example.com/2023/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8F%8C%E9%87%8D%E9%94%81%E6%A3%80%E6%9F%A5/"/>
    <id>http://example.com/2023/10/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8F%8C%E9%87%8D%E9%94%81%E6%A3%80%E6%9F%A5/</id>
    <published>2023-10-24T02:52:22.000Z</published>
    <updated>2023-10-24T03:08:47.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一般的单例模式"><a href="#一般的单例模式" class="headerlink" title="一般的单例模式"></a>一般的单例模式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            uniqueSingleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在多线程情况下，可能会导致多个实例：</p><table><thead><tr><th><strong>Time</strong></th><th>Thread A</th><th>Thread B</th></tr></thead><tbody><tr><td>T1</td><td>检查到<code>uniqueSingleton</code>为空</td><td></td></tr><tr><td>T2</td><td></td><td>检查到<code>uniqueSingleton</code>为空</td></tr><tr><td>T3</td><td></td><td>初始化对象A</td></tr><tr><td>T4</td><td></td><td>返回对象A</td></tr><tr><td>T5</td><td>初始化对象B</td><td></td></tr><tr><td>T6</td><td>返回对象B</td><td></td></tr></tbody></table><p>这种场景，就会创建两次对象。</p><h1 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h1><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            uniqueSingleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法也存在问题，加锁的粒度太大了，只有在创建对象时才需要加锁，后续获取对象时并不需要加锁。</p><h1 id="双重锁检查"><a href="#双重锁检查" class="headerlink" title="双重锁检查"></a>双重锁检查</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">                    <span class="comment">// 可能存在问题</span></span><br><span class="line">                    uniqueSingleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写，顺序就变成下面这样：</p><ol><li>先判断对象是否存在，不存在则加锁。</li><li>加完锁之后再次判断对象是否存在。</li><li>不存在则创建。</li></ol><p>双重加锁是因为如果多个线程同时通过了第一次判断，那么这几个线程中会有一个线程加锁成功，然后创建对象，后续线程在获取锁之后，就不用再继续创建对象。</p><h2 id="存在的隐患"><a href="#存在的隐患" class="headerlink" title="存在的隐患"></a>存在的隐患</h2><p>在实例化一个对象时，可以分为以下步骤：</p><ol><li>分配内存空间</li><li>初始化对象</li><li>将对象指向刚分配的内存空间</li></ol><p>但是编译器在为了执行速度，可能会进行<strong>指令重排序</strong>，那么顺序就有可能如下：</p><ol><li>分配内存空间</li><li>将对象指向刚分配的内存空间</li><li>初始化对象</li></ol><p>现在考虑如下场景：</p><table><thead><tr><th><strong>Time</strong></th><th>Thread A</th><th>Thread B</th></tr></thead><tbody><tr><td>T1</td><td>检查到<code>uniqueSingleton</code>为空</td><td></td></tr><tr><td>T2</td><td>获取锁</td><td></td></tr><tr><td>T3</td><td>第二次检查<code>uniqueSingleton</code>为空</td><td></td></tr><tr><td>T4</td><td>为<code>uniqueSingleton</code>分配空间</td><td></td></tr><tr><td>T5</td><td>将<code>uniqueSingleton</code>指向内存空间</td><td></td></tr><tr><td>T6</td><td></td><td>检查到<code>uniqueSingleton</code>不为空</td></tr><tr><td>T7</td><td></td><td>访问<code>uniqueSingleton</code>（此时对象还未完成初始化）</td></tr><tr><td>T8</td><td>初始化将<code>uniqueSingleton</code></td><td></td></tr></tbody></table><p>这种情况下，线程B就访问到了一个还未初始化完成的对象。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>使用<code>volatile</code>关键字禁止指令重排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == uniqueSingleton) &#123;</span><br><span class="line">                    uniqueSingleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一般的单例模式&quot;&gt;&lt;a href=&quot;#一般的单例模式&quot; class=&quot;headerlink&quot; title=&quot;一般的单例模式&quot;&gt;&lt;/a&gt;一般的单例模式&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JDK动态代理和CGlib动态代理</title>
    <link href="http://example.com/2023/10/23/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGlib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://example.com/2023/10/23/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGlib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>2023-10-23T02:57:21.000Z</published>
    <updated>2023-11-02T02:54:16.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h1><p>JDK动态代理是Spring动态代理的默认实现方法。如果我们的类实现了一个接口，那么Spring就会使用这种方法，因为使用JDK动态代理的一个缺陷就是代理的类必须实现接口。</p><p><code>JDK</code>实现动态代理需要两个组件，首先第一个就是<code>InvocationHandler</code>接口。我们在使用<code>JDK</code>的动态代理时，需要编写一个类，去实现这个接口，然后重写<code>invoke</code>方法，这个方法其实就是我们提供的代理方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里是一个动态的代理类，只需要传入对应的类，就会执行对应类的对应方法</span></span><br><span class="line"><span class="comment"> * 也就是说我们只用实现这一个代理类就行了，我们所有相同的代理实现都可以用该类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里的Method，我们通过new Proxy创建的一个代理对象，调用它的哪个方法，这里传过来的就是哪个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object o, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------插入前置通知代码-------------&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行相应的目标方法，rs是方法的返回值</span></span><br><span class="line">        <span class="comment">// 这里是执行被代理对象的方法。由于被代理对象是传进来的，所以一个方法就可以了。</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">rs</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;------插入后置处理代码-------------&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> rs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后<code>JDK</code>动态代理需要使用的第二个组件就是<code>Proxy</code>这个类，我们可以通过这个类的<code>newProxyInstance</code>方法，返回一个代理对象。生成的代理类实现了原来那个类的所有接口，并对接口的方法进行了代理，我们通过代理对象调用这些方法时，底层将通过反射，调用我们实现的<code>invoke</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IHello</span> <span class="variable">iHello2</span> <span class="operator">=</span> (IHello) Proxy.newProxyInstance(IHello.class.getClassLoader(), <span class="comment">// 加载接口的类加载器</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;IHello.class&#125;, <span class="comment">// 一组接口</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(<span class="keyword">new</span> <span class="title class_">HelloImpl</span>())); <span class="comment">// 自定义的InvocationHandle</span></span><br><span class="line"><span class="comment">// 这里执行哪个方法，传给MyInvocationHandler的Method就是哪个方法</span></span><br><span class="line">iHello2.sayHello();</span><br></pre></td></tr></table></figure><p>JDK动态代理的要求：</p><ul><li>委托类和代理类实现的公共接口</li><li>实现公共接口的具体委托类</li><li>InvocationHandler接口被Proxy类回调处理，一般实现 InvocationHandler 接口的类具有委托类引用，接口方法 invoke 中添加公共代码并调用委托类的接口方法</li><li>JDK提供生成动态代理类的核心类Proxy</li></ul><p>JDK的动态代理，是创建了一个匿名类来继承Proxy类，然后实现了需要被代理的接口。因为Java只能单继承，所以代理类不能通过继承来实现。</p><h1 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h1><p>若需要代理的类没有实现接口，此时<code>JDK</code>的动态代理将没有办法使用，于是<code>Spring</code>会使用<code>CGLib</code>的动态代理来生成代理对象。</p><p>CGLib是基于继承的，如果对应的类无法被继承，或者对应方法无法被重写，那么CGLib也无法生成代理对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JDK动态代理&quot;&gt;&lt;a href=&quot;#JDK动态代理&quot; class=&quot;headerlink&quot; title=&quot;JDK动态代理&quot;&gt;&lt;/a&gt;JDK动态代理&lt;/h1&gt;&lt;p&gt;JDK动态代理是Spring动态代理的默认实现方法。如果我们的类实现了一个接口，那么Spring就会</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Spring" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal源码</title>
    <link href="http://example.com/2023/10/21/Java/ThreadLocal%E6%BA%90%E7%A0%81/"/>
    <id>http://example.com/2023/10/21/Java/ThreadLocal%E6%BA%90%E7%A0%81/</id>
    <published>2023-10-21T07:04:29.000Z</published>
    <updated>2023-10-22T03:22:34.445Z</updated>
    
    <content type="html"><![CDATA[<p>以下源码是基于JDK11。</p><h1 id="Get以及Set"><a href="#Get以及Set" class="headerlink" title="Get以及Set"></a>Get以及Set</h1><p>一开始，一直在疑惑这个ThreadLocal到底是用来干嘛的，其实他可以用来存储一些变量，这些变量普通存储会由于被多线程访问或导致一些并发问题，用ThreadLocal存储，就会为每一个线程存储它自己的副本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这一步，它首先获取到了当前的线程，也就是说哪一个线程去调用ThreadLocal，就获取到哪一个线程。</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 这一步就是获取到线程对应的ThreadLocalMap，后文会有具体的结构</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="built_in">this</span>.getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里就是从ThreadLocalMap中获取到对应的元素</span></span><br><span class="line">        ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果之前的map为空，则调用该方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这个初始化值为null</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> <span class="built_in">this</span>.initialValue();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 这里又重新判断了一次，应该是考虑到其他的线程可能在此之间已经创建了对应的map</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="built_in">this</span>.getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里判断map为空，那么就创建新的map</span></span><br><span class="line">        <span class="built_in">this</span>.createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> TerminatingThreadLocal) &#123;</span><br><span class="line">        TerminatingThreadLocal.register((TerminatingThreadLocal)<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    <span class="comment">// 这个threadLocals的类型是ThreadLocalMap</span></span><br><span class="line">    <span class="comment">// 这个创建，是为当前的线程创建一个ThreadLocalMap</span></span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">// 这一步set的设计思路与get一致，都是获取到当前的线程之后，再进行操作。</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="built_in">this</span>.getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实中源码中可以看出，get和set操作都是先获取到当前线程，而每一个Thread中有一个变量ThreadLocalMap，然后去该变量中获取对应的元素。也就是说在每一个Thread中存储了对应的变量，这样就避免了并发访问的问题。</p><h1 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h1><p>ThreadLocalMap是ThreadLocal的一个内部类，ThreadLocalMap内部还有一个内部类，表示ThreadLocalMap的每一个节点。</p><p>首先看ThreadLocalMap的两个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">    <span class="comment">// creatMap调用的构造方法就是该方法。</span></span><br><span class="line">    <span class="comment">// 这里创建该ThreadLocalMap时，需要传入ThreadLocal，其目的就是为了获取对应的hash值，然后将该元素放入对应的下标即可。</span></span><br><span class="line">    <span class="comment">// 而且要获取到该ThreadLocal的table，因为元素的值需要与ThreadLocal绑定，我们要能通过ThreadLocal来拿到对应的元素。</span></span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        <span class="built_in">this</span>.table = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry[<span class="number">16</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; <span class="number">15</span>;</span><br><span class="line">        <span class="built_in">this</span>.table[i] = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry(firstKey, firstValue);</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">this</span>.setThreshold(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ThreadLocalMap</span><span class="params">(ThreadLocal.ThreadLocalMap parentMap)</span> &#123;</span><br><span class="line">        ThreadLocal.ThreadLocalMap.Entry[] parentTable = parentMap.table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> parentTable.length;</span><br><span class="line">        <span class="built_in">this</span>.setThreshold(len);</span><br><span class="line">        <span class="built_in">this</span>.table = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry[len];</span><br><span class="line">        ThreadLocal.ThreadLocalMap.Entry[] var4 = parentTable;</span><br><span class="line">        <span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> parentTable.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="number">0</span>; var6 &lt; var5; ++var6) &#123;</span><br><span class="line">            ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> var4[var6];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                ThreadLocal&lt;Object&gt; key = (ThreadLocal)e.get();</span><br><span class="line">                <span class="keyword">if</span> (key != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> key.childValue(e.value);</span><br><span class="line">                    ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry(key, value);</span><br><span class="line">                    <span class="type">int</span> h;</span><br><span class="line">                    <span class="keyword">for</span>(h = key.threadLocalHashCode &amp; len - <span class="number">1</span>; <span class="built_in">this</span>.table[h] != <span class="literal">null</span>; h = nextIndex(h, len)) &#123;&#125;</span><br><span class="line">                    <span class="built_in">this</span>.table[h] = c;</span><br><span class="line">                    ++<span class="built_in">this</span>.size;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ThreadLocalMap的一个静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="built_in">super</span>(k);</span><br><span class="line">            <span class="built_in">this</span>.value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的Entry，就是对应存储的具体值，比如说如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该代码中，Entry就是一个City</span></span><br><span class="line">ThreadLocal&lt;City&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>每一个Thread有一个变量ThreadLocalMap，在创建该变量时，需要传入首个key以及value，其中key是一个ThreadLocal。</p><p>为什么要传入这个ThreadLocal呢？</p><p>我的理解是ThreadLocal要与对应的Thread绑定。换句话说，我们在使用ThreadLocal时，一般都是在多个线程中通过ThreadLocal来获取一个本该是共享的变量，而在ThreadLocal内部，它会先获取到当前线程，然后调用该线程的ThreadLocalMap来返回线程所需要的变量。所以，创建ThreadLocalMap时就需要传入一个ThreadLocal，方便后续获取值。</p><h2 id="Get以及Set-1"><a href="#Get以及Set-1" class="headerlink" title="Get以及Set"></a>Get以及Set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里，是根据传入的key先获取到hash值，然后去table的对应下标获取元素，存在则直接返回，不存在则调用getEntryAfterMiss</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ThreadLocal.ThreadLocalMap.Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; <span class="built_in">this</span>.table.length - <span class="number">1</span>;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> <span class="built_in">this</span>.table[i];</span><br><span class="line">    <span class="keyword">return</span> e != <span class="literal">null</span> &amp;&amp; e.get() == key ? e : <span class="built_in">this</span>.getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里就是遍历table所有的元素（该ThreadLocalMap存储的所有元素），找是否有key匹配的，有就直接返回</span></span><br><span class="line"><span class="comment"> * 如果table中某一个值为空，则调用expungeStaleEntry方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ThreadLocal.ThreadLocalMap.Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, ThreadLocal.ThreadLocalMap.Entry e)</span> &#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = <span class="built_in">this</span>.table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length; e != <span class="literal">null</span>; e = tab[i]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = (ThreadLocal)e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.expungeStaleEntry(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法的主要目的是为了清除对应下标的元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = <span class="built_in">this</span>.table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">    --<span class="built_in">this</span>.size;</span><br><span class="line"></span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 这里是遍历该ThreadLocalMap的Entry数组，也就是看该ThreadLocalMap存储的所有元素</span></span><br><span class="line">    <span class="keyword">for</span>(i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = nextIndex(i, len)) &#123;</span><br><span class="line">       <span class="comment">// 获取到对应的ThreadLocal</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = (ThreadLocal)e.get();</span><br><span class="line">        <span class="comment">// 这里应该是考虑对应的ThreadLocal已经被释放了</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">            --<span class="built_in">this</span>.size;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这几步操作，就是为了调整元素位置，将他们放在合适的位置，以减小tab大小</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                <span class="comment">// 这一步是循环，断开强引用</span></span><br><span class="line">                <span class="keyword">for</span>(tab[i] = <span class="literal">null</span>; tab[h] != <span class="literal">null</span>; h = nextIndex(h, len)) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = <span class="built_in">this</span>.table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(ThreadLocal.ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i]; e != <span class="literal">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = (ThreadLocal)e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry(key, value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++<span class="built_in">this</span>.size;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= <span class="built_in">this</span>.threshold) &#123;</span><br><span class="line">        <span class="built_in">this</span>.rehash();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value, <span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = <span class="built_in">this</span>.table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line"></span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = prevIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = prevIndex(i, len)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="literal">null</span>; i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = (ThreadLocal)e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot) &#123;</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">this</span>.cleanSomeSlots(<span class="built_in">this</span>.expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot) &#123;</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>.ThreadLocalMap.Entry(key, value);</span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot) &#123;</span><br><span class="line">        <span class="built_in">this</span>.cleanSomeSlots(<span class="built_in">this</span>.expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，ThreadLocalMap是用Entry[]去保存value，而Entry继承了WeakReference，查资料得知这里Entry的key是弱引用，意味着当ThreadLocal没有外部强引用时，会被GC回收，而对应的该ThreadLocal对应的value却不会被回收，若当前线程一直没有结束，会存在一条强引用链, value也会一直累加导致内存泄露。</p><p>而<code>expungeStaleEntry</code>方法就是为了解决上述问题。主动去清理key为空的ThreadLocal对应的value。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以下源码是基于JDK11。&lt;/p&gt;
&lt;h1 id=&quot;Get以及Set&quot;&gt;&lt;a href=&quot;#Get以及Set&quot; class=&quot;headerlink&quot; title=&quot;Get以及Set&quot;&gt;&lt;/a&gt;Get以及Set&lt;/h1&gt;&lt;p&gt;一开始，一直在疑惑这个ThreadLocal到底是</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="源码分析" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>如何使用3m内存来找到1G文件中词频前100的单词</title>
    <link href="http://example.com/2023/10/17/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A81m%E5%86%85%E5%AD%98%E6%9D%A5%E6%89%BE%E5%88%B01G%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%8D%E9%A2%91%E5%89%8D100%E7%9A%84%E5%8D%95%E8%AF%8D/"/>
    <id>http://example.com/2023/10/17/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A81m%E5%86%85%E5%AD%98%E6%9D%A5%E6%89%BE%E5%88%B01G%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%8D%E9%A2%91%E5%89%8D100%E7%9A%84%E5%8D%95%E8%AF%8D/</id>
    <published>2023-10-17T01:36:12.000Z</published>
    <updated>2023-10-26T02:49:01.410Z</updated>
    
    <content type="html"><![CDATA[<p>题目原场景与标题相似，只不过文件的每一行是一个单词，然后在内存只有3m空间，需要获取到1G文件中所有单词频率前100的单词。</p><p>想到了用bitmap。</p><h1 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h1><p>bitmap往往是做一个映射，来减小数原数据占用空间的大小。在Java中，一个int类型的大小是32位，也就是32bit，它占4字节，也就是4byte，现考虑如下场景：</p><p>现在要存储三个数字，比如说5，16，20，如果用一个int数组存储，那么就需要3 * 4 &#x3D; 12字节，但是我们可以换一个思路，比如说使用byte数组，1byte是8位，也就是说可以通过这8位的值位0或1，来代表是否存在数字0-7。那么原来的4字节，就可以代表数字0-31是否存在于集合当中。具体如下表所示</p><table><thead><tr><th>数组值</th><th>1</th><th>1</th><th>0</th><th>0</th><th>0</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>下标</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>说明</td><td>值为1，代表存在数字0</td><td>值为1，代表存在数字1</td><td>值为0，代表不存在数字2</td><td>值为0，代表不存在数字3</td><td>值为0，代表不存在数字4</td><td>值为0，代表不存在数字5</td><td>值为1，代表存在数字6</td><td>值为1，代表存在数字7</td></tr></tbody></table><p>通过这种转换，我们就使用了1字节存储原来需要16字节（4个数字0，1，6，7）才可以存储的集合。</p><p>在具体的实现中，我们初始化一个byte数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><p>我们在计算某一个数字是否存在时，我们要先计算该数字在byte[]数组中的下标，当计算完下标之后，我们就需要将该数字移位，计算出它在该下标在哪一位。</p><p>这里的bytes[i]就是上面表格中的样子。每一个byte的大小为2^8 - 1，可以表示0~2^8 - 1。</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>1GB大小的文件，全部存储单词，我们假设平均每个单词的长度为10，查阅资料得知Java中空字符串占用40字节，我们做一个大致的估算，一个单词长度为10，那么每个单词占用空间大小就是60字节（一个char[]数组中每个字符占2字节）。那么这1GB大小的文件当中一共有1 * 1024 * 1024 &#x2F; 60 &#x3D; 17476个单词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象头（<span class="number">8</span> 字节）+ 引用 (<span class="number">4</span> 字节 )  + <span class="type">char</span> 数组（<span class="number">16</span> 字节）+ <span class="number">1</span>个 <span class="type">int</span>（<span class="number">4</span>字节）+ <span class="number">1</span>个<span class="type">long</span>（<span class="number">8</span>字节）= <span class="number">40</span> 字节</span><br></pre></td></tr></table></figure><p>一个最笼统的思路，我们可以对每一个单词做一个Hash，然后将他映射到一个bitmap上，通过这种转化，原先1G大小的单词，就可以通过该映射存储到对应的位置。</p><p>但是这种思路好像没办法解决对应的问题，因为bitmap只能存储0或者1，如果存在两个相同的单词，并不能够进行统计，并且还有Hash冲突的可能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目原场景与标题相似，只不过文件的每一行是一个单词，然后在内存只有3m空间，需要获取到1G文件中所有单词频率前100的单词。&lt;/p&gt;
&lt;p&gt;想到了用bitmap。&lt;/p&gt;
&lt;h1 id=&quot;bitmap&quot;&gt;&lt;a href=&quot;#bitmap&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="场景分析" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    
    
    <category term="场景分析" scheme="http://example.com/tags/%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Spring的事务传播</title>
    <link href="http://example.com/2023/10/15/Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD/"/>
    <id>http://example.com/2023/10/15/Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD/</id>
    <published>2023-10-15T07:39:21.000Z</published>
    <updated>2023-10-30T08:51:44.373Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务传播"><a href="#事务传播" class="headerlink" title="事务传播"></a>事务传播</h3><blockquote><p>写在前面</p><p><strong>Spring的事务是通过AOP这种代理的方式实现的。</strong></p></blockquote><p>事务传播就是多个事务方法相互调用时，事务如何在这些方法间传播。比如事务方法A调用了方法B，那么方法B有无事务以及方法B对事务的要求不同都会对方法A的事务执行造成影响，而方法A的事务对方法B的事务执行也有影响，这种影响就由两个方法定义的事务传播类型所决定。</p><p>spring中的事务传播定义了七种类型：<strong>REQUIRED、SUPPORTS、MANDATORY、REQUIRES_NEW、NOT_SUPPORTED、NEVER、NESTED</strong>。这七种类型以枚举的形式存储在<code>org.springframework.transaction.annotation</code>的<code>Propagation</code>。</p><p>下面根据集体的例子来解释每一个情况。</p><p>假设现在有两个方法A和B，A会在ATable中插入一条数据，B会在BTable中插入一条数据。伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将传入参数a存入ATable</span></span><br><span class="line">pubilc <span class="keyword">void</span> <span class="title function_">A</span><span class="params">(a)</span>&#123;</span><br><span class="line">    insertIntoATable(a);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将传入参数b存入BTable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">B</span><span class="params">(b)</span>&#123;</span><br><span class="line">    insertIntoBTable(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设没有事务时，如下场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMain</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 调用A入参a1</span></span><br><span class="line">    A(a1);</span><br><span class="line">    <span class="comment">// 调用testB</span></span><br><span class="line">    testB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 调用B入参b1</span></span><br><span class="line">    B(b1);</span><br><span class="line">    <span class="comment">// 发生异常抛出</span></span><br><span class="line">    <span class="keyword">throw</span> Exception;</span><br><span class="line">    <span class="comment">// 调用B入参b2</span></span><br><span class="line">    B(b2);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，a1和b1这两条数据会存入对用的数据库，而b2这条数据会因为异常而没有入库。</p><h4 id="REQUIRED（Spring默认的事务传播）"><a href="#REQUIRED（Spring默认的事务传播）" class="headerlink" title="REQUIRED（Spring默认的事务传播）"></a>REQUIRED（Spring默认的事务传播）</h4><blockquote><p><strong>如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务</strong></p></blockquote><p>使用场景如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMain</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 调用A入参a1</span></span><br><span class="line">    A(a1);</span><br><span class="line">    <span class="comment">// 调用testB</span></span><br><span class="line">    testB();    </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 调用B入参b1</span></span><br><span class="line">    B(b1);</span><br><span class="line">    <span class="comment">// 发生异常抛出</span></span><br><span class="line">    <span class="keyword">throw</span> Exception;</span><br><span class="line">    <span class="comment">// 调用B入参b2</span></span><br><span class="line">    B(b2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，数据库的状态会停留在没有执行这两个方法的状态。</p><p><code>testMain()</code>声明了事务，它执行时会创建事务，在执行<code>testB()</code>的时候，它就会加入<code>testMain()</code>的事务，而不会自己创建。</p><h4 id="SUPPORTS"><a href="#SUPPORTS" class="headerlink" title="SUPPORTS"></a>SUPPORTS</h4><blockquote><p><strong>当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMain</span><span class="params">()</span>&#123;</span><br><span class="line">    A(a1);  <span class="comment">//调用A入参a1</span></span><br><span class="line">    testB();    <span class="comment">//调用testB</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.SUPPORTS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>&#123;</span><br><span class="line">    B(b1);  <span class="comment">//调用B入参b1</span></span><br><span class="line">    <span class="keyword">throw</span> Exception;     <span class="comment">//发生异常抛出</span></span><br><span class="line">    B(b2);  <span class="comment">//调用B入参b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，a1和b1会插入数据库，b2不会插入，因为<code>testMain()</code>是没有事务的，所以执行<code>testB()</code>方法时，无法加入其他的事务。</p><h4 id="MANDATORY"><a href="#MANDATORY" class="headerlink" title="MANDATORY"></a>MANDATORY</h4><blockquote><p><strong>当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。</strong></p></blockquote><p>上面的代码在这种情况下，执行结果就是a1存储数据库，而b1和b2没有存入，因为<code>testMain()</code>没有事务而产生报错。</p><h4 id="REQUIRES-NEW"><a href="#REQUIRES-NEW" class="headerlink" title="REQUIRES_NEW"></a>REQUIRES_NEW</h4><blockquote><p><strong>创建一个新事务，如果存在当前事务，则挂起该事务。</strong>可以理解为在执行时，不论当前是否存在事务，总是会新建一个事务。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMain</span><span class="params">()</span>&#123;</span><br><span class="line">    A(a1);  <span class="comment">//调用A入参a1</span></span><br><span class="line">    testB();    <span class="comment">//调用testB</span></span><br><span class="line">    <span class="keyword">throw</span> Exception;     <span class="comment">//发生异常抛出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testB</span><span class="params">()</span>&#123;</span><br><span class="line">    B(b1);  <span class="comment">//调用B入参b1</span></span><br><span class="line">    B(b2);  <span class="comment">//调用B入参b2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，a1没有存入成功，而b1和b2会存入成功。因为<code>testB()</code>会新建一个事务，而不是采用<code>testMain()</code>的事务。</p><h4 id="NOT-SUPPORTED"><a href="#NOT-SUPPORTED" class="headerlink" title="NOT_SUPPORTED"></a>NOT_SUPPORTED</h4><blockquote><p><strong>始终以非事务方式执行,如果当前存在事务，则挂起当前事务</strong>，可以理解为始终不执行事务。</p></blockquote><h4 id="NEVER"><a href="#NEVER" class="headerlink" title="NEVER"></a>NEVER</h4><blockquote><p><strong>不使用事务，如果当前事务存在，则抛出异常</strong></p></blockquote><h4 id="NESTED"><a href="#NESTED" class="headerlink" title="NESTED"></a>NESTED</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;事务传播&quot;&gt;&lt;a href=&quot;#事务传播&quot; class=&quot;headerlink&quot; title=&quot;事务传播&quot;&gt;&lt;/a&gt;事务传播&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;写在前面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring的事务是通过AOP这种代理的方式实现的。&lt;/s</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Spring" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码</title>
    <link href="http://example.com/2023/10/14/Java/HashMap%E6%BA%90%E7%A0%81/"/>
    <id>http://example.com/2023/10/14/Java/HashMap%E6%BA%90%E7%A0%81/</id>
    <published>2023-10-14T02:29:37.000Z</published>
    <updated>2023-10-21T07:05:27.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap源码"><a href="#HashMap源码" class="headerlink" title="HashMap源码"></a>HashMap源码</h1><h2 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    HashMap.Node e;</span><br><span class="line">    <span class="keyword">return</span> (e = <span class="built_in">this</span>.getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> HashMap.Node&lt;K, V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    HashMap.Node[] tab;</span><br><span class="line">    HashMap.Node first;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 这里，先把tab指向了整个类的table，也就是先获取目前存储的所有元素</span></span><br><span class="line">    <span class="comment">// 同时判断是否为空，长度是否大于0，并初始化first的值，n - 1 &amp; hash是为了保证hash值有效</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = <span class="built_in">this</span>.table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (first = tab[n - <span class="number">1</span> &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">// 这里是为了判断是否存在hash冲突，如果hash值相等，并且key也相当，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; ((k = first.key) == key || key != <span class="literal">null</span> &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap.Node e;</span><br><span class="line">        <span class="comment">// 这里是判断冲突后，是否还存在下一个元素</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断此时的结构是否为红黑树，如果是，则遍历红黑树找节点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> HashMap.TreeNode) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((HashMap.TreeNode)first).getTreeNode(hash, key);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不是红黑树，那么就是一个链表，直接遍历链表到结尾，找对应元素即可。</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key != <span class="literal">null</span> &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span>((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getTreeNode"><a href="#getTreeNode" class="headerlink" title="getTreeNode"></a>getTreeNode</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap.TreeNode&lt;K, V&gt; <span class="title function_">getTreeNode</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span> ? <span class="built_in">this</span>.root() : <span class="built_in">this</span>).find(h, k, (Class)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> HashMap.TreeNode&lt;K, V&gt; <span class="title function_">find</span><span class="params">(<span class="type">int</span> h, Object k, Class&lt;?&gt; kc)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先获取到该节点的整个红黑树</span></span><br><span class="line">    HashMap.<span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        HashMap.TreeNode&lt;K, V&gt; pl = p.left;</span><br><span class="line">        HashMap.TreeNode&lt;K, V&gt; pr = p.right;</span><br><span class="line">        <span class="type">int</span> ph;</span><br><span class="line">        <span class="comment">// 首先，是因为发生hash冲突后，才会用这个红黑树来解决hash冲突，那么该树中节点的hash值不是应该全部相等吗？</span></span><br><span class="line">        <span class="comment">// 应该是没有看生成代码的原因，转变为红黑树后，应该要做一次reHash，那么他们就会有新的hash值来用于构建红黑树</span></span><br><span class="line">        <span class="comment">// 这里，就是获取到左子树和右子树的hash值，然后与传入的值进行比较，一直找到相等的</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h) &#123;</span><br><span class="line">            p = pl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h) &#123;</span><br><span class="line">            p = pr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里是找到了Hash值相等的</span></span><br><span class="line">            Object pk;</span><br><span class="line">            <span class="comment">// 先判断key值是否相等，如果相等则返回</span></span><br><span class="line">            <span class="keyword">if</span> ((pk = p.key) == k || k != <span class="literal">null</span> &amp;&amp; k.equals(pk)) &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里是仍然有冲突，那么就看该节点的左右子树</span></span><br><span class="line">            <span class="keyword">if</span> (pl == <span class="literal">null</span>) &#123;</span><br><span class="line">                p = pr;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="literal">null</span>) &#123;</span><br><span class="line">                p = pl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 这里是左右子树都不为空</span></span><br><span class="line">                <span class="type">int</span> dir;</span><br><span class="line">                <span class="comment">// 这里由于没有传入比较器，所以不会走if，只会走else</span></span><br><span class="line">                <span class="keyword">if</span> ((kc != <span class="literal">null</span> || (kc = HashMap.comparableClassFor(k)) != <span class="literal">null</span>) &amp;&amp; (dir = HashMap.compareComparables(kc, k, pk)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    p = dir &lt; <span class="number">0</span> ? pl : pr;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 这里是左右子树都不为空，则递归的进行搜索即可</span></span><br><span class="line">                    HashMap.TreeNode q;</span><br><span class="line">                    <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    p = pl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(p != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HashMap源码&quot;&gt;&lt;a href=&quot;#HashMap源码&quot; class=&quot;headerlink&quot; title=&quot;HashMap源码&quot;&gt;&lt;/a&gt;HashMap源码&lt;/h1&gt;&lt;h2 id=&quot;get操作&quot;&gt;&lt;a href=&quot;#get操作&quot; class=&quot;header</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="源码分析" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>单点登录</title>
    <link href="http://example.com/2023/10/13/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <id>http://example.com/2023/10/13/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</id>
    <published>2023-10-13T06:33:30.000Z</published>
    <updated>2023-10-30T08:51:55.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h1><p>一个真正的单点登录流程如下：该流程属于不同域下的单点登录。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/637ec3d1265a44629a45aa7571a77c9f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><ul><li>用户进入 A 系统，没有登录凭证（ticket），A 系统给他跳到 SSO。</li><li>SSO 没登录过，也就没有 sso 系统下没有凭证（怎么感知到的）（注意这个和前面 A ticket 是两回事），输入账号密码登录。</li><li>SSO 账号密码验证成功，通过接口返回做两件事：一是种下 sso 系统下凭证（记录用户在 SSO 登录状态）；二是下发一个 ticket。</li><li>客户端拿到 ticket，保存起来，带着请求系统 A 接口。</li><li>系统 A 校验 ticket，成功后正常处理业务请求。</li><li>此时用户第一次进入系统 B，没有登录凭证（ticket），B 系统给他跳到 SSO。</li><li>SSO 登录过，系统下有凭证，不用再次登录，只需要下发 ticket。</li><li>客户端拿到 ticket，保存起来，并携带ticket请求系统B的接口。</li></ul><p>至此，还存在问题，SSO 域下返回的数据要怎么存，才能在访问 A 的时候带上？因为浏览器对跨域有严格限制，cookie、localStorage 等方式都是有域限制的。</p><p>下面这张图是一个更细致的流程：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/6dabc898da7149d9b8972a7830825bc9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><ul><li>在 SSO 域下，SSO 不是通过接口把 ticket 直接返回，而是通过一个带 code 的 URL 重定向到系统 A 的接口上，这个接口通常在 A 向 SSO 注册时约定。相当于提前定义好了一个接口来接收SSO系统返回的code。</li><li>浏览器被重定向到 A 域下，带着 code 访问了 A 的 callback 接口，callback 接口通过 code 换取 ticket。</li><li>这个 code 不同于 ticket，code 是一次性的，暴露在 URL 中，只为了传一下换 ticket，换完就失效。</li><li>callback 接口拿到 ticket 后，在自己的域下 set cookie 成功。</li><li>在后续请求中，只需要把 cookie 中的 ticket 解析出来，去 SSO 验证就好。</li></ul><p>这里，用户第一次请求时，由于本地没有cookie，所以验证会失败，跳转到SSO系统去验证，而这个验证也会因为没有cookie而失败，所以要求用户进行登录。当登录完成过后，会跳转到系统A提前定义好的接口，并携带code，此时也会在用户本地存储SSO域的一个cookie。该接口会拿到code后去SSO系统换取ticket，拿到ticket后会向SSO系统验证这个ticket是否正确（防止有人伪造ticket而直接请求接口），如果正确则可以正常处理。</p><p>此时如果用户使用系统B，因为本地已经有SSO域的cookie 了，携带者去请求SSO就可以，然后可以直接下发凭证。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单点登录&quot;&gt;&lt;a href=&quot;#单点登录&quot; class=&quot;headerlink&quot; title=&quot;单点登录&quot;&gt;&lt;/a&gt;单点登录&lt;/h1&gt;&lt;p&gt;一个真正的单点登录流程如下：该流程属于不同域下的单点登录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image-1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL limit 1和limit 10000，1性能一样吗</title>
    <link href="http://example.com/2023/10/11/MySQL%E7%9A%84limit/"/>
    <id>http://example.com/2023/10/11/MySQL%E7%9A%84limit/</id>
    <published>2023-10-11T02:50:37.000Z</published>
    <updated>2023-10-26T03:31:19.582Z</updated>
    
    <content type="html"><![CDATA[<p> 考虑两条MySQL语句的执行，其中key1是二级索引，id是主键。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from my_table order by key1 limit 1;</span><br></pre></td></tr></table></figure><p>该条语句，key1是二级索引，本身就是有序的，那么当查询一条语句之后，它就会直接回表查询具体的数据然后返回。</p><p>但是如果SQL变为下面的写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from my_table order by key1 limit 10000, 1;</span><br></pre></td></tr></table></figure><p>执行这条语句就会发现它走了全表的扫描 + filesort，它并没有像想象中的那样，扫描到10001的索引，然后回表返回结果。</p><h1 id="limit的执行"><a href="#limit的执行" class="headerlink" title="limit的执行"></a>limit的执行</h1><p>MySQL分为Server层和具体的存储引擎层，Server层是统一的，而存储引擎我们这里默认使用InnoDB。</p><p>当具体执行一个带有limit操作的SQL时，它并不会在存储引擎层进行过滤，存储引擎查询到所需要的所有数据，然后返回给Server层，Server层依据具体的查询需求来进行过滤，也就是说需要先查询10001条数据返回给Server，然后进行过滤。</p><h1 id="优化器选择"><a href="#优化器选择" class="headerlink" title="优化器选择"></a>优化器选择</h1><p>优化器在执行这个查询时会有两种选择</p><ol><li>全表扫描，然后返回，过滤掉不需要的数据。</li><li>第二种查询方案涉及到数据返回策略，InnoDB在执行查询索引时，查找到一条满足条件的数据后，会进行回表，查找完整数据，然后返回给Server层，Server层在返回给用户时发现还有limit，所以要做限制，就不能进行返回，并开始计数。直到引擎层给Server层返回了10001条数据后，才可以完成limit操作，之后再将结果返回给用户，也就是说这里需要进行10001次回表操作，并且要查询10001行数据，然后前10000行全部被Server层丢弃。</li></ol><p>这两种方案会由优化器决定走哪一种，但不管走哪一种，都需要进行大量的回表操作。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>当执行 <code>limit 1</code> 和执行 <code>limit 10000，1</code>时，性能上的差距还是很大的。并且由于MySQL内存有限，在查询前10000行数据时，难免会有数据页被移出内存，然后从磁盘中加载新的数据页，这也会消耗一定的时间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 考虑两条MySQL语句的执行，其中key1是二级索引，id是主键。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="场景分析" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    
    
    <category term="场景分析" scheme="http://example.com/tags/%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>远程调用</title>
    <link href="http://example.com/2023/10/08/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
    <id>http://example.com/2023/10/08/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/</id>
    <published>2023-10-08T03:14:44.000Z</published>
    <updated>2023-10-18T04:08:01.857Z</updated>
    
    <content type="html"><![CDATA[<h1 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h1><p>本地调用通常指的是，进程内函数之间的相互调用；而远程调用，是进程间函数的相互调用，是进程间通信 IPC（Inter-Process Communication）的一种方式。</p><p>根据进程是否部署在一台机器上，远程调用可以分为以下两类：</p><ol><li><strong>本地过程调用（Local Procedure Call，LPC）</strong>，是指运行在同一台机器上的进程之间 的互相通信，即在多进程操作系统中，运行的不同进程之间可以通过 LPC 进行函数调 用。</li><li><strong>远程过程调用（Remote Procedure Call，RPC）</strong>，是指不同机器中运行的进程之间的 相互通信，某一机器上运行的进程在不知道底层通信细节的情况下，就像访问本地服务 一样，去调用远程机器上的服务。</li></ol><h2 id="远程调用的原理"><a href="#远程调用的原理" class="headerlink" title="远程调用的原理"></a>远程调用的原理</h2><p>在B&#x2F;S ( Browser&#x2F;Server，浏览器 &#x2F; 服务器) 架构中，被调用方（服务器）会有一个开放的接口，然后调用方（用户）会通过Browser使用这个接口，来间接的调用相应的服务。</p><p>但是，B&#x2F;S 架构是基于 HTTP 协议实现的，每次调用接口时，都需要先进行 HTTP 请求，比较的耗时，不适合分布式中的远程调用。更为常用的是 <strong>远程过程调用 RPC(Remote Procedure Call)</strong> 和 **远程方法调用 RMI(Remote Method Invocation)**。</p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>简单地说，RPC 就是调用方采用参数传递的方式，通过调用本机器上的一个函数或方法， 去执行远程机器上的函数或方法（可以统称为服务），并返回结果。在整个过程中，RPC 会隐藏具体的通信细节。一个支付流程的网络调用如下图所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231012092420486.png" alt="image-20231012092420486" style="zoom:80%;" /><p>其中，Stub 是用于转换 RPC 过程中在订单系统和支付系统所在机器之间传递的参数。说白了，客户端的Stub用于封装参数，而服务端的Stub就是为了将收到的封装后的参数解析出来。</p><p>不难看出，机器 A 上的 Pay(Order)、 Client Stub 和网络调用之间的交互属于本地调用，机器 B 上的 Pay(Order)、Server Stub 和网络调用之间的交互也属于本地调用。而机器 A 和机器 B 之间的远程调用的核心是，发生在机器 A 上的网络调用和机器 B 上的网络调用。</p><p>RPC的目的是，将第 2 到第 8 步的几个过程封装起来，让用户看不到这些细节。 从用户的角度看，订单系统的进程只是做了一次普通的本地调用，然后就得到了结果。</p><p>订单系统进程并不需要知道底层是如何传输的，在用户眼里，远程过程调用和调用一次本地服务没什么不同。这就是 RPC 的核心。</p><h4 id="RPC与本地调用的区别"><a href="#RPC与本地调用的区别" class="headerlink" title="RPC与本地调用的区别"></a>RPC与本地调用的区别</h4><p>第一个区别是<strong>调用 ID 和函数的映射</strong>。在本地调用中，进程内可共享内存地址空间，因此程序可直接通过函数名来调用函数。函数名的本质是一个函数指针，可以看作函数在内存中的地址。而在远程调用中，只通过函数名却不行，因为不同进程的地址空间不一样，所以必须通过一个调用ID来标识，在远程调用时要附上ID。</p><p>调用方首先通过映射表，先找到调用函数的ID，传给被调用方。被调用方拿到ID后，通过ID找到具体被调用的函数。</p><p>第二个区别是，<strong>序列化和反序列化</strong>。在本地调用中，进程之间共享内存等，因此我们只需要把参数压到栈里，然后进程自己去栈 里读取就行。但是在 RPC 中，两个进程分布在不同的机器上，使用的是不同机器的内存， 因此不可能通过内存来传递参数。</p><p>而网络协议传输的内容是二进制流，无法直接传输参数的类型，因此这就需要调用方把参数 先转成一个二进制流，传到被调用方后，被调用方再把二进制流转换成自己能读取的格式。 这个过程，就叫作序列化和反序列化。</p><p>第三个区别是，<strong>网络传输协议</strong>。序列化和反序列化解决了调用方和被调用方之间的数据传输 格式问题，但要想序列化后的数据能在网络中顺利传输，还需要有相应的网络协议，比如 TCP、UDP 等，因此就需要有一个底层通信层。而大部分的RPC框架，采用的都是TCP协议。</p><h3 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h3><p>RMI 是一个基于 Java 环境的应用编程接口，能够让本地 Java 虚拟机上运行的对象，像调用本地对象一样调用远程 Java 虚拟机上的对象。RMI可以说是RPC的一种具体形式，原理与RPC基本一致，不同的是RMI 是基于对象的，充分利用了面向对象的思想去实现整个过程，其本质就是一种基于对象的 RPC 实现。</p><p>RMI 与 PRC 最大的不同在于调用方式和返回结果的形式，RMI 通 过对象作为远程接口来进行远程方法的调用，返回的结果也是对象形式，可以是 Java 对象 类型，也可以是基本数据类型。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《分布式技术原理与算法实战》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;远程调用&quot;&gt;&lt;a href=&quot;#远程调用&quot; class=&quot;headerlink&quot; title=&quot;远程调用&quot;&gt;&lt;/a&gt;远程调用&lt;/h1&gt;&lt;p&gt;本地调用通常指的是，进程内函数之间的相互调用；而远程调用，是进程间函数的相互调用，是进程间通信 IPC（Inter-Proc</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="分布式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>服务治理</title>
    <link href="http://example.com/2023/10/06/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"/>
    <id>http://example.com/2023/10/06/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/</id>
    <published>2023-10-06T07:07:56.000Z</published>
    <updated>2023-10-29T07:20:07.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务治理手段"><a href="#服务治理手段" class="headerlink" title="服务治理手段"></a>服务治理手段</h1><p>服务的调用涉及到注册中心，服务调用的发起方和提供方三者，这三者中任意两个的通信都是通过网络，那么不论是网络出现问题，还是说这三者中任意一个出现问题，此次调用都会失败。所以就需要服务治理。</p><h2 id="节点管理"><a href="#节点管理" class="headerlink" title="节点管理"></a>节点管理</h2><p>该部分可以分为两点。</p><ol><li>注册中心主动摘除机制。这种机制要求服务提供者定时向注册中心汇报心跳，当两次汇报中间的时间超过规定时间后，就认为服务提供者出现问题，进行摘除，然后把最近的可用服务列表推送给服务消费者。</li><li>服务消费者摘除机制。上述机制可能因为网络问题导致一个正常的服务被摘除，最坏情况所有服务都正常，但是全被摘除。一个更合理的摘除办法就是让服务的调用者去执行。即服务调用者调用失败时，就从本地缓存的可用服务列表中去移除该服务，而不进行实际的摘除。</li></ol><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>这里边有几个算法：</p><ol><li>随机算法</li><li>轮询算法</li><li>最少活跃调用算法</li><li>一致性Hash算法</li></ol><h2 id="服务路由"><a href="#服务路由" class="headerlink" title="服务路由"></a>服务路由</h2><p>对于服务消费者而言，在内存中的可用服务节点列表中选择哪个节点不仅由负载均衡算法决定，还由路由规则确定。而指定路由规则的主要原因有以下两点：</p><ol><li>服务功能做了变更，需要灰度发布，根据这部分人的使用反馈来决定是否全量发布时，就可以做一些路由规则的限制，比如说使用尾号限制，让特定比例的人群才会访问到新发布的服务节点。</li><li>部分规模比较大的公司，为了业务高可用，会将业务部署在不止一个IDC中，这时候不同IDC之间访问要跨IDC，而距离比较远时延迟就会比较大。所以一次服务调用尽可能选择同一个IDC内部的节点，减少网络开销，提高性能。</li></ol><p>路由的配置规则一般有<strong>静态配置</strong>和<strong>动态配置</strong>。其中静态配置是防止在每一个服务本地的，服务上线后规则不发生改变。而动态配置一般都是放在注册中心，需要修改时改动注册中心的内容即可。</p><h2 id="服务容错"><a href="#服务容错" class="headerlink" title="服务容错"></a>服务容错</h2><p>对于服务调用失败的情况，需要有手段自动恢复，来保证调用成功。常用手段有以下几种：</p><ol><li>失败自动切换。顾名思义，调用失败了后就从最近的可用服务列表中选一个进行重试，可以限制重试次数，但是这种操作要求服务的调用操作是<strong>幂等</strong>的。</li><li>失败通知。服务调用失败后，不再进行重试，而是根据失败返回的信息而决定后续的操作。</li><li>失败缓存。服务调用失败后，并不立即进行重试，而是隔一段时间后再进行重试。</li><li>快速失败。调用失败后就不管了。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《从0开始学微服务》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;服务治理手段&quot;&gt;&lt;a href=&quot;#服务治理手段&quot; class=&quot;headerlink&quot; title=&quot;服务治理手段&quot;&gt;&lt;/a&gt;服务治理手段&lt;/h1&gt;&lt;p&gt;服务的调用涉及到注册中心，服务调用的发起方和提供方三者，这三者中任意两个的通信都是通过网络，那么不论是网络出</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="分布式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>多主复制</title>
    <link href="http://example.com/2023/10/04/%E5%A4%9A%E4%B8%BB%E5%A4%8D%E5%88%B6/"/>
    <id>http://example.com/2023/10/04/%E5%A4%9A%E4%B8%BB%E5%A4%8D%E5%88%B6/</id>
    <published>2023-10-04T07:50:22.000Z</published>
    <updated>2023-10-04T07:56:20.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多主复制"><a href="#多主复制" class="headerlink" title="多主复制"></a>多主复制</h1><p>在主从复制的场景中，只有一个主节点，所有的写入操作都要先经过主节点，主节点压力大的问题还是没能解决。而且单主节点的容灾效果也不是很好。</p><p>为了达到好的容灾效果，各个机房的距离应该足够远，尽可能的分布在不同的地区，那么这种场景下，用户直接读写自己最近的数据中心，网络延迟最小，效果最好。因此就出现了多住复制。</p><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><p>它是指在一个数据系统中，存在多个主从 复制单元，每一个主从复制单元都可以处理读写请求，一个主从复制单元的主副本处理了写请 求后，需要复制到其他的主从复制单元的主副本，具体的流程见下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231004112141400.png" alt="image-20231004112141400" style="zoom: 80%;" /><p>有几点需要注意：</p><p>首先，每一个主从复制单元内部是一个常规的主 从复制模式，这里的主副本、从副本之间的复制可以是同步的，也可以是异步的。</p><p>其次，多个主从复制单元之间，每一个主副本都会将自己的修改复制到其他的主副本，主副本 之间的复制可以是同步的，也可以是异步的。</p><p>如果主副本之间的复制是同步的，那么一个主副本的写入，需要等待复制到其他的主副本成功 后，才能返回给用户，但是，这样却失去了多主复制最重要的一个优点，即多个主副本都可以独立处理写入，这就导致整个模式 退化为主从复制的形式。所以一般来说，多主复制的主副本之间，大多采用异步模式。</p><p>但采用异步复制也会出现问题，如果多个主副本同时成功修 改一个数据，当主副本之间复制这个数据的修改时，会出现冲突，我们就不知道以哪一个主副 本的写入结果为准了，该问题在同步复制时可以让用户决定哪个为主。</p><h2 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h2><p>冲突主要由两种形式，</p><p>首先是由于更新导致的冲突，多个主副本同时更新了一个数据，导致这个数据的版本是非线性的，出现了分叉，具体见下图：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231004124557885.png" alt="image-20231004124557885">其次，由于新增导致的冲突，多个主副本同时新增了一个含有唯一性约束的数据，导致数据的唯一性约束被破坏。例如，在酒店预订业务中，一个时段内一个房间只能预订给一个用户，如 果多个用户在多个主副本上，同时发起预订操作，就可能出现同一个时段内，一个房间被多个 用户预定成功的情况。</p><h3 id="避免冲突"><a href="#避免冲突" class="headerlink" title="避免冲突"></a>避免冲突</h3><p>由上可知，冲突是多个主副本同时 修改了一个数据，或者破坏了数据的唯一性约束导致的，那么我们就对数据进行分片，让不同的主数据负责不同的数据分片，这个方式可以在一定程度上避免冲突，但是会导致两个问题：</p><p>首先，一个修改操作可能会修改多个分片数据，这样我们就没有办法通过分片来隔离修改了。</p><p>其次，由于就近接入和故障等原因，我们会将出现故障的主副本流量切换到其他的主副本，这 时也会出现写入冲突的情况。</p><p>注意：这里的分片，并不是每个主副本只保留一部分数据，而是每个主副本仍然保留全量的数据，但是只负责主动的修改某一部分，其他部分等待其他主副本进行同步。</p><h4 id="写时解决冲突"><a href="#写时解决冲突" class="headerlink" title="写时解决冲突"></a>写时解决冲突</h4><p>写时解决冲突有两种实现，预定义解决冲突和自定义解决冲突。</p><p>预定义解决冲突，是指由存储系统预先定义好规则，在冲突发生时依据预先定义好的规则，自动来解决冲突，主要有以下几种：</p><ol><li>从操作维度来处理，最后写入获胜。也就是为每一个写操作分配一个时间戳，如果发生 冲突，只保留时间戳最大的版本数据，其他的修改都丢弃，但是这个方法会导致修改丢失。</li><li>从副本维度来处理，最高优先级写入获胜。也就是为每一个副本都排好优先级，如果发 生冲突，只保留优先级最高的副本修改数据，其他的修改都丢弃。</li><li>从数据结构和算法的维度来处理，通过研究一些可以自动解决冲突的数据结构来解决问题。目前不成熟。</li></ol><p>自定义解决冲突，它是由业务系统来定义冲突的解决方式，如果发生冲突 了，存储系统就依据业务系统定义的方式执行。</p><p>自定义冲突解决的处理逻辑是，在主副本之间复制变更日志时，如果检测到冲突，就调用用户 自定义的冲突处理程序来进行处理。由于主副本之间的数据复制是异步的，所以一般都是后台 执行，不会提示用户。</p><h4 id="读时解决冲突"><a href="#读时解决冲突" class="headerlink" title="读时解决冲突"></a>读时解决冲突</h4><p>读时解决冲突的思路和写时解决冲突的思路正好相反，即在写入数据时，如果检测到冲突，不 用立即进行处理，只需要将所有冲突的写入版本都记录下来。当下一次读取数据时，会将所有的数据版本都返回给业务层，在业务层解决冲突，那么读时解决冲突的方式有下面两种：</p><ol><li>由用户来解决冲突。业务层将冲突提示给用户，让用户来解决。</li><li>自定义解决冲突。业务层先依据业务情况，自定义好解决冲突的处理程序，当检 测到冲突时，直接调用处理程序来解决。</li></ol><h2 id="多主复制的关键问题"><a href="#多主复制的关键问题" class="headerlink" title="多主复制的关键问题"></a>多主复制的关键问题</h2><p>1、正确解决冲突的难度非常大。</p><p>2、异步模式的多主复制会存在数据一致性的问题。因为多个主副本都是独立写入的，而他们之间是通过异步复制的方式。</p><p>3、多个主副本之间的复制拓扑结构问题。一般来说，多主复制的主副本之间的复制拓扑结 构主要有三种：环形拓扑、星形拓扑以及全部至全部拓扑，具体见下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231004155403956.png" alt="image-20231004155403956" style="zoom:80%;" /><p>前两种，如果一个主副本出现问题，则会导致整个副本的数据无法同步，而第三种虽然一个挂了不影响，但是他们主副本之间同步的时延却要大很多。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入浅出分布式技术原理》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多主复制&quot;&gt;&lt;a href=&quot;#多主复制&quot; class=&quot;headerlink&quot; title=&quot;多主复制&quot;&gt;&lt;/a&gt;多主复制&lt;/h1&gt;&lt;p&gt;在主从复制的场景中，只有一个主节点，所有的写入操作都要先经过主节点，主节点压力大的问题还是没能解决。而且单主节点的容灾效果也</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="分布式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据分片</title>
    <link href="http://example.com/2023/10/02/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87/"/>
    <id>http://example.com/2023/10/02/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87/</id>
    <published>2023-10-02T11:31:22.000Z</published>
    <updated>2023-10-02T11:32:46.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><p>对数据进行分片的策略，主要有三种：水平分片、垂直分片和混合分片，具体如下图所示。水平分片和垂直分片是通过数据切分的操作方向来区分的，而混合分片 是它们的组合体。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002105033499.png" alt="image-20231002105033499" style="zoom: 67%;" /><h3 id="水平分片"><a href="#水平分片" class="headerlink" title="水平分片"></a>水平分片</h3><p>水平分片有点类似于负载均衡，从流量角度来看，是负载均衡，从数据存储角度来看，是水平分片。</p><p>水平分片算法有两个最关键的因素，一是，如何对数据进行划分，即数据划分，二是，分片是 否支持动态分裂与合并，即数据平衡。</p><h4 id="数据划分"><a href="#数据划分" class="headerlink" title="数据划分"></a>数据划分</h4><p>数据划分主要有两种方案，一种是基于模运算，一种是基于范围划分。基于模运算比较简单，不再阐述。而基于范围划分，又分为基于关键词划分和基于关键词的 Hash 值划分两种方式。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002110024878.png" alt="image-20231002110024878" style="zoom:67%;" /><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002110040276.png" alt="image-20231002110040276" style="zoom:67%;" /><p>这两种分片都是给每一个分片分配一个固定的范围，两者的不同区别在于一个是直接拿关键词进行划分，另一个是利用了关键词的Hash值进行划分。看似区别不大，但是会影响数据的分布。</p><h5 id="基于关键词划分"><a href="#基于关键词划分" class="headerlink" title="基于关键词划分"></a>基于关键词划分</h5><p>基于<strong>关键词划分</strong>的好处是，分片后数据的分布依然保留了关键词的顺序，我们可以方便地进行区间查询，因为某个关键词区间的数据都是连续存储的。</p><p>但是基于关键词划分也会带来问题，即<strong>数据分布不均匀和访问的热度不均匀</strong>。比如说按照地区进行划分，那么某些省份人数多，这个分片的数据就会多，人数少，分片数据就少。而且数据分布不均时，数据多的分片被访问到的概率也会变大。</p><p>如果基于自增 ID 或者时间等关键词对数据进行分片的时候，即使数据是均匀分布的，对于一般的业务场景来说，往往新产生数据的访问热度，也是远远大于历史数据的，这也会导致访问的热度不均匀。</p><p>很明显，数据的分布与关键词的分布是一致的。</p><h5 id="基于关键词的hash值"><a href="#基于关键词的hash值" class="headerlink" title="基于关键词的hash值"></a>基于关键词的hash值</h5><p>基于关键词的 Hash 值划分就可以上述问题，它通过对关键词进行 Hash 运算，然后基于计算后的 Hash 值范围对数据进行划分，一个好的 Hash 算法可以处理数据倾斜并让它均匀分布。这样可以解决数据分布和访问热度不均的问题。</p><p>但导致的问题就是无法高效的进行范围查询。</p><h4 id="数据平衡"><a href="#数据平衡" class="headerlink" title="数据平衡"></a>数据平衡</h4><p>根据数据分片是否支持<strong>动态的分裂与合并</strong>，我们可以将水平分片的数据平衡方式分为<strong>静态分片</strong>和<strong>动态分片</strong>。</p><p>静态分片是指在系统设计之初，数据分片的数目和区间就预估好了，数据划分后不能再变化。</p><p>动态分片则可以在运行时，根据分片的负载和容量做调整。</p><p>因为动态分片在运行时分区时可以进行分裂与合并的，不需要担心数据分布的问题，所以动态分片与基于关键词的划分，往往是一个 比较好的组合方式，它避免了基于关键词划分的问题，还保留了数据基于关键词有序的优点。</p><p>但是，在基于关键词的划分中，基于自增 ID 或者时间戳等原因，导致的访问冷热不均匀的问题，即使是在动态分片中也不能很好地解决，因为数据的热点往往集中在最新的一个分片区间上。而基于关键词的 Hash 值划分的方式，则可以很方便地将最新的热点数据分布到多个分片 上，很好地解决这个问题。</p><p>动态分片存在冷启动的问题。当一个基于动态分片的存储系统启动时，通常是从一个分片开始，当数据量不断增长后，再动态进行分裂。在第一次进行分裂前，所有的读写请求都由 第一个分片来进行处理，而其他的节点则都属于空闲状态。关于这个问题，一个比较好的解决 方式是，动态分片在冷启动时，预分裂为多个分片来缓解。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002112557636.png" alt="image-20231002112557636" style="zoom:67%;" /><h3 id="垂直分片"><a href="#垂直分片" class="headerlink" title="垂直分片"></a>垂直分片</h3><p>水平分片策 略将整个数据集的条数作为划分的对象，每一个分片负责处理一定的数据条数。而垂直分片策略则是将数据 Schema 的字段集个数作为划分的对象，每一个分片负责处理一个或几个字段 的全部数据，具体如下图所示。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002164951470.png" alt="image-20231002164951470" style="zoom: 80%;" /><p>如果垂直分片策略的处理方式为一个字段一个分片，那么垂直分片策略就等价于列式存储了，所以列式存储是垂直分片策略的一种特殊情况，也是最常见的情况。</p><p>列式存储往往用于大数据分析当中，这类数据的特点是一次写入，多次查询（从不修改），而且是按列读取，每次只关心一列或者几列，每张表都很宽，比如上百列。而且查询无规律，不能索引覆盖。</p><h4 id="列式存储"><a href="#列式存储" class="headerlink" title="列式存储"></a>列式存储</h4><p>如果是行式存储，当我们只需要读取一列时，有两种方案，第一个是挨个读取每一行的数据，但是只取出自己要的那一列，这会导致读取数据的量放大很多。如果我们只读取那一列，这会导致我们读取时不是按顺序读取，会对读取造成性能影响。</p><p>读多写少的场景，会减少列式存储对写性能的影响。一般来说，数据写入存储系统是以 行的形式写入的，而列式存储会导致一行数据的写入操作，按字段拆分为多个写入操作，使写入放大。</p><p>大数据场景，采用列式存储非常适合压缩存储，比如下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002192207839.png" alt="image-20231002192207839" style="zoom:67%;" /><p>好处是使用压缩会大大减小存储成本，提高了存储效率，但是在存储和读取数据时，需要多一步，即找到数据的编码，需要消耗额外的CPU资源。</p><h3 id="混合分片策略"><a href="#混合分片策略" class="headerlink" title="混合分片策略"></a>混合分片策略</h3><p>根据水平分片和垂直分片的策略，混合分片可以分为<strong>垂直水平分片</strong>策略和<strong>水平垂直分片</strong>策略。前者先 进行垂直分片，再进行水平分片，而后者先进行水平分片，然后再进行垂直分片。具体如下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002192630321.png" alt="image-20231002192630321" style="zoom: 80%;" /><p>垂直水平分片看着不怎么滴，不过多介绍。</p><p>水平垂直分片更像是两者的结合提。先水平划分，划分完后在每一个分片内部再采用列式存储，这样可以保留水平分片和垂直分片的优点。</p><h3 id="行列存储比较"><a href="#行列存储比较" class="headerlink" title="行列存储比较"></a>行列存储比较</h3><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231002193058865.png" alt="image-20231002193058865" style="zoom:80%;" /><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入浅出分布式技术原理》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分片&quot;&gt;&lt;a href=&quot;#分片&quot; class=&quot;headerlink&quot; title=&quot;分片&quot;&gt;&lt;/a&gt;分片&lt;/h2&gt;&lt;p&gt;对数据进行分片的策略，主要有三种：水平分片、垂直分片和混合分片，具体如下图所示。水平分片和垂直分片是通过数据切分的操作方向来区分的，而混合分</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="分布式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Spring的IoC</title>
    <link href="http://example.com/2023/09/30/Spring%E7%9A%84IoC/"/>
    <id>http://example.com/2023/09/30/Spring%E7%9A%84IoC/</id>
    <published>2023-09-30T06:54:11.000Z</published>
    <updated>2023-09-30T07:30:30.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h1><p>1、解析xml文件，将xml中读取到的内容利用<code>ClassPathXmlResource</code>来进行存储。</p><p>2、初始化一个工厂，该工厂可以自由选择，比如<code>SimpleBeanFactory</code>或者<code>AutowireCapableBeanFactory</code>，又或者是<code>BeanFactory</code>，取决于场景需要。</p><p>3、实例化一个<code>XmlBeanDefinitionReader</code>，该类需要传入第二步生成的工厂，它的主要作用就是解析存储在<code>ClassPathXmlResource</code>中的属性，将它封装为一个<code>BeanDefinition</code>，然后存储在一个map中，map的key为对象的名字，value就是<code>BeanDefinition</code>。用于后续创建bean时，根据名称取到<code>BeanDefinition</code>，然后<code>BeanDefinition</code>中取得属性。</p><p>4、到此为止，上面的三步是为了初始化并且存储一些对象的信息，这些信息都来自xml中的配置。之后，调用<code>refresh()</code>来进行具体的创建。</p><p>5、在单例模式下，<code>refresh()</code>会先从存放了所有bean实例的map中根据名字取该元素，如果不为空，则直接返回，如果为空，则从毛坯实例中尝试获取该元素（存储毛坯实例是为了解决循环依赖的问题，创建一个空的对象，所有属性都不赋值，用于注入），如果还是为空，则执行创建。</p><p>6、创建的流程就是获取到之前存储的<code>BeanDefinition</code>，然后先创建一个毛坯实例，这里是利用Java的反射以及<code>BeanDefinition</code>中存储的<code>getConstructorArgumentValues</code>信息，来进行创建，只创建空的类，类的所有属性都不赋值。之后将毛坯实例进行存储。</p><p>7、这一步是将上一步创建的毛坯实例属性进行赋值，从<code>BeanDefinition</code>中获取到<code>PropertyValues</code>，然后遍历，调用<code>setXXX</code>方法进行赋值。</p><p>8、创建完后，将bean存储到第五步刚开始取元素的那个map当中，并返回本次创建的实例。如果没有采用注解，到这里就已经创建结束了。</p><p>9、如果创建的元素当中有属性使用了注解，则会调用<code>AutowiredAnnotationBeanPostProcessor</code>的<code>postProcessBeforeInitialization</code>方法，该方法会遍历传入实例的所有属性，如果发现带有@Autowired注解，那么就去工厂中获取到对应的实例，并进行注入，然后返回该对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大致流程&quot;&gt;&lt;a href=&quot;#大致流程&quot; class=&quot;headerlink&quot; title=&quot;大致流程&quot;&gt;&lt;/a&gt;大致流程&lt;/h1&gt;&lt;p&gt;1、解析xml文件，将xml中读取到的内容利用&lt;code&gt;ClassPathXmlResource&lt;/code&gt;来进行存储。</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>降级</title>
    <link href="http://example.com/2023/09/27/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%99%8D%E7%BA%A7/"/>
    <id>http://example.com/2023/09/27/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%99%8D%E7%BA%A7/</id>
    <published>2023-09-27T02:16:37.000Z</published>
    <updated>2023-09-27T02:18:44.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h1><p>上面的熔断，是为了在系统过载时不发生雪崩，限流是为了流量较大时，系统不发生过载。但是这两者都不会区分该服务是核心业务还是非核心业务。而降级，则是为了减少或者停掉一些非核心业务，来确保核心业务收到的影响最小。</p><h2 id="为什么需要降级"><a href="#为什么需要降级" class="headerlink" title="为什么需要降级"></a>为什么需要降级</h2><ol><li>降级机制能从全局角度对资源进行调配，通过牺牲非核心服务来保障核心服务的稳定性。降级是主动停掉一些非核心业务，而限流则是被动的将一些请求拒绝。</li><li>降级可以提高系统的用户体验性和可用性。在一些场景中，如果正常调用出现了非业务层错误后，我们可以不返回错误，而是执行接口的B计划，进行降级，虽然可能和正常流程不太一样，但是比直接返回错误要好。</li></ol><h2 id="如何实现降级"><a href="#如何实现降级" class="headerlink" title="如何实现降级"></a>如何实现降级</h2><h3 id="手动降级"><a href="#手动降级" class="headerlink" title="手动降级"></a>手动降级</h3><p>手动降级是指在分布式系统中提前设置好降级开关，然后通过类似配置中心的集中式降级平 台，来管理降级开关的配置信息，在系统需要降级的时候，通过降级平台手动启动降级开关， 对系统进行降级处理。</p><p>该方案需要注意的是，往往服务有成千上百个，如果全部手动操作，则很麻烦。一个解决办法是：通过对降级分级，利用服务的等级信息和业务信息进行批量降级，比如一次直接把p1,p2,p3的服务全部降级。</p><h3 id="自动降级"><a href="#自动降级" class="headerlink" title="自动降级"></a>自动降级</h3><p>自动降级是指在分布式系统中，当系统的某些指标或者接口调用出现错误时，直接启动降级逻辑。一个降级的例子如下：</p><p>我们在网关中调用鉴权服务进行鉴权，每一 个调用鉴权服务的鉴权接口，需要执行如下的两个校验逻辑，不论哪一个失败，都会导致鉴权失败。</p><ol><li>校验 Token 是否合法。</li><li>校验 UID 是否被管理员封禁。</li></ol><p>在这个情况下，我们可以将 Token 设计为可以自校验的，在鉴权服务出现故障的时候，则启动降级逻辑，直接在网关中校验 Token 是否合法，如果合法就返回鉴权成功。</p><h2 id="降级机制的关键问题"><a href="#降级机制的关键问题" class="headerlink" title="降级机制的关键问题"></a>降级机制的关键问题</h2><p>一般来 说，我们使用降级都是在系统已经出现过载的场景下，这时我们需要考虑，降级的配置信息是 否能正常下发。并且，降级通常会与熔断和限流一起出现，我们应该如何处理它们三者之间的关系。</p><h3 id="配置信息下发的问题"><a href="#配置信息下发的问题" class="headerlink" title="配置信息下发的问题"></a>配置信息下发的问题</h3><p>对于熔断和限流来说，其阈值相关的配置信息在系统正常运行的时候，就已经下发到实例上了，所以在系统出现故障的时候，这些配置信息会直接生效。但是对于手动降级，我们需要在系统出问题时，通过降级平台下发配置来启动降级。</p><p>针对于配置无法正常下发的情况，我们可以考虑，由服务直接暴露出修改降级配置的 HTTP 接口，在必要的时候，可以手动通过 HTTP 接口，来启动服务的降级逻辑。</p><h3 id="熔断、限流和降级之间的关系"><a href="#熔断、限流和降级之间的关系" class="headerlink" title="熔断、限流和降级之间的关系"></a>熔断、限流和降级之间的关系</h3><p>首先，因为熔断机制是系统稳定性保障的最后一道防线，并且它是自适应的，所以我们应该在系统全局默认启用；</p><p>其次，限流是用来保障被限流服务稳定性的，一般在系统的核心链路和核心服务上，默认启用限流机制；</p><p>最后，降级是通过牺牲被降级的接口或者服务，来保障其他的接口和服务正常运行的，可以通过降级直接停用非核心服务，然后对于核心接口和服务，在必要的时候，可以提供一个“ B 计划”。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入浅出分布式技术原理》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;降级&quot;&gt;&lt;a href=&quot;#降级&quot; class=&quot;headerlink&quot; title=&quot;降级&quot;&gt;&lt;/a&gt;降级&lt;/h1&gt;&lt;p&gt;上面的熔断，是为了在系统过载时不发生雪崩，限流是为了流量较大时，系统不发生过载。但是这两者都不会区分该服务是核心业务还是非核心业务。而降级，</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="分布式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>限流</title>
    <link href="http://example.com/2023/09/26/%E9%99%90%E6%B5%81/"/>
    <id>http://example.com/2023/09/26/%E9%99%90%E6%B5%81/</id>
    <published>2023-09-26T05:48:45.000Z</published>
    <updated>2023-09-26T05:50:25.563Z</updated>
    
    <content type="html"><![CDATA[<p>如果系统只有熔断机制，当流量激增的时候，就相当于被动的等待熔断机制的触发，此时就需要另外的手段来防止系统负载过高，限流就是一个很好的方案，要主动出击，防止服务挂掉。</p><h1 id="为什么需要限流"><a href="#为什么需要限流" class="headerlink" title="为什么需要限流"></a>为什么需要限流</h1><ol><li>熔断处理的方式不够优雅。熔断是等到系统过载之后才触发的，即先发生过载，等系统故障后才会介入，让系统恢复。这样的处理方式会导致系统的不必要抖动。</li><li>熔断机制是最后的底线。虽然熔断可以解决雪崩问题，但是它应该作为系统稳定性保障的 最后一道防线，正确使用熔断的思路应该是，在其他方法用尽 之后，如果过载问题依旧存在，这时熔断才会被动触发。</li><li>在快速失败的时候，需要能考虑调用方的重要程度。熔断是调用方依据响应结果自适应来触发的，在被调用方出现过载的时候，所有的调用方都将受到影响。但是不同接口的重要程度不一样，需要保证有些接口优先处理。</li><li>在多租户的情况下，不能让一个租户的问题影响到其他的租户，我们需要对每一个租户分配一定的配额，谁超过了就对谁进行限流，保证租户之间的隔离性。</li></ol><h1 id="如何实现限流"><a href="#如何实现限流" class="headerlink" title="如何实现限流"></a>如何实现限流</h1><p>限流一般有固定的限流算法，有以下几种：</p><h2 id="固定窗口和滑动窗口"><a href="#固定窗口和滑动窗口" class="headerlink" title="固定窗口和滑动窗口"></a>固定窗口和滑动窗口</h2><p>固定窗口就是定义一个“固定”的统计周期，比如 10 秒、30 秒或者 1 分钟，然后在每个周 期里，统计当前周期中被接收到的请求数量，经过计数器累加后，如果超过设定的阈值就触发 限流，直到进入下一个周期后，计数器清零，流量接收再恢复正常状态，如下图所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230926104828548.png" alt="image-20230926104828548" style="zoom:80%;" /><p>存在的问题：</p><ol><li><p>抗抖动性差。由于流量突增使请求超过预期，导致流量可能在一个统计周期的前 10 ms 内就达到了 100 次，给服务的处理能力造成一定压力，同时后面的 1990 ms 将会触发限流。 </p><p>这个问题虽然可以通过减小统计周期来改善，但是因为统计周期变小，每个周期的阈值也会变 小，一个小的流量抖动就会导致限流的发生，所以系统的抗抖动能力就变得更差了。</p></li><li><p>如果上一个统计周期的流量集中在最后 10 ms ，而现在这个统计周期的流量集中在前 10 ms ，那么这 20 ms 的时间内会出现 200 次调用，这就超过了我们预期的 2 秒内不能超 过 100 次请求的目的了。这时候，我们就需要使用“滑动窗口”算法来改善这个问题了。</p></li></ol><p>滑动窗口就是固定窗口的优化，它对固定窗口做了进一步切分，将统计周期的粒度切分 得更细，比如 1 分钟的固定窗口，切分为 60 个 1 秒的滑动窗口，然后统计的时间范围随着时 间的推移同步后移，如下图所示。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230926110157298.png" alt="image-20230926110157298" style="zoom:80%;" /><p>但是这里要注意一个问题，如果滑动窗口的统计窗口切分得过细，会增加系统性能和资源损耗 的压力。同时，滑动窗口和固定窗口一样面临抗抖动性差的问题。</p><h2 id="漏桶"><a href="#漏桶" class="headerlink" title="漏桶"></a>漏桶</h2><p>如下图所示，“漏桶”就像一个漏斗，进来的水量就像访问流量一样，而出去的水量 就像是我们的系统处理请求一样。当访问流量过大时，这个漏斗中就会积水，如果水太多了就会溢出。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230926110501239.png" alt="image-20230926110501239"></p><p>该算法相对于滑动窗口和固定窗口做了两个改进点，第一，增加了一个桶来缓存请求，在流量突增的时候，可以先缓存起来，直到超过桶的容量才触发限流；第二，对出口的流量上限做了限制，使上游流量的抖动不会扩散到下游服务。</p><p>漏桶提供流量整形能力有一定的代价，超过漏桶流出速率的请求，需要先在漏桶中排队等待，其中流出速率是漏桶限流的防线，一般会设置得相对保守，可是这样就无法完全利用系 统的性能，就增加了请求的排队时间。</p><h2 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h2><p>令牌桶算法的核心是固定“进口”速率，限流器在一个一定容量的桶内，按照一定的速率放入 Token ，然后在处理程序去处理请求的时候，需要拿到 Token 才能处理；如果拿不到，就进行限流。</p><p>因此，当大量的流量进入时，只要令牌的生成速度大于等于请求被处理的速度，那么此时系统处理能力就是极限的。<img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230926112343201.png" alt="image-20230926112343201" style="zoom:80%;" /></p><p>令牌桶算法相对于漏桶，虽然提高了系统的资源利用率，但是却放弃了一定的流量整形能力，也就是当请求流量突增的时候，上游流量的抖动可能会扩散到下游服务。</p><h1 id="单节点限流"><a href="#单节点限流" class="headerlink" title="单节点限流"></a>单节点限流</h1><p>单节点限流比较简单，可以基于内存来做，需要注意两点：</p><ol><li><p>限流机制作用的位置是客户端还是服务端，即选择客户端限流还是服务端限流。一般来说，熔断机制作用的位置是客户端，限流机制作用的位置更多是服务端，因为熔断更强调自适应，让作用点分散在客户端是没有问题的，而限流机制则更强调控制，它的作用点在服务端的控制能力会更强。</p><p>将作用点放置在服务端，会给服务端带来性能压力。如果将作用点放置在客户端，这就是一个天然的分布式模式，每一个调用方的客户端执行自己的限流逻辑，而将作用点放置在服务端时，服务端要执行所有请求的限流逻辑， 就需要更多的内存来缓存请求，以及更多的 CPU 来执行限流逻辑。</p></li><li><p>如果触发限流后，我们应该直接抛弃请求还是阻塞等待，即否决式限流和阻塞式限流。一般来说，如果我们可以控制流量产生的速率，那么阻塞式限流就是一个更好的选择，因为它既可以实现限流的目的，又不会抛弃请求；</p><p>如果我们不能控制流量产生的速率，那么阻塞式限流将会因为请求积压，出现大量系统资源占用的情况，很容易引发雪崩，这时否决式限流将是 更好的选择。</p></li></ol><h1 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h1><p>为了系统的高可用，一般每个服务都会有多个实例，所以在进行限流时，需要协调该服务的多个实例，进行统一限流。主要方案有以下几点。</p><p>1、进行集中限流。该方案可以借助一个外部存储，比如Redis，然后采用令牌桶算法。但是会带来问题，每次请求都需要先去Redis获取令牌，会导致Redis成为性能瓶颈，并且限流器故障会导致所有请求都被拒绝，而且每次请求都多了一次网络调用，增加时延。</p><p>2、将分布式限流进行本地化处理。限流器在获得一个服务限额的总阈值后， 将这个总阈值按一定的策略分配给服务的实例，每一个实例依据分配的阈值进行单节点限流。这里要考虑如果每个服务器的配置不一样，那么分配的流量就需要不同.</p><p>一个折中的方案：该方案建立在集中式限流的基础上，为了解决每次请求 都需要，通过网络访问限流器获取令牌的问题，客户端只有在令牌数不足时，才会通过限流器 获取令牌，并且一次获取一批令牌。即令牌由集中式限流器生成，但是具体的限流策略是在每个客户端本地处理。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入浅出分布式技术原理》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果系统只有熔断机制，当流量激增的时候，就相当于被动的等待熔断机制的触发，此时就需要另外的手段来防止系统负载过高，限流就是一个很好的方案，要主动出击，防止服务挂掉。&lt;/p&gt;
&lt;h1 id=&quot;为什么需要限流&quot;&gt;&lt;a href=&quot;#为什么需要限流&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="分布式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
</feed>
