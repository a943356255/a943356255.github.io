<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便起个名字吧</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-07-17T13:35:11.931Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Guo Junhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>消息队列中如何设计高性能的网络模块</title>
    <link href="http://example.com/2023/07/17/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97/"/>
    <id>http://example.com/2023/07/17/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97/</id>
    <published>2023-07-17T12:52:46.000Z</published>
    <updated>2023-07-17T13:35:11.931Z</updated>
    
    <content type="html"><![CDATA[<p>消息队列是需要满足高吞吐、高可靠、低延时，并支持多语言访问的基础软件，网络模块最需要解决的是<strong>性能</strong>、<strong>稳定性、开发成本</strong>三个问题。</p><h1 id="网络模块的性能瓶颈分析"><a href="#网络模块的性能瓶颈分析" class="headerlink" title="网络模块的性能瓶颈分析"></a>网络模块的性能瓶颈分析</h1><p>消息队列的访问链路图如下：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717205443205.png" alt="image-20230717205443205" style="zoom: 80%;" /><p>对于<strong>单个请求</strong>来说，请求流程是：客户端构建请求，发送给服务端，服务端收到后交由业务线程处理，业务线程处理完后返回给客户端。</p><p>该流程性能消耗有三个点：</p><ul><li><strong>编解码的速度</strong>。即序列化与反序列化的速度。</li><li><strong>网络延迟</strong>。这点几乎无法优化，与网络传输有关。</li><li><strong>服务端 &#x2F; 客户端网络模块的处理速度</strong>。发送 &#x2F; 接收请求包后，包是否能及时被处理。</li></ul><p>对于<strong>并发请求</strong>来说，在单个请求维度的问题的基础上，还需要处理高并发、高 QPS、高流量等场景带来的性能问题。主要包含三个方面。</p><ul><li><strong>高效的连接管理</strong>：当客户端和服务端之间的 TCP 连接数很多，如何高效处理、管理连接。</li><li><strong>快速处理高并发请求</strong>：当客户端和服务端之间的 QPS 很高，如何快速处理（接收、返回）请求。</li><li><strong>大流量场景</strong>：当客户端和服务端之间的流量很高，如何快速吞吐（读、写）数据。</li></ul><p>大流量场景分为两类，单个请求包大，但是并发小，单个请求包小，但是并发大。</p><p>第一种的瓶颈主要在于数据拷贝、垃圾回收、CPU 占用等方面，主要依赖语言层面的编码技巧来解决。</p><p>我们这里主要看第二种。</p><h1 id="高性能网络模块的设计实现"><a href="#高性能网络模块的设计实现" class="headerlink" title="高性能网络模块的设计实现"></a>高性能网络模块的设计实现</h1><p>从技术上来看，高性能网络模块的设计可以分为如何<strong>高效管理大量的 TCP 连接</strong>、如何<strong>快速处理高并发的请求</strong>、如何<strong>提高稳定性和降低开发成本</strong>等三个方面。</p><h2 id="基于多路复用技术管理-TCP-连接"><a href="#基于多路复用技术管理-TCP-连接" class="headerlink" title="基于多路复用技术管理 TCP 连接"></a>基于多路复用技术管理 TCP 连接</h2><p>从技术原理来看，高效处理大量 TCP 连接，在消息队列中主要有<strong>单条 TCP 连接的复用</strong>和<strong>多路复用</strong>两种技术思路。</p><h3 id="1-单条-TCP-连接的复用"><a href="#1-单条-TCP-连接的复用" class="headerlink" title="1. 单条 TCP 连接的复用"></a>1. 单条 TCP 连接的复用</h3><p>如下图，在一条真实的 TCP 连接中，创建信道（channel，可以理解为虚拟连接）的概念。通过编程手段，我们把信道当做一条 TCP 连接使用，做到 TCP 连接的复用，避免创建大量 TCP 连接导致系统资源消耗过多。</p><p>缺点是在协议设计和编码实现的时候有额外开发工作量，而且近年随着异步 IO、IO 多路复用技术的发展，这种方案有点多余。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717210315458.png" alt="image-20230717210315458" style="zoom:67%;" /><h3 id="2-IO-多路复用技术"><a href="#2-IO-多路复用技术" class="headerlink" title="2. IO 多路复用技术"></a>2. IO 多路复用技术</h3><p>IO 多路复用技术，是指通过把多个 IO 的阻塞复用到同一个 selector 的阻塞上，让系统在单线程的情况下可以同时处理多个客户端请求。最大的优势是系统开销小，系统不需要创建额外的进程或者线程，降低了维护的工作量，也节省了资源。</p><p>目前支持 IO 多路复用的系统调用有 Select、Poll、Epoll 等，Java NIO 库底层就是基于 Epoll 机制实现的。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717210436640.png" alt="image-20230717210436640" style="zoom:80%;" /><p>即使用了这两种技术，<strong>单机能处理的连接数还是有上限的</strong>。</p><p>第一个上限是操作系统的 FD 上限，如果连接数超过了 FD 的数量，连接会创建失败。</p><p>第二个限制是系统资源的限制，主要是 CPU 和内存。频繁创建、删除或者创建过多连接会消耗大量的物理资源，导致系统负载过高。</p><h2 id="基于-Reactor-模型处理高并发请求"><a href="#基于-Reactor-模型处理高并发请求" class="headerlink" title="基于 Reactor 模型处理高并发请求"></a>基于 Reactor 模型处理高并发请求</h2><p><strong>对于单个请求来说</strong>，最快的处理方式就是客户端直接发出请求，服务端接收到包后，直接丢给后面的业务线程处理，当业务线程处理成功后，直接返回给客户端。但存在以下两个问题：</p><ul><li><p>如何第一时间拿到包交给后端的业务逻辑处理？</p></li><li><p>当业务逻辑处理完成后，如何立即拿到返回值返回给客户端？</p></li></ul><p>最直观的思路是阻塞等待模型，不断轮询等待请求拿到包，业务逻辑处理完后返回给客户端。但是阻塞等待模型是穿行机制，下一个请求需要等到上一个请求处理完才能处理，效率低。</p><p>所以，单个请求，最合理的方式就是<strong>异步的事件驱动模型</strong>，可以通过 Epoll 和异步编程来解决。</p><p><strong>在高并发的情况下</strong>会有很多连接、请求需要处理，核心思路就是并行、多线程处理，需要用到Reactor模型。</p><p>Reactor 模型是一种处理并发服务请求的事件设计模式，当主流程收到请求后，通过多路分离处理的方式，把请求分发给相应的请求处理器处理。</p><p>如下图所示，Reactor 模式包含 Reactor、Acceptor、Handler 三个角色。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717211239869.png" alt="image-20230717211239869" style="zoom: 80%;" /><ul><li>Reactor：负责监听和分配事件。收到事件后分派给对应的 Handler 处理，事件包括连接建立就绪、读就绪、写就绪等。</li><li>Acceptor：负责处理客户端新连接。Reactor 接收到客户端的连接事件后，会转发给 Acceptor，Acceptor 接收客户端的连接，然后创建对应的 Handler，并向 Reactor 注册此 Handler。</li><li>Handler：请求处理器，负责业务逻辑的处理，即业务处理线程。</li></ul><p><strong>从技术上看，Reactor 模型一般有三种实现模式。</strong></p><ul><li>单 Reactor 单线程模型（单 Reactor 单线程）</li><li>单 Reactor 多线程模型 （单 Reactor 多线程）</li><li>主从 Reactor 多线程模型 (多 Reactor 多线程)</li></ul><h3 id="1、单-Reactor-单线程模型"><a href="#1、单-Reactor-单线程模型" class="headerlink" title="1、单 Reactor 单线程模型"></a>1、单 Reactor 单线程模型</h3><p>特点是 Reactor 和 Handler 都是单线程的串行处理。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717212026725.png" alt="image-20230717212026725" style="zoom:80%;" /><p>优点是所有处理逻辑放在单线程中实现，没有上下文切换、线程竞争、进程通信等问题。缺点是在性能与可靠性方面存在比较严重的问题。</p><p>性能上，因为是单线程处理，无法充分利用 CPU 资源，并且业务逻辑 Handler 的处理是同步的，容易造成阻塞，出现性能瓶颈。<strong>所以单</strong> <strong>Reactor</strong> <strong>单进程模型不适用于计算密集型的场景，只适用于业务处理非常快速的场景</strong>。</p><h3 id="2、单-Reactor-多线程模型"><a href="#2、单-Reactor-多线程模型" class="headerlink" title="2、单 Reactor 多线程模型"></a>2、单 Reactor 多线程模型</h3><p>业务逻辑处理 Handler 变成了多线程，也就是说，获取到 IO 读写事件之后，业务逻辑是一批线程在处理。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717212143234.png" alt="image-20230717212143234"></p><p>优点是 Handler 收到响应后通过 send 把响应结果返回给客户端，降低 Reactor 的性能开销，提升整个应用的吞吐。而且 Handler 使用多线程模式，可以充分利用 CPU 的性能，提高了业务逻辑的处理速度。</p><p>缺点是 Handler 使用多线程模式，带来了多线程竞争资源的开销，同时涉及共享数据的互斥和保护机制，实现比较复杂。另外，单个 Reactor 承担所有事件的监听、分发和响应，对于高并发场景，容易造成性能瓶颈。</p><h3 id="3、主从-Reactor-多线程模型"><a href="#3、主从-Reactor-多线程模型" class="headerlink" title="3、主从 Reactor 多线程模型"></a>3、主从 Reactor 多线程模型</h3><p>该模型让 Reactor 也变为了多线程。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717212515159.png" alt="image-20230717212515159"  /><p>这种方案，优点是 Reactor 的主线程和子线程分工明确，主线程只负责接收新连接，子线程负责完成后续的业务处理。主线程接收到主线程的连接后，只需要交由后续业务处理即可，不需要关注主线程，可以直接在子线程把处理结果返回给客户端。</p><p>缺点是Acceptor 是一个单线程，如果挂了，如何处理客户端新连接是一个风险点。</p><p>优化后，将Acceptor改为多线程</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717212849187.png" alt="image-20230717212849187"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入拆解消息队列 47 讲》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;消息队列是需要满足高吞吐、高可靠、低延时，并支持多语言访问的基础软件，网络模块最需要解决的是&lt;strong&gt;性能&lt;/strong&gt;、&lt;strong&gt;稳定性、开发成本&lt;/strong&gt;三个问题。&lt;/p&gt;
&lt;h1 id=&quot;网络模块的性能瓶颈分析&quot;&gt;&lt;a href=&quot;#网络模块的</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="消息队列" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>主流消息队列的网络模型</title>
    <link href="http://example.com/2023/07/16/%E4%B8%BB%E6%B5%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2023/07/16/%E4%B8%BB%E6%B5%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</id>
    <published>2023-07-16T13:35:28.000Z</published>
    <updated>2023-07-17T13:43:10.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kafka-网络模型"><a href="#Kafka-网络模型" class="headerlink" title="Kafka 网络模型"></a>Kafka 网络模型</h1><p>Kafka 的网络层没有用 Netty 作为底层的通信库，而是直接采用 Java NIO 实现网络通信。在网络模型中，也是参照 Reactor 多线程模型，采用多线程、多 Selector 的设计。</p><p>Processor 线程和 Handler 线程之间通过 RequestChannel 传递数据，RequestChannel 中包含一个 RequestQueue 队列和多个 ResponseQueues 队列。每个 Processor 线程对应一个 ResponseQueue。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717213627999.png" alt="image-20230717213627999"></p><p>具体流程上：</p><ul><li><p>一个 Acceptor 接收客户端建立连接的请求，创建 Socket 连接并分配给 Processor 处理。</p></li><li><p>Processor 线程把读取到的请求存入 RequestQueue 中，Handler 线程从 RequestQueue 队列中取出请求进行处理。</p></li><li><p>Handler 线程处理请求产生的响应，会存放到 Processor 对应的 ResponseQueue 中，Processor 线程从其对应的 ResponseQueue 中取出响应信息，并返回给客户端。</p></li></ul><h1 id="RocketMQ-网络模型"><a href="#RocketMQ-网络模型" class="headerlink" title="RocketMQ 网络模型"></a>RocketMQ 网络模型</h1><p>RocketMQ 采用 Netty 组件作为底层通信库，遵循 Reactor 多线程模型，同时又在 Reactor 模型上做了一些扩展和优化。</p><p>所以它的网络模型是 Netty 的网络模型，Netty 底层采用的是主从 Reactor 多线程模型，模型的原理逻辑跟前面讲到的主从 Reactor 多线程模型是一样的。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230717213829623.png" alt="image-20230717213829623"></p><p>具体流程上：</p><ul><li><p>一个 Reactor 主线程负责监听 TCP 网络连接请求，建立好连接，创建 SocketChannel，并注册到 Selector 上。RocketMQ 的源码中会自动根据 OS 的类型选择 NIO 和 Epoll，也可以通过参数配置，监听真正的网络数据。</p></li><li><p>接收到网络数据后，会把数据传递给 Reactor 线程池处理。</p></li><li><p>真正执行业务逻辑之前，会进行 SSL 验证、编解码、空闲检查、网络连接管理，这些工作在 Worker 线程池处理（defaultEventExecutorGroup）。</p></li><li><p>处理业务操作，放在业务 Processor 线程池中执行。</p></li></ul><h1 id="NIO-编程和-RPC-框架"><a href="#NIO-编程和-RPC-框架" class="headerlink" title="NIO 编程和 RPC 框架"></a>NIO 编程和 RPC 框架</h1><p>因为 RPC 调用的是一个远端对象，调用者和被调用者处于不同的节点上，想完成调用，必须实现 4 个能力。</p><ul><li><p><strong>网络传输协议</strong>：远端调用底层需要经过网络传输，所以需要选择网络通信协议，比如 TCP。</p></li><li><p><strong>应用通信协议</strong>：网络传输需要设计好应用层的通信协议，比如 HTTP2 或自定义协议。</p></li><li><p><strong>服务发现</strong>：调用的是远端对象，需要可以定位到调用的服务器地址以及调用的具体方法。</p></li><li><p><strong>序列化和反序列化：</strong>网络传输的是二进制数据，因此 RPC 框架需要自带序列化和反序列化的能力。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Kafka-网络模型&quot;&gt;&lt;a href=&quot;#Kafka-网络模型&quot; class=&quot;headerlink&quot; title=&quot;Kafka 网络模型&quot;&gt;&lt;/a&gt;Kafka 网络模型&lt;/h1&gt;&lt;p&gt;Kafka 的网络层没有用 Netty 作为底层的通信库，而是直接采用 Ja</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="消息队列" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>并发场景下的幂等问题--分布式锁详解</title>
    <link href="http://example.com/2023/07/14/%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%B9%82%E7%AD%89%E9%97%AE%E9%A2%98-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/07/14/%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%B9%82%E7%AD%89%E9%97%AE%E9%A2%98-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-07-14T02:38:21.000Z</published>
    <updated>2023-07-14T03:23:01.689Z</updated>
    
    <content type="html"><![CDATA[<p>业务流程：</p><p>1）用户选择实人认证后会在服务端初始化一条记录；<br>2）用户在钉钉移动端按照指示完成人脸比对；<br>3）比对完成后访问服务端修改数据库状态。</p><p>问题现象：数据库一个人有两条认证记录。</p><p>原因：并发导致了不幂等。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/640" alt="图片"></p><p>如果依赖的组件天然幂等，比如说数据库唯一键的约束，那么不需要做太多的处理，否则，可以采用以下方法来保证幂等。</p><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>如何实现一个分布式锁？</p><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>分布式系统中常见有两个问题：</p><p>1）单点故障问题，即当持有锁的应用发生单点故障时，锁将被长期无效占有；</p><p>2）网络超时问题，即当客户端发生网络超时但实际上锁成功时，我们无法再次正确的获取锁。</p><p>要解决问题1，一个简单的方案是引入过期时间（lease time），对锁的持有将是有时效的，当应用发生单点故障时，被其持有的锁可以自动释放。</p><p>要解决问题2，一个简单的方案是支持可重入，我们为每个获取锁的客户端都配置一个不会重复的身份标识（通常是UUID），上锁成功后锁将带有该客户端的身份标识。当实际上锁成功而客户端超时重试时，我们可以判断锁已被该客户端持有而返回成功。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MdbDistributeLock</span> <span class="keyword">implements</span> <span class="title class_">DistributeLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的命名空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> namespace;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁对应的缓存key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lockName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的唯一标识，保证可重入，以应对put成功，但是返回超时的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lockId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否持有锁。true：是</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> locked;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TairManager tairManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MdbDistributeLock</span><span class="params">(TairManager tairManager, <span class="type">int</span> namespace, String lockCacheKey)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.tairManager = tairManager;</span><br><span class="line">        <span class="built_in">this</span>.namespace = namespace;</span><br><span class="line">        <span class="built_in">this</span>.lockName = lockCacheKey;</span><br><span class="line">        <span class="built_in">this</span>.lockId = UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取锁状态</span></span><br><span class="line">            Result&lt;DataEntry&gt; getResult = <span class="literal">null</span>;</span><br><span class="line">            <span class="type">ResultCode</span> <span class="variable">getResultCode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>; cnt &lt; DEFAULT_RETRY_TIMES; cnt++) &#123;</span><br><span class="line">                getResult = tairManager.get(namespace, lockName);</span><br><span class="line">                getResultCode = getResult == <span class="literal">null</span> ? <span class="literal">null</span> : getResult.getRc();</span><br><span class="line">                <span class="keyword">if</span> (noNeedRetry(getResultCode)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重入，已持有锁，返回成功</span></span><br><span class="line">            <span class="keyword">if</span> (ResultCode.SUCCESS.equals(getResultCode)</span><br><span class="line">                &amp;&amp; getResult.getValue() != <span class="literal">null</span> &amp;&amp; lockId.equals(getResult.getValue().getValue())) &#123;</span><br><span class="line">                locked = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不可获取锁，返回失败</span></span><br><span class="line">            <span class="keyword">if</span> (!ResultCode.DATANOTEXSITS.equals(getResultCode)) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;tryLock fail code=&#123;&#125; lock=&#123;&#125; traceId=&#123;&#125;&quot;</span>, getResultCode, <span class="built_in">this</span>, EagleEye.getTraceId());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//尝试获取锁</span></span><br><span class="line">            <span class="type">ResultCode</span> <span class="variable">putResultCode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>; cnt &lt; DEFAULT_RETRY_TIMES; cnt++) &#123;</span><br><span class="line">                putResultCode = tairManager.put(namespace, lockName, lockId, MDB_CACHE_VERSION,</span><br><span class="line">                    DEFAULT_EXPIRE_TIME_SEC);</span><br><span class="line">                <span class="keyword">if</span> (noNeedRetry(putResultCode)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!ResultCode.SUCCESS.equals(putResultCode)) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;tryLock fail code=&#123;&#125; lock=&#123;&#125; traceId=&#123;&#125;&quot;</span>, getResultCode, <span class="built_in">this</span>, EagleEye.getTraceId());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            locked = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;DistributedLock.tryLock fail lock=&#123;&#125;&quot;</span>, <span class="built_in">this</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!locked) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ResultCode</span> <span class="variable">resultCode</span> <span class="operator">=</span> tairManager.invalid(namespace, lockName);</span><br><span class="line">        <span class="keyword">if</span> (!resultCode.isSuccess()) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;DistributedLock.unlock fail lock=&#123;&#125; resultCode=&#123;&#125; traceId=&#123;&#125;&quot;</span>, <span class="built_in">this</span>, resultCode,</span><br><span class="line">                EagleEye.getTraceId());</span><br><span class="line">        &#125;</span><br><span class="line">        locked = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否需要重试</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultCode 缓存的返回码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true：不用重试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">noNeedRetry</span><span class="params">(ResultCode resultCode)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> resultCode != <span class="literal">null</span> &amp;&amp; !ResultCode.CONNERROR.equals(resultCode) &amp;&amp; !ResultCode.TIMEOUT.equals(</span><br><span class="line">            resultCode) &amp;&amp; !ResultCode.UNKNOW.equals(resultCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分布式锁工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MdbDistributeLockFactory</span> <span class="keyword">implements</span> <span class="title class_">DistributeLockFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存的命名空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> namespace;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> MultiClusterTairManager mtairManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> DistributeLock <span class="title function_">getLock</span><span class="params">(String lockName)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MdbDistributeLock</span>(mtairManager, namespace, lockName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分布式锁的一般使用方式如下：</p><ul><li>初始化分布式锁的工厂</li><li>利用工厂生成一个分布式锁实例</li><li>使用该分布式实例上锁和解锁操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTryLock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化工厂</span></span><br><span class="line">    <span class="type">MdbDistributeLockFactory</span> <span class="variable">mdbDistributeLockFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MdbDistributeLockFactory</span>();</span><br><span class="line">    mdbDistributeLockFactory.setNamespace(<span class="number">603</span>);</span><br><span class="line">    mdbDistributeLockFactory.setMtairManager(<span class="keyword">new</span> <span class="title class_">MultiClusterTairManager</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得锁</span></span><br><span class="line">    <span class="type">DistributeLock</span> <span class="variable">lock</span> <span class="operator">=</span> mdbDistributeLockFactory.getLock(<span class="string">&quot;TestLock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上锁解锁操作</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="keyword">if</span> (!locked) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do something </span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样实现简单，但是也存在问题：释放锁的时候只是简单的将缓存中的key失效，所以存在错误释放他人已持有锁问题。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKg8iaeq9DENh4Ow1NmjvfqmapX7ERkKOhIS0Rz8ibzwVWxH4j8tJ7gGkytBrhvEW3Vns3hPfviboWwg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>设想一种情况，当占有锁的Client 1在释放锁之前，锁就已经到期了，Client 2将获取锁，此时锁被Client 2持有，但是Client 1可能会错误的将其释放。只要锁的租期设置的足够长，该问题出现几率就足够小。</p><p>一个更优秀的方案，我们给每个锁都设置一个身份标识，在释放锁的时候，1）首先查询锁是否是自己的，2）如果是自己的则释放锁。</p><p>受限于实现方式，步骤1和步骤2不是原子操作，在步骤1和步骤2之间，如果锁到期被其他客户端获取，此时也会错误的释放他人的锁。</p><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>借助Redis的Lua脚本，可以完美的解决存在错误释放他人已持有锁问题的。</p><p>当我们想要获取锁时，我们可以执行如下方法：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET resource_name my_random_value NX PX <span class="number">30000</span></span><br></pre></td></tr></table></figure><p>当我们想要释放锁时，我们可以执行如下的Lua脚本</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h2><p>在方案一和方案二的讨论过程中，有一个问题被我们反复提及：锁的自动释放。</p><p>他的好处以及坏处如下：</p><p>1）一方面它很好的解决了持有锁的客户端单点故障的问题</p><p>2）另一方面，如果锁提前释放，就会出现锁的错误持有状态</p><p>这个时候，我们可以引入Watch Dog自动续租机制，参考以下Redisson是如何实现的。</p><p>在上锁成功后，Redisson会调用renewExpiration()方法开启一个Watch Dog线程，为锁自动续期。每过1&#x2F;3时间续一次，成功则继续下一次续期，失败取消续期操作。</p><p>以下是Redisson的续期操作，Redisson也是使用Lua脚本进行锁续租的：1）判断锁是否存在；2）如果存在则重置过期时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager().newTimeout(timeout -&gt; &#123;</span><br><span class="line">        <span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">        <span class="keyword">if</span> (ent == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">        <span class="keyword">if</span> (threadId == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">        future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getRawName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                EXPIRATION_RENEWAL_MAP.remove(getEntryName());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                <span class="comment">// reschedule itself</span></span><br><span class="line">                renewExpiration();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cancelExpirationRenewal(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title function_">renewExpirationAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">                          <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;return 0;&quot;</span>,</span><br><span class="line">                          Collections.singletonList(getRawName()),</span><br><span class="line">                          internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h2><p>借助Redisson的自动续期机制，我们无需再担心锁的自动释放。但是讨论到这里，我还是不得不面对一个问题：分布式锁本身不是一个分布式应用。当Redis服务器故障无法正常工作时，整个分布式锁也就无法提供服务。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《阿里博客》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;业务流程：&lt;/p&gt;
&lt;p&gt;1）用户选择实人认证后会在服务端初始化一条记录；&lt;br&gt;2）用户在钉钉移动端按照指示完成人脸比对；&lt;br&gt;3）比对完成后访问服务端修改数据库状态。&lt;/p&gt;
&lt;p&gt;问题现象：数据库一个人有两条认证记录。&lt;/p&gt;
&lt;p&gt;原因：并发导致了不幂等。&lt;/p&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>并发编程实践之公平有界阻塞队列实现（下）</title>
    <link href="http://example.com/2023/07/13/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%85%AC%E5%B9%B3%E6%9C%89%E7%95%8C%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://example.com/2023/07/13/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%85%AC%E5%B9%B3%E6%9C%89%E7%95%8C%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2023-07-13T02:54:58.000Z</published>
    <updated>2023-07-13T03:30:41.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4、状态追踪解除竞争"><a href="#4、状态追踪解除竞争" class="headerlink" title="4、状态追踪解除竞争"></a>4、状态追踪解除竞争</h1><p>此处可以通过状态追踪，解除读与读之间和写与写之间的竞争问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FairnessBoundedBlockingQueue</span> <span class="keyword">implements</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头指针，empty: head.next == tail == null</span></span><br><span class="line">    <span class="keyword">protected</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾指针</span></span><br><span class="line">    <span class="keyword">protected</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canPollCount, head</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">pollLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canPollCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> waitPollCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canOfferCount, tail</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">offerLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canOfferCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> waitOfferCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FairnessBoundedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.canPollCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.canOfferCount = capacity;</span><br><span class="line">        <span class="built_in">this</span>.waitPollCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.waitOfferCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，通过返回值标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            <span class="keyword">while</span>(canOfferCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                waitOfferCount++;</span><br><span class="line">                offerLock.wait();</span><br><span class="line">                waitOfferCount--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(obj);</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            canOfferCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            ++canPollCount;</span><br><span class="line">            <span class="keyword">if</span> (waitPollCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pollLock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，阻塞等待</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            <span class="keyword">while</span>(canPollCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                waitPollCount++;</span><br><span class="line">                pollLock.wait();</span><br><span class="line">                waitPollCount--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = head.next.value;</span><br><span class="line">            head.next.value = <span class="literal">null</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            canPollCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            canOfferCount++;</span><br><span class="line">            <span class="keyword">if</span> (waitOfferCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                offerLock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        Node next;</span><br><span class="line">        Node(Object obj) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = obj;</span><br><span class="line">            next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上</p><ol><li>通过 waitOfferCount 和 waitPollCount 的状态追踪解决 读写内部的竞争问题；</li><li>当队列变更时，根据追踪的状态，决定是否派发消息，触发线程阻塞状态解除；</li></ol><p>但，上述的实现在某些场景下会运行失败，面临活性问题，考虑</p><p>情况一：</p><ol><li>初始状态队列为空 线程 A 执行出队动作，被阻塞在 pollLock , 此时 waitPollCount&#x3D;&#x3D;1；</li><li>此时线程 A 在执行 wait 时被中断，抛出异常， waitPollCount&#x3D;&#x3D;1 并未被重置；</li><li>阻塞队列为空，但 waitPollCount&#x3D;&#x3D;1 类状态异常；</li></ol><p>情况二：</p><ol><li>初始状态队列为空 线程 A B 执行出队动作，被阻塞在 pollLock , 此时 waitPollCount&#x3D;&#x3D;2；</li><li>线程 C 执行入队动作，可以立即执行，执行完成后，触发 pollLock 解除一个线程等待 notify；</li><li><strong>触发的线程在 JVM 实现中是随机的</strong>，假设线程 A 被解除阻塞；</li><li>假设线程 A 在阻塞过程中已被中断，阻塞解除后 JVM 检查 interrupted 状态，抛出 InterruptedException 异常；（线程A在阻塞时被中断，那么它的状态是interrupted，但是还处在被阻塞状态，此时去唤醒该线程，则会报错，而此次唤醒操作则丢失。线程A等中断结束后还会进入阻塞状态。）</li><li>此时队列中有一个元素，但线程 A 仍阻塞在 pollLock 中，且一直阻塞下去；</li></ol><p>以上为解除阻塞消息丢失的例子，问题的根源在与异常处理。</p><h1 id="5、解决异常问题"><a href="#5、解决异常问题" class="headerlink" title="5、解决异常问题"></a>5、解决异常问题</h1><p>解决线程中断退出的问题，线程校验中断状态的场景</p><ol><li>JVM 通常只会在有限的几个场景检测线程的中断状态， wait, Thread.join, Thread.sleep；</li><li>JVM 在检测到线程中断状态 Thread.interrupted() 后，会清除中断标志，抛出 InterruptedException；</li><li>通常为了保证线程对中断及时响应， run 方法中需要自主检测中断标志，中断线程，特别是对中断比较敏感需要保持类的不变式的场景；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FairnessBoundedBlockingQueue</span> <span class="keyword">implements</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头指针，empty: head.next == tail == null</span></span><br><span class="line">    <span class="keyword">protected</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾指针</span></span><br><span class="line">    <span class="keyword">protected</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canPollCount, head, waitPollCount</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">pollLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canPollCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> waitPollCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canOfferCount, tail, waitOfferCount</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">offerLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canOfferCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> waitOfferCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FairnessBoundedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.canPollCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.canOfferCount = capacity;</span><br><span class="line">        <span class="built_in">this</span>.waitPollCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.waitOfferCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，通过返回值标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>(); <span class="comment">// 线程已中断，直接退出即可，防止中断线程竞争锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            <span class="keyword">while</span>(canOfferCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                waitOfferCount++;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    offerLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 触发其他线程</span></span><br><span class="line">                    offerLock.notify();</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    waitOfferCount--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(obj);</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            canOfferCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            ++canPollCount;</span><br><span class="line">            <span class="keyword">if</span> (waitPollCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pollLock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，阻塞等待</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            <span class="keyword">while</span>(canPollCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                waitPollCount++;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    pollLock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    pollLock.notify();</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    waitPollCount--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = head.next.value;</span><br><span class="line">            head.next.value = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// ignore head;</span></span><br><span class="line">            head = head.next;</span><br><span class="line">            canPollCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            canOfferCount++;</span><br><span class="line">            <span class="keyword">if</span> (waitOfferCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                offerLock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 Node 的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上</p><ol><li>当等待线程中断退出时，捕获中断异常，通过 pollLock.notify 和 offerLock.notify 转发消息；</li><li>通过在 finally 中恢复状态追踪变量；</li></ol><p>通过状态变量追踪可以解决读与读之间和写与写之间的锁竞争问题。</p><h1 id="6、解决公平性"><a href="#6、解决公平性" class="headerlink" title="6、解决公平性"></a>6、解决公平性</h1><p>公平性的问题的解决需要将状态变量的追踪转换为：<strong>请求监视器追踪</strong>。</p><ol><li>每个请求对应一个监视器；</li><li>通过内部维护一个 FIFO 队列，实现公平性；</li><li>在队列状态变更时，释放队列中的监视器；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> needToWait;</span><br><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">    needToWait = calculateNeedToWait();</span><br><span class="line">    <span class="keyword">if</span> (needToWait) &#123;</span><br><span class="line">        enqueue(monitor); <span class="comment">// 请求对应的monitor</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needToWait) &#123;</span><br><span class="line">    monitor.doWait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意</p><ol><li>monitor.doWait() 需要在 this 的卫式语句之外，因为如果在内部， monitor.doWait 并不会释放 this锁；</li><li>calculateNeedToWait() 需要在 this 的守卫之内完成，避免同步问题；</li><li>需要考虑中断异常的问题；</li></ol><p>基于以上的逻辑抽象，实现公平队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略接口定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FairnessBoundedBlockingQueue</span> <span class="keyword">implements</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头指针，empty: head.next == tail == null</span></span><br><span class="line">    <span class="keyword">protected</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾指针</span></span><br><span class="line">    <span class="keyword">protected</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canPollCount, head, pollQueue</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">pollLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canPollCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canOfferCount, tail, offerQueue</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">offerLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canOfferCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">WaitQueue</span> <span class="variable">pollQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitQueue</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">WaitQueue</span> <span class="variable">offerQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FairnessBoundedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.canOfferCount = capacity;</span><br><span class="line">        <span class="built_in">this</span>.canPollCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，通过返回值标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>(); <span class="comment">// 线程已中断，直接退出即可，防止中断线程竞争锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">WaitNode</span> <span class="variable">wait</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            <span class="comment">// 在有阻塞请求或者队列为空时，阻塞等待</span></span><br><span class="line">            <span class="keyword">if</span> (canOfferCount &lt;= <span class="number">0</span> || !offerQueue.isEmpty()) &#123;</span><br><span class="line">                wait = <span class="keyword">new</span> <span class="title class_">WaitNode</span>();</span><br><span class="line">                offerQueue.enq(wait);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// continue.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (wait != <span class="literal">null</span>) &#123;</span><br><span class="line">                wait.doWait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            offerQueue.doNotify();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保此时线程状态正常，以下不会校验中断</span></span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(obj);</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            canOfferCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            ++canPollCount;</span><br><span class="line">            pollQueue.doNotify();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，阻塞等待</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">WaitNode</span> <span class="variable">wait</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            <span class="comment">// 在有阻塞请求或者队列为空时，阻塞等待</span></span><br><span class="line">            <span class="keyword">if</span> (canPollCount &lt;= <span class="number">0</span> || !pollQueue.isEmpty()) &#123;</span><br><span class="line">                wait = <span class="keyword">new</span> <span class="title class_">WaitNode</span>();</span><br><span class="line">                pollQueue.enq(wait);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (wait != <span class="literal">null</span>) &#123;</span><br><span class="line">                wait.doWait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 传递消息</span></span><br><span class="line">            pollQueue.doNotify();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下不会检测线程中断状态</span></span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            result = head.next.value;</span><br><span class="line">            head.next.value = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// ignore head;</span></span><br><span class="line">            head = head.next;</span><br><span class="line">            canPollCount--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            canOfferCount++;</span><br><span class="line">            offerQueue.doNotify();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WaitQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">        WaitNode head;</span><br><span class="line">        WaitNode tail;</span><br><span class="line"></span><br><span class="line">        WaitQueue() &#123;</span><br><span class="line">            head = <span class="keyword">new</span> <span class="title class_">WaitNode</span>();</span><br><span class="line">            tail = head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doNotify</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">                <span class="type">WaitNode</span> <span class="variable">node</span> <span class="operator">=</span> deq();</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.doNotify()) &#123;</span><br><span class="line">                    <span class="comment">// 此处确保NOTIFY成功</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// ignore, and retry.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> head.next == <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">enq</span><span class="params">(WaitNode node)</span> &#123;</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> WaitNode <span class="title function_">deq</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">WaitNode</span> <span class="variable">res</span> <span class="operator">=</span> head.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                tail = head; <span class="comment">// 为空，迁移tail节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WaitNode</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> released;</span><br><span class="line">        WaitNode next;</span><br><span class="line">        WaitNode() &#123;</span><br><span class="line">            released = <span class="literal">false</span>;</span><br><span class="line">            next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doWait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!released) &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125;             </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!released) &#123;</span><br><span class="line">                    released = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果是NOTIFY之后收到中断的信号，不能抛出异常；需要做RELAY处理</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">doNotify</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!released) &#123;</span><br><span class="line">                released = <span class="literal">true</span>;</span><br><span class="line">                notify();</span><br><span class="line">                <span class="comment">// 明确释放了一个线程，返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没有释放新的线程，返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 Node 的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上</p><ol><li>核心是替换状态追踪变量为同步节点， WaitNode；</li><li>WaitNode 通过简单的同步队列组织实现 FIFO 协议，每个线程等待各自的 WaitNode 监视器；</li><li>WaitNode 内部维持 released 状态，标识线程阻塞状态是否被释放，主要是为了处理中断的问题；</li><li>WaitQueue 本身是全同步的，由于已解决了读写竞争已经读写内部竞争的问题， WaitQueue 同步并不会造成问题；</li><li>WaitQueue 是无界队列，是一个潜在的问题；但由于其只做同步的追踪，而且追踪的通常是线程，通常并不是问题；</li><li>最终的公平有界队列实现，无论是入队还是出队，首先卫式语句判定是否需要入队等待，如果入队等待，通过公平性协议等待;<br>当信号释放时，借助读写锁同步更新队列；最后同样借助读写锁，触发队列更新消息；</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《阿里技术博客》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;4、状态追踪解除竞争&quot;&gt;&lt;a href=&quot;#4、状态追踪解除竞争&quot; class=&quot;headerlink&quot; title=&quot;4、状态追踪解除竞争&quot;&gt;&lt;/a&gt;4、状态追踪解除竞争&lt;/h1&gt;&lt;p&gt;此处可以通过状态追踪，解除读与读之间和写与写之间的竞争问题。&lt;/p&gt;
&lt;fi</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>并发编程实践之公平有界阻塞队列实现（上）</title>
    <link href="http://example.com/2023/07/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%85%AC%E5%B9%B3%E6%9C%89%E7%95%8C%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2023/07/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E4%B9%8B%E5%85%AC%E5%B9%B3%E6%9C%89%E7%95%8C%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-07-12T03:34:31.000Z</published>
    <updated>2023-07-13T02:54:37.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、基础版本"><a href="#1、基础版本" class="headerlink" title="1、基础版本"></a>1、基础版本</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span>;</span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">poll</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FairnessBoundedBlockingQueue</span> <span class="keyword">implements</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="comment">// 当前大小</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头指针，empty: head.next == tail == null</span></span><br><span class="line">    <span class="keyword">protected</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾指针</span></span><br><span class="line">    <span class="keyword">protected</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FairnessBoundedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = head;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，通过返回值标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; capacity) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(obj);</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，head.next == null；返回空元素</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> head.next.value;</span><br><span class="line">            head.next.value = <span class="literal">null</span>;</span><br><span class="line">            head = head.next; <span class="comment">// 丢弃头结点</span></span><br><span class="line">            --size;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        Node next;</span><br><span class="line">        Node(Object obj) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = obj;</span><br><span class="line">            next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>定义支持队列的两个基础接口， poll 和 offer；</li><li>队列的实现，采用经典实现；</li><li>考虑在队列空的情况下， poll 返回为空，非阻塞；</li><li>队列在满的情况下， offer 返回 false ，入队不成功，无异常；</li></ol><h1 id="2、并发版本"><a href="#2、并发版本" class="headerlink" title="2、并发版本"></a>2、并发版本</h1><p>如果在并发场景下，上述的实现面临一些问题，同时未实现给定的一些需求。通过添加 synchronized ，保证并发条件下的线程安全问题。注意此处做同步的原因是为了保证类的不变式。</p><p>以上，简单粗暴的加 synchronized 可以解决问题，但会引入新的问题：系统活性问题（此问题下文会解决）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoundedBlockingQueue</span> <span class="keyword">implements</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前大小</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头指针，empty: head.next == tail == null</span></span><br><span class="line">    <span class="keyword">protected</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾指针</span></span><br><span class="line">    <span class="keyword">protected</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BoundedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = head;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，通过返回值标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; capacity) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(obj);</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，head.next == null；返回空元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> head.next.value;</span><br><span class="line">            head.next.value = <span class="literal">null</span>;</span><br><span class="line">            head = head.next; <span class="comment">// 丢弃头结点</span></span><br><span class="line">            --size;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Object value;</span><br><span class="line">        BoundedBlockingQueue.Node next;</span><br><span class="line">        Node(Object obj) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = obj;</span><br><span class="line">            next = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，简单加 synchronized 同步是无法实现阻塞等待；即</p><ol><li>如果队列为空，那么出队的动作还是会立即返回，返回为空；</li><li>如果队列已满，那么入队动作还是会立即返回，返回操作不成功；</li></ol><h2 id="卫式方法"><a href="#卫式方法" class="headerlink" title="卫式方法"></a>卫式方法</h2><p>阻塞等待，可以通过简单的卫式方法来实现，此问题本质上可以抽象为：</p><ol><li>任何一个方法都需要在满足一定条件下才可以执行；</li><li>执行方法前需要首先校验不变式，然后执行变更；</li><li>在执行完成后，校验是否满足后验不变式；</li></ol><p>代码逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 当前线程</span></span><br><span class="line"><span class="keyword">synchronized</span> Object <span class="title function_">action</span><span class="params">(Object arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(!condition) &#123;</span><br><span class="line">        wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前置条件，不变式</span></span><br><span class="line">    checkPreCondition();</span><br><span class="line">    doAction();</span><br><span class="line">    <span class="comment">// 后置条件，不变式</span></span><br><span class="line">    checkPostCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他线程</span></span><br><span class="line"><span class="keyword">synchronized</span> Object <span class="title function_">notifyAction</span><span class="params">(Object arg)</span> &#123;</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意：</p><ol><li>通常会采用 notifyAll 发送通知，而非 notify ；因为如果当前线程收到 notify 通知后被中断，那么系统将一直等待下去。</li><li>如果使用了 notifyAll 那么卫式语句必须放在 while 循环中；因为线程唤醒后，执行条件已经不满足，虽然当前线程持有互斥锁。</li><li>卫式条件的所有变量，有任何变更都需要发送 notifyAll 不然面临系统活性问题。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    Object <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FairnessBoundedBlockingQueue</span> <span class="keyword">implements</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="comment">// 当前大小</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头指针，empty: head.next == tail == null</span></span><br><span class="line">    <span class="keyword">protected</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾指针</span></span><br><span class="line">    <span class="keyword">protected</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FairnessBoundedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = head;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，通过返回值标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        size&gt;=capacity &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(obj);</span><br><span class="line">        tail.next = node;</span><br><span class="line">        tail = node;</span><br><span class="line">        ++size;</span><br><span class="line">        notifyAll(); <span class="comment">// 可以出队</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，阻塞等待</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> head.next.value;</span><br><span class="line">        head.next.value = <span class="literal">null</span>;</span><br><span class="line">        head = head.next; <span class="comment">// 丢弃头结点</span></span><br><span class="line">        --size;</span><br><span class="line">        notifyAll(); <span class="comment">// 可以入队</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 Node 的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，实现了阻塞等待，但也引入了更大的性能问题</p><ol><li>入队和出队动作阻塞等待同一把锁，恶性竞争；（这里不管入队还是出队操作的都是同一个队列，入队还是出队都操作了size，所以不能同时进行）</li><li>当队列变更时，所有阻塞线程被唤醒，大量的线程上下文切换，竞争同步锁，最终可能只有一个线程能执行；</li></ol><p>需要注意的点：</p><ol><li>阻塞等待 wait 会抛出中断异常。关于异常的问题下文会处理；</li><li>接口需要支持抛出中断异常；</li><li>队里变更需要 notifyAll 避免线程中断或异常，丢失消息；</li></ol><h1 id="3、锁拆分优化"><a href="#3、锁拆分优化" class="headerlink" title="3、锁拆分优化"></a>3、锁拆分优化</h1><p>以上第一个问题，可以通过锁拆分来解决，即：定义两把锁，读锁和写锁；读写分离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 省略接口定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FairnessBoundedBlockingQueue</span> <span class="keyword">implements</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="comment">// 容量</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头指针，empty: head.next == tail == null</span></span><br><span class="line">    <span class="keyword">protected</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尾指针</span></span><br><span class="line">    <span class="keyword">protected</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canPollCount, head</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">pollLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canPollCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// guard: canOfferCount, tail</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">offerLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> canOfferCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FairnessBoundedBlockingQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.canPollCount = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.canOfferCount = capacity;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.tail = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列已满，通过返回值标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            <span class="keyword">while</span>(canOfferCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                offerLock.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(obj);</span><br><span class="line">            tail.next = node;</span><br><span class="line">            tail = node;</span><br><span class="line">            canOfferCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            ++canPollCount;</span><br><span class="line">            pollLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队列为空，阻塞等待</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(pollLock) &#123;</span><br><span class="line">            <span class="keyword">while</span>(canPollCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                pollLock.wait();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = head.next.value;</span><br><span class="line">            head.next.value = <span class="literal">null</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            canPollCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span>(offerLock) &#123;</span><br><span class="line">            canOfferCount++;</span><br><span class="line">            offerLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 Node 定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上</p><ol><li>定义了两把锁， pollLock 和 offerLock 拆分出队和入队竞争；</li><li>入队锁同步的变量为：callOfferCount 和 tail；</li><li>出队锁同步的变量为：canPollCount 和 head；</li><li>出队的动作：首先拿到 pollLock 卫式等待后，完成出队动作；然后拿到 offerLock 发送通知，解除入队的等待线程。</li><li>入队的动作：首先拿到 offerLock 卫式等待后，完成入队的动作；然后拿到 pollLock 发送通知，解除出队的等待线程。</li></ol><p>以上实现</p><ol><li>确保通过入队锁和出队锁，分别保证入队和出队的原子性；</li><li>出队动作，通过特别的实现，确保出队只会变更 head ，避免获取 offerLock；</li><li>通过 offerLock.notifyAll 和 pollLock.notifyAll 解决读写竞争的问题；</li></ol><p>问题：当有多个入队线程等待时，一次出队的动作会触发所有入队线程竞争，大量的线程上下文切换，最终只有一个线程能执行。<br>即，还有 <strong>读与读</strong> 和 <strong>写与写</strong> 之间的竞争问题。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《阿里技术博客》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、基础版本&quot;&gt;&lt;a href=&quot;#1、基础版本&quot; class=&quot;headerlink&quot; title=&quot;1、基础版本&quot;&gt;&lt;/a&gt;1、基础版本&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件单例服务优化</title>
    <link href="http://example.com/2023/07/09/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8D%95%E4%BE%8B%E6%9C%8D%E5%8A%A1%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2023/07/09/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8D%95%E4%BE%8B%E6%9C%8D%E5%8A%A1%E4%BC%98%E5%8C%96/</id>
    <published>2023-07-09T03:14:06.000Z</published>
    <updated>2023-07-09T06:16:03.232Z</updated>
    
    <content type="html"><![CDATA[<p>几乎所有串行化理论真正解决的问题只有一个：性能。 所以，在性能允许的前提下，对于消费者角色，建议采用单实例部署。通过单实例部署，有序性、串行化、完整性和一致性问题自动获得了解决。另外，单实例部署的消费者拥有全部所需信息，它可以在频次控制上采取很多优化策略。</p><p>单实例部署并非没有代价，它意味着系统可用性的降低，解决可用性问题的最直接的思路就是冗余（Redundancy）。最常用的冗余方案是Master-slave架构，不过大部分的Master-slave架构都是Active&#x2F;active模式，即主从服务器都提供服务。</p><p>大部分基于负载均衡设计的Master-slave集群中，主服务器和从服务器同时提供相同的服务。这显然不满足单例服务优化需求。有序性和串行化需要Active&#x2F;passive架构，即在某一时刻只有主实例提供服务，其他的从服务等待主实例失效。这是典型的领导人选举架构，即只有获得领导权的实例才能充当实际消费者，其他实例都在等待下一次选举。采用领导人选举的Active&#x2F;passive架构可以大大缓解纯粹的单实例部署所带来的可用性问题。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《美团博客》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;几乎所有串行化理论真正解决的问题只有一个：性能。 所以，在性能允许的前提下，对于消费者角色，建议采用单实例部署。通过单实例部署，有序性、串行化、完整性和一致性问题自动获得了解决。另外，单实例部署的消费者拥有全部所需信息，它可以在频次控制上采取很多优化策略。&lt;/p&gt;
&lt;p&gt;单</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="消息队列" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件选型标准</title>
    <link href="http://example.com/2023/07/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%80%89%E5%9E%8B%E6%A0%87%E5%87%86/"/>
    <id>http://example.com/2023/07/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%80%89%E5%9E%8B%E6%A0%87%E5%87%86/</id>
    <published>2023-07-07T02:52:20.000Z</published>
    <updated>2023-07-09T03:21:17.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中间件的功能"><a href="#中间件的功能" class="headerlink" title="中间件的功能"></a>中间件的功能</h1><p>典型的消息中间件主要包含如下几个功能： </p><ul><li><p>消息接收 </p></li><li><p>消息分发 </p></li><li><p>消息存储 </p></li><li><p>消息读取</p></li></ul><h1 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h1><p>抽象的消息中间件模型包含如下几个角色：</p><ol><li>发送者和接收者客户端（Sender&#x2F;Receiver Client）；</li><li>代理服务器（Broker Server），它们是与客户端代码直接交互的服务端代码；</li><li>消息交换机（Exchanger），接收到的消息一般需要通过消息交换机（Exchanger）分发到具体的消息队列中；</li><li>消息队列，一般是一块内存数据结构或持久化数据。</li></ol><p>如下图所示：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230709105627284.png" alt="image-20230709105627284"></p><h1 id="选型标准"><a href="#选型标准" class="headerlink" title="选型标准"></a>选型标准</h1><p>大致有以下几点</p><h2 id="1、性能"><a href="#1、性能" class="headerlink" title="1、性能"></a>1、性能</h2><p>性能主要有两个方面需要考虑：吞吐量（Throughput）和响应时间（Latency）。 不同的消息队列中间件的吞吐量和响应时间相差甚远，对于同一种中间件，不同的配置方式也会影响性能。</p><p>配置主要有以下几种：</p><ul><li>是否需要确认机制，即写入队列后，或从队列读取后，是否需要进行确认。确认机制对响应时间的影响往往很大。</li><li>能否批处理，即消息能否批量读取或者写入。批量操作可以大大减少应用程序与消息中间件的交互次数和消息传递量，大大提高吞吐量。</li><li>能否进行分区（Partition）。将某一主题消息队列进行分区，同一主题消息可以有多台机器并行处理。这不仅仅能影响消息中间件的吞吐量，还决定着消息中间件是否具备良好的可伸缩性（Scalability）。</li><li>是否需要进行持久化。将消息进行持久化往往会同时影响吞吐量和响应时间。</li></ul><h2 id="2、可靠性"><a href="#2、可靠性" class="headerlink" title="2、可靠性"></a>2、可靠性</h2><p>可靠性主要包含：可用性、持久化、确认机制等。高可用性的消息中间件应该具备如下特征：</p><ul><li>消息中间件代理服务器（Broker）具有主从备份。即当一台代理服务宕机之后，备用服务器能接管相关的服务。</li><li>消息中间件中缓存的消息是否有备份、并持久化。高可用、高一致性以及网络分裂不可兼得，大部分中间件在面临网络分裂情况下都很难保证高可用和一致性，而且可用性和一致性之间也不可兼得。</li></ul><p>高可靠的消息中间件应该确保从发送者接收到的消息不会丢失。中间件代理服务器的宕机并不是小概率事件，所以大部分消息中间件都提供持久化，将消息写入磁盘中。但仍有两个问题需要考虑：</p><ul><li>磁盘损坏问题。长时间来看，磁盘出问题的概率仍然存在。</li><li>性能问题。与操作内存相比，磁盘I&#x2F;O的操作性能要慢几个数量级。频繁持久化不仅会增加响应时间，也会降低吞吐量。</li></ul><p>解决方案：多机确认，定期持久化。即消息被缓存在多台机器的内存中，只有每台机器都确认收到消息，才跟发送者确认（很多消息中间件都会提供相应的配置选项，让用户设置最少需要多少台机器接收到消息）。</p><p>确认机制本质上是通讯的握手机制（Handshaking）。如果没有该机制，消息在传输过程中丢失将不会被发现。当然如果没有接收到消息中间件确认完成的指令，应用程序需要决定如何处理。典型的做法有两个： </p><ol><li>多次重试。 </li><li>暂存到本地磁盘或其它持久化媒介。</li></ol><h2 id="3、投递策略（Delivery-policies）"><a href="#3、投递策略（Delivery-policies）" class="headerlink" title="3、投递策略（Delivery policies）"></a>3、投递策略（Delivery policies）</h2><p>投递策略指的是一个消息会被发送几次。主要包含三种策略：</p><ol><li>最多一次（At most Once ）</li><li>最少一次（At least Once）</li><li>仅有一次（Exactly Once）。</li></ol><p>在实际应用中，只考虑消息中间件的投递策略并不能保证业务的投递策略，因为接收者在确认收到消息和处理完消息并持久化之间存在一个时间窗口。</p><p>例如，即使消息中间件保证仅有一次（Exactly Once），如果接收者先确认消息，在持久化之前宕机，则该消息并未被处理。从应用的角度，这就是最多一次（At most Once）。反之，接收者先处理消息并完成持久化，但在确认之前宕机，消息就要被再次发送，这就是最少一次（At least Once）。</p><h1 id="面临的挑战"><a href="#面临的挑战" class="headerlink" title="面临的挑战"></a>面临的挑战</h1><p>消费者是分布式队列编程中真正的数据处理方，数据处理方最常见的挑战包括：有序性、串行化（Serializability）、频次控制、完整性和一致性等。</p><h2 id="1、有序性"><a href="#1、有序性" class="headerlink" title="1、有序性"></a>1、有序性</h2><p>如下图，假定分布式队列保证请求严格有序，请求ri2和ri1都是针对同一数据记录的不同状态，ri2的状态比ri1的状态新。T1、T2、T3和T4代表各个操作发生的时间，并且 T1 &lt; T2 &lt; T3 &lt; T4（”&lt;“代表早于）。</p><p>采用多消费者架构，这两条记录被两个消费者（Consumer1和Consumer2）处理后更新到数据库里面。Consumer1虽然先读取ri1但是却后写入数据库，这就导致，新的状态被老的状态覆盖，所以多消费者不保证数据的有序性。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230709111658723.png" alt="image-20230709111658723"></p><h2 id="2、串行化"><a href="#2、串行化" class="headerlink" title="2、串行化"></a>2、串行化</h2><p>很多场景下，串行化是数据处理的一个基本需求，这是保证数据完整性、可恢复性、事务原子性等的基础。对于分布式队列编程架构，要在在多台消费者实现串行化非常复杂。</p><h2 id="3、频次控制"><a href="#3、频次控制" class="headerlink" title="3、频次控制"></a>3、频次控制</h2><p>有时候，消费者的消费频次需要被控制，可能的原因包括：</p><ul><li>费用问题。如果每次消费所引起的操作都需要收费，而同一个请求消息在队列中保存多份，不进行频次控制，就会导致无谓的浪费。 </li><li>性能问题。每次消费可能会引起对其他服务的调用，被调用服务希望对调用量有所控制，对同一个请求消息的多次访问就需要有所控制。</li></ul><h2 id="4、完整性和一致性"><a href="#4、完整性和一致性" class="headerlink" title="4、完整性和一致性"></a>4、完整性和一致性</h2><p>完整性和一致性是所有多线程和多进程的代码都面临的问题。在多线程或者多进程的系统中考虑完整性和一致性往往会大大地增加代码的复杂度和系统出错的概率。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《美团博客》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;中间件的功能&quot;&gt;&lt;a href=&quot;#中间件的功能&quot; class=&quot;headerlink&quot; title=&quot;中间件的功能&quot;&gt;&lt;/a&gt;中间件的功能&lt;/h1&gt;&lt;p&gt;典型的消息中间件主要包含如下几个功能： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;消息接收 &lt;/p&gt;
&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="消息队列" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>分布式队列编程优化</title>
    <link href="http://example.com/2023/07/06/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E5%88%86%E5%B8%83%E5%BC%8F%E9%98%9F%E5%88%97%E7%BC%96%E7%A8%8B%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2023/07/06/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E5%88%86%E5%B8%83%E5%BC%8F%E9%98%9F%E5%88%97%E7%BC%96%E7%A8%8B%E4%BC%98%E5%8C%96/</id>
    <published>2023-07-06T02:38:48.000Z</published>
    <updated>2023-07-09T03:13:09.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓存优化（接收请求和处理之间）"><a href="#缓存优化（接收请求和处理之间）" class="headerlink" title="缓存优化（接收请求和处理之间）"></a>缓存优化（接收请求和处理之间）</h1><p>处于“处理－转发”模式下运行的生产者往往被设计成请求驱动型的服务，即每个请求都会触发一个处理线程，线程处理完后将结果写入分布式队列。但是如果队列不可用，那么生产者的处理线程就会产生堆积，则会导致以下两个问题：</p><ul><li>系统可用性降低。由于每个线程都需要一定的内存开销，线程过多会使系统内存耗尽，甚至可能产生雪崩效应导致最终完全不可用。</li><li>信息丢失。为了避免系统崩溃，一般会给请求驱动型服务设置一个处理线程池，设置最大处理线程数量。这是一种典型的降级策略，目的是为了防止系统崩溃。但是，后续的请求会因为没有处理线程而被迫阻塞，最终可能产生信息丢失。</li></ul><p>解决思路来自CAP理论，即通过降低<strong>一致性</strong>来保证<strong>可用性</strong>。具体如下：</p><p>生产者接收线程在收到请求之后第一时间不去处理，直接将请求缓存在内存中（牺牲一致性），而在后台启动多个处理线程从缓存中读取请求、进行处理并写入分布式队列。</p><p>与线程所占用的内存开销相比，大部分的请求所占内存几乎可以忽略。通过在接收请求和处理请求之间增加一层内存缓存，可以大大提高系统的处理吞吐量和可扩展性。这个方案本质上是一个内存生产者消费者模型。</p><h1 id="批量写入优化（处理请求和写入队列之间）"><a href="#批量写入优化（处理请求和写入队列之间）" class="headerlink" title="批量写入优化（处理请求和写入队列之间）"></a>批量写入优化（处理请求和写入队列之间）</h1><p>如果生产者请求过大，写入分布式队列则会成为瓶颈，有以下几点原因：</p><ul><li>队列自身性能不高；</li><li>分布式队列编程模型往往被应用在跨机房的系统里面，跨机房的网络开销往往容易成为系统瓶颈；</li><li>消息确认机制往往会大大降低队列的吞吐量以及响应时间。</li></ul><p>如果在<strong>处理请求和写队列之间</strong>添加一层缓存，消息写入程序批量将消息写入队列，可以大大提高系统的吞吐量。原因如下：</p><ul><li>批量写队列可以大大减少生产者和分布式队列的交互次数和消息传输量。特别是对于高吞吐小载荷的消息实体，批量写可以显著降低网络传输量；</li><li>对于需要确认机制的消息，确认机制往往会大大降低队列的吞吐量以及响应时间，某些高敏感的消息需要多个消息中间件代理同时确认，这近一步恶化性能。在生产者的应用层将多条消息批量组合成一个消息体，消息中间件就只需要对批量消息进行一次确认，这可能会数量级的提高消息传输性能。</li></ul><h1 id="持久化优化"><a href="#持久化优化" class="headerlink" title="持久化优化"></a>持久化优化</h1><p>添加缓存可以提高吞吐行，但是也会导致新的问题，内存数据丢失。对于敏感数据，要考虑以下问题：</p><ul><li>如果内存中存在未处理完的请求，而某些原因导致生产者服务宕机，内存数据就会丢失而可能无法恢复；</li><li>如果分布式队列长时间不可用，随着请求数量的不断增加，最终系统内存可能会耗尽而崩溃，内存的消息也可能丢失。</li></ul><p>所以缓存中的数据要定时持久化到磁盘中。主要有两种 ：</p><ul><li>定期触发，即每隔一段时间进行一次持久化；</li><li>定量触发，即每当缓存中的请求数量达到一定阈值后进行持久化。</li></ul><p>是否需要持久化优化，以及持久化策略应该由请求数据的敏感度、请求量、持久化性能等因素共同决定。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《美团博客》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;缓存优化（接收请求和处理之间）&quot;&gt;&lt;a href=&quot;#缓存优化（接收请求和处理之间）&quot; class=&quot;headerlink&quot; title=&quot;缓存优化（接收请求和处理之间）&quot;&gt;&lt;/a&gt;缓存优化（接收请求和处理之间）&lt;/h1&gt;&lt;p&gt;处于“处理－转发”模式下运行的生产者</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="消息队列" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Java的NIO</title>
    <link href="http://example.com/2023/07/04/Java/Java%E7%9A%84NIO/"/>
    <id>http://example.com/2023/07/04/Java/Java%E7%9A%84NIO/</id>
    <published>2023-07-04T03:10:11.000Z</published>
    <updated>2023-07-04T06:50:06.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见I-x2F-O模型对比"><a href="#常见I-x2F-O模型对比" class="headerlink" title="常见I&#x2F;O模型对比"></a>常见I&#x2F;O模型对比</h1><p>所有的系统I&#x2F;O都分为两个阶段：等待就绪和操作。</p><p>比如读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。</p><p>其中，<strong>等待就绪的阻塞</strong>是不使用CPU的，是在“空等”；而真正的读写操作的阻塞是使用CPU的，真正在”干活”，而且这个过程非常快，属于memory copy，可以理解为基本不耗时。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230704111300465.png" alt="image-20230704111300465" style="zoom:67%;" /><h2 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h2><p>以socket.read()为例子：</p><p>传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。</p><p>对于NIO，如果TCP RecvBuffer有数据，就把数据从网卡读到内存，并且返回给用户；反之则直接返回0，永远不会阻塞。</p><p>最新的AIO(Async I&#x2F;O)里面会更进一步：不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。</p><p>BIO里用户最关心“我要读”，NIO里用户最关心”我可以读了”，在AIO模型里用户更需要关注的是“读完了”。</p><p>NIO一个重要的特点是：socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I&#x2F;O操作是同步阻塞的（消耗CPU但性能非常高）。</p><h1 id="结合事件模型使用NIO同步非阻塞特性"><a href="#结合事件模型使用NIO同步非阻塞特性" class="headerlink" title="结合事件模型使用NIO同步非阻塞特性"></a>结合事件模型使用NIO同步非阻塞特性</h1><p>BIO中，之所以需要多线程，是因为在进行I&#x2F;O操作时，无法估计什么时候完成，只能等待，即使通过估算算出来一个大概的时间，也无法通过socket.read()和socket.write()进行返回，所以另外开启一个新的线程是最好的解决办法。</p><p><strong>NIO的读写函数可以立刻返回</strong>，这就给了我们不开线程利用CPU的最好机会：如果一个连接不能读写（socket.read()返回0或者socket.write()返回0），我们可以把这件事记下来，<strong>记录的方式通常是在Selector上注册标记位</strong>，然后切换到其它就绪的连接（channel）继续进行读写。</p><h2 id="如何使用单线程处理所有I-x2F-O"><a href="#如何使用单线程处理所有I-x2F-O" class="headerlink" title="如何使用单线程处理所有I&#x2F;O"></a>如何使用单线程处理所有I&#x2F;O</h2><p>NIO的主要事件有几个：读就绪、写就绪、有新连接到来。</p><p>首先需要注册当这几个事件到来的时候所对应的处理器，然后在合适的时机告诉事件选择器：我对这个事件感兴趣。例如，对于写操作，就是写不出去的时候对写事件感兴趣；对于读操作，就是完成连接和系统没有办法承载新读入的数据的时；对于accept，一般是服务器刚启动的时候；而对于connect，一般是connect失败需要重连或者直接异步调用connect的时候。</p><p>其次，用一个死循环选择就绪的事件，会执行系统调用（Linux 2.6之前是select、poll，2.6之后是epoll，Windows是IOCP），<strong>还会阻塞的等待新事件的到来</strong>。新事件到来的时候，会在selector上注册标记位，标示可读、可写或者有连接到来。</p><p>注意，<strong>select是阻塞的</strong>，无论是通过操作系统的通知（epoll）还是不停的轮询(select，poll)，这个函数是阻塞的。所以你可以放心大胆地在一个while(true)里面调用这个函数而不用担心CPU空转。</p><p>一个最简单的Reactor模式的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ChannelHandler</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelReadable</span><span class="params">(Channel channel)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">channelWritable</span><span class="params">(Channel channel)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span> &#123;</span><br><span class="line">    Socket socket;</span><br><span class="line">    Event event;<span class="comment">//读，写或者连接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IO线程主循环:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IoThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        Channel channel;</span><br><span class="line">        <span class="keyword">while</span> (channel = Selector.select()) &#123;<span class="comment">//选择就绪的事件和对应的连接</span></span><br><span class="line">            <span class="keyword">if</span> (channel.event == accept) &#123;</span><br><span class="line">                registerNewChannelHandler(channel);<span class="comment">//如果是新连接，则注册一个新的读写处理器</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (channel.event == write) &#123;</span><br><span class="line">                getChannelHandler(channel).channelWritable(channel);<span class="comment">//如果可以写，则执行写事件</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (channel.event == read) &#123;</span><br><span class="line">                getChannelHandler(channel).channelReadable(channel);<span class="comment">//如果可以读，则执行读事件</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Channel，ChannelHandler&gt; handlerMap;<span class="comment">//所有channel的对应事件处理器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优化线程模型"><a href="#优化线程模型" class="headerlink" title="优化线程模型"></a>优化线程模型</h1><p>NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I&#x2F;O操作都是纯CPU操作，没有必要开启多线程。</p><p>而且不开多线程，连接数大的时候减少了线程切换。</p><p>真正需要的线程：</p><ol><li>事件分发器，单线程选择就绪的事件。 </li><li>I&#x2F;O处理器，包括connect、read、write等，这种纯CPU操作，一般开启CPU核心个线程就可以。 </li><li>业务线程，在处理完I&#x2F;O后，业务一般还会有自己的业务逻辑，有的还会有其他的阻塞I&#x2F;O，如DB操作，RPC等。只要有阻塞，就需要单独的线程。</li></ol><p>Java的Selector对于Linux系统来说，有一个致命限制：同一个channel的select不能被并发的调用。因此，如果有多个I&#x2F;O线程，必须保证：一个socket只能属于一个IoThread，而一个IoThread可以管理多个socket。</p><p>另外连接的处理和读写的处理通常可以选择分开，这样对于海量连接的注册和读写就可以分发。虽然read()和write()是比较高效无阻塞的函数，但毕竟会占用CPU，如果面对更高的并发则无能为力。</p><p>NIO在服务端对于解放线程，优化I&#x2F;O和处理海量连接方面有一定的优势。</p><p>常见的客户端BIO+连接池模型，可以建立n个连接，然后当某一个连接被I&#x2F;O占用的时候，可以使用其他连接来提高性能。</p><p>但多线程的模型面临和服务端相同的问题：如果指望增加连接数来提高性能，则连接数又受制于线程数、线程很贵、无法建立很多线程，则性能遇到瓶颈。</p><h1 id="连接顺序请求的Redis"><a href="#连接顺序请求的Redis" class="headerlink" title="连接顺序请求的Redis"></a>连接顺序请求的Redis</h1><p>对于Redis来说，由于服务端是全局串行的，能够保证同一连接的所有请求与返回顺序一致。这样可以使用单线程＋队列，把请求数据缓冲。然后pipeline发送，返回future，然后channel可读时，直接在队列中把future取回来，done()就可以了。</p><h1 id="Proactor与Reactor"><a href="#Proactor与Reactor" class="headerlink" title="Proactor与Reactor"></a>Proactor与Reactor</h1><p>一般情况下，I&#x2F;O 复用机制需要事件分发器（event dispatcher）。事件分发器的作用，即将那些读写事件源分发给各读写事件的处理者,开发人员在开始的时候需要在分发器那里注册感兴趣的事件，并提供相应的处理者（event handler)，或者是回调函数；事件分发器在适当的时候，会将请求的事件分发给这些handler或者回调函数。</p><p>涉及到事件分发器的两种模式称为：Reactor和Proactor。 Reactor模式是基于同步I&#x2F;O的，而Proactor模式是和异步I&#x2F;O相关的。</p><p>在Reactor模式中，事件分发器等待某个事件或者可应用或某个操作的状态发生（比如文件描述符可读写，或者是socket可读写），事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。</p><p>而在Proactor模式中，事件处理者（或者代由事件分发器发起）直接发起一个异步读写操作（相当于请求），而实际的工作是由操作系统来完成的。发起时，需要提供的参数包括用于存放读到数据的缓存区、读的数据大小或用于存放外发数据的缓存区，以及这个请求完后的回调函数等信息。事件分发器得知了这个请求，它默默等待这个请求的完成，然后转发完成事件给相应的事件处理者或者回调。</p><p>举例来说，在Windows上事件处理者投递了一个异步IO操作（称为overlapped技术），事件分发器等IO Complete事件完成。这种异步模式的典型实现是基于操作系统底层异步API的，所以我们可称之为“系统级别”的或者“真正意义上”的异步，因为具体的读写是由操作系统代劳的。</p><h2 id="Reactor中实现读"><a href="#Reactor中实现读" class="headerlink" title="Reactor中实现读"></a>Reactor中实现读</h2><ul><li>注册读就绪事件和相应的事件处理器。</li><li>事件分发器等待事件。</li><li>事件到来，激活分发器，分发器调用事件对应的处理器。</li><li>事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li></ul><h2 id="Proactor中实现读"><a href="#Proactor中实现读" class="headerlink" title="Proactor中实现读"></a>Proactor中实现读</h2><ul><li>处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。</li><li>事件分发器等待操作完成事件。</li><li>在分发器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分发器读操作完成。</li><li>事件分发器呼唤处理器。</li><li>事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分发器。</li></ul><p>两个模式的相同点，都是对某个I&#x2F;O事件的事件通知（即告诉某个模块，这个I&#x2F;O操作可以进行或已经完成)。在结构上，两者也有相同点：事件分发器负责提交IO操作（异步)、查询设备是否可操作（同步)，然后当条件满足时，就回调handler；不同点在于，异步情况下（Proactor)，当回调handler时，表示I&#x2F;O操作已经完成；同步情况下（Reactor)，回调handler时，表示I&#x2F;O设备可以进行某个操作（can read 或 can write)。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《美团技术团队》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常见I-x2F-O模型对比&quot;&gt;&lt;a href=&quot;#常见I-x2F-O模型对比&quot; class=&quot;headerlink&quot; title=&quot;常见I&amp;#x2F;O模型对比&quot;&gt;&lt;/a&gt;常见I&amp;#x2F;O模型对比&lt;/h1&gt;&lt;p&gt;所有的系统I&amp;#x2F;O都分为两个阶段：等待就</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    
    <category term="I/O" scheme="http://example.com/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="http://example.com/2023/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-30T02:00:26.000Z</published>
    <updated>2023-06-30T02:10:39.396Z</updated>
    
    <content type="html"><![CDATA[<p>命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不 同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等 （附加控制）功能。</p><p>一些编程语言不支持传递函数，但是我们将函数封装在对象中，然后传递对象，就可以达到同样的效果。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不 同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等 （附加控制）功能。&lt;/p&gt;
&lt;p&gt;一些编程语言不支持传递函数，但是我们将函数封装在对象中，然后传递对象，就可以</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>备忘录模式</title>
    <link href="http://example.com/2023/06/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-28T03:03:51.000Z</published>
    <updated>2023-06-28T03:25:33.301Z</updated>
    
    <content type="html"><![CDATA[<p>备忘录模式，也叫快照（Snapshot）模式，在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外 保存这个状态，以便之后恢复对象为先前的状态。</p><p>这个模式包含两部分：一部分是，存储副本以便后期恢复。另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。</p><p>一个demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputText</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">StringBuilder</span> <span class="variable">text</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getText</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> text.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">append</span><span class="params">(String input)</span> &#123;</span><br><span class="line">        text.append(input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Snapshot <span class="title function_">createSnapshot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Snapshot</span>(text.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreSnapshot</span><span class="params">(Snapshot snapshot)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.text.replace(<span class="number">0</span>, <span class="built_in">this</span>.text.length(), snapshot.getText());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Snapshot</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Snapshot</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getText</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnapshotHolder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Snapshot&gt; snapshots = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> Snapshot <span class="title function_">popSnapshot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> snapshots.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushSnapshot</span><span class="params">(Snapshot snapshot)</span> &#123;</span><br><span class="line">        snapshots.push(snapshot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InputText</span> <span class="variable">inputText</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputText</span>();</span><br><span class="line">        <span class="type">SnapshotHolder</span> <span class="variable">snapshotsHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SnapshotHolder</span>();</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            <span class="keyword">if</span> (input.equals(<span class="string">&quot;:list&quot;</span>)) &#123;</span><br><span class="line">                System.out.println(inputText.toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (input.equals(<span class="string">&quot;:undo&quot;</span>)) &#123;</span><br><span class="line">                <span class="type">Snapshot</span> <span class="variable">snapshot</span> <span class="operator">=</span> snapshotsHolder.popSnapshot();</span><br><span class="line">                inputText.restoreSnapshot(snapshot);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                snapshotsHolder.pushSnapshot(inputText.createSnapshot());</span><br><span class="line">                inputText.append(input);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;备忘录模式，也叫快照（Snapshot）模式，在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外 保存这个状态，以便之后恢复对象为先前的状态。&lt;/p&gt;
&lt;p&gt;这个模式包含两部分：一部分是，存储副本以便后期恢复。另一部分是，要在不违背封装原则的前提下，进行对象的</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>访问者模式</title>
    <link href="http://example.com/2023/06/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/06/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-06-27T02:07:18.000Z</published>
    <updated>2023-06-27T03:32:24.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>访问者模式：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>一般来说，访问者模式针对的是一组类型不同的对象（PdfFile、PPTFile、WordFile）。不 过，尽管这组对象的类型是不同的，但是，它们继承相同的父类（ResourceFile）或者实 现相同的接口。在不同的应用场景下，我们需要对这组对象进行一系列不相关的业务操作 （抽取文本、压缩等），但为了避免不断添加功能导致类（PdfFile、PPTFile、WordFile） 不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致的频繁代码修改，我们使用访问者模式，将<strong>对象</strong>与<strong>操作</strong>解耦，将这些业务操作抽离出来，定义在独立细分的访问者类 （Extractor、Compressor）中。</p><h1 id="为什么支持双分派的语言不需要访问者模式？"><a href="#为什么支持双分派的语言不需要访问者模式？" class="headerlink" title="为什么支持双分派的语言不需要访问者模式？"></a>为什么支持双分派的语言不需要访问者模式？</h1><h2 id="Single-Dispatch，"><a href="#Single-Dispatch，" class="headerlink" title="Single Dispatch，"></a>Single Dispatch，</h2><p>指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的<strong>编译时类型</strong>来决定。</p><h2 id="Double-Dispatch"><a href="#Double-Dispatch" class="headerlink" title="Double Dispatch"></a>Double Dispatch</h2><p>指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的<strong>运行时类型</strong>来决定。</p><h2 id="Single-和-Double"><a href="#Single-和-Double" class="headerlink" title="Single 和 Double"></a>Single 和 Double</h2><p>Single Dispatch 之所以称为“Single”，是因为执行哪个对象的哪个方法，<strong>只跟“对象”的运行时类型有关</strong>。Double Dispatch 之所以称为“Double”，是因为执行哪个对象的哪个方法，跟“对象”和“方法参数”两者的运行时类型有关。</p><h2 id="Java的Single-Dispatch"><a href="#Java的Single-Dispatch" class="headerlink" title="Java的Single Dispatch"></a>Java的Single Dispatch</h2><p>Java 支持多态特性，代码可以在运行时获得对象的实际类型（也就是前面提到的运行时类 型），然后根据实际类型决定调用哪个方法。尽管 Java 支持函数重载，但 Java 设计的函数重载的语法规则是，<strong>并不是在运行时，根据传递进函数的参数的实际类型，来决定调用哪个重载函数</strong>，<strong>而是在编译时，根据传递进函数的参数的声明类型（也就是前面提到的编译时 类型），来决定调用哪个重载函数</strong>。也就是说，具体执行哪个对象的哪个方法，只跟<strong>对象的运行时类型</strong>有关，跟参数的运行时类型无关。所以，Java 语言只支持 Single Dispatch。</p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am ParentClass&#x27;s f().&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChildClass</span> <span class="keyword">extends</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am ChildClass&#x27;s f().&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleDispatchClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">polymorphismFunction</span><span class="params">(ParentClass p)</span> &#123;</span><br><span class="line">        p.f();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">overloadFunction</span><span class="params">(ParentClass p)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am overloadFunction(ParentClass p).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">overloadFunction</span><span class="params">(ChildClass c)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I am overloadFunction(ChildClass c).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoMain</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SingleDispatchClass</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleDispatchClass</span>();</span><br><span class="line">        <span class="type">ParentClass</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChildClass</span>();</span><br><span class="line">        <span class="comment">// 执行哪个对象的方法，由对象的实际类型决定。</span></span><br><span class="line">        <span class="comment">// 这里对象p的实例化是ChildClass，所以调用了child的f方法。</span></span><br><span class="line">        demo.polymorphismFunction(p);</span><br><span class="line">        <span class="comment">// 执行对象的哪个方法，由参数对象的声明类型决定</span></span><br><span class="line">        <span class="comment">// 这里指的是执行SingleDispatchClass的哪一个overloadFunction方法</span></span><br><span class="line">        <span class="comment">// 他取决于参数p声明的类型，即ParentClass</span></span><br><span class="line">        demo.overloadFunction(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230627112245628.png" alt="image-20230627112245628"></p><p>注：Java作为Single Dispatch，执行重载方法的时候，只会根据执行方法时传递的参数<strong>声明时的类型</strong>来执行，并不会关注他到底实例化了哪一个对象。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;访问者模式：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。&lt;/p&gt;
&lt;h1 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; </summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>迭代器模式（下）</title>
    <link href="http://example.com/2023/06/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://example.com/2023/06/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2023-06-26T02:33:49.000Z</published>
    <updated>2023-06-26T04:29:21.316Z</updated>
    
    <content type="html"><![CDATA[<p>如何实现一个支持“快照”功能的迭代器？</p><p>所谓“快照”，指我们为容器创建迭代器的 时候，相当于给容器拍了一张快照（Snapshot）。之后即便我们增删容器中的元素，快照 中的元素并不会做相应的改动。而迭代器遍历的对象是快照而非容器，这样就避免了在使用 迭代器遍历的过程中，增删容器中的元素，导致的不可预期的结果或者报错。</p><h1 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h1><p>在迭代器类中定义一个成员变量 snapshot 来存储快 照。每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这 个迭代器自己持有的快照来进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnapshotArrayIterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cursor;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;E&gt; snapshot;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SnapshotArrayIterator</span><span class="params">(ArrayList&lt;E&gt; arrayList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cursor = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.snapshot = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.snapshot.addAll(arrayList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">currentItem</span> <span class="operator">=</span> snapshot.get(cursor);</span><br><span class="line">        cursor++;</span><br><span class="line">        <span class="keyword">return</span> currentItem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：这个解决方案虽然简单，但代价也有点高。每次创建迭代器的时候，都要拷贝一份数据到快 照中，会增加内存的消耗。如果一个容器同时有多个迭代器在遍历元素，就会导致数据在内 存中重复存储多份。不过，庆幸的是，Java 中的拷贝属于浅拷贝，也就是说，容器中的对 象并非真的拷贝了多份，而只是拷贝了对象的引用而已。</p><h1 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h1><p>我们可以在容器中，为每个元素保存两个时间戳，一个是添加时间戳 addTimestamp，一 个是删除时间戳 delTimestamp。</p><p>当元素被加入到集合中的时候，我们将 addTimestamp 设置为当前时间，将 delTimestamp 设置成最大长整型值。当元素被删除时，我们将 delTimestamp 更新为当前时间，表示已经被删除。</p><p>这里只是标记删除，而非真正将它从容器中删除。</p><p>同时，每个迭代器也保存一个迭代器创建时间戳 snapshotTimestamp，也就是迭代器对应 的快照的创建时间戳。当使用迭代器来遍历容器的时候，只有满足 addTimestamp&lt;snapshotTimestamp&lt;delTimestamp的元素，才是属于这个迭代器的快照。</p><p>可以将元素删除时间以及创建时间与迭代器的创建时间进行比较，来判断该元素是否是当前快照中的元素，这样就在不复制的情况下做到了快照，同时因为删除是标记删除，也不会造成影响，而且添加新的元素也不会被遍历到。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如何实现一个支持“快照”功能的迭代器？&lt;/p&gt;
&lt;p&gt;所谓“快照”，指我们为容器创建迭代器的 时候，相当于给容器拍了一张快照（Snapshot）。之后即便我们增删容器中的元素，快照 中的元素并不会做相应的改动。而迭代器遍历的对象是快照而非容器，这样就避免了在使用 迭代器遍历</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>迭代器模式（上）</title>
    <link href="http://example.com/2023/06/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://example.com/2023/06/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2023-06-26T02:08:31.000Z</published>
    <updated>2023-06-26T02:32:39.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="迭代器模式的原理和实现"><a href="#迭代器模式的原理和实现" class="headerlink" title="迭代器模式的原理和实现"></a>迭代器模式的原理和实现</h1><p>迭代器模式（Iterator Design Pattern），也叫作游标模式（Cursor Design Pattern）。</p><p>迭代器是用来遍历容器的，所以，一个完整的迭代器模式一般会涉及容器和容器迭代器两部 分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代 器又包含迭代器接口、迭代器实现类。</p><p>一个demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口定义方式一</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    E <span class="title function_">currentItem</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cursor;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;E&gt; arrayList;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayIterator</span><span class="params">(ArrayList&lt;E&gt; arrayList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cursor = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.arrayList = arrayList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterator <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayIterator</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != arrayList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        cursor++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">currentItem</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cursor &gt;= arrayList.size()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayList.get(cursor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        names.add(<span class="string">&quot;xzg&quot;</span>);</span><br><span class="line">        names.add(<span class="string">&quot;wang&quot;</span>);</span><br><span class="line">        names.add(<span class="string">&quot;zheng&quot;</span>);</span><br><span class="line">        <span class="comment">// Iterator&lt;String&gt; iterator = new ArrayIterator(names);</span></span><br><span class="line">        Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.currentItem());</span><br><span class="line">            iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230626102617700.png" alt="image-20230626102617700"></p><h1 id="迭代器的优点"><a href="#迭代器的优点" class="headerlink" title="迭代器的优点"></a>迭代器的优点</h1><p>首先是Java中遍历的三种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">names.add(<span class="string">&quot;xzg&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;wang&quot;</span>);</span><br><span class="line">names.add(<span class="string">&quot;zheng&quot;</span>);</span><br><span class="line"><span class="comment">// 第一种遍历方式：for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; names.size(); i++) &#123;</span><br><span class="line">    System.out.print(names.get(i) + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种遍历方式：foreach循环</span></span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">    System.out.print(name + <span class="string">&quot;,&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第三种遍历方式：迭代器遍历</span></span><br><span class="line">Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.print(iterator.next() + <span class="string">&quot;,&quot;</span>);<span class="comment">//Java中的迭代器接口是第二种定义方式，next</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foreach 循环只是一个语法糖而已，底层是基于迭代器来实现的。</p><p>从代码上看，for循环要比 iterator简单，但是这是针对于数组这种数据结构来说的，如果是图或者树，用for循环则不那么容易。可以直接在迭代器中写好遍历，然后只注重与具体业务的开发，而不需要在业务层去书写这些遍历代码。</p><p>将游标指向的当前位置等信息，存储在迭代器类中，每个迭代器独享游标信息。这 样，我们就可以创建多个不同的迭代器，同时对同一个容器进行遍历而互不影响。</p><p>最后，容器和迭代器都提供了抽象的接口，方便我们在开发的时候，基于接口而非具体的实 现编程。当需要切换新的遍历算法的时候，比如，从前往后遍历链表切换成从后往前遍历链 表，客户端代码只需要将迭代器类从 LinkedIterator 切换为 ReversedLinkedIterator 即 可，其他代码都不需要修改。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;迭代器模式的原理和实现&quot;&gt;&lt;a href=&quot;#迭代器模式的原理和实现&quot; class=&quot;headerlink&quot; title=&quot;迭代器模式的原理和实现&quot;&gt;&lt;/a&gt;迭代器模式的原理和实现&lt;/h1&gt;&lt;p&gt;迭代器模式（Iterator Design Pattern），也叫作</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="http://example.com/2023/06/25/Java/HashMap/"/>
    <id>http://example.com/2023/06/25/Java/HashMap/</id>
    <published>2023-06-25T02:57:56.000Z</published>
    <updated>2023-06-25T12:59:26.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h1><p>下面是jdk8中的hash方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的作用：<strong>将 key 的 hashCode 值进行处理，得到最终的哈希值</strong>。</p><p>如下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure><p>其中put的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hash-方法的作用"><a href="#hash-方法的作用" class="headerlink" title="hash 方法的作用"></a>hash 方法的作用</h2><p>HashMap 的底层是通过数组的形式实现的，初始大小是 16，在添加第一个元素的时候，需要通过键的哈希码在大小为 16 的数组中确定一个位置，而确定位置的具体计算方法为 <strong>(n - 1) &amp; hash</strong>，其中变量 n 为数组的长度，变量 hash 就是通过 <code>hash()</code> 方法计算后的结果。</p><p>而 <strong>(n - 1) &amp; hash</strong> 这个操作是为了去摸运算，不用%来是为了优化算法，减少碰撞概率。</p><h1 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h1><p>HashMap 的扩容是通过 resize 方法来实现的，JDK 8 中融入了红黑树（链表长度超过 8 的时候，会将链表转化为红黑树来提高查询效率）。</p><h2 id="jdk7的扩容"><a href="#jdk7的扩容" class="headerlink" title="jdk7的扩容"></a>jdk7的扩容</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newCapacity为新的容量</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 小数组，临时过度下</span></span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="comment">// 扩容前的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="comment">// MAXIMUM_CAPACITY 为最大容量，2 的 30 次方 = 1&lt;&lt;30</span></span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        <span class="comment">// 容量调整为 Integer 的最大值 0x7fffffff（十六进制）=2 的 31 次方-1</span></span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个新的数组（大容量）</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">    <span class="comment">// 把小数组的元素转移到大数组中</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    <span class="comment">// 引用新的大数组</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    <span class="comment">// 重新计算阈值</span></span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法接收一个新的容量 newCapacity，然后将 HashMap 的容量扩大到 newCapacity。</p><p>首先，方法获取当前 HashMap 的旧数组 oldTable 和旧容量 oldCapacity。</p><p>接着，方法创建一个新的数组 newTable，并将旧数组 oldTable 中的元素转移到新数组 newTable 中。转移过程是通过调用 transfer 方法来实现的。该方法遍历旧数组中的每个桶，并将每个桶中的键值对重新计算哈希值后，将其插入到新数组对应的桶中。</p><p>转移完成后，方法将 HashMap 内部的数组引用 table 指向新数组 newTable，并重新计算阈值 threshold。</p><p>transfer 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="comment">// 新的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="comment">// 遍历小数组</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            <span class="comment">// 拉链法，相同 key 上的不同值</span></span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 是否需要重新计算 hash</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据大数组的容量，和键的 hash 计算元素在数组中的下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            <span class="comment">// 同一位置上的新元素被放在链表的头部</span></span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            <span class="comment">// 放在新的数组上</span></span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            <span class="comment">// 链表上的下一个元素</span></span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法接受一个新的 Entry 数组 newTable 和一个布尔值 rehash 作为参数，其中 newTable 表示新的哈希表，rehash 表示是否需要重新计算键的哈希值。</p><p>在方法中，首先获取新哈希表（数组）的长度 newCapacity，然后遍历旧哈希表中的每个 Entry。对于每个 Entry，使用拉链法将相同 key 值的不同 value 值存储在同一个链表中。如果 rehash 为 true，则需要重新计算键的哈希值，并将新的哈希值存储在 Entry 的 hash 属性中。</p><p>接着，根据新哈希表的长度和键的哈希值，计算 Entry 在新数组中的位置 i，然后将该 Entry 添加到新数组的 i 位置上。由于新元素需要被放在链表的头部，因此将新元素的下一个元素设置为当前数组位置上的元素。</p><p>注意，<code>e.next = newTable[i]</code>，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素最终会被放到链表的尾部，这就会导致<strong>在旧数组中同一个链表上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上</strong>。</p><h2 id="Java-8-扩容"><a href="#Java-8-扩容" class="headerlink" title="Java 8 扩容"></a>Java 8 扩容</h2><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table; <span class="comment">// 获取原来的数组 table</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">// 获取数组长度 oldCap</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold; <span class="comment">// 获取阈值 oldThr</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果原来的数组 table 不为空</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的 resize 上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr; <span class="comment">// 将新阈值赋值给成员变量 threshold</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap]; <span class="comment">// 创建新数组 newTab</span></span><br><span class="line">    table = newTab; <span class="comment">// 将新数组 newTab 赋值给成员变量 table</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123; <span class="comment">// 如果旧数组 oldTab 不为空</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123; <span class="comment">// 遍历旧数组的每个元素</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123; <span class="comment">// 如果该元素不为空</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>; <span class="comment">// 将旧数组中该位置的元素置为 null，以便垃圾回收</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>) <span class="comment">// 如果该元素没有冲突</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e; <span class="comment">// 直接将该元素放入新数组</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果该元素是树节点</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap); <span class="comment">// 将该树节点分裂成两个链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 如果该元素是链表</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>; <span class="comment">// 低位链表的头结点和尾结点</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>; <span class="comment">// 高位链表的头结点和尾结点</span></span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123; <span class="comment">// 遍历该链表</span></span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">// 如果该元素在低位链表中</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>) <span class="comment">// 如果低位链表还没有结点</span></span><br><span class="line">                                loHead = e; <span class="comment">// 将该元素作为低位链表的头结点</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e; <span class="comment">// 如果低位链表已经有结点，将该元素加入低位链表的尾部</span></span><br><span class="line">                            loTail = e; <span class="comment">// 更新低位链表的尾结点</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123; <span class="comment">// 如果该元素在高位链表中</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>) <span class="comment">// 如果高位链表还没有结点</span></span><br><span class="line">                                hiHead = e; <span class="comment">// 将该元素作为高位链表的头结点</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e; <span class="comment">// 如果高位链表已经有结点，将该元素加入高位链表的尾部</span></span><br><span class="line">                            hiTail = e; <span class="comment">// 更新高位链表的尾结点</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>); <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123; <span class="comment">// 如果低位链表不为空</span></span><br><span class="line">                        loTail.next = <span class="literal">null</span>; <span class="comment">// 将低位链表的尾结点指向 null，以便垃圾回收</span></span><br><span class="line">                        newTab[j] = loHead; <span class="comment">// 将低位链表作为新数组对应位置的元素</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123; <span class="comment">// 如果高位链表不为空</span></span><br><span class="line">                        hiTail.next = <span class="literal">null</span>; <span class="comment">// 将高位链表的尾结点指向 null，以便垃圾回收</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead; <span class="comment">// 将高位链表作为新数组对应位置的元素</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab; <span class="comment">// 返回新数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、获取原来的数组 table、数组长度 oldCap 和阈值 oldThr。</p><p>2、如果原来的数组 table 不为空，则根据扩容规则计算新数组长度 newCap 和新阈值 newThr，然后将原数组中的元素复制到新数组中。</p><p>3、如果原来的数组 table 为空但阈值 oldThr 不为零，则说明是通过带参数构造函数创建的 HashMap，此时将阈值作为新数组长度 newCap。</p><p>4、如果原来的数组 table 和阈值 oldThr 都为零，则说明是通过无参数构造函数创建的 HashMap，此时将默认初始容量 DEFAULT_INITIAL_CAPACITY（16）和默认负载因子 DEFAULT_LOAD_FACTOR（0.75）计算出新数组长度 newCap 和新阈值 newThr。</p><p>5、计算新阈值 threshold，并将其赋值给成员变量 threshold。</p><p>6、创建新数组 newTab，并将其赋值给成员变量 table。</p><p>7、如果旧数组 oldTab 不为空，则遍历旧数组的每个元素，将其复制到新数组中。</p><p>8、返回新数组 newTab。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hash方法&quot;&gt;&lt;a href=&quot;#hash方法&quot; class=&quot;headerlink&quot; title=&quot;hash方法&quot;&gt;&lt;/a&gt;hash方法&lt;/h1&gt;&lt;p&gt;下面是jdk8中的hash方法：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;t</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="集合" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E9%9B%86%E5%90%88/"/>
    
    
    <category term="集合" scheme="http://example.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>职责链模式（下）</title>
    <link href="http://example.com/2023/06/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://example.com/2023/06/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2023-06-25T02:12:22.000Z</published>
    <updated>2023-06-25T03:10:23.146Z</updated>
    
    <content type="html"><![CDATA[<p>职责链模式常用在框架的开发中，为框架提供扩展点，让框架的使用者在不修改框架源码的情况下，基于扩展点添加新的功能。实际上，更具体点来说，职责链模式最常用来开发框架的过滤器和拦截器。</p><h1 id="Servlet-Filter"><a href="#Servlet-Filter" class="headerlink" title="Servlet Filter"></a>Servlet Filter</h1><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230625102800683.png" alt="image-20230625102800683" style="zoom:67%;" /><p>其中核心设计代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ApplicationFilterChain</span> <span class="keyword">implements</span> <span class="title class_">FilterChain</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 当前执行到了哪个filter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n; </span><br><span class="line">    <span class="comment">// filter的个数</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationFilterConfig[] filters;</span><br><span class="line">    <span class="keyword">private</span> Servlet servlet;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">            <span class="type">ApplicationFilterConfig</span> <span class="variable">filterConfig</span> <span class="operator">=</span> filters[pos++];</span><br><span class="line">            <span class="type">Filter</span> <span class="variable">filter</span> <span class="operator">=</span> filterConfig.getFilter();</span><br><span class="line">            <span class="comment">// 这里是一个递归调用，每次进一层时pos就会++，当到达最后时，就会走else</span></span><br><span class="line">            filter.doFilter(request, response, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// filter都处理完毕后，执行servlet</span></span><br><span class="line">            servlet.service(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(ApplicationFilterConfig filterConfig)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ApplicationFilterConfig filter:filters)</span><br><span class="line">            <span class="keyword">if</span> (filter==filterConfig)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == filters.length) &#123;</span><br><span class="line">            <span class="comment">// 扩容</span></span><br><span class="line">            ApplicationFilterConfig[] newFilters = <span class="keyword">new</span> <span class="title class_">ApplicationFilterConfig</span>[n + IN];</span><br><span class="line">            System.arraycopy(filters, <span class="number">0</span>, newFilters, <span class="number">0</span>, n);</span><br><span class="line">            filters = newFilters;</span><br><span class="line">        &#125;</span><br><span class="line">        filters[n++] = filterConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-Interceptor"><a href="#Spring-Interceptor" class="headerlink" title="Spring Interceptor"></a>Spring Interceptor</h1><p>这个也是一个拦截器，和Servlet Filter不同的是，Servlet Filter 是 Servlet 规范的一部分，实现依赖于 Web 容器。 Spring Interceptor 是 Spring MVC 框架的一部分，由 Spring MVC 框架来提供实现。客 户端发送的请求，会先经过 Servlet Filter，然后再经过 Spring Interceptor，最后到达具 体的业务代码中。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230625105015677.png" alt="image-20230625105015677"></p><p>它的底层实现也是基于职责链模式实现。</p><p>其中，HandlerExecutionChain 类是职责链模式中 的处理器链。它的实现相较于 Tomcat 中的 ApplicationFilterChain 来说，逻辑更加清 晰，不需要使用递归来实现，主要是因为它将请求和响应的拦截工作，拆分到了两个函数中实现。关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerExecutionChain</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line">    <span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptor</span><span class="params">(HandlerInterceptor interceptor)</span> &#123;</span><br><span class="line">        initInterceptorList().add(interceptor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">                <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">                <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="built_in">this</span>.handler)) &#123;</span><br><span class="line">                    triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">        HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> interceptors.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">                interceptor.postHandle(request, response, <span class="built_in">this</span>.handler, mv);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">HandlerInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors[i];</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    interceptor.afterCompletion(request, response, <span class="built_in">this</span>.handler, ex);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line">                    logger.error(<span class="string">&quot;HandlerInterceptor.afterCompletion threw exception&quot;</span>, ex2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;职责链模式常用在框架的开发中，为框架提供扩展点，让框架的使用者在不修改框架源码的情况下，基于扩展点添加新的功能。实际上，更具体点来说，职责链模式最常用来开发框架的过滤器和拦截器。&lt;/p&gt;
&lt;h1 id=&quot;Servlet-Filter&quot;&gt;&lt;a href=&quot;#Servlet-F</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>职责链模式（上）</title>
    <link href="http://example.com/2023/06/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://example.com/2023/06/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2023-06-24T01:39:10.000Z</published>
    <updated>2023-06-24T02:26:27.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="职责链模式的原理和实现"><a href="#职责链模式的原理和实现" class="headerlink" title="职责链模式的原理和实现"></a>职责链模式的原理和实现</h1><p>定义：将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这 些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。</p><p>在职责链模式中，多个处理器依次处理同一个请 求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。</p><p>一个具体的demo如下：</p><p>如果它能处理该请求，就不继续往下传递；如果不能处理，则交由后面的处理器来处理（也 就是调用 successor.handle()）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Handler</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerA</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (!handled &amp;&amp; successor != <span class="literal">null</span>) &#123;</span><br><span class="line">            successor.handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerB</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 这里，是因为他不能处理该请求，就往下传递，并非调用本身</span></span><br><span class="line">        <span class="comment">// 这里是一个链表，如果他自己不能处理，并且不为空，就往下传递</span></span><br><span class="line">        <span class="comment">// 这里省略的代码应该有一步需要往下找另外一个handler</span></span><br><span class="line">        <span class="keyword">if</span> (!handled &amp;&amp; successor != <span class="literal">null</span>) &#123;</span><br><span class="line">            successor.handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerChain</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addHandler</span><span class="params">(Handler handler)</span> &#123;</span><br><span class="line">        handler.setSuccessor(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = handler;</span><br><span class="line">            tail = handler;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tail.setSuccessor(handler);</span><br><span class="line">        tail = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            head.handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HandlerChain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerChain</span>();</span><br><span class="line">        chain.addHandler(<span class="keyword">new</span> <span class="title class_">HandlerA</span>());</span><br><span class="line">        chain.addHandler(<span class="keyword">new</span> <span class="title class_">HandlerB</span>());</span><br><span class="line">        chain.handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述demo存在问题，处理器类的 handle() 函数，不仅包含自己的业务逻 辑，还包含对下一个处理器的调用，也就是代码中的 successor.handle()，如果不熟悉可能会忘记这一步操作，一个优化版本如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Handler</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSuccessor</span><span class="params">(Handler successor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这种写法，把调用链表下一个节点的操作放在了Handler中，而子类只需要重写doHandle</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> doHandle();</span><br><span class="line">        <span class="keyword">if</span> (successor != <span class="literal">null</span> &amp;&amp; !handled) &#123;</span><br><span class="line">            successor.handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">doHandle</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerA</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">doHandle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerB</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">doHandle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// HandlerChain和Application代码不变</span></span><br></pre></td></tr></table></figure><h1 id="职责链模式的应用场景举例"><a href="#职责链模式的应用场景举例" class="headerlink" title="职责链模式的应用场景举例"></a>职责链模式的应用场景举例</h1><p>考虑以下场景：我们要设计一个针对于博客或者评论的敏感词过滤模块，就可以使用该模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SensitiveWordFilter</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">doFilter</span><span class="params">(Content content)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SexyWordFilter</span> <span class="keyword">implements</span> <span class="title class_">SensitiveWordFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doFilter</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">legal</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> legal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// PoliticalWordFilter、AdsWordFilter类代码结构与SexyWordFilter类似</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SensitiveWordFilterChain</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;SensitiveWordFilter&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFilter</span><span class="params">(SensitiveWordFilter filter)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.filters.add(filter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return true if content doesn&#x27;t contain sensitive words.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">filter</span><span class="params">(Content content)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (SensitiveWordFilter filter : filters) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!filter.doFilter(content)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SensitiveWordFilterChain</span> <span class="variable">filterChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SensitiveWordFilterChain</span>();</span><br><span class="line">        filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">AdsWordFilter</span>());</span><br><span class="line">        filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">SexyWordFilter</span>());</span><br><span class="line">        filterChain.addFilter(<span class="keyword">new</span> <span class="title class_">PoliticalWordFilter</span>());</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">legal</span> <span class="operator">=</span> filterChain.filter(<span class="keyword">new</span> <span class="title class_">Content</span>());</span><br><span class="line">        <span class="keyword">if</span> (!legal) &#123;</span><br><span class="line">            <span class="comment">// 不发表</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实不使用职责链，而是直接在一个类中使用if else判断也可以完成该功能，那为什么还要使用呢？</p><p>1、将大块代码逻辑拆分成函数，将大类拆分成小类，是应对代码复杂性的常用方法。应用职责链模式，把各个敏感词过滤函数继续拆分出来，设计成独立的类，进一步简化了 SensitiveWordFilter 类，让 SensitiveWordFilter 类的代码不会过多，过复杂。</p><p>2、如果需要新添加一个过滤方法，我们只需要加一个新的类，实现SensitiveWordFilter接口，并将其添加到SensitiveWordFilterChain中即可，不需要修改太多之前已经存在的代码。如果使用if-else判断的写法，那么就需要添加新的判断。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;职责链模式的原理和实现&quot;&gt;&lt;a href=&quot;#职责链模式的原理和实现&quot; class=&quot;headerlink&quot; title=&quot;职责链模式的原理和实现&quot;&gt;&lt;/a&gt;职责链模式的原理和实现&lt;/h1&gt;&lt;p&gt;定义：将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="http://example.com/2023/06/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://example.com/2023/06/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2023-06-23T10:19:20.000Z</published>
    <updated>2023-06-24T01:46:52.948Z</updated>
    
    <content type="html"><![CDATA[<p>策略模式，最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断，它也可以像模板模式那样，提供框架的扩展点等等。</p><h1 id="策略模式的原理与实现"><a href="#策略模式的原理与实现" class="headerlink" title="策略模式的原理与实现"></a>策略模式的原理与实现</h1><p>定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略 模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。</p><p>工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者，策略模式跟两者类似，也能起到解耦的作用，不过，它解耦的是策略的定义、创建、使用这三部分。</p><h2 id="1-策略的定义"><a href="#1-策略的定义" class="headerlink" title="1. 策略的定义"></a>1. 策略的定义</h2><p>策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//具体的算法...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithmInterface</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//具体的算法...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-策略的创建"><a href="#2-策略的创建" class="headerlink" title="2. 策略的创建"></a>2. 策略的创建</h2><p>因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。为了封装创建逻辑，需要对客户端代码屏蔽创建细节。可以把根据 type 创建策略的逻辑抽离出来，放到工厂类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Strategy&gt; strategies = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        strategies.put(<span class="string">&quot;A&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>());</span><br><span class="line">        strategies.put(<span class="string">&quot;B&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title function_">getStrategy</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span> || type.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;type should not be empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strategies.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果策略类是无状态的，只包含算法实现，可以被共享，就可以使用上面这种方法实现。</p><p>但是如果策略类是有状态的，需要根据业务场景的需要获得不同的对象，那么就需要如下方式创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title function_">getStrategy</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="literal">null</span> || type.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;type should not be empty.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteStrategyA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteStrategyB</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-策略的使用"><a href="#3-策略的使用" class="headerlink" title="3. 策略的使用"></a>3. 策略的使用</h2><p>策略模式包含一组可选策略，客户端代码一般是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景。</p><p>这里的“运行时动态”指的是，我们事先并不知道会使用哪个策略，而是在程序运行期间， 根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 策略接口：EvictionStrategy</span></span><br><span class="line"><span class="comment">// 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...</span></span><br><span class="line"><span class="comment">// 策略工厂：EvictionStrategyFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, User&gt; cacheData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> EvictionStrategy eviction;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserCache</span><span class="params">(EvictionStrategy eviction)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.eviction = eviction;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行时动态确定，根据配置文件的配置决定使用哪种策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">EvictionStrategy</span> <span class="variable">evictionStrategy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        props.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./config.properties&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;eviction_type&quot;</span>);</span><br><span class="line">        evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type);</span><br><span class="line">        <span class="type">UserCache</span> <span class="variable">userCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserCache</span>(evictionStrategy);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非运行时动态确定，在代码中指定使用哪种策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="type">EvictionStrategy</span> <span class="variable">evictionStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LruEvictionStrategy</span>();</span><br><span class="line">        <span class="type">UserCache</span> <span class="variable">userCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserCache</span>(evictionStrategy);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用策略模式来避免分支"><a href="#使用策略模式来避免分支" class="headerlink" title="使用策略模式来避免分支"></a>使用策略模式来避免分支</h2><p>分支代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">discount</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">discount</span> <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="type">OrderType</span> <span class="variable">type</span> <span class="operator">=</span> order.getType();</span><br><span class="line">        <span class="keyword">if</span> (type.equals(OrderType.NORMAL)) &#123; <span class="comment">// 普通订单</span></span><br><span class="line">            <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.GROUPON)) &#123; <span class="comment">// 团购订单</span></span><br><span class="line">            <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.PROMOTION)) &#123; <span class="comment">// 促销订单</span></span><br><span class="line">            <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> discount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用策略模式代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 策略的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DiscountStrategy</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">calDiscount</span><span class="params">(Order order)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrateg</span></span><br><span class="line"><span class="comment">// 策略的创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiscountStrategyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;OrderType, DiscountStrategy&gt; strategies = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        strategies.put(OrderType.NORMAL, <span class="keyword">new</span> <span class="title class_">NormalDiscountStrategy</span>());</span><br><span class="line">        strategies.put(OrderType.GROUPON, <span class="keyword">new</span> <span class="title class_">GrouponDiscountStrategy</span>());</span><br><span class="line">        strategies.put(OrderType.PROMOTION, <span class="keyword">new</span> <span class="title class_">PromotionDiscountStrategy</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DiscountStrategy <span class="title function_">getDiscountStrategy</span><span class="params">(OrderType type)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> strategies.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 策略的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">discount</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="type">OrderType</span> <span class="variable">type</span> <span class="operator">=</span> order.getType();</span><br><span class="line">        <span class="type">DiscountStrategy</span> <span class="variable">discountStrategy</span> <span class="operator">=</span> DiscountStrategyFactory.getDiscountStrategy();</span><br><span class="line">        <span class="keyword">return</span> discountStrategy.calDiscount(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里通过提前在map冲存储相应的类型，直接从map中获取，而不再用那些if判断。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;策略模式，最常见的应用场景是，利用它来避免冗长的 if-else 或 switch 分支判断，它也可以像模板模式那样，提供框架的扩展点等等。&lt;/p&gt;
&lt;h1 id=&quot;策略模式的原理与实现&quot;&gt;&lt;a href=&quot;#策略模式的原理与实现&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>模板方法（下）</title>
    <link href="http://example.com/2023/06/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://example.com/2023/06/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2023-06-22T02:54:49.000Z</published>
    <updated>2023-06-22T04:39:30.001Z</updated>
    
    <content type="html"><![CDATA[<p>回调也可以实现类似于模板模式的作用。</p><h1 id="回调的原理解析"><a href="#回调的原理解析" class="headerlink" title="回调的原理解析"></a>回调的原理解析</h1><p>相对于普通的函数调用来说，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。</p><p>A 类如何将回调函数传递给 B 类呢？不同的编程语言，有不同的实现方法。C 语言可以使 用函数指针，Java 则需要使用包裹了回调函数的类对象，我们简称为回调对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICallback</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodToCallback</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(ICallback callback)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        callback.methodToCallback();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BClass</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BClass</span>();</span><br><span class="line">        b.process(<span class="keyword">new</span> <span class="title class_">ICallback</span>() &#123; <span class="comment">//回调对象</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodToCallback</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Call back me.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从代码实现中，我们可以看出，回调跟模板模 式一样，也具有复用和扩展的功能。除了回调函数之外，BClass 类的 process() 函数中的 逻辑都可以复用。</p><p>如果 ICallback、BClass 类是框架代码，AClass 是使用框架的客户端代码，我们可以通过 ICallback 定制 process() 函数，也就是说，框架因此具有了扩展的能力。</p><p>我们使用了框架的代码逻辑，而且利用回调，在框架的逻辑中插入了我们需要做的修改，因此说具有了扩展能力。</p><p>Spring 提供了很多 Template 类，比如，JdbcTemplate、RedisTemplate、 RestTemplate。尽管都叫作 xxxTemplate，但它们并非基于模板模式来实现的，而是基于回调来实现的，确切地说应该是同步回调。</p><h1 id="模板模式-VS-回调"><a href="#模板模式-VS-回调" class="headerlink" title="模板模式 VS 回调"></a>模板模式 VS 回调</h1><p>从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自 由替换其中的某个步骤，起到代码复用和扩展的目的。而异步回调跟模板模式有较大差别， 更像是观察者模式。</p><p>从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递 给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽 象方法，是一种类之间的关系。</p><p>在代码实现上，回调相对于模板 模式会更加灵活，主要体现在下面几点：</p><ul><li>像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不 再具有继承的能力。</li><li>回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实 现都要定义不同的子类。</li><li>如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到 其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需 要往用到的模板方法中注入回调对象即可。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;回调也可以实现类似于模板模式的作用。&lt;/p&gt;
&lt;h1 id=&quot;回调的原理解析&quot;&gt;&lt;a href=&quot;#回调的原理解析&quot; class=&quot;headerlink&quot; title=&quot;回调的原理解析&quot;&gt;&lt;/a&gt;回调的原理解析&lt;/h1&gt;&lt;p&gt;相对于普通的函数调用来说，回调是一种双向调用关系</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>模板方法（上）</title>
    <link href="http://example.com/2023/06/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://example.com/2023/06/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2023-06-22T02:17:25.000Z</published>
    <updated>2023-06-22T02:51:50.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板模式的原理与实现"><a href="#模板模式的原理与实现" class="headerlink" title="模板模式的原理与实现"></a>模板模式的原理与实现</h1><p>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类 中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些 步骤。</p><p>一个具体的例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        method1();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        method2();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass1</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass2</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">AbstractClass</span> <span class="variable">demo</span> <span class="operator">=</span> ConcreteClass1();</span><br><span class="line">demo.templateMethod();</span><br></pre></td></tr></table></figure><h1 id="模板模式作用一：复用"><a href="#模板模式作用一：复用" class="headerlink" title="模板模式作用一：复用"></a>模板模式作用一：复用</h1><p>模板模式把一个算法中不变的流程抽象到父类的模板方法 templateMethod() 中，将可变的部分 method1()、method2() 留给子类 ContreteClass1 和 ContreteClass2 来实现。 所有的子类都可以复用父类中模板方法定义的流程代码。</p><h1 id="模板模式作用二：扩展"><a href="#模板模式作用二：扩展" class="headerlink" title="模板模式作用二：扩展"></a>模板模式作用二：扩展</h1><p>模板模式的第二大作用的是扩展。这里所说的扩展，并不是指代码的扩展性，而是指框架的 扩展性，有点类似我们之前讲到的控制反转。基于这个作用，模板模式常用在框架的开发中，让框架用户可以在不修改框架源码的情况下，定制化框架的功能。</p><h2 id="1-Java-Servlet"><a href="#1-Java-Servlet" class="headerlink" title="1.Java Servlet"></a>1.Java Servlet</h2><p>在平时开发中，如果我们使用Servlet进行web开发，那么就需要继承 HttpServlet，并且重写其中的 doGet() 或 doPost() 方 法，来分别处理 get 和 post 请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> Expection &#123;</span><br><span class="line">        <span class="built_in">this</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throw</span> Expection &#123;</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;Hello World.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，我们还需要在配置文件 web.xml 中做如下配置。Tomcat、Jetty 等 Servlet 容 器在启动的时候，会自动加载这个配置文件中的 URL 和 Servlet 之间的映射关系。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.xzg.cd.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们在浏览器中输入网址（比如，<a href="http://127.0.0.1:8080/hello">http://127.0.0.1:8080/hello</a> ）的时候，Servlet 容 器会接收到相应的请求，并且根据 URL 和 Servlet 之间的映射关系，找到相应的 Servlet（HelloServlet），然后执行它的 service() 方法。service() 方法定义在父类 HttpServlet 中，它会调用 doGet() 或 doPost() 方法，然后输出数据（“Hello world”）到网页。</p><p>以下是service方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    HttpServletRequest request;</span><br><span class="line">    HttpServletResponse response;</span><br><span class="line">    <span class="keyword">if</span> (!(req <span class="keyword">instanceof</span> HttpServletRequest &amp;&amp;</span><br><span class="line">          res <span class="keyword">instanceof</span> HttpServletResponse)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span>(<span class="string">&quot;non-HTTP request or response&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    request = (HttpServletRequest) req;</span><br><span class="line">    response = (HttpServletResponse) res;</span><br><span class="line">    service(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">    <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// servlet doesn&#x27;t support if-modified-since, no reason</span></span><br><span class="line">            <span class="comment">// to go through further expensive logic</span></span><br><span class="line">            doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ifModifiedSince</span> <span class="operator">=</span> req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">            <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">                maybeSetLastModified(resp, lastModified);</span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> getLastModified(req);</span><br><span class="line">        maybeSetLastModified(resp, lastModified);</span><br><span class="line">        doHead(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">        doPut(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">        doDelete(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">        doOptions(req,resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">        doTrace(req,resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">1</span>];</span><br><span class="line">        errArgs[<span class="number">0</span>] = method;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以看出，HttpServlet 的 service() 方法就是一个模板方法，它实现 了整个 HTTP 请求的执行流程，doGet()、doPost() 是模板中可以由子类来定制的部分。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《设计模式之美》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模板模式的原理与实现&quot;&gt;&lt;a href=&quot;#模板模式的原理与实现&quot; class=&quot;headerlink&quot; title=&quot;模板模式的原理与实现&quot;&gt;&lt;/a&gt;模板模式的原理与实现&lt;/h1&gt;&lt;p&gt;模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类 中实现。模</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="设计模式" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
