<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便起个名字吧</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-19T08:59:23.485Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Guo Junhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分页：快速地址转换</title>
    <link href="http://example.com/2023/04/19/%E5%88%86%E9%A1%B5%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/"/>
    <id>http://example.com/2023/04/19/%E5%88%86%E9%A1%B5%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/</id>
    <published>2023-04-19T08:12:14.000Z</published>
    <updated>2023-04-19T08:59:23.485Z</updated>
    
    <content type="html"><![CDATA[<p>为了解决分页带来的额外内存访问，又引入了地址转换旁路缓冲存储器，又称TLB。它是一个硬件缓存，它记录了频繁发生的虚拟地址到物理地址的转换。</p><p>引入该缓存后，每次需要访问内存时，硬件会先检查TLB中是否有期望的映射，如果有就直接转换。</p><h1 id="TLB的基本算法"><a href="#TLB的基本算法" class="headerlink" title="TLB的基本算法"></a>TLB的基本算法</h1><p>硬件会先从虚拟地址中提取页号，然后检查TLB中是否有该页号（在引入TLB之前，这里需要直接访问一次内存，去读取页表），如果有，则可以根据TLB的值，经过计算得到正确的物理地址。</p><p>如果没有找到，那么硬件需要去内存访问页表，然后将映射更新到TLB当中，前提是该虚拟地址有效，而且我们有权限访问。</p><h1 id="上下文切换时对TLB的处理"><a href="#上下文切换时对TLB的处理" class="headerlink" title="上下文切换时对TLB的处理"></a>上下文切换时对TLB的处理</h1><p>引入TLB之后，我们在发生上下文切换时，要对TLB进行特殊的处理。因为TLB记录的是某一个进程的地址空间到物理地址的转换，如果切换进程，那么当前的TLB对于另一个进程是不可用的。</p><p>一种解决方案：</p><p>在发生上下文切换时，直接清空TLB，那么就不会有进程读到错误的TLB。但是也存在问题，每个进程刚运行时，都会发生TLB未命中。</p><p>第二种解决方案：</p><p>增加一个地址空间标识符，也可以看作是进程标识符，用于标识存储的内容是那个进程的映射。这样一来，TLB可以同时缓存多个进程的地址映射。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了解决分页带来的额外内存访问，又引入了地址转换旁路缓冲存储器，又称TLB。它是一个硬件缓存，它记录了频繁发生的虚拟地址到物理地址的转换。&lt;/p&gt;
&lt;p&gt;引入该缓存后，每次需要访问内存时，硬件会先检查TLB中是否有期望的映射，如果有就直接转换。&lt;/p&gt;
&lt;h1 id=&quot;TL</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL怎么保证主备一致</title>
    <link href="http://example.com/2023/04/19/MySQL%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4/"/>
    <id>http://example.com/2023/04/19/MySQL%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4/</id>
    <published>2023-04-19T06:59:51.000Z</published>
    <updated>2023-04-19T07:20:53.857Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL在进行主备同步时，主库会直接把binlog拿到从库中去执行。这里就涉及到binlog的一些内容。</p><h1 id="binlog的三种格式"><a href="#binlog的三种格式" class="headerlink" title="binlog的三种格式"></a>binlog的三种格式</h1><p>binlog有三种格式，分别是statement，row和mixed。其中第三种是前两种的混合方式。</p><h2 id="这三种日志的区别"><a href="#这三种日志的区别" class="headerlink" title="这三种日志的区别"></a>这三种日志的区别</h2><p>假如说执行如下sql语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from t where a &gt;= 4 and t_modified &lt;= &#x27;2018-11-10&#x27; limit 1;</span><br></pre></td></tr></table></figure><p>如果说binlog的格式为statement，那么binlog中会记录一个事务，事务中会执行这个sql。也就是说，该设置下，相当于把该条sql语句直接拿到从库中去执行。</p><p>如果说格式为row，那么binglog中会记录很多的内容，但是总的来说，它能够根据这些内容，去从库中直接定位到主库删除的那一条记录。就比如说，主库删除主键是1的那一行，如果记录为row格式，那么从库一定可以定位到从库中主键是1的那一行。</p><p>为什么说要定位到从库主键是1的这一行呢？</p><p>因为如果格式为statement，那么直接在从库中执行上述语句，可能会导致一些主备不一致的情况。</p><p>上述语句，如果走索引a，那么会找到第一条a &gt;&#x3D; 4的记录后，就直接删除。而走索引t_modified，则会找到第一条满足t_modified &lt;&#x3D; ‘2018-11-10’的后，就直接删除。这样的话，如果主备的索引不一致，那么就会导致删除不同的行，导致主备不一致。</p><p>而mixed就是结合了两者的优点。因为row格式需要记录 太多的内容，会占用大量的空间。比如我删除10万行数据，row格式就需要10万条记录。而statement格式只需要记录一条sql，但有可能会导致主备不一致，所以采用结合的方式。由系统判断该sql是否会产生主备不一致的可能，如果会就用row记录，否则用statement。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL45讲》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL在进行主备同步时，主库会直接把binlog拿到从库中去执行。这里就涉及到binlog的一些内容。&lt;/p&gt;
&lt;h1 id=&quot;binlog的三种格式&quot;&gt;&lt;a href=&quot;#binlog的三种格式&quot; class=&quot;headerlink&quot; title=&quot;binlog的三种</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    <category term="日志" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="MySQL45讲" scheme="http://example.com/tags/MySQL45%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>MySQL怎么保证数据不丢失</title>
    <link href="http://example.com/2023/04/18/MySQL%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1/"/>
    <id>http://example.com/2023/04/18/MySQL%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1/</id>
    <published>2023-04-18T06:11:22.000Z</published>
    <updated>2023-04-18T07:57:57.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="binlog的写入机制"><a href="#binlog的写入机制" class="headerlink" title="binlog的写入机制"></a>binlog的写入机制</h1><p>总的流程：先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中。</p><p>但是需要注意，一个事务的binlog无论多大，都需要一次性写入，这就涉及到binlog cache的保存。</p><p>每一个线程都会有一个binlog cache，可以设置其大小。如果超过大小限制，就要暂存在磁盘当中。但是所有的线程共享一个binlog file，也就是说，每个线程的binlog cache，都会存入到同一个文件。</p><p>一个具体的例子如下：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230418143649904.png" alt="image-20230418143649904" style="zoom:67%;" /><p>上图中的write操作，其实只是把binlog cache的内容写入文件系统的缓存，并没有直接同步到磁盘，而fsync才是真正的将文件系统缓存的内容写入到磁盘上。</p><p>write 和fsync的时机，是由参数sync_binlog控制的：</p><ol><li>sync_binlog&#x3D;0的时候，表示每次提交事务都只write，不fsync；</li><li>sync_binlog&#x3D;1的时候，表示每次提交事务都会执行fsync；</li><li>sync_binlog&#x3D;N(N&gt;1)的时候，表示每次提交事务都write，但累积N个事务后才fsync。</li></ol><h1 id="redo-log的写入机制"><a href="#redo-log的写入机制" class="headerlink" title="redo log的写入机制"></a>redo log的写入机制</h1><p>redo log 每次写入时，生成的redo log会先写入redo log buffer，而redo log buffer里面的内容并不需要每次写完后都同步到磁盘。</p><p>因为事务还没提交时，数据库异常重启，这部分日志会丢失，但是因为事务没提交，所以不会对数据一致性造成影响。因为事务只有在提交时，事务内所作的修改才真正起作用。</p><p><strong>但是事务还没提交时，redo log buffer里面的内容也会有刷入磁盘的情况。</strong></p><h2 id="redo-log可能存在的三种状态"><a href="#redo-log可能存在的三种状态" class="headerlink" title="redo log可能存在的三种状态"></a>redo log可能存在的三种状态</h2><p>1、存在于redo log buffer中，也就是还在MySQL进程中。</p><p>2、写入了文件系统的缓存当中。</p><p>3、写入了磁盘当中。</p><h2 id="redo-log的写入策略"><a href="#redo-log的写入策略" class="headerlink" title="redo log的写入策略"></a>redo log的写入策略</h2><p>为了控制redo log的写入策略，InnoDB提供了innodb_flush_log_at_trx_commit参数，控制写入策略：</p><ol><li>设置为0的时候，表示每次事务提交时都只是把redo log留在redo log buffer中;</li><li>设置为1的时候，表示每次事务提交时都将redo log直接持久化到磁盘；</li><li>设置为2的时候，表示每次事务提交时都只是把redo log写到page cache。</li></ol><p>InnoDB有一个后台线程，每隔1秒，就会把redo log buffer中的日志，调用write写到文件系统的page cache，然后调用fsync持久化到磁盘。</p><p>这也就解释了为什么会有没提交事务的redo log也被写入了磁盘当中。因为事务执行时，日志就会先写入redo log buffer中，后台线程会在事务没提交时，将数据刷入磁盘当中。</p><p>另外两种会导致事务没提交时，redo log 被写入磁盘：</p><p><strong>一种是，redo log buffer占用的空间即将达到 innodb_log_buffer_size一半的时候，后台线程会主动写盘。</strong>但这里只是写入文件系统的缓存中，不是写入磁盘。</p><p><strong>另一种是，并行的事务提交的时候，顺带将这个事务的redo log buffer持久化到磁盘。</strong>比如说事务A执行了一半，它已经写入了一部分日志到redo log buffer中。如果此时另一个事务提交了，而且innodb_flush_log_at_trx_commit参数设置的是1，那么它就会直接将redo log buffer中的内容直接写入磁盘，这样事务A的一部分日志就被写入了磁盘当中。</p><h1 id="双一配置"><a href="#双一配置" class="headerlink" title="双一配置"></a>双一配置</h1><p>两阶段提交的流程是：时序上redo log先prepare， 再写binlog，最后再把redo log commit。</p><p>将innodb_flush_log_at_trx_commit设置为1时，redo log在处于prepare阶段时，就会刷新到磁盘当中。</p><p>通常我们说MySQL的“双1”配置，指的就是sync_binlog和innodb_flush_log_at_trx_commit都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是redo log（prepare 阶段），一次是binlog。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL45讲》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;binlog的写入机制&quot;&gt;&lt;a href=&quot;#binlog的写入机制&quot; class=&quot;headerlink&quot; title=&quot;binlog的写入机制&quot;&gt;&lt;/a&gt;binlog的写入机制&lt;/h1&gt;&lt;p&gt;总的流程：先把日志写到binlog cache，事务提交的时候，再把</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    <category term="日志" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="MySQL45讲" scheme="http://example.com/tags/MySQL45%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>分页</title>
    <link href="http://example.com/2023/04/18/%E5%88%86%E9%A1%B5/"/>
    <id>http://example.com/2023/04/18/%E5%88%86%E9%A1%B5/</id>
    <published>2023-04-18T06:03:04.000Z</published>
    <updated>2023-04-18T12:06:42.928Z</updated>
    
    <content type="html"><![CDATA[<p>因为分段采用的是将空间划分为大小不同的部分，这样的话会导致整个空间比较零碎，会给内存维护带来一定的困难。</p><p>为了解决这个问题，我们可以把内存空间分割成大小一样的片段，这种思想称为分页。</p><p>分页不是将一个进程的地址空间分割成几个不同长度的逻辑段（即代码、堆、段），而是分割成固定大小的单元，每个单元称为一页。</p><p>我们把物理内存看成是定长的一个分割过的槽，叫作页帧（page frame）。每个这样的页帧包含一个虚拟内存页。如下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230418170854468.png" alt="image-20230418170854468" style="zoom:67%;" /><p>当分页出现以后，一个进程地址空间被引入内存就变为下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230418171040236.png" alt="image-20230418171040236" style="zoom:67%;" /><p>为了记录地址空间的每个虚拟页放在物理内存中的位置，操作系统通常为每个进程保存一个数据结构，称为页表（page table）。</p><p>页表的主要作用是为地址空间的每个虚拟页面保存地址转换（address translation），从而让我们知道每个页在物理内存中的位置。</p><h1 id="页表中有什么"><a href="#页表中有什么" class="headerlink" title="页表中有什么"></a>页表中有什么</h1><p>页表中有一个有效位的标识符。该标识符用于标记对应的地址空间是否使用，如果尝试访问标记为未使用的地址空间，那么程序可能会被终止。</p><p>通过有效位，我们可以只对标识为已经使用了的地址空间进行分配物理内存，这样就节省了大量内存。</p><p>还有一个存在位，用于标识该页是在内存中还是被换出到了磁盘。</p><p>参考位用于标记该页是否被访问。</p><h1 id="分页带来的问题"><a href="#分页带来的问题" class="headerlink" title="分页带来的问题"></a>分页带来的问题</h1><p>引入分页后，我们每次想要找到具体的物理地址时，系统需要先从进程的页表中取到对应的页表项，然后才能进行具体的地址空间到物理地址的转换。</p><p>在分段的设计下，我们可以直接从进程的基址寄存器中找到对应的物理位置。</p><p>而引入分页后，我们需要先从内存中取出页表，然后在页表中去找对应的地址空间到物理地址的转换。相当于多了一次取页表的操作。</p><p>而且页表需要占用物理内存。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为分段采用的是将空间划分为大小不同的部分，这样的话会导致整个空间比较零碎，会给内存维护带来一定的困难。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我们可以把内存空间分割成大小一样的片段，这种思想称为分页。&lt;/p&gt;
&lt;p&gt;分页不是将一个进程的地址空间分割成几个不同长度的逻辑段（即代码</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>对于socket的一些理解</title>
    <link href="http://example.com/2023/04/18/%E5%AF%B9%E4%BA%8Esocket%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2023/04/18/%E5%AF%B9%E4%BA%8Esocket%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</id>
    <published>2023-04-18T03:13:41.000Z</published>
    <updated>2023-04-18T05:34:59.279Z</updated>
    
    <content type="html"><![CDATA[<p> 在大学刚接触到网络编程以及web编程的时候，听说过socket以及端口号，但是当时只是知道写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> xx;</span><br><span class="line">ServerSocket serverSocket <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);;</span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(ip, port);</span><br></pre></td></tr></table></figure><p>但是并不明白为什么要这样做，在学习了计算机网络后，有了一些个人理解。</p><p>在计算机网络中，我们编写的代码，是属于应用层的内容，当需要传输数据时，需要先将数据传送给运输层，然后运输层送往网络层，依次往下传送。</p><p>其实我们可以将应用层与其他的几层拆分开，然后把运输层及其以下的几层当作是一个其他人已经封装好了的计算机网络。我们传输数据，只需要把数据交给这个计算机网络，它就能帮我们把数据传输到我们的目的地。而socket，就是我们的编写的程序与计算机网络之间的接口，也可以理解为一个桥梁，连接我们应用程序与计算机网络。</p><p>而我们在web编程，比如使用springboot框架，也需要在配置文件中指定端口号，它其实也是用于底层封装的socket指定对应端口号。</p><p>一个较为形象的比喻，我们的应用程序可以理解为手机，也就是应用层。而运输层及其以下的那几层可以理解为我们的房子内的电线。我们想要充电，就需要一个充电器，连接我们的手机以及那些电线。而这个充电器，可以理解为socket。</p><p>也就是说，每个socket都需要绑定端口号，用于标识它对应于哪个进程，我们的进程需要指定这个端口号，然后将数据通过socket传送到运输层，并进行第一次数据封装，用于目的主机找到对应的进程。到这里，就可以认为我们进程要传送的数据已经交给计算机网络，剩余的内容就由计算机网络处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 在大学刚接触到网络编程以及web编程的时候，听说过socket以及端口号，但是当时只是知道写法如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络编程" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>计网中的多路分解与多路复用</title>
    <link href="http://example.com/2023/04/17/%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>http://example.com/2023/04/17/%E5%A4%9A%E8%B7%AF%E5%88%86%E8%A7%A3%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2023-04-17T13:46:42.000Z</published>
    <updated>2023-04-18T04:25:05.598Z</updated>
    
    <content type="html"><![CDATA[<p><strong>多路复用</strong>与<strong>多路分解</strong>是将网络层提供的主机到主机交付服务延伸到为运行在主机上的<strong>应用程序</strong>提供进程到进程的交付服务。</p><p>在目的主机，运输层负责从网络层接受报文段，然后将报文段中的数据交付给对应的进程。而每个进程都会有一个或者多个套接字，这些套接字可以理解为网络层和运输层传输数据的门户（一个更形象的比喻，可以把套接字理解为插座的插口。传输数据需要先连接套接字，而充电也要先找到插口）。其实数据并不是直接由网络层传输给数据层，而是网络层传送给套接字，而套接字又传送给运输层。如下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417220052440.png" alt="image-20230417220052440" style="zoom:67%;" /><h1 id="多路分解"><a href="#多路分解" class="headerlink" title="多路分解"></a>多路分解</h1><p>将运输层报文段中的数据交付到正确的套接字的工作称为多路分解。</p><p>因为接受端不会只有一个套接字，所以需要找到正确的套接字。而每个套接字都会有唯一的标识符。</p><p>运输层为了找到正确的套接字，运输层的每个报文段都会有几个特殊字段，这几个字段，用于找到正确的套接字。</p><h1 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h1><p>在源主机中，从不同套接字收集数据块，然后将数据块封装生成报文段，并将报文段传送到网络层，这些工作统称为多路复用。</p><p>而在目的主机中，运输层从网络层接受到的报文段分解后交给对应的进程，这个过程是通过将报文段定向到对应套接字来完成的。</p><h1 id="多路复用要求"><a href="#多路复用要求" class="headerlink" title="多路复用要求"></a>多路复用要求</h1><p>1、套接字有唯一标识符</p><p>2、每个报文段有特殊字段来指示该报文段所要交付到的套接字。</p><p>报文段中会包含源端口号和目的端口号，如下图所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230418095136342.png" alt="image-20230418095136342" style="zoom:67%;" /><p>运输层分解：</p><p>主机上的每一个套接字都会有对应的端口号，当报文段到达主机后，运输层会查看报文段中的端口号，并将其定向到相应的套接字。然后报文段中的数据就通过套接字进入套接字对应的进程。</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>只有运输层与进程之间有套接字，也就是说进程发送给运输层数据，需要指定端口号和对应套接字，然后运输层会将报文封装，添加源主机端口号和目的主机端口号，用于目的主机对数据进行分解，找到对应进程。</p><p>而运输层与网络层之间，没有套接字的概念。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《计算机网络：自顶向下方法》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;多路复用&lt;/strong&gt;与&lt;strong&gt;多路分解&lt;/strong&gt;是将网络层提供的主机到主机交付服务延伸到为运行在主机上的&lt;strong&gt;应用程序&lt;/strong&gt;提供进程到进程的交付服务。&lt;/p&gt;
&lt;p&gt;在目的主机，运输层负责从网络层接受报文段，然后将</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="运输层" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
    
    <category term="运输层" scheme="http://example.com/tags/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>空闲空间管理</title>
    <link href="http://example.com/2023/04/17/%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2023/04/17/%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/</id>
    <published>2023-04-17T07:48:51.000Z</published>
    <updated>2023-04-17T08:54:15.770Z</updated>
    
    <content type="html"><![CDATA[<p>这一部分，书中做了一些假设：</p><p>1、如果请求内存，就需要指定请求内存的大小，而释放该内存则不用指定大小。</p><p>2、只考虑外部碎片，不考虑因分配空间稍微大于请求内存而造成的内部碎片。</p><p>3、内存一旦被分配给用户，那么它就不可能被重定位。即这块内存分配给用户后，除非用户调用free函数，否则无法被其他人使用。</p><p>4、分配程序管理的内存区域是连续的，而且还可以增大这块区域。</p><h1 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h1><h2 id="1、分割与合并"><a href="#1、分割与合并" class="headerlink" title="1、分割与合并"></a>1、分割与合并</h2><p>假如内存中空闲状态如下图：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417162102174.png" alt="image-20230417162102174"></p><p>那么它对应的空闲链表如图：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417162144075.png" alt="image-20230417162144075"></p><p>这也就意味着，任何长度大于10字节的分配请求都会失败。</p><p>如果请求分配的内存小于10字节，那么它会找到一块满足的空间区域，然后进行分割，第一块分给用户，剩下的加入空闲列表。</p><p>而用户在调用free时，它并不是把用户使用的那块区域直接加入，而是会看用户释放的空间左右两端是否是空闲的，如果是，则进行合并。</p><p>比如参考第一张图，如果用户释放中间用掉的10字节，它会变为如下：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417163036922.png" alt="image-20230417163036922"></p><p>而不是</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417163055234.png" alt="image-20230417163055234"></p><h2 id="2、追踪已分配空间的大小"><a href="#2、追踪已分配空间的大小" class="headerlink" title="2、追踪已分配空间的大小"></a>2、追踪已分配空间的大小</h2><p>由于在释放对应区域空间时，并不需要指出大小，这是因为在大多数分配程序都会在头块中保存一些额外的信息，头块位于内存中，就在返回的内存区域前面。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417164000218.png" alt="image-20230417164000218" style="zoom:67%;" /><p>这里释放的时候会释放头块加具体的内存空间，那么意味着在申请内存时，申请的大小也是头块加用户指明的大小。</p><h1 id="内存分配的基本策略"><a href="#内存分配的基本策略" class="headerlink" title="内存分配的基本策略"></a>内存分配的基本策略</h1><p>1、最优匹配：找到和用户申请大小最接近的一块区域，分配给用户。但是他需要遍历所有的空闲列表，性能差一点。</p><p>2、最差匹配：找最大的空闲区域，分割并分配给用户。会导致过量碎片，而且性能不好。</p><p>3、首次匹配：找到第一个足够大的块，分配给用户。不需要全部遍历，但可能会导致开头的部分有很多的小块，因此，如何管理空闲列表顺序就变的比较重要。</p><p>一种解决办法：一种方式是基于地址排序，保持空闲块按内存地址有序，会让合并变得容易，减少内存碎片。</p><p>4、下次匹配：每一次都从上一次分配完成的地址开始往后遍历。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一部分，书中做了一些假设：&lt;/p&gt;
&lt;p&gt;1、如果请求内存，就需要指定请求内存的大小，而释放该内存则不用指定大小。&lt;/p&gt;
&lt;p&gt;2、只考虑外部碎片，不考虑因分配空间稍微大于请求内存而造成的内部碎片。&lt;/p&gt;
&lt;p&gt;3、内存一旦被分配给用户，那么它就不可能被重定位。即这块</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>分段</title>
    <link href="http://example.com/2023/04/17/%E5%88%86%E6%AE%B5/"/>
    <id>http://example.com/2023/04/17/%E5%88%86%E6%AE%B5/</id>
    <published>2023-04-17T05:35:17.000Z</published>
    <updated>2023-04-17T07:48:36.505Z</updated>
    
    <content type="html"><![CDATA[<p> 在分段之前，操作系统会直接把进程的地址空间完整的加载到内存当中，但是栈和堆中间却有很大一块空间没有使用，如下图：</p><img src="C:\Users\郭俊豪\AppData\Roaming\Typora\typora-user-images\image-20230417134359838.png" alt="image-20230417134359838" style="zoom: 67%;" /><p>但是由于进程的地址空间被加载到了内存中，那么就意味着这些虚拟的地址空间都会被分配对应的物理地址，虽然这些地址没有被该进程写入内容，但是他们已经不能再分配给其他进程使用。</p><p>为了解决这个问题，引入了分段的概念。有了分段的概念后，就不是给每个地址空间一个寄存器，而是让地址空间内的每个段都有自己的基址寄存器和界限寄存器。<strong>一个段是地址空间中连续的定长区域。</strong></p><p>这样设计，就可以把进程的单个段加载到内存中，而不是将整个地址空间都加载到内存中，这样就能确保被加载到物理内存空间中的内容都是正在使用的，或者说最小程度的浪费一些空间。</p><p>在经典的地址空间中，有三个逻辑不同的段：代码，栈和堆。分段之后，我们可以把这三个部分分别加载到物理内存对应的位置，如下图所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230417141138659.png" alt="image-20230417141138659" style="zoom: 67%;" /><p>而不需要像之前那样，必须把整个地址空间全部加载到内存当中。</p><h1 id="分段存在的问题"><a href="#分段存在的问题" class="headerlink" title="分段存在的问题"></a>分段存在的问题</h1><p>分段的出现会导致内存中零散的分布很多的段，如果现在有不连续的24k空间，现在有一个20k大小的段，则会导致该段进入内存失败。</p><p>即分段会造成一定的外部碎片。</p><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>这篇笔记是在学习操作系统导论时写的，该书采用的是层层递进的方式，由最初的设计，存在什么问题，一步一步解决问题，更改设计，得到一个现代的操作设计方案。所以本文中有些内容可能并非目前操作系统正确的设计。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 在分段之前，操作系统会直接把进程的地址空间完整的加载到内存当中，但是栈和堆中间却有很大一块空间没有使用，如下图：&lt;/p&gt;
&lt;img src=&quot;C:\Users\郭俊豪\AppData\Roaming\Typora\typora-user-images\image-2023</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>地址转换</title>
    <link href="http://example.com/2023/04/16/%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/"/>
    <id>http://example.com/2023/04/16/%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/</id>
    <published>2023-04-16T09:35:58.000Z</published>
    <updated>2023-04-18T01:43:09.564Z</updated>
    
    <content type="html"><![CDATA[<p>地址转换：硬件对每次的内存访问进行处理，将指令的虚拟地址转换为数据实际的物理地址。</p><p>但是仅仅靠硬件无法解决，它只能提高效率。还需要操作系统的帮助。</p><p>这使得每个程序好像拥有了自己私有的内存空间，存放着自己的代码和数据。但实际上是多个程序共用内存。</p><h1 id="动态重定位"><a href="#动态重定位" class="headerlink" title="动态重定位"></a>动态重定位</h1><p>每个CPU需要两个硬件寄存器：基址寄存器和界限寄存器。这两个寄存器能够让我们将地址空间放在物理内存的任何位置，同时又保证程序只访问自己的地址空间。</p><p>采用这种硬件的地址转换方式，进程中的内存引用都是虚拟地址，而虚拟地址加上基址寄存器中的内容，可以算出来真实的物理地址，再发送给内存系统。</p><p>由于这个由虚拟内存转换为具体的物理内存的过程是在运行时发生的，所以又叫做动态重定位。</p><p>这里面的界限寄存器，就是用来保证进程只访问自己范围内的空间，如果越界，则cpu会触发异常，进程会被终止。</p><h1 id="操作系统要做什么"><a href="#操作系统要做什么" class="headerlink" title="操作系统要做什么"></a>操作系统要做什么</h1><p>1、进程创建时，操作系统要为进程的地址空间找到内存空间。这就需要操作系统来维护哪些空间是可用的，哪些是已经被使用了的。</p><p>2、当进程运行结束时，操作系统要负责回收它的内存，供其他进程使用。当进程结束时，操作系统会把这些内存放入空闲列表。</p><p>3、每个cpu只有一个界限寄存器和基址寄存器，但对于每个运行的程序，他们要存入的值都是不同的。所以在发生上下文切换时，操作系统需要保存当前正在运行进程的界限寄存器和基址寄存器的值，以便后续恢复该进程时使用。</p><p>4、操作系统需要提供异常处理。比如当一个程序要越界访问时，cpu会触发异常，而操作系统需要终止该程序。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;地址转换：硬件对每次的内存访问进行处理，将指令的虚拟地址转换为数据实际的物理地址。&lt;/p&gt;
&lt;p&gt;但是仅仅靠硬件无法解决，它只能提高效率。还需要操作系统的帮助。&lt;/p&gt;
&lt;p&gt;这使得每个程序好像拥有了自己私有的内存空间，存放着自己的代码和数据。但实际上是多个程序共用内存。&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的next-key lock</title>
    <link href="http://example.com/2023/04/16/MySQL%E7%9A%84next-key%20lock/"/>
    <id>http://example.com/2023/04/16/MySQL%E7%9A%84next-key%20lock/</id>
    <published>2023-04-16T07:10:20.000Z</published>
    <updated>2023-04-16T08:31:50.128Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB引擎为了解决幻读带来的问题，引入了间隙锁。而间隙锁和行锁组合起来叫做next-key lock，他是一个左开右闭的区间，代表锁住对应数据行以及数据行之间的间隙。</p><p>比如现在有两行数据，（5，5，5）和（10，10，10）。在可重复读得隔离级别下执行如下sql ，，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where id = 7</span><br></pre></td></tr></table></figure><p>就会锁住(5, 10]之间的间隙，以及第（10，10，10）这一行。因为锁是加在索引上面，而索引是有序的，所以需要保证这两条数据间没有新的数据插入。</p><p>在《MySQL45讲》中给出了加锁的一些规则：</p><ol><li>原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。</li><li>原则2：查找过程中访问到的对象才会加锁。</li><li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。</li><li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候（比如查询id &#x3D; 5，而最后一个值是id &#x3D; 10，那么就会变为间隙锁），next-key lock退化为间隙锁。</li><li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li></ol><p>假如现在有如下表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `c` (`c`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into t values(0,0,0),(5,5,5),</span><br><span class="line">(10,10,10),(15,15,15),(20,20,20),(25,25,25);</span><br></pre></td></tr></table></figure><p>下面我们看一些具体的例子。</p><h1 id="等值查询间隙锁"><a href="#等值查询间隙锁" class="headerlink" title="等值查询间隙锁"></a>等值查询间隙锁</h1><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416152532725.png" alt="image-20230416152532725"></p><p>课程中讲的是：</p><p>1、根据原则1，加锁单位是next-key lock，session A加锁范围就是(5,10]；</p><p>2、同时根据优化2，这是一个等值查询(id&#x3D;7)，而id&#x3D;10不满足查询条件，next-key lock退化成间隙锁，因此最终加锁的范围是(5,10)。</p><p>所以插入（8，8，8）失败，而update10成功。</p><p>这里有一个疑问：为什么没有根据优化1，将（5，10]的next-key lock转变为行锁呢？</p><p>个人理解：虽然是唯一索引的等值操作，但是查询条件是id &#x3D; 7，而表中的值是id &#x3D; 5和 id &#x3D; 10这两条记录，并不相等，所以没有退化成行锁。</p><h1 id="非唯一索引等值锁"><a href="#非唯一索引等值锁" class="headerlink" title="非唯一索引等值锁"></a>非唯一索引等值锁</h1><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416152814309.png" alt="image-20230416152814309"></p><p>这个例子中，由于数据是（0，0，0）（5，5，5）（10，10，10），而查询条件是c &#x3D; 5，所以会先在（0，5]之间加上next-key lock。</p><p>但是c是非唯一索引，所以需要遍历到不满足条件的为止，也就是说会访问到c &#x3D; 10这一行。所以还会给（5，10]加上锁，但是该锁最后一行c &#x3D; 10并不满足c &#x3D; 5的查询条件，所以会退化为间隙锁，也就是（5，10），并不锁c &#x3D; 10这一行。</p><p>而这个查询语走索引c，却只查询了id，恰好是覆盖索引，并不会回表，也就是说只锁了索引c，而没有锁索引id，那么意味着sessionB要操作的数据并没有加锁，所以B成功了，而C失败了。</p><h1 id="主键索引范围锁"><a href="#主键索引范围锁" class="headerlink" title="主键索引范围锁"></a>主键索引范围锁</h1><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416154441303.png" alt="image-20230416154441303" style="zoom: 50%;" /><p>sessionA会先找到id &#x3D; 5这一行，然后是id &#x3D; 10这一行，所以会加（5，10]的next-key lock。但是id &#x3D; 10满足了查询条件，所以这个锁会退化为行锁，只锁id &#x3D; 10这一行。</p><p>但是查询还有第二个条件id  &lt;  11，则会继续往后走，查找到id &#x3D; 15这一行。所以会加（10，15]的next-key lock。由于查询条件id &lt; 11在id &#x3D; 15这一行不满足，所以无法退化成间隙锁，也即是说15这一行也会被锁住。就会导致如图的情况。</p><h1 id="非唯一索引范围锁"><a href="#非唯一索引范围锁" class="headerlink" title="非唯一索引范围锁"></a>非唯一索引范围锁</h1><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416160330625.png" alt="image-20230416160330625" style="zoom:50%;" /><p>这个例子中，由于查询所有的值，所以走索引c需要回表。意味着不仅要锁索引c，也要锁id。</p><p>在第一次用c&#x3D;10定位记录的时候，索引c上加了(5,10]这个next-key lock后，由于索引c是非唯一索引，没有优化规则，也就是说不会变为行锁，因此最终sesion A加的锁是，索引c上的(5,10] 和(10,15] 这两个next-key lock。</p><p>所以插入8 和修改c &#x3D; 15也都会被阻塞。</p><h1 id="非唯一索引上存在”等值”的例子"><a href="#非唯一索引上存在”等值”的例子" class="headerlink" title="非唯一索引上存在”等值”的例子"></a>非唯一索引上存在”等值”的例子</h1><p>假如新插入了一行记录（30，10，30）那么索引c就会变为如下：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416162231844.png" alt="image-20230416162231844" style="zoom: 67%;" /><p>那么如下操作：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416162440432.png" alt="image-20230416162440432"></p><p>这里会加5，10以及10，15的锁，然后不包括端点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;InnoDB引擎为了解决幻读带来的问题，引入了间隙锁。而间隙锁和行锁组合起来叫做next-key lock，他是一个左开右闭的区间，代表锁住对应数据行以及数据行之间的间隙。&lt;/p&gt;
&lt;p&gt;比如现在有两行数据，（5，5，5）和（10，10，10）。在可重复读得隔离级别下执行如</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    <category term="锁" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/%E9%94%81/"/>
    
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>运输层概述</title>
    <link href="http://example.com/2023/04/16/%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2023/04/16/%E8%BF%90%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0/</id>
    <published>2023-04-16T03:04:45.000Z</published>
    <updated>2023-04-18T01:42:32.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>运输层协议为运行在不同端的应用进程提供逻辑上的通信，该协议是在端系统中实现，而不是在路由器中实现。</p><p>在发送端，运输层将从发送应用程序进程接收到的报文转换成运输层分组，该分组称为<strong>运输层报文段</strong>（segment）。</p><p>转换的方法：</p><p>1、将应用报文划分为较小的块，并为每块加上一个运输层首部以生成运输层报文段。</p><p>2、然后，在发送端系统中，运输层将这些报文段传递给网络层，网路层将其封装成网络层分组（即数据报）并向目的地发送。</p><h1 id="运输层和网络层关系"><a href="#运输层和网络层关系" class="headerlink" title="运输层和网络层关系"></a>运输层和网络层关系</h1><p>运输层位于网络层之上。网络层提供主机到主机的逻辑通信，而运输层提供的是进程到进程的逻辑通信。</p><p>用书上的一个例子，场景是：假如现在有两个家庭A和B，每个家庭有4个孩子。而每个月两家孩子都会互相的写信。家庭A有一个孩子负责收集所有孩子的信件，然后送给邮局。家庭B同样有一个孩子来做这件事情。家庭A的孩子设为C，家庭B的孩子设为D。</p><p>在这个例子中，从这些孩子的角度来看，孩子C和孩子D就为他们提供了逻辑通信。因为其他孩子只需要把信交给孩子C和D，剩余事情都无需关心。邮局则提供了两个家庭间的逻辑通信，因为孩子C和D只需要把信交给邮局，其他的也无需关心。</p><p>所以可以做以下类比：</p><p>1、应用层报文 &#x3D; 信封上的字符</p><p>2、进程 &#x3D; 这群孩子 （他们是通信主体）</p><p>3、主机（端系统） &#x3D;  家庭  </p><p>4、运输层协议  &#x3D;  孩子C和D</p><p>5、网络层协议  &#x3D;  邮政服务</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《计算机网络导论：自顶向下方法》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;运输层协议为运行在不同端的应用进程提供逻辑上的通信，该协议是在端系统中实现，而不是在路由器中实现。&lt;/p&gt;
&lt;p&gt;在发送端，运输层将从发送应</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="运输层" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
    
    <category term="运输层" scheme="http://example.com/tags/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>CDN</title>
    <link href="http://example.com/2023/04/16/CDN/"/>
    <id>http://example.com/2023/04/16/CDN/</id>
    <published>2023-04-16T01:37:45.000Z</published>
    <updated>2023-04-18T01:43:39.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内容分发网络CDN"><a href="#内容分发网络CDN" class="headerlink" title="内容分发网络CDN"></a>内容分发网络CDN</h1><p>现阶段，很多视频公司没日需要给用户推送大量的视频，这些视频如果都从公司的主服务器推送出去，则会给主服务器造成压力，而且由于区域原因，还会带来很高的时延。</p><p>CDN就是为了解决上面的问题。CDN服务器可以分布在多个地区，它存储那些视频以及图片的副本，用于用户请求时将视频等内容响应给用户。可以减小主服务器带宽压力，而且根据用户地理位置，分配不同的CDN，可以减少时延。</p><p>CDN采用集群部署，如果用户请求的CDN集群没有用户的目标视频，则该CDN集群会从中心仓库或者另一个集群搜索该视频，然后一边给用户传输，一边缓存在本集群中。</p><h1 id="CDN操作"><a href="#CDN操作" class="headerlink" title="CDN操作"></a>CDN操作</h1><p>当用于从浏览器请求某视频时，CDN需要先截获用户请求，才能确定适合用户的CDN集群，以及将用户请求重定向到该集群中。</p><h2 id="如何截获和重定向"><a href="#如何截获和重定向" class="headerlink" title="如何截获和重定向"></a>如何截获和重定向</h2><p>截获请求和重定向需要依赖于DNS。假如公司A用了公司B提供的CDN服务，那么一个大概的流程如下：</p><p>1、用户访问公司A的网站，点击了一个视频，那么他会向对应的域名发起请求（例如请求<a href="https://www.bilibili.com/video/xxx%EF%BC%89%EF%BC%8C%E8%8E%B7%E5%8F%96%E8%AF%A5%E8%A7%86%E9%A2%91%E3%80%82">https://www.bilibili.com/video/xxx），获取该视频。</a></p><p>2、用户的本地DNS服务器会将请求转发到权威DNS服务器，权威DNS服务器发现了域名中的video，那么它并不会向用户返回一个IP地址，而是返回一个B公司的主机名。</p><p>3、然后，该请求就进入了B公司专用的DNS设施。然后用户本地DNS会发起第二个请求，此时就是直接向公司B发起的DNS请求，这个请求会得到一个指向B公司的ip地址，然后用户可以从这里获取到视频的信息。</p><p>从这里，用户发起向公司A的请求就被转变为向公司B的CDN服务器的请求。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230416102329355.png" alt="image-20230416102329355" style="zoom:67%;" /><h2 id="集群选择策略"><a href="#集群选择策略" class="headerlink" title="集群选择策略"></a>集群选择策略</h2><p>在上面的重定向过程中，公司B的CDN服务器是可以知道用户本地DNS地址，那么他就可以根据该ip来为用户分配最为临近的CDN集群。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《计算机网络导论：自顶向下方法》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内容分发网络CDN&quot;&gt;&lt;a href=&quot;#内容分发网络CDN&quot; class=&quot;headerlink&quot; title=&quot;内容分发网络CDN&quot;&gt;&lt;/a&gt;内容分发网络CDN&lt;/h1&gt;&lt;p&gt;现阶段，很多视频公司没日需要给用户推送大量的视频，这些视频如果都从公司的主服务器推送</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="应用层" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
  </entry>
  
  <entry>
    <title>地址空间</title>
    <link href="http://example.com/2023/04/15/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/"/>
    <id>http://example.com/2023/04/15/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4/</id>
    <published>2023-04-15T09:23:14.000Z</published>
    <updated>2023-04-15T10:39:36.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h1><p>一个线程的地址空间如下图所示：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230415172631305.png" alt="image-20230415172631305"></p><p>这个地址空间看似是从0KB开始，但这里的0KB映射到具体的物理地址并不一定是从内存的地址0开始，它可能是物理内存的任意位置。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;地址空间&quot;&gt;&lt;a href=&quot;#地址空间&quot; class=&quot;headerlink&quot; title=&quot;地址空间&quot;&gt;&lt;/a&gt;地址空间&lt;/h1&gt;&lt;p&gt;一个线程的地址空间如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://image-1314238346.cos.</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>一个sleep操作引起的问题</title>
    <link href="http://example.com/2023/04/15/%E4%B8%80%E4%B8%AAsleep%E6%93%8D%E4%BD%9C%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2023/04/15/%E4%B8%80%E4%B8%AAsleep%E6%93%8D%E4%BD%9C%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2023-04-15T03:17:51.000Z</published>
    <updated>2023-04-18T03:14:27.521Z</updated>
    
    <content type="html"><![CDATA[<p>在学习Java并发编程时，有以下demo，简单演示商品出售的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 减少t</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                t--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 减少t</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                t--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是存在并发问题的，当库存为1的时候，两个线程同时判断 t &gt; 0，然后都进入t–操作，会导致输出的值为-1。</p><p>但是在本地实测的时候却发现，尝试了很多次都没有出现t为负数的情况，然后将代码改成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 减少t</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                t--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 减少t</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                t--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况，很容易出现t为负数的情况。</p><p>为什么加了sleep就很容易出现，而不加却需要尝试很多次呢？</p><h3 id="一个比较简单的解释"><a href="#一个比较简单的解释" class="headerlink" title="一个比较简单的解释"></a>一个比较简单的解释</h3><p>在不加sleep的情况下，由于操作只有t–，执行的特别快，所以说很难出现错误的情况，概率比较小。</p><p>而加了sleep之后，进入判断后会先进行sleep，sleep完再去处理t–。这样在t &#x3D; 1时，线程判断完进入while后就睡眠，另一个线程在这100ms内有很大概率也会进入相同的判断，导致结果为-1。</p><p>在这里加sleep可以理解为加大了判断与执行t–之间的时间，导致更多的线程会在这之间执行。</p><h3 id="另一种情况"><a href="#另一种情况" class="headerlink" title="另一种情况"></a>另一种情况</h3><p>如果sleep是在下面这个位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 减少t</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                t--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + t);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">// 减少t</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                t--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + t);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说先执行t–，然后打印，之后再进行sleep。按照这么个顺序来执行，一个线程的判断和执行扣减操作的时间并没有被加长，却也很容易出现t为负数或者打印相同t的情况。</p><h3 id="从硬件考虑"><a href="#从硬件考虑" class="headerlink" title="从硬件考虑"></a>从硬件考虑</h3><p>我的电脑是8核cpu的，该程序只开了两个线程，如果当前电脑cpu资源比较充足是时，从理论上来讲，存在一种情况就是两个线程都是并行执行，并不存在竞争cpu资源的问题。</p><p>当并发的资源竞争没那么大时，每个线程在工作内存中所做的修改，可以很快的同步回主内存，另一个线程也可以从主内存中读取到最新的值（非volatile修饰的公共变量，虚拟机并不保证其可见性，但不代表一定是不可见的），然后再进行操作。</p><p>所以，当每个线程都执行的很快且并发资源竞争没那么大时（对应上面不加sleep的demo），我们可以做一个大胆一点的假设（虽然不对）：对t &gt; 0的判断和 t –操作是原子性的。也就是说，这两步执行的太快，以至于其他线程无法在中间穿插任何操作（而事实是存在穿插操作的可能），好像加了锁一样。</p><p>而加了sleep之后，无论在哪里加，都会导致当前的线程阻塞。而阻塞操作涉及到一个从用户态切换到核心态。因为Java的线程设计是每一个Java线程都绑定了一个内核线程，要阻塞一个线程或者唤醒都需要操作系统帮忙。这里由于内核切换带来的开销，可能会导致线程写入主内存延，也可能会导致另一个线程读取主内存的数据延迟，加大了发生问题的概率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在学习Java并发编程时，有以下demo，简单演示商品出售的问题。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;s</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>多处理器调度</title>
    <link href="http://example.com/2023/04/14/%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/"/>
    <id>http://example.com/2023/04/14/%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/</id>
    <published>2023-04-14T09:20:38.000Z</published>
    <updated>2023-04-17T06:29:55.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多处理器架构"><a href="#多处理器架构" class="headerlink" title="多处理器架构"></a>多处理器架构</h1><p>多处理器与单处理器最大的区别在于对硬件缓存的使用，以及处理器之间共享数据的方式。</p><p>在单CPU系统中，存在多级硬件缓存，一般会让程序执行更快。</p><p>假设一个程序需要从内存中加载指令并读取一个值，在它第一次读取时，需要从内存中读取，之后处理器判定在短期内很可能会再次使用这个数据，会将其放入缓存中，下一次再请求时，直接从缓存中取即可。</p><p>在多CPU系统中，缓存则会变得复杂。</p><p>假如有两个CPU，一个内存。现在有一个运行在CPU1上的程序，要去地址A读值，但是CPU1里面没有该数据的缓存，所以需要去内存中读取，读取完成后，程序要修改地址A上的值，假设改为D，它会先写入缓存中，然后再去写入内存。但是写入内存时发生了中断，中断完后此程序交由CPU2执行，但是CPU2中没有数据的缓存，就需要从内存中读，这时候就会读到旧得数据，而不是修改后得D。</p><p>硬件提供了这个问题得解决方案：通过监控内存得访问，硬件可以保证获得正确数据，并确保共享内存的唯一性。</p><h1 id="单队列调度"><a href="#单队列调度" class="headerlink" title="单队列调度"></a>单队列调度</h1><p>这种调度方式就是采用一个队列来存储任务，然后有多个cpu从中获取任务，然后执行。但是这里需要用加锁的方式来保证调度的正确性，而加锁又会带来性能上的损耗。而且可能存在一种情况，一个任务频繁的在不同的cpu上运行，导致cpu的缓存几乎不起作用。我们应该尽可能保证一个任务一直在一个cpu上处理，来尽可能多的提高缓存命中率。</p><p>一个cpu缓存命中率特别低的情况：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414205315810.png" alt="image-20230414205315810"></p><h1 id="多队列调度"><a href="#多队列调度" class="headerlink" title="多队列调度"></a>多队列调度</h1><p>这种设计下，队列与CPU是多对多的关系，我们可以让一个队列对应一个CPU。</p><p>这样锁的竞争就会小很多，如果每一个CPU只从固定的一个队列获取任务，甚至可以消除锁竞争。而且它的缓存亲和性比较好，一个队列里面的任务会固定在一个CPU上运行。</p><p>如果按照一个CPU只处理自己对应队列的任务，会存在一种情况，cpu1里的任务已经执行完了，而cpu2里的任务还没有，那么cpu2一直在忙碌 ，cpu1却在空闲，导致负载不均衡。</p><p>如下图：A独占cpu0，而B 和 D交替执行在cpu1上。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414205421683.png" alt="image-20230414205421683"></p><p>若A执行完成，则会变成如下：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414205507938.png" alt="image-20230414205507938"></p><p>解决办法：迁移。通过工作的跨cpu迁移，可以实现负载均衡。</p><p><strong>即cpu1可以处理cpu2对应队列中的任务。</strong></p><p>假如cpu1队列中一开始只有任务A，而cpu2中有任务B和D，那么在迁移的设计下，执行过程如下：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414205237310.png" alt="image-20230414205237310"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多处理器架构&quot;&gt;&lt;a href=&quot;#多处理器架构&quot; class=&quot;headerlink&quot; title=&quot;多处理器架构&quot;&gt;&lt;/a&gt;多处理器架构&lt;/h1&gt;&lt;p&gt;多处理器与单处理器最大的区别在于对硬件缓存的使用，以及处理器之间共享数据的方式。&lt;/p&gt;
&lt;p&gt;在单CPU系</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="CPU虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>调度：多级反馈队列</title>
    <link href="http://example.com/2023/04/14/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2023/04/14/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97/</id>
    <published>2023-04-14T08:10:53.000Z</published>
    <updated>2023-04-17T06:30:08.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h1><p>MLFQ有许多独立的队列，每个队列都有优先级，任何时刻，一个任务只能存在一个队列当中，而MLFQ总是执行优先级最高的队列中的任务。在同一个队列中的任务，采用轮转调度。而MLFQ会观察任务的行为，然后调整他们的优先级。</p><h1 id="尝试1：改变优先级"><a href="#尝试1：改变优先级" class="headerlink" title="尝试1：改变优先级"></a>尝试1：改变优先级</h1><p>工作进入系统时，放在优先级最高的队列当中，工作用完整个时间片后，降低其优先级，如果时间片没用完，主动放弃CPU，则优先级不进行变化。</p><p>按照这种方法，如果有一个很长的cpu密集型任务要执行，那么它会被慢慢降级到最低的优先级。而此时来了一个短任务，会被放在优先级最高的队列中执行，它大概率会在降到最低优先级之前处理完，这种情况下MLFQ近似于短任务优先。</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>这样设计，如果一个任务一直不把CPU时间片用完，那么他就一直可以处于优先级最高的队列当中，那么会导致一些用完时间片而导致降级的任务永远无法处理。</p><p>而且会有程序恶意放弃CPU资源而一直占用处理器，比如在时间片用完之间，执行一段I&#x2F;O操作，主动放弃CPU。</p><h1 id="尝试2：提升优先级"><a href="#尝试2：提升优先级" class="headerlink" title="尝试2：提升优先级"></a>尝试2：提升优先级</h1><p>一个简单的设计，经过一段时间S后，就把队列中的所有任务全部放在优先级最高的队列当中。</p><p>但是这个S的值设置不合适也会导致问题，太长，会导致任务饥饿，太短的话，交互性任务达不到合适的CPU时间比例。</p><h1 id="尝试3：更好的设计"><a href="#尝试3：更好的设计" class="headerlink" title="尝试3：更好的设计"></a>尝试3：更好的设计</h1><p>为了防止一些恶意代码在CPU时间片用完前执行一次I&#x2F;O操作来放弃处理器资源，以达到刷新时间片的目的，我们可以将时间片设计为该任务在该队列可以执行的总时间。意思就是，一个任务可以执行1s，那么无论它放弃了多少次，只要执行的总时间达到1s，他就要被降到低优先级的队列当中。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本规则&quot;&gt;&lt;a href=&quot;#基本规则&quot; class=&quot;headerlink&quot; title=&quot;基本规则&quot;&gt;&lt;/a&gt;基本规则&lt;/h1&gt;&lt;p&gt;MLFQ有许多独立的队列，每个队列都有优先级，任何时刻，一个任务只能存在一个队列当中，而MLFQ总是执行优先级最高的队列中的</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="CPU虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的幻读</title>
    <link href="http://example.com/2023/04/14/MySQL%E7%9A%84%E5%B9%BB%E8%AF%BB/"/>
    <id>http://example.com/2023/04/14/MySQL%E7%9A%84%E5%B9%BB%E8%AF%BB/</id>
    <published>2023-04-14T05:55:01.000Z</published>
    <updated>2023-04-14T13:58:14.459Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章将介绍MySQL幻读相关的内容。</p><p>假设数据库中有以下表：</p><table><thead><tr><th>id</th><th>c</th><th>d</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>5</td><td>5</td><td>5</td></tr><tr><td>10</td><td>10</td><td>10</td></tr><tr><td>15</td><td>15</td><td>15</td></tr><tr><td>20</td><td>20</td><td>20</td></tr><tr><td>25</td><td>25</td><td>25</td></tr></tbody></table><p>其中id是主键，c上建立有普通索引。</p><p>以下讨论场景除非必要说明，否则都是在可重复读的隔离级别下。</p><h1 id="什么是幻读"><a href="#什么是幻读" class="headerlink" title="什么是幻读"></a>什么是幻读</h1><p>现在考虑以下场景：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414141001291.png" alt="image-20230414141001291" style="zoom:50%;" /><p>其中，select * from table for update表示当前读，并且加上写锁。</p><p>幻读就是指在同一个事务中执行相同的sql，后一次查询看到了前一次没看到的数据。就比如Q3比Q2多了一条数据。</p><p>Q2看到Q1并不被称为幻读，幻读仅仅指新插入的数据。</p><p>在可重复读的隔离级别下，普通查询是看不到其他插入的数据，只有当前读（要能读到所有已经提交的记录的最新值）才有可能出现幻读。</p><h1 id="幻读存在的问题"><a href="#幻读存在的问题" class="headerlink" title="幻读存在的问题"></a>幻读存在的问题</h1><h2 id="1、语义的破坏"><a href="#1、语义的破坏" class="headerlink" title="1、语义的破坏"></a>1、语义的破坏</h2><p>session A已经声明了写锁，即要锁住d &#x3D; 5的行，不允许其他事务进行读写，而后续却插入了一条d &#x3D; 5的数据。</p><p>考虑另一个更明显的场景：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414143724913.png" alt="image-20230414143724913" style="zoom: 50%;" /><p>sessionB将id &#x3D; 0的这一行的d改成了5，然后又把c改成了5，也就是说变化为从（0，0，5）-&gt;（0，5，5）。这样破坏了sessionA要锁住所有d&#x3D;5的行的加锁声明。</p><p>sessionC也是同样的道理，修改了d &#x3D; 5，id &#x3D; 1的行。</p><h2 id="2、数据一致性问题"><a href="#2、数据一致性问题" class="headerlink" title="2、数据一致性问题"></a>2、数据一致性问题</h2><p>现在在sessionA追加一条语句：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414144337377.png" alt="image-20230414144337377" style="zoom:50%;" /><p>此时，sessionA要锁住d &#x3D; 5的这一行，然后把d 改为100，即sessionA在T1要做的操作为将（5，5，5）-&gt; (5，5，100)。</p><p>在T2时刻，id &#x3D; 0这一行变成了（0，5，5）</p><p>在T4时刻，数据库多了一条（1，5，5）的记录。</p><p>但是我们看binlog的内容：</p><p>在T2时刻，sessionB提交，写入两条语句，两条update。</p><p>T4时刻，sessionC提交，写入两条语句，一条insert，一条update。</p><p>把上面的语句放在一起，顺序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* sessionB */</span><br><span class="line">update t set d = 5 where id = 0; /*(0,0,5)*/</span><br><span class="line">update t set c = 5 where id = 0; /*(0,5,5)*/</span><br><span class="line"></span><br><span class="line">/* sessionC */</span><br><span class="line">insert into t values(1,1,5); /*(1,1,5)*/</span><br><span class="line">update t set c = 5 where id = 1; /*(1,5,5)*/</span><br><span class="line"></span><br><span class="line">/* sessionA */</span><br><span class="line">update t set d = 100 where d = 5;/*所有d=5的行，d改成100*/</span><br></pre></td></tr></table></figure><p>通过这个语句的顺序，如果我们要拿它来恢复数据，最终恢复出来的数据会变为： (0,5,100)、(1,5,100) 和 (5,5,100)。</p><p>而正确的数据应该是（0，5，5），（1，5，5）和（5，5，100）。因为在可重复读隔离级别下，事务A没提交，事务B和C看不到A的修改，而事务A在提交之前看不到B和C的修改。</p><p>这里的数据不一致是因为我们假设了select * from t where d&#x3D;5 for update这条语句只给id &#x3D; 5这一样加锁导致的。</p><p>现在我们假设把扫描过程中的所有行都加锁，场景如下：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414150914211.png" alt="image-20230414150914211" style="zoom:50%;" /><p>这个时候，id &#x3D; 0的这一行在修改时，由于被加了锁，所以无法执行。也就是说现在的执行顺序如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert into t values(1,1,5); /*(1,1,5)*/</span><br><span class="line">update t set c=5 where id=1; /*(1,5,5)*/</span><br><span class="line"></span><br><span class="line">update t set d=100 where d=5;/*所有d=5的行，d改成100*/</span><br><span class="line"></span><br><span class="line">update t set d=5 where id=0; /*(0,0,5)*/</span><br><span class="line">update t set c=5 where id=0; /*(0,5,5)*/</span><br></pre></td></tr></table></figure><p>此时，id &#x3D; 0的这一行数据正确，但是新插入的id &#x3D; 1的问题还是没有解决。</p><p><strong>也就是说，即使把所有的记录都加上锁，还是阻止不了新插入的记录</strong>，这也是为什么要单独解决幻读。</p><h1 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h1><p>即使我们在一开始就锁住所有行，但是由于插入语句是在行的间隙进行的，所以InnoDB的解决办法是引入了间隙锁(Gap Lock)。比如开头的表，有6行数据，7个间隙。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414151304834.png" alt="image-20230414151304834" style="zoom:67%;" /><p>这样，当你执行 select * from t where d&#x3D;5 for update的时候，就不止是给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录。</p><p>间隙锁和间隙锁之间不冲突，两个事务可以在同一个间隙加间隙锁，与间隙锁冲突的是往间隙插入数据的操作。</p><p><strong>间隙锁和行锁合称next-key lock</strong>，每个next-key lock是前开后闭区间，</p><p>间隙锁只有在可重复读的隔离级别下才有。而且引入间隙锁会降低并发度，并且有可能造成死锁。</p><p>另外一种解决幻读的方式是采用读提交的隔离级别加binlog_format&#x3D;row。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文章将介绍MySQL幻读相关的内容。&lt;/p&gt;
&lt;p&gt;假设数据库中有以下表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;c&lt;/th&gt;
&lt;th&gt;d&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    <category term="其他" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="MySQL45讲" scheme="http://example.com/tags/MySQL45%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>DNS域名解析</title>
    <link href="http://example.com/2023/04/14/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2023/04/14/DNS%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/</id>
    <published>2023-04-14T02:22:20.000Z</published>
    <updated>2023-04-16T03:05:33.659Z</updated>
    
    <content type="html"><![CDATA[<p>DNS是一个由分层的DNS服务器实现的分布式数据库，它主要记录了域名与IP地址的对应关系。</p><p>我们平时访问网站，都是输入域名，而不是IP地址，而域名被解析为对应IP地址这一步，就是由DNS实现的。</p><p>它还提供了一些其他的服务，比如说将一个域名映射到多个IP地址上，用于减轻单个服务器的压力。</p><h1 id="DNS架构"><a href="#DNS架构" class="headerlink" title="DNS架构"></a>DNS架构</h1><p>它是一个分布式的数据库，且分多层次。</p><p>不采用单点是因为如果单点故障，那么整个因特网就不能用，而且单点无法承载那么大的请求量，存储那么多的数据。如果采用单点，还会因为地理位置原因导致很大的时延。</p><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><p>DNS分为根域名服务器，顶级域名服务器，权威域名服务器和本地域名服务器。</p><p>一个用户在浏览器中输入一个域名，解析的过程大致如下（迭代查询）：</p><p>1、向本地域名服务器发送请求。</p><p>2、本地域名服务器向根域名服务器发送请求，根域名服务器返回顶级域名服务器的地址。</p><p>3、本地再向顶级域名服务器发起请求，顶级域名服务器返回权威域名服务器的地址，到这一步就可以获取到IP。</p><p>4、本地域名服务器将获取到的ip返回给用户浏览器。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/test.png" alt="test" style="zoom: 50%;" /><p>递归查询：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230414110639339.png" alt="image-20230414110639339" style="zoom: 67%;" /><h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><p>某一个DNS服务器接受一个DNS回答时，它可以将映射存储在本地的存储器中，下一次如果有同样的映射，可以直接返回而不用去往下一层请求。</p><p>但是该缓存并不是永久存在的，过一段时间会被清除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;DNS是一个由分层的DNS服务器实现的分布式数据库，它主要记录了域名与IP地址的对应关系。&lt;/p&gt;
&lt;p&gt;我们平时访问网站，都是输入域名，而不是IP地址，而域名被解析为对应IP地址这一步，就是由DNS实现的。&lt;/p&gt;
&lt;p&gt;它还提供了一些其他的服务，比如说将一个域名映射到多</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="应用层" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
    
    <category term="应用层" scheme="http://example.com/tags/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>进程调度：介绍</title>
    <link href="http://example.com/2023/04/13/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%9A%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2023/04/13/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%9A%E4%BB%8B%E7%BB%8D/</id>
    <published>2023-04-13T08:00:56.000Z</published>
    <updated>2023-04-14T09:19:58.110Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍一些基础的调度策略。</p><h1 id="调度指标"><a href="#调度指标" class="headerlink" title="调度指标"></a>调度指标</h1><p>以下算法的性能指标只考虑周转时间。</p><p>周转时间 &#x3D; 完成时间 - 到达时间</p><h1 id="先进先出（FIFO）"><a href="#先进先出（FIFO）" class="headerlink" title="先进先出（FIFO）"></a>先进先出（FIFO）</h1><p>这个算法的思路很简单，先来的先执行，并且易于实现。就好比有三个任务A，B，C，他们到来的顺序是B，A，C，那么就按照他们到来的顺序进行执行。</p><p>存在的问题：如果先来的任务执行了很长时间，会导致后边的任务等待很久才可以执行，这样会导致系统的周转时间变的很长。</p><h1 id="最短任务优先（SJF）"><a href="#最短任务优先（SJF）" class="headerlink" title="最短任务优先（SJF）"></a>最短任务优先（SJF）</h1><p>该算法会先运行短任务，然后运行次短任务，依次下去。如果任务同时到达，该算法较FIFO算法可以很好的解决平均周转时间长的问题。</p><p>但是如果任务不同时到达，那么执行时间长的任务比短时任务先到达，还是会导致短任务需要等待。</p><h1 id="最短完成时间优先（STCF）"><a href="#最短完成时间优先（STCF）" class="headerlink" title="最短完成时间优先（STCF）"></a>最短完成时间优先（STCF）</h1><p>上面两种算法都是非抢占式的。</p><p>而最短完成时间优先可以理解为一种抢占式的最短任务优先算法。</p><p>该算法下，没当有任务进入系统，会判断当前正在执行任务的剩余时间和新任务的时间，哪个短就执行哪个。</p><h1 id="新的性能指标"><a href="#新的性能指标" class="headerlink" title="新的性能指标"></a>新的性能指标</h1><p>从现在开始，性能不仅考虑周转时间，还要考虑响应时间。</p><p>响应时间 &#x3D; 首次运行 - 到达时间。</p><h1 id="轮转"><a href="#轮转" class="headerlink" title="轮转"></a>轮转</h1><p>在加入新的性能指标后，上述算法就会出现问题，因为会导致长任务的响应时间特别长。</p><p>轮转的思想是，每一个任务执行一个时间片，然后切换到队列中的下一个任务，而不是一个任务一直执行，直到完毕。</p><p>该算法需要考虑时间片长短的问题，太短会导致频繁切换而导致性能下降，而太长，则会导致周转时间和响应时间太长，所以需要权衡考虑。</p><h1 id="结合I-x2F-O"><a href="#结合I-x2F-O" class="headerlink" title="结合I&#x2F;O"></a>结合I&#x2F;O</h1><p>现在假设任务都需要进行I&#x2F;O操作，那么轮转这种设计方法就会体现出它的优势。</p><p>如果不进行轮转，先到来的任务占用处理器资源，然后又进行了I&#x2F;O操作，那么会导致一个任务占用处理器资源却不使用，而是进行I&#x2F;O操作，导致其他任务也无法执行，这是对处理器的浪费。</p><p>而轮转却能很好的解决该问题，因为任务在执行I&#x2F;O操作时，可以让出处理器，让其他任务使用。</p><h1 id="无法预知"><a href="#无法预知" class="headerlink" title="无法预知"></a>无法预知</h1><p>上面的讨论都是建立在操作系统知道任务需要处理多长时间，而事实情况是，执行时间是无法估计的，所以像SJF或者STCF这种算法，几乎无法实现。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要介绍一些基础的调度策略。&lt;/p&gt;
&lt;h1 id=&quot;调度指标&quot;&gt;&lt;a href=&quot;#调度指标&quot; class=&quot;headerlink&quot; title=&quot;调度指标&quot;&gt;&lt;/a&gt;调度指标&lt;/h1&gt;&lt;p&gt;以下算法的性能指标只考虑周转时间。&lt;/p&gt;
&lt;p&gt;周转时间 &amp;#x3D; 完</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="CPU虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>机制：受限直接执行</title>
    <link href="http://example.com/2023/04/12/%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%8F%97%E9%99%90%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C/"/>
    <id>http://example.com/2023/04/12/%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%8F%97%E9%99%90%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C/</id>
    <published>2023-04-12T12:05:09.000Z</published>
    <updated>2023-04-14T09:19:46.585Z</updated>
    
    <content type="html"><![CDATA[<p>当我们采用时分共享或者空分共享虚化CPU时，也要考虑它带来的问题，第一个是性能问题，频繁的进行上下文切换必然会导致性能下降。第二个是控制权，如何有效的运行进程，同时保留对CPU的控制。</p><p>关键问题：如何高效、可控的进行虚化。</p><h1 id="受限直接执行"><a href="#受限直接执行" class="headerlink" title="受限直接执行"></a>受限直接执行</h1><h2 id="1、直接执行"><a href="#1、直接执行" class="headerlink" title="1、直接执行"></a>1、直接执行</h2><p>直接执行比较好理解，即直接在CPU资源上运行程序即可。</p><p>当程序需要运行时，直接将代码加载到内存中，然后找到入口点运行用户代码。</p><p>但是如果没有限制，那么会产生问题：如何保证程序不做我们不想让它做的事情，另一方面是如何停止一个进程让另一个进程运行。</p><h2 id="2、受限制的操作"><a href="#2、受限制的操作" class="headerlink" title="2、受限制的操作"></a>2、受限制的操作</h2><p>关键问题：如何执行受限制的操作</p><p>一个进程要能够执行I&#x2F;O和其他一些受限制的操作，但又不能让进程控制系统。</p><p>针对这个问题，引入了一个新的处理器模式：用户模式。在用户模式下运行的代码会收到限制，比如不能发出I&#x2F;O请求。</p><p>与之对应的是内核模式。该模式代码可以做任何操作。</p><p>目前硬件提供了用户程序执行<strong>系统调用</strong>的功能，即用户代码可以通过系统调用执行如创建和销毁进程，与其他进程通信等。</p><p>要执行系统调用，程序必须执行特殊的陷阱（trap）指令。该指令跳入内核并将特权级别提升到内核模式。但是执行该指令时需要有足够多的寄存器来存储程序目前的状态，确保程序能够正确返回。</p><p>很明显的一点是，发起系统调用的过程不能让程序决定跳转到内核的哪里，因为这样会导致恶意程序在内核运行。</p><p>解决办法是由一个陷阱表，可以理解为一个map，记录了发生某种指令时需要运行那些代码，这样当用户程序执行系统调用，就会执行对应的位置的代码，而不再由程序决定跳入内核的那个位置。</p><h2 id="3、在进程之间切换"><a href="#3、在进程之间切换" class="headerlink" title="3、在进程之间切换"></a>3、在进程之间切换</h2><p>一个很关键的问题，如果进程在CPU上运行，那就意味着操作系统此时没有运行，那操作系统如何拿回控制权呢？</p><h3 id="协作方式：等待系统调用"><a href="#协作方式：等待系统调用" class="headerlink" title="协作方式：等待系统调用"></a>协作方式：等待系统调用</h3><p>在这种方式下，运行时间过长的进程会被<strong>假定主动放弃</strong>CPU，以便操作系统决定运行其他任务。注意，这里需要程序手动的将控制权交还给操作系统。</p><p>但是也有恶意或者不小的代码执行一些非法操作，就会陷入操作系统，此时操作系统将再次获得CPU。</p><h3 id="非协作方式：操作系统进行控制"><a href="#非协作方式：操作系统进行控制" class="headerlink" title="非协作方式：操作系统进行控制"></a>非协作方式：操作系统进行控制</h3><p>这里要解决的问题：如何在没有协作的情况下获得控制权。</p><p>上面的那种方式，在出现非法操作时会导致进程陷入操作系统，但是如果一个进程进入无限循环，它不进行系统调用也不出错，那么操作系统就无法获得控制权。</p><p>这个问题的解决办法是<strong>时钟中断</strong>。</p><p>时钟设备可以便成为每几毫秒产生一次中断，中断发生时，正在运行的进程停止，操作系统预先配置的中断程序会运行，然后操作系统会获得CPU的控制权。然后它就可以停止当前进程，运行另外一个进程。</p><h3 id="保存和恢复上下文"><a href="#保存和恢复上下文" class="headerlink" title="保存和恢复上下文"></a>保存和恢复上下文</h3><p>当操作系统获得CPU时，它就要确定是继续执行当前进程还是进行切换。如果进行切换，就需要为当前正在运行的进行保存一些信息到寄存器（通用寄存器，程序计数器，当前正在运行进程的内核指针），并且恢复将要运行的进程恢复一些寄存器的值。这个过程就叫做上下文切换。</p><p>当发生时钟中断时，运行进程由用户寄存器隐式保存，使用该进程的内核栈。</p><p>当操作系统决定从A切换到B，内核寄存器被操作系统（OS）明确的保存在该进程的进程结构的内存中。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当我们采用时分共享或者空分共享虚化CPU时，也要考虑它带来的问题，第一个是性能问题，频繁的进行上下文切换必然会导致性能下降。第二个是控制权，如何有效的运行进程，同时保留对CPU的控制。&lt;/p&gt;
&lt;p&gt;关键问题：如何高效、可控的进行虚化。&lt;/p&gt;
&lt;h1 id=&quot;受限直接执行</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="CPU虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/CPU%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
</feed>
