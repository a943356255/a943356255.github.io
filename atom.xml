<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便起个名字吧</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-04-30T11:49:07.162Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Guo Junhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何正确的选择缓存读写策略</title>
    <link href="http://example.com/2023/04/30/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%80%89%E6%8B%A9%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5/"/>
    <id>http://example.com/2023/04/30/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%80%89%E6%8B%A9%E7%BC%93%E5%AD%98%E8%AF%BB%E5%86%99%E7%AD%96%E7%95%A5/</id>
    <published>2023-04-30T11:26:41.000Z</published>
    <updated>2023-04-30T11:49:07.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cache-Aside（旁路缓存）策略"><a href="#Cache-Aside（旁路缓存）策略" class="headerlink" title="Cache Aside（旁路缓存）策略"></a>Cache Aside（旁路缓存）策略</h1><p>读策略为：</p><ul><li>从缓存中读取数据，命中则直接返回</li><li>缓存未命中，则从数据库查询，然后写入缓存，并返回给用户</li></ul><p>写策略为：</p><ul><li>更新数据库中的数据</li><li>删除缓存的数据</li></ul><p>先删除缓存再删数据或者先删数据库再删除缓存都会导致一定的问题，分析比较简单，不做具体说明。</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>如果新注册了一个用户，然后立刻发起了查询（此时缓存无法命中），如果查询走的是从库，而且存在一定的时延，那么会有可能查询不到个人信息。</p><p>解决办法就是在特定的场景下，我们可以修改后将修改的信息写入缓存当中，而不是删除。</p><p>而且该策略对于频繁的修改会导致缓存中的数据被频繁的清理，造成缓存命中率低。</p><p>两种解决办法：</p><ol><li><p>一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；</p></li><li><p>另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务的影响也是可以接受。</p></li></ol><h1 id="Read-x2F-Write-Through（读穿-x2F-写穿）策略"><a href="#Read-x2F-Write-Through（读穿-x2F-写穿）策略" class="headerlink" title="Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略"></a>Read&#x2F;Write Through（读穿 &#x2F; 写穿）策略</h1><p>这个策略的核心原则是用户只与缓存打交道，由缓存和数据库通信，写入或者读取数据。</p><p><strong>Write Through 的策略</strong>是这样的：先查询要写入的数据在缓存中是否已经存在，如果已经存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中，如果缓存中数据不存在，我们把这种情况叫做“Write Miss（写失效）”。</p><p>如果发生写失效，则解决办法有以下两种：</p><ul><li>Write Allocate（按写分配）：写入缓存相应位置，再由缓存组件同步更新到数据库中；</li><li>No-write allocate（不按写分配）：不写入缓存中，而是直接更新到数据库中。</li></ul><p><strong>Read Through 策略</strong>就简单一些，它的步骤是这样的：先查询缓存中数据是否存在，如果存在则直接返回，如果不存在，则由缓存组件负责从数据库中同步加载数据。</p><h1 id="Write-Back（写回）策略"><a href="#Write-Back（写回）策略" class="headerlink" title="Write Back（写回）策略"></a>Write Back（写回）策略</h1><p>这个策略的核心思想是在写入数据时只写入缓存，并且把缓存块儿标记为“脏”的。而脏块儿只有被再次使用时才会将其中的数据写入到后端存储中。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230430194034299.png" alt="image-20230430194034299" style="zoom:67%;" /><p><strong>如果使用 Write Back 策略的话，读的策略也有一些变化了。</strong></p><p>我们在读取缓存时如果发现缓存命中则直接返回缓存数据。</p><p>如果缓存不命中则寻找一个可用的缓存块儿，如果这个缓存块儿是“脏”的，就把缓存块儿中之前的数据写入到后端存储中，并且从后端存储加载数据到缓存块儿。</p><p>如果不是脏的，则由缓存组件将后端存储中的数据加载到缓存中，最后我们将缓存设置为不是脏的，返回数据就好了。</p><p>这个策略一般不直接在生产环境中使用，往往是计算机结构中使用，比如说操作系统层面的 Page Cache，日志的异步刷盘，消息队列中消息的异步写入磁盘等。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《高并发系统设计》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Cache-Aside（旁路缓存）策略&quot;&gt;&lt;a href=&quot;#Cache-Aside（旁路缓存）策略&quot; class=&quot;headerlink&quot; title=&quot;Cache Aside（旁路缓存）策略&quot;&gt;&lt;/a&gt;Cache Aside（旁路缓存）策略&lt;/h1&gt;&lt;p&gt;读策</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="高并发系统设计" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="缓存篇" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E7%BC%93%E5%AD%98%E7%AF%87/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP连接的管理</title>
    <link href="http://example.com/2023/04/30/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2023/04/30/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%AE%A1%E7%90%86/</id>
    <published>2023-04-30T02:49:26.000Z</published>
    <updated>2023-04-30T03:32:19.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="建立连接过程"><a href="#建立连接过程" class="headerlink" title="建立连接过程"></a>建立连接过程</h1><p>TCP建立连接的过程如下：</p><p><strong>第一步</strong>：客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段。该报文段中不包含应用层数据。该报文段会将首部中的SYN置为1，这个特殊报文段被称为SYN报文段。</p><p>客户会随机地选择一个初始序号（client_isn）,并将此编号放置于该起始的TCP SYN报文段的序号字段中。该报文段会被封装在一个IP数据报中，并发送给服务器。</p><p><strong>第二步</strong>：一旦包含TCP SYN报文段的IP数据报到达服务器主机，服务器会从该数据报中提取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段。这个允许连接的报文段也不包含应用层数据。</p><p>在报文段的首部包含3个重要的信息。首先，SYN比特被置为1。其次，该TCP报文段首部的确认号字段被置为client _ isn + 1。最后，服务器选择自己的初始序号（server_isn）,并将其放置到TCP报文段首部的序号字段中。</p><p>这个允许连接的报文段实际上表明了： “我收到了你发起建立连接的SYN分组，该分组带有初始序号client_isn。我同意建立该连接。我自己的初始序号是server_isn。该允许连接的报文段被称为SYNACK报文段（SYNACK segment）。</p><p><strong>第三步</strong>：在收到SYNACK报文段后，客户也要给该连接分配缓存和变量。客户主机则向服务器发送另外一个报文段；这最后一个报文段对服务器的允许连接的报文段进行了确认（该客户通过将值server_isn + 1放置到TCP报文段首部的确认字段中来完成此项工作）。</p><p>该三次握手的第三个阶段可以在报文段负载中携带客户到服务器的数据。 </p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230430112825050.png" alt="image-20230430112825050" style="zoom:67%;" /><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>也就是说，第一步客户端先发起一个报文段请求，用于表明我想要建立连接，不携带数据。</p><p>第二步，服务器收到请求，允许建立连接，分配缓存，然后给客户端通知该消息，也不携带数据。</p><p>第三步，客户端收到服务端同意建立连接的请求，然后给服务端回应，我收到了你的同意建立连接。第三步其实是一个确认的消息，只不过可以携带一部分数据。</p><h1 id="终止连接的过程"><a href="#终止连接的过程" class="headerlink" title="终止连接的过程"></a>终止连接的过程</h1><p>当连接结束后,主机中的“资源”（即缓存和变量）将被释放。</p><p>当客户想要关闭连接，它会向服务端发送一个特殊的报文，服务端收到后会给他一个ACK响应。然后服务端发送自己的终止报文段，客户端收到后会给该终止报文段一个确认。之后，两台主机上用于该连接的所有资源都被释放。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230430113216637.png" alt="image-20230430113216637" style="zoom:67%;" /><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《计算机网络：自顶向下方法》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;建立连接过程&quot;&gt;&lt;a href=&quot;#建立连接过程&quot; class=&quot;headerlink&quot; title=&quot;建立连接过程&quot;&gt;&lt;/a&gt;建立连接过程&lt;/h1&gt;&lt;p&gt;TCP建立连接的过程如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步&lt;/strong&gt;：客户端的TCP首先向服务</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="运输层" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
    
    <category term="-运输层" scheme="http://example.com/tags/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>消息模型：主题和队列区别</title>
    <link href="http://example.com/2023/04/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%BB%E9%A2%98%E5%92%8C%E9%98%9F%E5%88%97%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2023/04/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%BB%E9%A2%98%E5%92%8C%E9%98%9F%E5%88%97%E5%8C%BA%E5%88%AB/</id>
    <published>2023-04-28T06:51:06.000Z</published>
    <updated>2023-04-28T07:09:42.199Z</updated>
    
    <content type="html"><![CDATA[<p><strong>早期的消息队列，就是按照“队列”的数据结构来设计的。</strong>我们一起看下这个图，生产者（Producer）发消息就是入队操作，消费者（Consumer）收消息就是出队也就是删除操作，服务端存放消息的容器自然就称为“队列”。</p><p>以下是最初的一种消息模型：队列模型</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230428145326054.png" alt="image-20230428145326054" style="zoom:67%;" /><p>这种模型中，消费者之间是竞争关系，每个消息只能被一个消费者消费。</p><p>但是如果想要一个消息被多个消费者消费，比如说对于一个订单消息，风控系统，分析系统，支付系统都需要得到该订单的信息，那么采用这种模型的话就需要为每一个消费者创建一个队列，但是这样做就需要提前知道有多少个消费者，违背了解耦。</p><p>为了解决这个问题，演化出了另外一种消息模型：“<strong>发布 - 订阅模型（Publish-Subscribe Pattern）</strong>”。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230428145647672.png" alt="image-20230428145647672" style="zoom:67%;" /><p>以上两种模型的区别就是，<strong>一份消息数据能不能被消费多次的问题。</strong></p><h1 id="RabbitMQ-的消息模型"><a href="#RabbitMQ-的消息模型" class="headerlink" title="RabbitMQ 的消息模型"></a>RabbitMQ 的消息模型</h1><p>rabbitmq采用队列模型，它用了一个交换机来解决多个消费者消费同一条消息的问题。</p><p>生产者不关心消息发送给哪个消费者，它只需要发送给交换机，由交换机决定发送给哪个消费者。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230428145907388.png" alt="image-20230428145907388" style="zoom:67%;" /><h1 id="RocketMQ-的消息模型"><a href="#RocketMQ-的消息模型" class="headerlink" title="RocketMQ 的消息模型"></a>RocketMQ 的消息模型</h1><p>RocketMQ 使用的消息模型是标准的发布 - 订阅模型。但是它也有队列的概念。</p><p>几乎所有的消息队列都采用<strong>请求-确认机制</strong>，即生产者将消息发送给服务端，服务端收到并写入队列后，会给生产者发送确认响应。而消费端，消费者收到消息并处理完后，也会给服务端发送消息，服务端在收到确认消息后，才会判定消息被消费成功。上面两种，如果没收到确认消息，会重试。</p><p>但是这样也存在一个问题，即还没收到一个消息的确认信息时，只能等待，而不能去执行第二条消息，这样是为了保证消息的顺序性。</p><p>为了解决这个问题，RocketMQ引入了队列的概念。</p><p><strong>每个主题包含多个队列，通过多个队列来实现多实例并行生产和消费。</strong>RocketMQ 只在队列上保证消息的有序性，主题层面是无法保证消息的严格顺序的。</p><p>RocketMQ 中，订阅者的概念是通过消费组（Consumer Group）来体现的。每个消费组都消费主题中一份完整的消息，不同消费组之间消费进度彼此不受影响，也就是说，一条消息被 Consumer Group1 消费过，也会再给 Consumer Group2 消费。</p><p>一个消费组中的消费者是竞争关系，一条消息只会被消费组中的一个消费者消费。</p><p>由于每一条消息需要被多个消费组消费，所以消费完的消息并不会立即被删除，这就需要 RocketMQ 为每个消费组在每个队列上维护一个消费位置（Consumer Offset），这个位置之前的消息都被消费过，之后的消息都没有被消费过，每成功消费一条消息，消费位置就加一。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230428150934219.png" alt="image-20230428150934219"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;早期的消息队列，就是按照“队列”的数据结构来设计的。&lt;/strong&gt;我们一起看下这个图，生产者（Producer）发消息就是入队操作，消费者（Consumer）收消息就是出队也就是删除操作，服务端存放消息的容器自然就称为“队列”。&lt;/p&gt;
&lt;p&gt;以下是最初</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="消息队列" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>分库分表时如何保证id唯一</title>
    <link href="http://example.com/2023/04/27/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%97%B6%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81id%E5%94%AF%E4%B8%80/"/>
    <id>http://example.com/2023/04/27/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%97%B6%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81id%E5%94%AF%E4%B8%80/</id>
    <published>2023-04-27T13:38:43.000Z</published>
    <updated>2023-04-28T07:19:05.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主键如何选择"><a href="#主键如何选择" class="headerlink" title="主键如何选择"></a>主键如何选择</h1><p>1、使用业务字段作为主键，比如说对于用户表来说，可以使用手机号，email 或者身份证号作为主键。</p><p>2、使用生成的唯一 ID 作为主键。</p><p>但是第一种并不是每一张表都可以使用的，一些特殊的字段可以使用，比如说身份证，邮箱，手机号，但是这些字段可能存在变更的情况，就比较麻烦，所以最好采取第二种方案。</p><p>第二种方案在单表时，可以采用简单的自增id来实现，但是在分库分表的情况下却并不能这样，因为不同库和不同表的自增id会重复。我们需要采取一些其他的办法来实现。</p><h1 id="基于-Snowflake-算法搭建发号器"><a href="#基于-Snowflake-算法搭建发号器" class="headerlink" title="基于 Snowflake 算法搭建发号器"></a>基于 Snowflake 算法搭建发号器</h1><p>首先一点是，为什么不采用uuid来当作主键 ？</p><p>1、id最好是有序的，某些场景会需要排序，如果按照id则效率高一点，而且id有序分区也会简单。</p><p>2、id有序时，将其作为主键，插入数据时效率也会高，如果采用无序的插入，可能会频繁的导致页分裂。</p><p>3、uuid作为主键可能会占用大量的空间。</p><p>4、uuid并不具备业务含义。</p><h2 id="Snowflake-算法"><a href="#Snowflake-算法" class="headerlink" title="Snowflake 算法"></a>Snowflake 算法</h2><p>Snowflake 的核心思想是将 64bit 的二进制数字分成若干部分，每一部分都存储有特定含义的数据，比如说时间戳、机器 ID、序列号等等，最终生成全局唯一的有序 ID。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230427220731511.png" alt="image-20230427220731511"></p><p>其中机器ID可以用来标识在不同的机房，12位序列号代表着每个节点每毫秒最多可以生成 4096 的 ID。也可以根据不同的业务来规定每一部分的长度。</p><h2 id="具体实现方式"><a href="#具体实现方式" class="headerlink" title="具体实现方式"></a>具体实现方式</h2><p>1、<strong>嵌入到业务代码里，也就是分布在业务服务器中。</strong></p><p>这样实现的好处是不需要跨网络调用，性能会好一点。但是业务层的部署可能存在很多分，这就要求我们用更多的机器位，来确保唯一性。</p><p>2、<strong>作为独立的服务部署，这也就是我们常说的发号器服务。</strong></p><p>这种部署方式需要业务层多一次网络请求来获取id，但是可以减少机器id的位数，留更多的位数给自增信息位。</p><p>该算法的一个缺点是依赖于子系统的时间戳，一旦系统时间不准，就有可能生成重复的id。所以当我们发现系统时钟不准时，就可以让发号器拒绝发号，一直到时钟准为止。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《高并发系统设计 40 问》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;主键如何选择&quot;&gt;&lt;a href=&quot;#主键如何选择&quot; class=&quot;headerlink&quot; title=&quot;主键如何选择&quot;&gt;&lt;/a&gt;主键如何选择&lt;/h1&gt;&lt;p&gt;1、使用业务字段作为主键，比如说对于用户表来说，可以使用手机号，email 或者身份证号作为主键。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="高并发系统设计" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="数据库篇" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/"/>
    
    
    <category term="分库分表" scheme="http://example.com/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>MySQL分库分表</title>
    <link href="http://example.com/2023/04/27/MySQL/MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>http://example.com/2023/04/27/MySQL/MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</id>
    <published>2023-04-27T12:09:52.000Z</published>
    <updated>2023-04-27T13:37:30.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><p>分库分表是一种常见的数据分片方式，它不同于集群那种完全的备份数据，而是每个数据库或者每张表只存储整个数据的一部分，这样可以保证总数据量不变的情况下，每个数据库和每张表少存储一些数据。</p><p>而且在数据写入时，也会变为往一个库或者一张表写变为往多个库或者多张表写，提高并发写入能力。</p><h1 id="如何对数据库做垂直拆分"><a href="#如何对数据库做垂直拆分" class="headerlink" title="如何对数据库做垂直拆分"></a>如何对数据库做垂直拆分</h1><p>垂直拆分就是对数据库竖着拆分，也就是将<strong>数据库的表</strong>拆分到多个<strong>不同的数据库中</strong>。</p><p>垂直拆分的原则一般是按照业务类型来拆分，核心思想是专库专用，将业务耦合度比较高的表拆分到单独的库中。</p><h1 id="如何对数据库做水平拆分"><a href="#如何对数据库做水平拆分" class="headerlink" title="如何对数据库做水平拆分"></a>如何对数据库做水平拆分</h1><p>水平拆分指的是将<strong>单一数据表</strong>按照某一种规则拆分到<strong>多个数据库</strong>和<strong>多个数据表</strong>中，关注点在数据的特点。</p><h2 id="拆分规则"><a href="#拆分规则" class="headerlink" title="拆分规则"></a>拆分规则</h2><p>1、按照某一个字段的哈希值做拆分，这种拆分规则比较适用于实体表。</p><p>比如说我们想把用户表拆分成 16 个库，每个库是 64 张表，那么可以先对用户 ID 做哈希，哈希的目的是将 ID 尽量打散，然后再对 16 取余，这样就得到了分库后的索引值；对 64 取余，就得到了分表后的索引值。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230427202234676.png" alt="image-20230427202234676" style="zoom:67%;" /><p>2、按照某一个字段的区间来拆分，比较常用的是时间字段。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230427202322368.png" alt="image-20230427202322368" style="zoom:67%;" /><h1 id="分库分表带来的问题"><a href="#分库分表带来的问题" class="headerlink" title="分库分表带来的问题"></a>分库分表带来的问题</h1><p>分库分表引入的一个最大的问题就是<strong>引入了分库分表键，也叫做分区键，</strong>也就是我们对数据库做分库分表所依据的字段。</p><p>这也就要求我们后续所有的查询都要带上分区或者分库所用的字段，否则就要遍历所有的库。</p><p>一个解决办法就是，我们可以建立一个其他字段和分区字段的映射，当需要根据其他字段查找时，我们先找到它所对应的id，然后再根据id来查询这个具体的值。</p><p>另一方面，我们无法通过join来连接两个库的表，只能查询到后端然后进行处理。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《高并发系统设计 40 问》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分库分表&quot;&gt;&lt;a href=&quot;#分库分表&quot; class=&quot;headerlink&quot; title=&quot;分库分表&quot;&gt;&lt;/a&gt;分库分表&lt;/h1&gt;&lt;p&gt;分库分表是一种常见的数据分片方式，它不同于集群那种完全的备份数据，而是每个数据库或者每张表只存储整个数据的一部分，这样可以保</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="高并发系统设计" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="数据库篇" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/"/>
    
    
    <category term="分库分表" scheme="http://example.com/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>池化技术</title>
    <link href="http://example.com/2023/04/26/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <id>http://example.com/2023/04/26/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</id>
    <published>2023-04-26T06:40:53.000Z</published>
    <updated>2023-04-26T07:32:52.245Z</updated>
    
    <content type="html"><![CDATA[<p>在后端代码操作MySQL时，需要先与MySQL建立连接， 这个连接需要使用TCP的三次握手，比较的耗时，如果在正常的系统中，每一次执行sql，都要建立连接，连接使用完毕后断开连接，那么就会带来严重的性能影响。因此，池化技术就这样诞生了。</p><h1 id="连接池基本配置"><a href="#连接池基本配置" class="headerlink" title="连接池基本配置"></a>连接池基本配置</h1><p>MySQL连接池有两个重要配置，<strong>最小连接数</strong>和<strong>最大连接数</strong>。</p><p>如果连接池中有空闲的连接，则直接使用这些已经建立好的连接，如果已有的连接数超过最小连接数，但是没有超过最大连接数，来了新的连接请求，则创建新的连接处理请求。如果当前连接数大于等于最大连接数，则让新的请求排队，如果超时则抛出错误。</p><p>还有一种情况是，当前连接池中的连接数小于最小连接数，那么新到的连接请求会直接创建新的连接，而不会使用池子中的连接。</p><p>针对于连接池中的连接，我们可以启动一个线程定期检测连接池是否可用，如果不可用就关闭该连接。</p><h1 id="用线程池预先创建线程"><a href="#用线程池预先创建线程" class="headerlink" title="用线程池预先创建线程"></a>用线程池预先创建线程</h1><p>jdk1.5中就提供了池化技术。ThreadPoolExecutor 就是其中的一种，它有两个参数coreThreadCount 和 maxThreadCount。</p><ul><li><p>如果线程池中的线程数少于 coreThreadCount 时，处理新的任务时会创建新的线程；</p></li><li><p>如果线程数大于 coreThreadCount 则把任务丢到一个队列里面，由当前空闲的线程执行；</p></li><li><p>当队列中的任务堆积满了的时候，则继续创建线程，直到达到 maxThreadCount；</p></li><li><p>当线程数达到 maxTheadCount 时还有新的任务提交，那么我们就不得不将它们丢弃了。</p></li></ul><p>流程如下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230426152317089.png" alt="image-20230426152317089" style="zoom:67%;" /><p>注意：JDK原生的线程池会优先把任务放进队列，而不是优先创建线程，这种就比较适合CPU密集型的任务。</p><p>因为CPU密集型的任务，如果创建过多的线程去执行任务，那么这些任务会争抢线程，导致频繁的上下文切换，造成性能的损失。</p><p>但是我们平时开发的web项目，其实属于I&#x2F;O密集型的任务，因为牵扯到数据库，所以Tomcat就没有采用JDK自带的，而是做了改进，优先创建线程去处理请求。因为I&#x2F;O密集型的大多时间都花费在去磁盘取数据，这段时间并不需要CPU，所以可以创建更多的线程去处理请求。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《高并发系统设计 40 问》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在后端代码操作MySQL时，需要先与MySQL建立连接， 这个连接需要使用TCP的三次握手，比较的耗时，如果在正常的系统中，每一次执行sql，都要建立连接，连接使用完毕后断开连接，那么就会带来严重的性能影响。因此，池化技术就这样诞生了。&lt;/p&gt;
&lt;h1 id=&quot;连接池基本配</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="高并发系统设计" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="数据库篇" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/"/>
    
    
    <category term="连接池" scheme="http://example.com/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>TCP</title>
    <link href="http://example.com/2023/04/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/"/>
    <id>http://example.com/2023/04/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP/</id>
    <published>2023-04-25T02:12:15.000Z</published>
    <updated>2023-04-30T03:01:24.414Z</updated>
    
    <content type="html"><![CDATA[<p>TCP是面向连接的。而且提供的是全双工服务，即如果两台主机A和B相连，那么A可以给B发数据，B也可以给A发数据。TCP连接是点对点的，即在单个发送方与单个接收方之间的连接。</p><h1 id="建立连接的过程"><a href="#建立连接的过程" class="headerlink" title="建立连接的过程"></a>建立连接的过程</h1><p>客户首先发送一个特殊的TCP报文段，服务器用另一个特殊的TCP报文段来响应，最后，客户再用第三个特殊报文段作为响应。</p><p>前两个报文段不承载“有效载荷” ，也就是不包含应用层数据；而第三个报文段可以承载有效载荷。</p><h1 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h1><p>一旦建立了连接之后，就需要传输数据。当应用层数据通过套接字以后，数据就交由TCP控制。TCP将这些数据引导到该连接的发送缓存里，然后不时的从发送缓存里取出一块数据，并将数据传递到网络层。</p><img src="C:\Users\郭俊豪\AppData\Roaming\Typora\typora-user-images\image-20230425102632021.png" alt="image-20230425102632021" style="zoom:67%;" /><h1 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h1><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230425102923389.png" alt="image-20230425102923389" style="zoom:67%;" /><p>其中，32比特的序号字段和32比特的确认号字段被TCP发送方和接收方用来实现可靠数据传输服务。</p><p>接收窗口字段用来实现流量控制。</p><p>TCP被称为累计确认是因为它的确认号也是按组确认的。比如说收到了0-500的报文段，那么它发送给发送方的确认号就是501，如果收到0-500，和600-900，而没有收到501-599，那么确认号还是501。</p><p>TCP的发送方，也使用了流水线。</p><h1 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h1><p>由于网络层提供的服务（IP服务）是不可靠的，无法保证数据按序交付，也无法保证完整性。而TCP则是建立在IP提供的网络服务之上，它创建了一种可靠数据传输服务。</p><h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h2><p>TCP有一种机制，就是延长超时时间，比如说第一个字数据经过50ms，被却认为丢失，然后重发，那么第二个就会将超时时间设置为100ms，以此类推。但是这会导致超时的时间越来越长，增加了端到端的时延。</p><p>解决办法是引入了快速重传，即通过冗余的ACK确认，来得知是数据错误，而不需要等待超时时间到达。</p><p>冗余的ACK就是再次确认已经收到的某个报文段的ACK，而发送方之前也已经收到该报文段的ACK。</p><p>一个具体的例子就是，比如说ACK &#x3D; 3是一个数据的确认，而且发送方也已经接收到了ACK &#x3D; 3的确认帧，而接收方收到了数据5和6，没有收到4，此时接收方就会重传ACK &#x3D; 3的确认帧，如果重传超过3次，则TCP就启动快速重传，立即重传3之后的数据。</p><h2 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h2><p>回退N帧协议，假设分组n的确认报文丢失，那么它会重传n以及n以后的所有报文，尽管只丢失了n，其他的全部已经正确接收。</p><p>而TCP则是允许接收方有选择的确认失序报文段，而不是累计的确认正确的接收最后一个。当启用重传时，它就会跳过重传那些已经被接收方选择性确认过的报文段。</p><h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><p>TCP连接的每一侧都为该连接设置了接收缓存。没当TCP接收到正确，按序的字节后，就会将这些数据放入接收缓存，相关的应用就会从接收缓存中读取数据。但是如果应用读取的比较慢，而发送方发送的比较快，则会导致缓存溢出。</p><p>所以TCP提供了流量控制服务，以消除发送方发送过快导致接收方缓存溢出的可能。</p><p>TCP通过让发送方维护一个接收窗口的变量来实现流量控制。接收窗口用于给发送方指示，表明现在接收方还有多少可用的缓存空间。因为TCP是全双工通信的，所以说连接两端都会维护一个接收窗口。</p><p>这样一来，发送方只需要根据对应接收方的窗口大小来确定此时可以发送多少数据，就能保证不溢出。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《计算机网络：自顶向下方法》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;TCP是面向连接的。而且提供的是全双工服务，即如果两台主机A和B相连，那么A可以给B发数据，B也可以给A发数据。TCP连接是点对点的，即在单个发送方与单个接收方之间的连接。&lt;/p&gt;
&lt;h1 id=&quot;建立连接的过程&quot;&gt;&lt;a href=&quot;#建立连接的过程&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="运输层" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
    
    <category term="-运输层" scheme="http://example.com/tags/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>如何提高系统性能</title>
    <link href="http://example.com/2023/04/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD/"/>
    <id>http://example.com/2023/04/24/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD/</id>
    <published>2023-04-24T11:50:36.000Z</published>
    <updated>2023-04-24T12:24:03.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="性能的度量指标"><a href="#性能的度量指标" class="headerlink" title="性能的度量指标"></a>性能的度量指标</h1><p>1、平均值</p><p>平均值是把这段时间所有请求的响应时间数据相加，再除以总请求数。但是它存在一定的问题，可能这段时间有10000个请求，只有100个响应时间为100ms，其他都是1s，这样算下来平均值不太大，但是系统是有问题的。</p><p>2、最大值</p><p>即找到一段时间请求的响应时间的最大值。但是又过于敏感，如果只有一个请求响应是100ms，那么最大值就是100。</p><p>3、分位值</p><p>分位值有很多种，比如 90 分位、95 分位、75 分位。以 90 分位为例，我们把这段时间请求的响应时间从小到大排序，假如一共有 100 个请求，那么排在第 90 位的响应时间就是 90 分位值。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424200201337.png" alt="image-20230424200201337"></p><h1 id="高并发下的性能优化"><a href="#高并发下的性能优化" class="headerlink" title="高并发下的性能优化"></a>高并发下的性能优化</h1><p>加入说现在的系统中只有一个处理核心，执行的响应时间都在10ms以内，我们该如何优化呢？</p><h2 id="1-提高系统的处理核心数"><a href="#1-提高系统的处理核心数" class="headerlink" title="1. 提高系统的处理核心数"></a>1. 提高系统的处理核心数</h2><p>当提高了系统的处理核心数，那么我们就可以开更多的线程来同时处理请求。那么系统的吞吐量会变得大一点。但是并不意味着无限制的增加处理核心数可以一直的提高性能。随着并发进程数的增加，并行的任务对于系统资源的争抢也会愈发严重。在某一个临界点上继续增加并发进程数，反而会造成系统性能的下降。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424201739627.png" alt="image-20230424201739627" style="zoom: 67%;" /><h2 id="2、减少单次任务响应时间"><a href="#2、减少单次任务响应时间" class="headerlink" title="2、减少单次任务响应时间"></a>2、减少单次任务响应时间</h2><p>想要减少任务的响应时间，首先要看你的系统是 CPU 密集型还是 IO 密集型的。不同类型的系统性能优化方式不尽相同。</p><p>CPU 密集型系统中，需要处理大量的 CPU 运算，那么选用更高效的算法或者减少运算次数就是这类系统重要的优化手段。</p><p>IO 密集型系统指的是系统的大部分操作是在等待 IO 完成，这里 IO 指的是磁盘 IO 和网络 IO。我们熟知的系统大部分都属于 IO 密集型，比如数据库系统、缓存系统、Web 系统。</p><p>比方说，如果是数据库访问慢，那么就要看是不是有锁表的情况、是不是有全表扫描、索引加的是否合适、是否有 JOIN 操作、需不需要加缓存，等等；如果是网络的问题，就要看网络的参数是否有优化的空间，抓包来看是否有大量的超时重传，网卡是否有大量丢包等。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《高并发系统设计40问》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;性能的度量指标&quot;&gt;&lt;a href=&quot;#性能的度量指标&quot; class=&quot;headerlink&quot; title=&quot;性能的度量指标&quot;&gt;&lt;/a&gt;性能的度量指标&lt;/h1&gt;&lt;p&gt;1、平均值&lt;/p&gt;
&lt;p&gt;平均值是把这段时间所有请求的响应时间数据相加，再除以总请求数。但是它存在一</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="高并发系统设计" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>临时表为什么可以重名</title>
    <link href="http://example.com/2023/04/24/MySQL/%E4%B8%B4%E6%97%B6%E8%A1%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%8D/"/>
    <id>http://example.com/2023/04/24/MySQL/%E4%B8%B4%E6%97%B6%E8%A1%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%90%8D/</id>
    <published>2023-04-24T08:26:40.000Z</published>
    <updated>2023-04-24T10:47:11.650Z</updated>
    
    <content type="html"><![CDATA[<p> 临时表的一些特性：</p><p>1、创建语法：create temporary table</p><p>2、只有创建该表的session才可以访问，其他线程无法访问</p><p>3、临时表可以与普通表重名</p><p>4、session中有同名的临时表和普通表时，操作的都是临时表</p><h1 id="临时表应用"><a href="#临时表应用" class="headerlink" title="临时表应用"></a>临时表应用</h1><p>在分库分表的场景下，我们现在假设某一个大表ht 按照字段f分为了1024个表，分布在32个数据库上。如下图所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424170242139.png" alt="image-20230424170242139" style="zoom: 50%;" /><p>这种设计下，如果我们执行如下sql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select v from ht where f = N;</span><br></pre></td></tr></table></figure><p>因为该sql使用了分表的字段f，那么我们就可以直接找到数据所在的表。</p><p>但是如果是如下sql：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select v from ht where k &gt;= M order by t_modified desc limit 100;</span><br></pre></td></tr></table></figure><p>该sql没有使用到分表的字段f，那么只能到所有的分区中去查找满足条件的所有行，然后统一做order by 的操作。</p><p>这种情况下，有两种方法：</p><p>1、把所有的数据全部查到，然后交给代理层去做排序。这种方法的优点是MySQL查询会很快，但是需要代理层多做额外的处理。</p><p>2、把各个分库拿到的数据，汇总到一个MySQL实例的一个表中，然后在这个汇总实例上做逻辑操作。流程如下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424171857340.png" alt="image-20230424171857340" style="zoom:67%;" /><h1 id="为什么临时表可以重名？"><a href="#为什么临时表可以重名？" class="headerlink" title="为什么临时表可以重名？"></a>为什么临时表可以重名？</h1><p>MySQL维护数据表，除了物理上要有文件外，内存里面也有一套机制区别不同的表，每个表都对应一个table_def_key。</p><ul><li>一个普通表的table_def_key的值是由“库名+表名”得到的，所以如果你要在同一个库下创建两个同名的普通表，创建第二个表的过程中就会发现table_def_key已经存在了。</li><li>而对于临时表，table_def_key在“库名+表名”基础上，又加入了“server_id+thread_id”。</li></ul><p>也就是说，session A和sessionB创建的两个临时表t1，它们的table_def_key不同，磁盘文件名也不同，因此可以并存。</p><p>在实现上，每个线程都维护了自己的临时表链表。这样每次session内操作表的时候，先遍历链表，检查是否有这个名字的临时表，如果有就优先操作临时表，如果没有再操作普通表；在session结束的时候，对链表里的每个临时表，执行 “DROP TEMPORARY TABLE +表名”操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 临时表的一些特性：&lt;/p&gt;
&lt;p&gt;1、创建语法：create temporary table&lt;/p&gt;
&lt;p&gt;2、只有创建该表的session才可以访问，其他线程无法访问&lt;/p&gt;
&lt;p&gt;3、临时表可以与普通表重名&lt;/p&gt;
&lt;p&gt;4、session中有同名的临时表和普通表时，</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    <category term="其他" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="MySQL45讲" scheme="http://example.com/tags/MySQL45%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>流水线可靠数据传输协议</title>
    <link href="http://example.com/2023/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/2023/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/</id>
    <published>2023-04-24T06:24:35.000Z</published>
    <updated>2023-04-24T08:11:32.420Z</updated>
    
    <content type="html"><![CDATA[<p>rdt3.0虽然是一个正确的协议，但是很多人对于它的性能并不是很满意，因为它基于停等协议。而且是发送一个报文，就需要等待对方回复后才可以发送下一个，这很大程度上会影响性能。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424143036576.png" alt="image-20230424143036576" style="zoom:67%;" /><p>对此最简单的解决办法是，发送一个报文段后并不等待回复，而是继续发送，累计N个报文段后再等待对方回复，这样效率就会提高。如下图所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424143059781.png" alt="image-20230424143059781" style="zoom:67%;" /><p>这种技术也被称为流水线。有如下要求：</p><p>1、必须增加序号范围，而且每个分组有一个唯一的序号，用于确认是否正确传输。</p><p>2、协议的发送方和接收方都需要缓存多个分组，发送方需最低要缓存已经发送的但是对方还没确认的报文，用于重新发送。</p><p>3、解决流水线的差错恢复有两种基本方法：回退N步和选择重传</p><h1 id="回退N步（GBN）"><a href="#回退N步（GBN）" class="headerlink" title="回退N步（GBN）"></a>回退N步（GBN）</h1><p>该协议中，允许发送方发送N个分组而不需要等待确认。这里的N一般称为窗口长度，如果窗口里面的数据都没有被确认，则无法继续发送，如果有数据确认，则窗口向前移动，继续发送数据。如下图所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424144240644.png" alt="image-20230424144240644" style="zoom:80%;" /><p>该协议也被称为滑动窗口协议。该协议的发送方必须响应以下三类事件：</p><p>1、上层的调用。当上层调用时，发送方先检查窗口是否已满，即是否有N个数据未确认。如果没满，就产生分组并且发送，并更新变量。如果满了，就告诉上层窗口已满，让它过一段时间重试。</p><p>2、接受一个ACK。该协议中对序号为n的分组采用累计确认的方式，表明接收方已经接收到序号为n以前包括序号为n的所有分组。</p><p>3、超时事件。如果发送的数据超过一定时间还未收到回复，那么就需要重传所有已经发送但是还未确认收到的数据。</p><p>接收方也会有对应的要求：</p><p>如果接受方正确接收到一个分组为n的分组（即上一次交给应用层的分组号是n - 1），则会给发送方回复一个ACK，并将分组交给上层，其他情况都会丢弃该分组。因为接收方发送序号为n的ACK，意味着n以及n以前的数据都正确接收。</p><p>即接收方的逻辑如下图所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424145709764.png" alt="image-20230424145709764" style="zoom:67%;" /><h1 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h1><p>上述协议虽然提升了性能，但是也存在一些问题。比如，当窗口和带宽的时延比较大的时候，中间有一个分组的差错，就会导致大量的重传。</p><p>而选择重传就是只重传错误的分组，而不是重传某一个错误分组以后的所有分组。该协议的实现需要接收方也缓存一部分的数据，而且也要有窗口。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424151809822.png" alt="image-20230424151809822" style="zoom:67%;" /><p>具体来说就是缓存那些乱序到达的数据，比如现在已经确认接收了需要为3的分组，而分组4丢失了，此时又接收到了分组5以及后续的数据。此时分组5以及以后的都会被缓存，直到接收到4后，才会从缓存中按序读取，然后交付给上层。具体过程如下：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424151833002.png" alt="image-20230424151833002"></p><p>由上图可以看出，发送方和接收方的窗口内的数据并不总是一样的，这也就会导致以下问题：</p><h2 id="如何判断一个分组是重传还是一个新的分组呢？"><a href="#如何判断一个分组是重传还是一个新的分组呢？" class="headerlink" title="如何判断一个分组是重传还是一个新的分组呢？"></a>如何判断一个分组是重传还是一个新的分组呢？</h2><p>考虑下面例子中可能发生的情况，该例有包括4个分组序号0、1、2、3的有限序号范围且窗口长度为3。假定发送了分组0至2,并在接收方被正确接收且确认了。此时，接收方窗口落在第4、5、6个分组上，其序号分别为3、0、1。</p><p>现在考虑两种情况，第一种如下图：</p><p>对前3个分组的ACK丢失，因此发送方重传这些分组，接收方下一步要接收序号为0的分组，而他期望的分组却是序号为3的，而且它无法发现这是重传的前三个已经接收的分组，而会当作是分组3丢失，等待重传3，而接收传送过来的0和1，将他们放在缓存当中。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424152342787.png" alt="image-20230424152342787" style="zoom:67%;" /><p>下图的情况是，对前3个分组的ACK都被正确交付。因此发送方向前移动窗口并发送第4、5、6个分组，其序号分别为3、0、10序号为3的分组丢失，但序号为0的分组到达（一个包含新数据的分组）。</p><p>这时候接收方收到序号为0的分组时，他无法判断发送方是重发自己已经接收的序号0还是新发送的序号为0的分组。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230424152417252.png" alt="image-20230424152417252" style="zoom:67%;" /><p>显然，窗口长度比序号空间小1时协议无法工作。窗口长度必须小于或等于序号空间大小的一半。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;rdt3.0虽然是一个正确的协议，但是很多人对于它的性能并不是很满意，因为它基于停等协议。而且是发送一个报文，就需要等待对方回复后才可以发送下一个，这很大程度上会影响性能。&lt;/p&gt;
&lt;img src=&quot;https://image-1314238346.cos.ap-chon</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="运输层" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
    
    <category term="运输层" scheme="http://example.com/tags/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>MySQL读写分离存在的问题</title>
    <link href="http://example.com/2023/04/23/MySQL/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2023/04/23/MySQL/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2023-04-23T02:49:01.000Z</published>
    <updated>2023-04-23T05:43:57.915Z</updated>
    
    <content type="html"><![CDATA[<p>在MySQL的一主多从的架构中，往往有以下两种设计方案：</p><p>1、由客户端决定连接哪个数据库</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230423105127688.png" alt="image-20230423105127688" style="zoom:67%;" /><p>2、由代理决定请求分发到哪一个数据库</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230423105207833.png" alt="image-20230423105207833" style="zoom:67%;" /><p>但不管是哪种方案，都存在过期读的问题，即主库和从库存在一定的时延，用户刚做一个修改，然后立马发起查询，就有可能查到过期数据。以下给出几种解决方案。</p><h1 id="强制走主库"><a href="#强制走主库" class="headerlink" title="强制走主库"></a>强制走主库</h1><p>该方案将请求分为了两类：</p><p>1、必须拿到最新数据的，就强制走主库查询。</p><p>2、对于可以读取到旧数据的，就走从库查询。</p><h1 id="Sleep-方案"><a href="#Sleep-方案" class="headerlink" title="Sleep 方案"></a>Sleep 方案</h1><p>该方案的设计很简单，读从库之前先sleep一段时间。</p><p>它假设大多情况下主备延迟在1秒之内，所以简单的sleep可以拿到最新的数据。</p><h1 id="判断主备无延迟方案"><a href="#判断主备无延迟方案" class="headerlink" title="判断主备无延迟方案"></a>判断主备无延迟方案</h1><p>这里有几种办法，第一种是从库查询前，先判断seconds_behind_master是否已经等于0。如果还不等于0 ，那就必须等到这个参数变为0才能执行查询请求。</p><p>第二种和第三种方案，都是通过对比主库和从库的日志执行位点来判断是否有延迟，即通过对比主库和从库执行的日志，来判断，要比对比时间准确。</p><p>但是这里也存在问题，主库存在一部分日志刚刚提交，而从库还没收到该日志，也会导致有一定的延迟。</p><h1 id="配合semi-sync"><a href="#配合semi-sync" class="headerlink" title="配合semi-sync"></a>配合semi-sync</h1><p>这里引入了半同步复制，semi-sync做了这样的设计：</p><ol><li>事务提交的时候，主库把binlog发给从库；</li><li>从库收到binlog以后，发回给主库一个ack，表示收到了；</li><li>主库收到这个ack以后，才能给客户端返回“事务完成”的确认。</li></ol><p>这样可以保证如果从库发送过确认消息，就代表收到了日志。这样，semi-sync配合前面关于位点的判断，就能够确定在从库上执行的查询请求，可以避免过期读。</p><p>但是该方案适合一主一从的架构，如果一主多从，那么一个从库响应，就默认已经同步成功，但是其他从库不确定。如果此时查询走的是其他从库，则还是会有问题。</p><p>而且存在一种情况，如果高峰期日志写的很快，可能会导致主库位点一直不一致的情况，就出现从库迟迟无法响应的问题。</p><h1 id="等主库位点方案"><a href="#等主库位点方案" class="headerlink" title="等主库位点方案"></a>等主库位点方案</h1><p>该方案涉及到以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select master_pos_wait(file, pos[, timeout]);</span><br></pre></td></tr></table></figure><p>该命令在从库执行，参数file和pos指向从库上的某个文件以及对应位置，timeout可选，表示这个函数最多的等待时间。</p><p>这个命令正常返回的结果是一个正整数M，表示从命令开始执行，到应用完file和pos表示的binlog位置，执行了多少事务。</p><p>那么我们的查询逻辑变为以下：</p><p>1、主库执行完事务后，执行show master status得到当前主库执行到的File和Position；</p><p>2、从库查询之间，先执行master_pos_wait（File，Position）</p><p>3、如果返回 &gt;&#x3D; 0的正整数，则在该从库执行查询，否则到主库查询。</p><h1 id="GTID方案"><a href="#GTID方案" class="headerlink" title="GTID方案"></a>GTID方案</h1><p>该方案和上述等主库位点方案思路一致，只不过是后续MySQL做了优化。</p><p>我们不再需要去主库执行show master status来获取位点，而是主库执行完后，直接返回一个事务的GTID，然后从库执行时，只需要在从库执行select wait_for_executed_gtid_set(gtid1, 1)，该命令也是用于等待主从同步的命令。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL45讲》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在MySQL的一主多从的架构中，往往有以下两种设计方案：&lt;/p&gt;
&lt;p&gt;1、由客户端决定连接哪个数据库&lt;/p&gt;
&lt;img src=&quot;https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-2023042310</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    <category term="其他" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="MySQL45讲" scheme="http://example.com/tags/MySQL45%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>高并发系统的通用设计方案</title>
    <link href="http://example.com/2023/04/22/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%80%9A%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/"/>
    <id>http://example.com/2023/04/22/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%80%9A%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/</id>
    <published>2023-04-22T10:07:31.000Z</published>
    <updated>2023-04-22T10:29:26.107Z</updated>
    
    <content type="html"><![CDATA[<p>高并发系统的通用设计：</p><p>Scale-out（横向扩展）：采用分布式部署的方式把流量分流开，让每个服务器都承担一部分并发和流量。</p><p>缓存：使用缓存来提高系统的性能，就好比用“拓宽河道”的方式抵抗高并发大流量的冲击。</p><p>异步：在某些场景下，未处理完成之前我们可以让请求先返回，在数据准备好之后再通知请求方，这样可以在单位时间内处理更多的请求。</p><h1 id="Scale-out"><a href="#Scale-out" class="headerlink" title="Scale-out"></a>Scale-out</h1><p>这里牵扯到一个横向扩展（Scale-out）与纵向扩展（Scale-up）。其中纵向扩展是不断的提高单个cpu的处理能力，来处理更多的请求。而横向扩展则是指利用多个cpu资源来并行处理，来处理更多请求。</p><p>一般来说，在项目初期，我们可以采用纵向扩展，当单机无法承受时，再使用横向扩展。</p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>我们的数据都是存储在磁盘上的，而磁盘的读取速度特别的慢，会给处理请求带来很大的压力。所以产生了缓存。在现代的设计中，从操作系统到浏览器，从数据库到消息队列都可以看到缓存的影子。</p><p>由于缓存是基于内存读写的，所以速度要比磁盘读取快很多。如果能够能快的读写数据，那么每个请求的处理时间都会变短，那么就会提高系统的并发度。</p><h1 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h1><p>异步处理相对应的就是同步。</p><p>同步是指调用一个方法，需要等到该方法返回之后，才可以继续执行后续的操作。这种情况下，如果调用的方法响应时间太长的话，会导致后续的业务阻塞。</p><p>异步处理是指调用方法后，并不需要等待方法处理完，可以直接执行后续的请求。比如说，我们可以将请求放入队列当中，然后响应用户一个信息，等处理完结果后，再给用户反馈一下，这样可以处理更多的请求。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230422182314880.png" alt="image-20230422182314880"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《高并发系统设计40问》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;高并发系统的通用设计：&lt;/p&gt;
&lt;p&gt;Scale-out（横向扩展）：采用分布式部署的方式把流量分流开，让每个服务器都承担一部分并发和流量。&lt;/p&gt;
&lt;p&gt;缓存：使用缓存来提高系统的性能，就好比用“拓宽河道”的方式抵抗高并发大流量的冲击。&lt;/p&gt;
&lt;p&gt;异步：在某些场景下，</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="高并发系统设计" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>超越物理内存的策略</title>
    <link href="http://example.com/2023/04/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B6%85%E8%B6%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E7%AD%96%E7%95%A5/"/>
    <id>http://example.com/2023/04/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B6%85%E8%B6%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E7%AD%96%E7%95%A5/</id>
    <published>2023-04-21T12:47:18.000Z</published>
    <updated>2023-04-22T10:07:51.541Z</updated>
    
    <content type="html"><![CDATA[<p>当有足够的内存时，发生页错误，只需要将页加入内存即可，但是如果内存不够，就需要将内存中的一些页换出，放入磁盘中去。那么现在问题就在于，要将那些页面换出呢？</p><p>这些存在于内存中的页，可以看作是一个缓存，如果访问该页时，页在内存，就当作缓存命中，不在就是没命中，那么我们的目标就变为让缓存的命中率尽可能地提高。</p><h1 id="最优替换策略"><a href="#最优替换策略" class="headerlink" title="最优替换策略"></a>最优替换策略</h1><p>该替换策略是将最远的将来才会使用到的页替换出去，这样就能使得命中率最高，但是也很难实现，或者换种方式说，几乎无法实现。因为我们无法知道哪个页最远才会被使用，该算法只能作为一个比较使用。</p><h1 id="FIFO（先进先出）"><a href="#FIFO（先进先出）" class="headerlink" title="FIFO（先进先出）"></a>FIFO（先进先出）</h1><p>先进入系统的页就先被换出。优点是实现很简单。缺点是可能导致内存页命中率特别低，极端情况下还会为0。</p><h1 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h1><p>依靠随机数，替换出某些页。该策略实现页比较简单，但是依靠运气。</p><h1 id="利用历史数据：LRU"><a href="#利用历史数据：LRU" class="headerlink" title="利用历史数据：LRU"></a>利用历史数据：LRU</h1><p>该算法考虑历史使用数据，如果一个页被很频繁的使用，那么它应该是比较重要的，不应该被换出。那么那些最近最不经常使用的页，就会被换出内存。</p><p>这里使用了局部性原则，包括空间局部性和时间局部性。</p><p>面临的问题：</p><p>该算法要求我们，每次访问内存，都需要同步的做一些修改，来更新页面位于队列中的位置。为了记录那些页最少被访问，我们需要记录内存的引用，但是这些记录可能会导致占用大量空间。</p><p>如果通过硬件实现，比如给每个页设置一个时间，每次系统访问内存时，硬件去更新该时间，而需要替换出页时，扫描所有页找到最久的即可。但是页特别多的话，耗时非常高。</p><h1 id="近似的LRU"><a href="#近似的LRU" class="headerlink" title="近似的LRU"></a>近似的LRU</h1><p>该算法的实现需要硬件添加一个使用位。系统的每一个页都有一个存在位，该值是0或者1。每当该页被引用时，就将该位改为1。但是硬件不会将其置为0，这是由操作系统设置的。</p><p>该算法的实现是始终算法。即将所有的页放在一个循环队列中，时钟指针开始时指向某个页，当需要替换页时，会检查时钟指针指向的页的标记为是0还是1，如果是1就说明不适合换出，而0就将它换出。如果是1，就会找下一个页，一直到找到一个是0的为止。如果找完所有的页，还是没有0，那么就将所有的页都设置为0。</p><p>它的一个改进算法为，扫描到1的，不置换出该页，但是将标记位改为0，防止遍历完一遍后找不到为0的标记位。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当有足够的内存时，发生页错误，只需要将页加入内存即可，但是如果内存不够，就需要将内存中的一些页换出，放入磁盘中去。那么现在问题就在于，要将那些页面换出呢？&lt;/p&gt;
&lt;p&gt;这些存在于内存中的页，可以看作是一个缓存，如果访问该页时，页在内存，就当作缓存命中，不在就是没命中，那么</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>超越物理内存的机制</title>
    <link href="http://example.com/2023/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B6%85%E8%B6%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2023/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%B6%85%E8%B6%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E6%9C%BA%E5%88%B6/</id>
    <published>2023-04-20T14:04:38.000Z</published>
    <updated>2023-04-20T14:40:46.917Z</updated>
    
    <content type="html"><![CDATA[<p> 在本章之前，我们所做的假设都是将进程的所有页都可以放入内存当中，但实际情况是，物理内存无法存储这么多的页。而且，为了更大的地址空间，我们也需要更大的物理内存来存储更大的页表。</p><p>这里的一个解决办法就是，利用磁盘空间，也就是说将页表取出一部分，放入磁盘当中。而操作系统需要知道这些被换出的页存在于磁盘的哪个位置，以便后续将他们加载到内存当中。</p><h1 id="交换空间"><a href="#交换空间" class="headerlink" title="交换空间"></a>交换空间</h1><p>在磁盘上开辟一块空间，用于物理页的移入和移出，这些空间就称为交换空间。而交换空间的大小，决定了系统在某一时刻能够使用的最大内存页数。而且操作系统需要记得给定页的硬件地址。</p><h1 id="存在位"><a href="#存在位" class="headerlink" title="存在位"></a>存在位</h1><p>按照之前的设定，一个虚拟地址转换为物理地址，会先检查TLB（快速地址转换），如果命中，则直接从中获取到映射，速度很快。</p><p>如果未命中，则需要先去内存中去找页目录，然后从页目录中找到对应页表页（页表被分为了很多个页），然后从页表中找到对应的映射，之后再把它加入TLB中。</p><p>如果添加了交换空间，这里边就需要考虑页是否在内存中的情况，则需要多一个标记位，即存在位，用于标记该页是否在内存当中。</p><h1 id="页错误"><a href="#页错误" class="headerlink" title="页错误"></a>页错误</h1><p>如果访问的页不在内存当中，就会发生页错误。</p><p>发生页错误，可能是因为该页被换出磁盘，那么系统就需要从对应的磁盘当中去加载内存页，这也就要求操作系统需要知道被换出的页的存储位置。操作系统可以使用PTE（页表项）的某些位来存储硬盘地址。</p><p>当将该页加载到内存后，操作系统会更新页表，将该页标记为存在内存当中，并且更新页表项中对应位置，它之前是记录了在硬盘的地址，现在把他改为在内存中的地址。</p><h1 id="何时交换页"><a href="#何时交换页" class="headerlink" title="何时交换页"></a>何时交换页</h1><p>操作系统都会设置一个高水位线，也就是说并不会等到内存满了才执行换出，而是会预留一部分内存。当内存的使用情况超过高水位线时，就会从内存中清除页。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 在本章之前，我们所做的假设都是将进程的所有页都可以放入内存当中，但实际情况是，物理内存无法存储这么多的页。而且，为了更大的地址空间，我们也需要更大的物理内存来存储更大的页表。&lt;/p&gt;
&lt;p&gt;这里的一个解决办法就是，利用磁盘空间，也就是说将页表取出一部分，放入磁盘当中。而操</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized的使用</title>
    <link href="http://example.com/2023/04/20/Java/Synchronized%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/04/20/Java/Synchronized%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-04-20T07:27:09.000Z</published>
    <updated>2023-04-20T13:15:25.945Z</updated>
    
    <content type="html"><![CDATA[<p> 考虑如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncTest</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + count++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SyncTest</span> <span class="variable">syncTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyncTest</span>();</span><br><span class="line">        <span class="type">SyncTest</span> <span class="variable">syncTest1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SyncTest</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(syncTest, <span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(syncTest1, <span class="string">&quot;thread2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在run方法上加了synchronized，也就意味着锁住的是该对象，也就是synchronized（this），当我们实例化两个对象时，他们是互相不影响的，所以打印结果如下：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230420161141896.png" alt="image-20230420161141896" style="zoom: 80%;" /><p>另一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt) &#123;</span><br><span class="line">      <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">      target.balance += amt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写，在转账的场景中并不能解决问题。</p><p>因为synchronized锁的是当前对象，它并不能锁住传进来的target，也就是说，如果此时实例化的对象是A，然后调用A.transfer(B, 100),它只能锁住A的balance，并不能锁住B的balance还会存在另一个线程修改B的balance的问题。</p><p>一开始看到这里有一个疑问，为什么不直接在接口中锁主呢，像如下写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JSONObject <span class="title function_">testInterface</span><span class="params">(<span class="meta">@RequestBody</span> Map&lt;String, Object&gt; map)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> crudServiceImpl.getCrudValue(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法会导致另外一个问题，也就是说我在A给B转账时，会进行加锁，导致C给D转账的时候，也无法进行。也就是说这种写法会导致锁的粒度太大，在实际场景中是无法使用的。</p><p>第一个优化版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target, <span class="type">int</span> amt)</span>&#123;</span><br><span class="line">    <span class="comment">// 锁定转出账户</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">      <span class="comment">// 锁定转入账户</span></span><br><span class="line">      <span class="keyword">synchronized</span>(target)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt) &#123;</span><br><span class="line">          <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">          target.balance += amt;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写可以保证this 和target都被锁住，达到我们预期地效果。但是也存在问题，如果A给B转账地同时，B也要给A转账，那么就会出现死锁。两者同时锁this，也就是对象A和对象B都被锁住，然后往下执行时，发现请求资源已经被锁，导致死锁。</p><p>第二个优化版本，防止死锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Allocator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; als = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次性申请所有资源</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(Object from, Object to)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (als.contains(from) || als.contains(to)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            als.add(from);</span><br><span class="line">            als.add(to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 归还资源</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">(Object from, Object to)</span> &#123;</span><br><span class="line">        als.remove(from);</span><br><span class="line">        als.remove(to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">// actr应该为单例</span></span><br><span class="line">    <span class="keyword">private</span> Allocator actr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转账</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account target, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">        <span class="comment">// 一次性申请转出账户和转入账户，直到成功</span></span><br><span class="line">        <span class="keyword">while</span> (!actr.apply(<span class="built_in">this</span>, target));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 锁定转出账户</span></span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 锁定转入账户</span></span><br><span class="line">                <span class="keyword">synchronized</span>(target) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">                        target.balance += amt;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            actr.free(<span class="built_in">this</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个版本中，Allocator是一个单例，也就意味着只有一个，然后在加锁之前，先判断是否可以同时获取两个对象的锁，如果可以，再进行加锁。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>上述代码都忽略了在两个线程中new 出来的对象不是同一个的问题。也就是说，transfer里传入的对象，在另一个线程中也是这两个。仅作为演示破会死锁。</p><p>而事实情况是，如果这段代码放在两个不同的线程中运行，线程A实例化account C和D，线程B实例化account C和D，在线程A执行transfer（C，D），在线程B执行transfer（D，C）还是有可能会发生死锁。</p><p>而上述代码的逻辑是建立在线程A 实例化的C和D 与线程B实例化的C和D是同一个对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 考虑如下代码&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>可靠数据传输原理</title>
    <link href="http://example.com/2023/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2023/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/</id>
    <published>2023-04-20T02:51:07.000Z</published>
    <updated>2023-04-21T03:01:09.568Z</updated>
    
    <content type="html"><![CDATA[<p>实现可靠传输是靠<strong>可靠数据传输协议</strong>来完成的，而该协议却建立在不可靠的下层协议上。就好比TCP提供可靠传输，而TCP却是建立在IP协议这个不可靠协议的基础上。</p><p>以下的讨论都是单向数据传输，而且暂且只考虑损坏比特或者整个报文段丢失的情况，而不考虑乱序到达的情况。</p><h1 id="rdt1-0：经完全可靠信道传输"><a href="#rdt1-0：经完全可靠信道传输" class="headerlink" title="rdt1.0：经完全可靠信道传输"></a>rdt1.0：经完全可靠信道传输</h1><p>该协议只考虑最简单的情况，即底层信道完全可信。</p><p>因为默认信道传输可信，那么它的发送端只等待来自上层的调用，接受端只等待来自下层的调用，发送端将数据发送出去之后，就不需要再管，默认一定会到达接收端。</p><p>而且这里也假定了接收方的接受速率和发送方的一致。</p><h1 id="rdt2-0：具有比特差错信道的可靠数据传输"><a href="#rdt2-0：具有比特差错信道的可靠数据传输" class="headerlink" title="rdt2.0：具有比特差错信道的可靠数据传输"></a>rdt2.0：具有比特差错信道的可靠数据传输</h1><p>在该协议中，我们只假定发送的比特可能会受损，而不考虑它们可能存在乱序到达或者丢失的情况。</p><p>这里可以类比打电话，我们说一句，对方听到后就会对其进行响应，如果没听清，一般会说让我们再说一边。</p><p>在该协议中，使用了肯定确认和否定确认，发送方收到肯定确认意味着接收方成功收到了数据，而否定确认意味着接收方收到的比特有误，需要重传。基于这种机制的协议叫做<strong>自动重传请求协议</strong>。</p><p>它最主要的是三点：</p><p>1、差错检测。它需要能够检测出传送的比特流是否有误。</p><p>2、接受方反馈。接收方收到比特后，如果有误，需要给发送方反馈。</p><p>3、重传。发送方收到接收方的否定确认后，需要重新传送刚刚发送的比特。</p><p>一个更具体地例子，发送方发送数据后，需要等待接收方返回一个确认分组。该分组可以是ACK或者NAK。收到ACK说明接收方正确收到分组，而受到NAK则说明有误，需要重传。而发送方发送数据后，只能等待接受对方响应的分组，这种设计也叫做<strong>停等协议</strong>。</p><p><strong>致命缺点：没有考虑ACK或者NAK分组受损的情况。</strong></p><p>简单的解决办法：发送方将发送的数据分组编号，接收方只需要根据序号就可以确定该数据分组是否被重发。这样一来，发送方接受到的AKC或者NAK由于受损而表意不明确时，直接重新发送即可。</p><h1 id="rdt3-0：具有比特差错的丢包信道的可靠传输"><a href="#rdt3-0：具有比特差错的丢包信道的可靠传输" class="headerlink" title="rdt3.0：具有比特差错的丢包信道的可靠传输"></a>rdt3.0：具有比特差错的丢包信道的可靠传输</h1><p>到这里，就不仅要考虑比特受损的情况，还要考虑比特丢失的情况。</p><p>在该协议下，我们让发送方负责检测和恢复丢包工作。假如发送方发送的数据分组丢了，那么接收方就无法响应该分组的ACK确认（因为发送的数据分组都有序号），发送方在未收到ACK时，不论是ACK丢失还是数据分组丢失，直接重传数据即可。</p><p>但是这个等待的时间也有要求，最低为一个数据分组从发送方到接收方以及从接收方返回发送方的时间和。这里就需要引入一个计时器，超过时间需要重传。</p><p>这里还要求发送方和接收方信道中引入<strong>冗余数据分组</strong>，这里面要存储已经发送了但是还没收到确认帧的数据。</p><p>该协议解决问题的核心点在于：</p><p>1、差错检测</p><p>2、数据分组增加编号</p><p>3、接收方的响应</p><p>4、一个计时器</p><p>5、冗余数据分组</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;实现可靠传输是靠&lt;strong&gt;可靠数据传输协议&lt;/strong&gt;来完成的，而该协议却建立在不可靠的下层协议上。就好比TCP提供可靠传输，而TCP却是建立在IP协议这个不可靠协议的基础上。&lt;/p&gt;
&lt;p&gt;以下的讨论都是单向数据传输，而且暂且只考虑损坏比特或者整个报文段丢失的</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="运输层" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
    
    <category term="运输层" scheme="http://example.com/tags/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>UDP</title>
    <link href="http://example.com/2023/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDP/"/>
    <id>http://example.com/2023/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDP/</id>
    <published>2023-04-20T01:53:33.000Z</published>
    <updated>2023-04-20T02:50:43.706Z</updated>
    
    <content type="html"><![CDATA[<p>UDP是面向无连接的，它没有拥塞控制。但是这里面存在一个问题，如果大量的UDP进行传输并且不经过控制，那么会导致整个网络的拥堵，造成大量UDP报文溢出，而且还会挤占TCP的通道，影响TCP通信。</p><p>UDP可以提供差错的检测，但是对于错误的报文段，却无法对其进行恢复，只能选择丢弃，或者交给应用程序，并发出警告。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;UDP是面向无连接的，它没有拥塞控制。但是这里面存在一个问题，如果大量的UDP进行传输并且不经过控制，那么会导致整个网络的拥堵，造成大量UDP报文溢出，而且还会挤占TCP的通道，影响TCP通信。&lt;/p&gt;
&lt;p&gt;UDP可以提供差错的检测，但是对于错误的报文段，却无法对其进行恢</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="运输层" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
    
    <category term="运输层" scheme="http://example.com/tags/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>分页：较小的表</title>
    <link href="http://example.com/2023/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E9%A1%B5%EF%BC%9A%E8%BE%83%E5%B0%8F%E7%9A%84%E8%A1%A8/"/>
    <id>http://example.com/2023/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E9%A1%B5%EF%BC%9A%E8%BE%83%E5%B0%8F%E7%9A%84%E8%A1%A8/</id>
    <published>2023-04-19T11:42:21.000Z</published>
    <updated>2023-04-19T14:35:36.346Z</updated>
    
    <content type="html"><![CDATA[<p>由于一个地址空间可能会对应很多页，从而导致每一个页表比较大。而每一个进程都有一个页表，则会给内存带来很大的压力。这里就是为了解决这个问题，如何让页表变得更小。</p><h1 id="更大的页"><a href="#更大的页" class="headerlink" title="更大的页"></a>更大的页</h1><p>我们可以让每一个页更大，如果每一个页可以对应更多的地址空间，那么页表需要存储的映射将会变少。这也意味着每一个页表会变得更小。</p><p>这种解决办法会带来新的问题，如果每个页太大，则会导致每个页所分配的内存用不完，导致内部碎片。</p><h1 id="分页和分段混合"><a href="#分页和分段混合" class="headerlink" title="分页和分段混合"></a>分页和分段混合</h1><p>在单独采用页表时，一个进程的地址空间映射可能如下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230419213904915.png" alt="image-20230419213904915" style="zoom:67%;" /><p>在上图中，一个地址空间会分为多个页，它单独对应一个页表。但是真正使用的空间却只有上图那些白色区域，而灰色区域是没有使用的，但是他们也被映射了具体的物理地址，而且这些映射还存在页表当中。</p><p>所以我们可以采用分段时的思想，不再将进程的整个空间分配单个页表，而是为进程的每个逻辑分段提供一个页表。</p><p>在上图的例子中，我们可以给代码段一个页表，给堆和栈分别一个页表。</p><p>在分段中，一个基址寄存器告诉我们每个段对应的物理地址，还有界限寄存器告诉我们段的大小。而在分段和分页混合的方案中，我们的基址寄存器存储的是该段的页表的物理地址。界限寄存器用于指示页表有有多少有效页。</p><p><strong>存在的问题</strong>：</p><p>如果存在一个大而稀疏的堆，那么还是要为他分配对应的物理空间，这些映射都要存储在页表当中，也会造成页表的浪费。</p><p>其次，这种杂合的方式会导致外部碎片产生。</p><h1 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h1><p>多级页表将线性页表变成了类似于树的东西。而且也是为了解决页表中存在着没有用的映射。</p><p>它的设计是，将页表分成页大小的单元。如果整个页的页表项都是无效的，就不为该页分配页表。为了追踪页表的页是否有效，以及有效页对应物理内存的位置，使用了一种页目录的新结构。</p><p>之前的页表与多级页表的对比如下图：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20230419222341075.png" alt="image-20230419222341075" style="zoom:67%;" /><p>上图左边，页表中存储了203以及204这两页对应的虚拟地址到物理地址的映射，但是这两页却没有存储任何内容。</p><p>而在右图，内存中存储了页目录，页目录标记了哪些页是使用过的，而此时的页表中也有多个页，我们只需要加载页表中两个页即可。这两个页存储了使用了的页的映射。</p><p>存在的问题：</p><p>如果TLB未命中，那么我们就需要从内存中访问两次，才可以找到虚拟地址到物理地址的映射。第一次用于访问页目录，从页目录中找到对应页表，第二次用于从页表中找到对应虚拟地址到物理地址的映射。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于一个地址空间可能会对应很多页，从而导致每一个页表比较大。而每一个进程都有一个页表，则会给内存带来很大的压力。这里就是为了解决这个问题，如何让页表变得更小。&lt;/p&gt;
&lt;h1 id=&quot;更大的页&quot;&gt;&lt;a href=&quot;#更大的页&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>分页：快速地址转换</title>
    <link href="http://example.com/2023/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E9%A1%B5%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/"/>
    <id>http://example.com/2023/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E9%A1%B5%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/</id>
    <published>2023-04-19T08:12:14.000Z</published>
    <updated>2023-04-19T08:59:23.485Z</updated>
    
    <content type="html"><![CDATA[<p>为了解决分页带来的额外内存访问，又引入了地址转换旁路缓冲存储器，又称TLB。它是一个硬件缓存，它记录了频繁发生的虚拟地址到物理地址的转换。</p><p>引入该缓存后，每次需要访问内存时，硬件会先检查TLB中是否有期望的映射，如果有就直接转换。</p><h1 id="TLB的基本算法"><a href="#TLB的基本算法" class="headerlink" title="TLB的基本算法"></a>TLB的基本算法</h1><p>硬件会先从虚拟地址中提取页号，然后检查TLB中是否有该页号（在引入TLB之前，这里需要直接访问一次内存，去读取页表），如果有，则可以根据TLB的值，经过计算得到正确的物理地址。</p><p>如果没有找到，那么硬件需要去内存访问页表，然后将映射更新到TLB当中，前提是该虚拟地址有效，而且我们有权限访问。</p><h1 id="上下文切换时对TLB的处理"><a href="#上下文切换时对TLB的处理" class="headerlink" title="上下文切换时对TLB的处理"></a>上下文切换时对TLB的处理</h1><p>引入TLB之后，我们在发生上下文切换时，要对TLB进行特殊的处理。因为TLB记录的是某一个进程的地址空间到物理地址的转换，如果切换进程，那么当前的TLB对于另一个进程是不可用的。</p><p>一种解决方案：</p><p>在发生上下文切换时，直接清空TLB，那么就不会有进程读到错误的TLB。但是也存在问题，每个进程刚运行时，都会发生TLB未命中。</p><p>第二种解决方案：</p><p>增加一个地址空间标识符，也可以看作是进程标识符，用于标识存储的内容是那个进程的映射。这样一来，TLB可以同时缓存多个进程的地址映射。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《操作系统导论》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了解决分页带来的额外内存访问，又引入了地址转换旁路缓冲存储器，又称TLB。它是一个硬件缓存，它记录了频繁发生的虚拟地址到物理地址的转换。&lt;/p&gt;
&lt;p&gt;引入该缓存后，每次需要访问内存时，硬件会先检查TLB中是否有期望的映射，如果有就直接转换。&lt;/p&gt;
&lt;h1 id=&quot;TL</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="内存虚拟化" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="虚拟化" scheme="http://example.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>MySQL怎么保证主备一致</title>
    <link href="http://example.com/2023/04/19/MySQL/MySQL%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4/"/>
    <id>http://example.com/2023/04/19/MySQL/MySQL%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E5%A4%87%E4%B8%80%E8%87%B4/</id>
    <published>2023-04-19T06:59:51.000Z</published>
    <updated>2023-04-19T07:20:53.857Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL在进行主备同步时，主库会直接把binlog拿到从库中去执行。这里就涉及到binlog的一些内容。</p><h1 id="binlog的三种格式"><a href="#binlog的三种格式" class="headerlink" title="binlog的三种格式"></a>binlog的三种格式</h1><p>binlog有三种格式，分别是statement，row和mixed。其中第三种是前两种的混合方式。</p><h2 id="这三种日志的区别"><a href="#这三种日志的区别" class="headerlink" title="这三种日志的区别"></a>这三种日志的区别</h2><p>假如说执行如下sql语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from t where a &gt;= 4 and t_modified &lt;= &#x27;2018-11-10&#x27; limit 1;</span><br></pre></td></tr></table></figure><p>如果说binlog的格式为statement，那么binlog中会记录一个事务，事务中会执行这个sql。也就是说，该设置下，相当于把该条sql语句直接拿到从库中去执行。</p><p>如果说格式为row，那么binglog中会记录很多的内容，但是总的来说，它能够根据这些内容，去从库中直接定位到主库删除的那一条记录。就比如说，主库删除主键是1的那一行，如果记录为row格式，那么从库一定可以定位到从库中主键是1的那一行。</p><p>为什么说要定位到从库主键是1的这一行呢？</p><p>因为如果格式为statement，那么直接在从库中执行上述语句，可能会导致一些主备不一致的情况。</p><p>上述语句，如果走索引a，那么会找到第一条a &gt;&#x3D; 4的记录后，就直接删除。而走索引t_modified，则会找到第一条满足t_modified &lt;&#x3D; ‘2018-11-10’的后，就直接删除。这样的话，如果主备的索引不一致，那么就会导致删除不同的行，导致主备不一致。</p><p>而mixed就是结合了两者的优点。因为row格式需要记录 太多的内容，会占用大量的空间。比如我删除10万行数据，row格式就需要10万条记录。而statement格式只需要记录一条sql，但有可能会导致主备不一致，所以采用结合的方式。由系统判断该sql是否会产生主备不一致的可能，如果会就用row记录，否则用statement。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL45讲》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MySQL在进行主备同步时，主库会直接把binlog拿到从库中去执行。这里就涉及到binlog的一些内容。&lt;/p&gt;
&lt;h1 id=&quot;binlog的三种格式&quot;&gt;&lt;a href=&quot;#binlog的三种格式&quot; class=&quot;headerlink&quot; title=&quot;binlog的三种</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    <category term="日志" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="MySQL45讲" scheme="http://example.com/tags/MySQL45%E8%AE%B2/"/>
    
  </entry>
  
</feed>
