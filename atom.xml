<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便起个名字吧</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-01-10T16:10:01.566Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Guo Junhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>乐观锁踩坑记录</title>
    <link href="http://example.com/2024/01/10/%E4%B9%90%E8%A7%82%E9%94%81%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2024/01/10/%E4%B9%90%E8%A7%82%E9%94%81%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</id>
    <published>2024-01-10T15:44:10.000Z</published>
    <updated>2024-01-10T16:10:01.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h1><p>背景：Excel的导入导出。由于数据量大，为了优化导出时的分页查询，插入数据时采用的是手动维护的自增id。</p><p>具体场景：如果有多个专家同时导入题库，如何保证手动维护自增id的不重复。</p><p>分析：由于同时多个专家同时导入的情况并不多见，为了不影响绝大多数的场景的性能，这里准备使用乐观锁来解决并发。</p><h1 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h1><p>使用EasyExcel，具体策略是单线程读取，然后使用线程池处理数据插入。核心的<code>LockCityDataListener</code>代码如下：</p><blockquote><p>注意，这一版代码是存在问题的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot_vue.utils.excel_util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.context.AnalysisContext;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.read.listener.ReadListener;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.util.ListUtils;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.toolkit.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> com.example.springboot_vue.mapper.CityMapper;</span><br><span class="line"><span class="keyword">import</span> com.example.springboot_vue.pojo.city.City;</span><br><span class="line"><span class="keyword">import</span> com.example.springboot_vue.rabbitmq_test.RabbitMQProvider;</span><br><span class="line"><span class="keyword">import</span> lombok.SneakyThrows;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.defaults.DefaultSqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DataSourceTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.support.DefaultTransactionDefinition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockCityDataListener</span> <span class="keyword">implements</span> <span class="title class_">ReadListener</span>&lt;City&gt; &#123;</span><br><span class="line"></span><br><span class="line">    CityMapper cityMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于标记当前申请的mark_id是否用完</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动开启事务</span></span><br><span class="line">    DataSourceTransactionManager dataSourceTransactionManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前申请到的起始id</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">currentStartNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里是设置批量插入数据的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BATCH_COUNT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;City&gt; cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">20</span>, <span class="number">40</span>, <span class="number">10</span>, TimeUnit.MINUTES, <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储所有错误数据，暂时没用</span></span><br><span class="line">    List&lt;List&lt;City&gt;&gt; wrongList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于使主线程等待所有异步线程结束</span></span><br><span class="line">    List&lt;CompletableFuture&lt;Integer&gt;&gt; allFutures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LockCityDataListener</span><span class="params">(CityMapper cityMapper, DataSourceTransactionManager dataSourceTransactionManager)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cityMapper = cityMapper;</span><br><span class="line">        <span class="built_in">this</span>.dataSourceTransactionManager = dataSourceTransactionManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(City city, AnalysisContext analysisContext)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里是手动开启事务</span></span><br><span class="line">            <span class="type">DefaultTransactionDefinition</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">            df.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);</span><br><span class="line">            <span class="type">TransactionStatus</span> <span class="variable">transaction</span> <span class="operator">=</span> dataSourceTransactionManager.getTransaction(df);</span><br><span class="line">            <span class="comment">// 注意</span></span><br><span class="line">            Map&lt;String, Object&gt; map = cityMapper.getTotalData();</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentData</span> <span class="operator">=</span> (<span class="type">int</span>) map.get(<span class="string">&quot;column_count&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取总行数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rowNumber</span> <span class="operator">=</span> analysisContext.readSheetHolder().getApproximateTotalRowNumber() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">resultNumber</span> <span class="operator">=</span> currentData + rowNumber;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> cityMapper.setData((Integer) map.get(<span class="string">&quot;version&quot;</span>), resultNumber);</span><br><span class="line">            <span class="comment">// 如果更新失败，就继续尝试更新</span></span><br><span class="line">            <span class="keyword">while</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 注意</span></span><br><span class="line">                map = cityMapper.getTotalData();</span><br><span class="line">                resultNumber = rowNumber + (<span class="type">int</span>) map.get(<span class="string">&quot;column_count&quot;</span>);</span><br><span class="line">                <span class="comment">// 注意</span></span><br><span class="line">                res = cityMapper.setData((Integer) map.get(<span class="string">&quot;version&quot;</span>), resultNumber);</span><br><span class="line">            &#125;</span><br><span class="line">            index = rowNumber;</span><br><span class="line">            currentStartNumber = (<span class="type">int</span>) map.get(<span class="string">&quot;column_count&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 手动提交事务</span></span><br><span class="line">            dataSourceTransactionManager.commit(transaction);</span><br><span class="line">        &#125;</span><br><span class="line">        city.setMarkId(++currentStartNumber);</span><br><span class="line">        cachedDataList.add(city);</span><br><span class="line">        index--;</span><br><span class="line">        <span class="comment">// 一次1000条，如果超过1000条，就清除之前的内容</span></span><br><span class="line">        <span class="keyword">if</span> (cachedDataList.size() &gt;= BATCH_COUNT) &#123;</span><br><span class="line">            List&lt;City&gt; tempList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(cachedDataList);</span><br><span class="line">            <span class="comment">// 存储完成清理 list</span></span><br><span class="line">            cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);</span><br><span class="line">            CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; saveData(tempList), executorService)</span><br><span class="line">                    .exceptionally(ex -&gt; &#123;</span><br><span class="line">                        wrongList.add(tempList);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;);</span><br><span class="line">            allFutures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里是处理遗留的数据</span></span><br><span class="line"><span class="comment">     * 注意：这里是每一个sheet读取完成后都会触发一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext analysisContext)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(cachedDataList)) &#123;</span><br><span class="line">            saveData(cachedDataList);</span><br><span class="line">            <span class="comment">// 这里如果不进行重置，如果每个sheet不是1000条数据，会存在多插入的情况</span></span><br><span class="line">            cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        CompletableFuture&lt;Void&gt; allCompleted = CompletableFuture.allOf(allFutures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>]));</span><br><span class="line">        allCompleted.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">saveData</span><span class="params">(List&lt;City&gt; cachedDataList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cityMapper.insertCityAll(cachedDataList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SQL如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select column_count, version from version_lock&quot;)</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getTotalData</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&lt;insert id=<span class="string">&quot;insertCityAll&quot;</span> parameterType=<span class="string">&quot;java.util.List&quot;</span>&gt;</span><br><span class="line">    insert into <span class="title function_">city</span><span class="params">(`name`, parent_name, `number`, column_1, column_2, mark_id)</span> values</span><br><span class="line">    &lt;foreach collection=<span class="string">&quot;list&quot;</span> separator=<span class="string">&quot;,&quot;</span> item=<span class="string">&quot;item&quot;</span>&gt;</span><br><span class="line">    (#&#123;item.name&#125;, #&#123;item.parentName&#125;, #&#123;item.number&#125;, #&#123;item.test&#125;, #&#123;item.test2&#125;, #&#123;item.markId&#125;)</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>当有两个线程同时进行插入时，但凡出现冲突，就会导致其中一个线程无限循环，另一个线程等待锁超时。</p><h1 id="具体原因"><a href="#具体原因" class="headerlink" title="具体原因"></a>具体原因</h1><p>问题出现在一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询数据</span></span><br><span class="line">Map&lt;String, Object&gt; map = cityMapper.getTotalData();</span><br><span class="line"><span class="comment">// 省略几行代码...</span></span><br><span class="line"><span class="comment">// 修改数据</span></span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> cityMapper.setData((Integer) map.get(<span class="string">&quot;version&quot;</span>), resultNumber);</span><br><span class="line"><span class="comment">// 如果更新失败，就继续尝试更新</span></span><br><span class="line"><span class="keyword">while</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 注意</span></span><br><span class="line">    map = cityMapper.getTotalData();</span><br><span class="line">    resultNumber = rowNumber + (<span class="type">int</span>) map.get(<span class="string">&quot;column_count&quot;</span>);</span><br><span class="line">    <span class="comment">// 注意</span></span><br><span class="line">    res = cityMapper.setData((Integer) map.get(<span class="string">&quot;version&quot;</span>), resultNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想一下，如果res为0，意味着两个线程同时查询数据，然后进行了更新，但是只有一个线程可以更新成功。另一个线程由于版本号不对进如while循环。</p><p>关键点来了，就是这个while循环，在进入时，当前事务并未结束（假设事务A），虽然另外一个线程提交了它的事务（假设事务B），但由于默认的隔离级别是<strong>可重复读</strong>，这意味着其他事务（事务B）所做的修改对于当前事务（事务A）是不可见的。也就意味着，哪怕事务A进入了循环，重新执行了查询，但是它查询到的数据和while循环之外查询到的是一致的。而Update进行修改时，它所做的是当前读，也就是说它可以读取到最新的数据。所以修改永远无法成功。</p><p>这样就出现了上面的场景，一个线程无限循环，而另一个线程由于无限循环的事务没有提交，一直处于等待状态，最终超时断开连接。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;业务场景&quot;&gt;&lt;a href=&quot;#业务场景&quot; class=&quot;headerlink&quot; title=&quot;业务场景&quot;&gt;&lt;/a&gt;业务场景&lt;/h1&gt;&lt;p&gt;背景：Excel的导入导出。由于数据量大，为了优化导出时的分页查询，插入数据时采用的是手动维护的自增id。&lt;/p&gt;
&lt;p&gt;具</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Redis变慢的原因</title>
    <link href="http://example.com/2023/12/29/Redis%E5%8F%98%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
    <id>http://example.com/2023/12/29/Redis%E5%8F%98%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0/</id>
    <published>2023-12-29T03:53:48.000Z</published>
    <updated>2023-12-29T03:54:24.177Z</updated>
    
    <content type="html"><![CDATA[<h3 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h3><p>这里主要涉及到一些时间复杂度比较高的查询或者聚合计算，要根据实际情况，使用合适的命令。可以通过<strong>查看 Redis 的响应延迟</strong>，来判断Redis是否真的变慢。</p><h3 id="文件系统AOF"><a href="#文件系统AOF" class="headerlink" title="文件系统AOF"></a>文件系统AOF</h3><p>Redis虽然是内存数据库，但为了保证数据不丢失，需要把数据写入到磁盘当中。而AOF的刷盘策略有以下三种：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231229113951578.png" alt="image-20231229113951578"></p><p>当使用<strong>evertsec</strong>时，允许丢失一秒的数据。这时候，使用后台子线程来进行fsync，并且是异步执行。这种情况下对主进程的影响并不会很大。</p><p>但是当写回策略配置为always时，情况就不一样了。为了确保每条数据都写入磁盘，Redis就不能使用后台子线程来进行fsync，因为这样无法知道是否写入完成。所以只能由主进程来执行，这大概率会影响性能。</p><p>另一方面，随着AOF文件的增大，还需要执行AOF重写，AOF重写采用的是后台子线程来进行，但是需要注意的是：</p><blockquote><p>AOF 重写会对磁盘进行大量 IO 操作，同时，fsync 又需要等到数据写到磁盘后才能返回，所以，当 AOF 重写的压力比较大时，就会导致 fsync 被阻塞。虽然 fsync 是由后台子线程负责执行的，但是，主线程会监控 fsync 的执行进度。</p><p>当主线程使用后台子线程执行了一次 fsync，需要再次把新接收的操作记录写回磁盘时，如果主线程发现上一次的 fsync 还没有执行完，那么它就会阻塞。</p><p>也就是说，当需要执行fsync时，并且此时正好在执行AOF重写，磁盘压力比较大，就会导致子线程的fsync操作被阻塞，这将会影响到下一次的主线程的写入。</p></blockquote><h3 id="操作系统Swap"><a href="#操作系统Swap" class="headerlink" title="操作系统Swap"></a>操作系统Swap</h3><p>内存 swap 是操作系统里将内存数据在内存和磁盘间来回换入和换出的机制。</p><p>这里就需要注意，如果物理机的内存不够时，就有可能将Redis中的数据换出，放入磁盘当中。这是出现查找命令，发现内存中没有，就需要从磁盘中加载到内存当中，这会严重影响性能。</p><h3 id="操作系统：内存大页"><a href="#操作系统：内存大页" class="headerlink" title="操作系统：内存大页"></a>操作系统：内存大页</h3><p>内存大页是linux新支持的一种机制。该机制支持2MB的大页，而通常的内存页分配是4KB。</p><p>内存大页一定程度上可以给Redis内存分配带来优势，但是需要注意的是，Redis 为了提供数据可靠性保证，需要将数据做持久化保存。这个写入过程由额外的线程执行，所以，此时，Redis 主线程仍然可以接收客户端写请求。</p><blockquote><p>客户端的写请求可能会修改正在进行持久化的数据。在这一过程中，Redis 就会采用<strong>写时复制机制</strong>，也就是说，一旦有数据要被修改，<strong>Redis 并不会直接修改内存中的数据</strong>，而是将这些数据拷贝一份，然后再进行修改。</p></blockquote><p>如果采用了内存大页，那么，即使客户端请求只修改 100B 的数据，Redis 也需要拷贝 2MB 的大页。解决方法就是关闭内存大页。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;命令使用&quot;&gt;&lt;a href=&quot;#命令使用&quot; class=&quot;headerlink&quot; title=&quot;命令使用&quot;&gt;&lt;/a&gt;命令使用&lt;/h3&gt;&lt;p&gt;这里主要涉及到一些时间复杂度比较高的查询或者聚合计算，要根据实际情况，使用合适的命令。可以通过&lt;strong&gt;查看 Redi</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Redis" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis的切片集群</title>
    <link href="http://example.com/2023/12/21/Redis%E7%9A%84%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4/"/>
    <id>http://example.com/2023/12/21/Redis%E7%9A%84%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4/</id>
    <published>2023-12-21T02:03:42.000Z</published>
    <updated>2023-12-23T02:04:55.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="切片集群"><a href="#切片集群" class="headerlink" title="切片集群"></a>切片集群</h2><p>切片集群，也叫分片集群，就是指启动多个 Redis 实例组成一个集群，然后按照一定的规则，把收到的数据划分成多份，每一份用一个实例来保存。</p><blockquote><p>这里需要注意的是，这多个实例对外其实是提供一个服务，因为每个实例只有所有数据的一部分，他们内部是5个，客户端在使用时其实只会感知到1个。</p></blockquote><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231221112358729.png" alt="image-20231221112358729"></p><h3 id="如何保存更多数据"><a href="#如何保存更多数据" class="headerlink" title="如何保存更多数据"></a>如何保存更多数据</h3><p>Redis应对数据量增多有两种办法：</p><ul><li>纵向扩展（scale up）：指的是升级单个Redis实例的配置资源，包括增加容量，使用更高配CPU等。</li><li>横向扩展（scale out）：增加Redis实例的个数。</li></ul><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231221112825594.png" alt="image-20231221112825594" style="zoom:80%;" /><p>纵向扩展实现起来最简单，换一个机器就可以，但是会面临问题，即内存越大，单实例存储的数据就越多，在进行RDB持久化时，主线程fork子进程时就可能阻塞。如果不要求持久化，是一个不错的选择。</p><p>而针对于特别大的数据量，更好的方案是切片集群。</p><h3 id="数据切片和实例的对应分布"><a href="#数据切片和实例的对应分布" class="headerlink" title="数据切片和实例的对应分布"></a>数据切片和实例的对应分布</h3><p>数据和实例之间如何对应，与Redis Cluster有关。</p><p>具体来说，Redis Cluster 方案采用哈希槽（Hash Slot，接下来我会直接称之为 Slot），来处理数据和实例之间的映射关系。在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。</p><p>首先根据键值对的 key，按照CRC16 算法计算一个 16 bit 的值；然后，再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。</p><p>在部署 Redis Cluster 方案时，可以使用 cluster create 命令创建集群，此时，Redis 会自动把这些槽平均分布在集群实例上。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231221154113991.png" alt="image-20231221154113991" style="zoom:80%;" /><p><strong>在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作</strong>。</p><h3 id="客户端定位"><a href="#客户端定位" class="headerlink" title="客户端定位"></a>客户端定位</h3><p>在定位键值对数据时，它所处的哈希槽是可以通过计算得到的，这个计算可以在客户端发送请求时来执行。</p><p>客户端和集群建立连接后。实例就会把哈希槽的分配信息发送给客户端。但是刚创建的时候，每个实例只知道自己的哈希槽，不知道其他的哈希槽信息，这时<strong>Redis实例会把自己的哈希槽信息发送给它相连接的其他实例，来完成哈希槽信息分配的扩散</strong>。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。</p><p>但是，哈希槽并不是一直不变的，最常见的有以下两种变化：</p><ul><li><p>在集群中，实例有新增或删除，Redis 需要重新分配哈希槽；</p></li><li><p>为了负载均衡，Redis 需要把哈希槽在所有实例上重新分布一遍。</p></li></ul><p>此时，Redis实例之间可以通过相互传递消息，获得最新的哈希槽分配。但是客户端是无从感知的。Redis Cluster提供了一种<strong>重定向机制</strong>。该机制，指的是客户端给一个实例发送读写操作时，这个实例上没有对应的数据，客户端需要给一个新的实例发送数据。</p><p>具体来说，如果请求的实例没有数据，那么该实例会给客户端返回拥有该数据的实例，然后客户端再次请求即可。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231221161342141.png" alt="image-20231221161342141" style="zoom:80%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;切片集群&quot;&gt;&lt;a href=&quot;#切片集群&quot; class=&quot;headerlink&quot; title=&quot;切片集群&quot;&gt;&lt;/a&gt;切片集群&lt;/h2&gt;&lt;p&gt;切片集群，也叫分片集群，就是指启动多个 Redis 实例组成一个集群，然后按照一定的规则，把收到的数据划分成多份，每一份用一</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Redis" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis的String</title>
    <link href="http://example.com/2023/12/15/Redis%E7%9A%84String/"/>
    <id>http://example.com/2023/12/15/Redis%E7%9A%84String/</id>
    <published>2023-12-15T02:06:27.000Z</published>
    <updated>2023-12-23T02:07:34.200Z</updated>
    
    <content type="html"><![CDATA[<p>假设，我们用String 类型存储一个键值对，他们的长度都是10位数，其实用两个8字节的Long类型表示就可以了。Long最大可以表示2^64次方，表示10为数字绝对没问题。</p><p>但是Redis中的String 类型表示这一对 key 和 val 却用了64字节，这是因为<strong>String类型实际上还需要额外的内存空间记录数据长度，空间使用，</strong>等信息。如果用String存储比较小的数据，额外的空间就显得比较大。</p><p>当我们保存64位有符号整数时，String类型会把它保存为一个8字节的Long类型整数，这种保存也叫 <strong>int 编码</strong>。如果保存的数据中包含字符串时，String 类型就会用 <strong>简单动态字符串（SDS）</strong>来保存。其结构如下图所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231222104741805.png" alt="image-20231222104741805" style="zoom:67%;" /><ul><li>buf：字节数组，保存实际的数据，为了表示数据结束，会在数组后加一个”\0”，这就会额外占用1个字节的开销。</li><li>len：占4个字节，表示buf已使用的长度。</li><li>alloc：占4个字节，表示buf的实际分配长度，一般大于len。</li></ul><p>对于String，除了SDS的额外开销，还有一个来自于<strong>RedisObjec</strong>t结构体的开销。</p><p>Redis 的数据类型有很多，而且，不同数据类型都有些相同的元数据要记录（比如最后一次访问的时间、被引用的次数等），所以，Redis 会用一个 RedisObject 结构体来统一记录这些元数据，同时指向实际数据。</p><p>一个 RedisObject 包含了 8 字节的元数据和一个 8 字节指针，这个指针再进一步指向具体数据类型的实际数据所在：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231222105622386.png" alt="image-20231222105622386" style="zoom:67%;" /><p>为了节省空间，Redis对Long类型和SDS的内存布局做了专门的设计。</p><p>一方面，当保存的是Long类型整数时，RedisObject中的指针就直接赋值为整数数据，不再使用额外的指针指向整数，节省了指针的空间开销。</p><p>另一方面，当保存的是字符串数据，并且字符串小于等于44时，RedisObject 中的元数据、指针和 SDS 是一块连续的内存区域，这样就可以避免内存碎片，这种布局被称为<strong>embstr编码</strong>。当字符串大于44字节时，Redis就不再把SDS和RedisObject布局在一起，而是给SDS分配单独空间，并用指针指向SDS结构，这种被称为<strong>raw编码</strong>。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231222111057985.png" alt="image-20231222111057985" style="zoom: 80%;" /><p>至此，十位数的key和十位数的val是Long类型整数，可以直接用int编码的RedisObject保存。每个int编码的RedisObject元数据部分占8字节，指针部分被直接赋值为8字节整数。此时，每个ID会使用16字节，加起来一共是32字节。与64字节还差32字节。</p><p>其实，<strong>Redis会使用一个全局哈希表保存所有键值对，哈希表每一项是一个dictEntry的结构体，用来指向一个键值对</strong>，三个指针一共24字节，如下图所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231222111723672.png" alt="image-20231222111723672" style="zoom:80%;" /><p>但是这样也只有24字节，还差了8字节。这里涉及到Redis使用的内存分配库<code>jemalloc</code>，该函数在分配内存时，会根据我们申请的字节数N，找一个比N大，但是最接近N的2的幂次数作为分配的空间，这样可以减少频繁分配次数。</p><p><strong>如何节省内存？</strong></p><p>Redis 有一种底层数据结构，叫压缩列表（ziplist）。压缩列表表头有三个字段，zlbytes、zltail 和 zllen，分别表示列表长度，列表尾的偏移量以及列表中的entry个数。压缩列表尾还有一个 zlend，表示列表结束。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231222112339962.png" alt="image-20231222112339962" style="zoom:80%;" /><p>每个entry又有以下及部分：</p><ul><li><strong>prev_len</strong>，表示前一个 entry 的长度。prev_len 有两种取值情况：1 字节或 5 字节。取值 1 字节时，表示上一个 entry 的长度小于 254 字节，取5时表示大于255字节。</li><li><strong>len</strong>：表示自身长度，4字节。</li><li><strong>encoding</strong>：表示编码方式，1字节。</li><li><strong>content</strong>：保存实际数据。</li></ul><p>这些 entry 会挨个儿放置在内存中，不需要再用额外的指针进行连接，这样就可以节省指针所占用的空间。</p><p>Redis 基于压缩列表实现了 List、Hash 和 Sorted Set 这样的集合类型，这样做的最大好处就是节省了 dictEntry 的开销。当你用 String 类型时，一个键值对就有一个 dictEntry，要用 32 字节空间。但采用集合类型时，一个 key 就对应一个集合的数据，能保存的数据多了很多，但也只用了一个 dictEntry，这样就节省了内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;假设，我们用String 类型存储一个键值对，他们的长度都是10位数，其实用两个8字节的Long类型表示就可以了。Long最大可以表示2^64次方，表示10为数字绝对没问题。&lt;/p&gt;
&lt;p&gt;但是Redis中的String 类型表示这一对 key 和 val 却用了64字节，</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Redis" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>如何保证消息不丢失</title>
    <link href="http://example.com/2023/12/11/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/"/>
    <id>http://example.com/2023/12/11/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/</id>
    <published>2023-12-11T01:48:02.000Z</published>
    <updated>2023-12-11T01:48:45.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何保证消息不丢失"><a href="#如何保证消息不丢失" class="headerlink" title="如何保证消息不丢失"></a>如何保证消息不丢失</h2><p>一般来讲，消息队列都会有一定的机制去保证消息的不丢失，丢失消息大多数是使用问题。</p><h3 id="检测消息是否丢失"><a href="#检测消息是否丢失" class="headerlink" title="检测消息是否丢失"></a>检测消息是否丢失</h3><p>这里有一个逻辑上的处理办法，就是发送消息时，给消息一个编号，然后利用消息的有序性来判断消息是否丢失。这里需要配合消息队列客户端的拦截机制去做，在拦截器中去检测消息的连续性，这样检测消息连续性的代码就不会侵入业务层。</p><p>但是需要注意的一点是，像Kafka和RocketMQ这种消息队列，<strong>他们并不能保证消息在Topic上是连续的，只能保证在分区内是连续的</strong>，那么我们在编号时，就需要按照分区来做消息的递增，确保编号连续性的检测是在每一个分区内部进行的。</p><p>如果producer是多实例的，由于并不好协调不同producer之间发送的顺序，所以该编号最好也是按照每个Producer单独递增的。</p><p>Consumer 实例的数量最好和分区数量一致，做到 Consumer 和分区一一对应，这样会比较方便地在 Consumer 内检测消息序号的连续性。</p><p>这里还需要考虑一种情况，就是消息重复发送的问题。因为难免会出现消息确认延迟，但实际上消息发送成功了，这时候，在消息的消费端，就需要保证消息的幂等性。要么给每条消息做标记，确保该消息只会消费一次，多次发送并不会消费该消息，要么保证一条消息多次消费的结果是一样的。</p><h3 id="确保消息的可靠传递"><a href="#确保消息的可靠传递" class="headerlink" title="确保消息的可靠传递"></a>确保消息的可靠传递</h3><p>消息的生产和消费一般分为一下几个阶段。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231207110009586.png" alt="image-20231207110009586"></p><ul><li><strong>生产阶段</strong>: 在这个阶段，从消息在 Producer 创建出来，经过网络传输发送到 Broker 端。</li><li><strong>存储阶段</strong>: 在这个阶段，消息在 Broker 端存储，如果是集群，消息会在这个阶段被复制到其他的副本上。</li><li><strong>消费阶段</strong>: 在这个阶段，Consumer 从 Broker 上拉取消息，经过网络传输发送到 Consumer 上。</li></ul><p>首先生产阶段，在编写代码时要注意，等收到Broker的响应确认后，再认为消息发送成功，否则进行重试。这样就可以保证在发送阶段消息的不丢失，换种说法，可以保证该条消息一定可以发送到Broker当中。</p><p>如果消息是异步发送的，我们需要在回调中，检查消息的发送结果。</p><p>而在于存储阶段，Broker不宕机是不会出现消息丢失的情况，这里涉及到刷盘策略，如果对于可靠性要求很高，可以将刷盘的频率调至最高频率。如果Broker是集群部署，则要确保发送到2个以上的节点，再给生产者返回存储成功。</p><p>消费阶段，这个阶段也是最容易代码编写出问题的阶段。该阶段不能在接收到消息后就给Broker返回消息确认，应该在业务代码全部执行完毕后，再返回消息确认，这时候Broker的ACK指针才会前移。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如何保证消息不丢失&quot;&gt;&lt;a href=&quot;#如何保证消息不丢失&quot; class=&quot;headerlink&quot; title=&quot;如何保证消息不丢失&quot;&gt;&lt;/a&gt;如何保证消息不丢失&lt;/h2&gt;&lt;p&gt;一般来讲，消息队列都会有一定的机制去保证消息的不丢失，丢失消息大多数是使用问题。&lt;/</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="消息队列" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>消息积压该如何处理</title>
    <link href="http://example.com/2023/12/09/%E6%B6%88%E6%81%AF%E6%8C%A4%E5%8E%8B%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/"/>
    <id>http://example.com/2023/12/09/%E6%B6%88%E6%81%AF%E6%8C%A4%E5%8E%8B%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/</id>
    <published>2023-12-09T02:25:09.000Z</published>
    <updated>2023-12-11T02:26:09.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息积压该如何处理"><a href="#消息积压该如何处理" class="headerlink" title="消息积压该如何处理"></a>消息积压该如何处理</h2><p>一般来说，消息积压的直接原因，是因为系统中某个部分出了问题，来不及处理上游发送的消息，才会导致消息积压。</p><h3 id="优化性能避免消息积压"><a href="#优化性能避免消息积压" class="headerlink" title="优化性能避免消息积压"></a>优化性能避免消息积压</h3><p>一般来说，我们并不需要考虑消息队列本身的性能，因为它的处理消息的能力要远强于我们业务处理能力。也就是说，性能瓶颈一般出现在生产者和消费者这两端。</p><h4 id="1-发送端性能优化"><a href="#1-发送端性能优化" class="headerlink" title="1. 发送端性能优化"></a>1. 发送端性能优化</h4><p>发送端一般都是执行完业务逻辑后，才开始发送消息。如果发送端速度过慢，则考虑是否是因为发送端业务逻辑执行太慢。</p><p>Producer 发送消息的过程：Producer 发消息给 Broker，Broker 收到消息后返回确认响应，这是一次完整的交互，它的耗时是以下几个步骤耗时的和：</p><ul><li>发送端准备数据、序列化消息、构造请求等逻辑的时间，也就是发送端在发送网络请求之前的耗时；</li><li>发送消息和返回响应在网络传输中的耗时；</li><li>Broker 处理消息的时延。</li></ul><p>这里，如果想提高发送端的性能，最好的办法就是多线程发送消息。如果是一般的web项目，那么它本身就是多线程的，并不需要我们手动开多线程去发送消息（消息的产生与业务相关，手动开多线程没有太大的意义）。如果是一些特殊场景，则可以尝试手动开多线程发送数据，比如日志的推送。</p><p>如果是一个离线系统，不关心时延，则可以采用批量发送，kafka还是什么就采用了这种优化，它并不会一有消息就发出去，而是稍微等待一下，达到一定量再发送。</p><h4 id="2-消费端性能优化"><a href="#2-消费端性能优化" class="headerlink" title="2. 消费端性能优化"></a>2. 消费端性能优化</h4><p>如果消息积压，那么就需要考虑为什么消费者的消费速度跟不上生产速度。一般的优化手段是，对消费端进行水平进行扩容，来提升总体的消费性能。但是需要注意的是：<strong>在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（Partition）（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的</strong>，如果Consumer的数量超过了分区（或者队列）的数量，扩容是没有效果的，因为每个分区只支持单线程消费。</p><p>还有一种处理办法，就是只从消息队列中取消息，然后放入本地内存队列当中，这样可以避免消息堆积。但是这并非一个很好的解决方案，甚至可以说是一个错误的解决方案。因为它很容易导致消息的丢失。本地节点如果挂了，消息就没了。</p><h4 id="积压了如何处理"><a href="#积压了如何处理" class="headerlink" title="积压了如何处理"></a>积压了如何处理</h4><p>积压无外乎两种情况导致的，一是发送速度过快了，二是消费速度变慢了。这个时候就要配合监控日志去排查到底是什么原因，然后采取相对应的解决办法。</p><p>还有一种情况是，频繁的出现消费错误，然后一直重试，导致消费变慢，这种情况就要去查看日志，看是否有大量的报错。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;消息积压该如何处理&quot;&gt;&lt;a href=&quot;#消息积压该如何处理&quot; class=&quot;headerlink&quot; title=&quot;消息积压该如何处理&quot;&gt;&lt;/a&gt;消息积压该如何处理&lt;/h2&gt;&lt;p&gt;一般来说，消息积压的直接原因，是因为系统中某个部分出了问题，来不及处理上游发送的消息</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="消息队列" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>逃逸分析</title>
    <link href="http://example.com/2023/12/01/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2023/12/01/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</id>
    <published>2023-12-01T04:23:38.000Z</published>
    <updated>2023-12-01T04:24:16.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h1><p><strong>逃逸分析是“一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针”</strong></p><p>在Java虚拟机的即时编译环境下，逃逸分析将判断<strong>新建的对象</strong>是否逃逸。判断逃逸的依据是：</p><ol><li>对象是否被存入堆中（静态字段或堆中对象的实例字段）</li><li>对象是否被传入未知代码中。</li></ol><p>前者很好理解，一旦对象放入堆中，其他线程就可以获得该对象的引用。即时编译器也因此无法追踪所有引用该对象代码的位置。</p><p>对于第二点，由于Java编译器的编译是以方法为单位的，对于方法中未被内联的方法调用，编译器会将其当作未知代码，因为无法确认该方法调用是否会将调用者或传入的参数存储至堆当中。所以可以把方法调用的调用者以及参数是逃逸的。</p><h2 id="基于逃逸分析的优化"><a href="#基于逃逸分析的优化" class="headerlink" title="基于逃逸分析的优化"></a>基于逃逸分析的优化</h2><p>即时编译器可以根据逃逸分析的结果进行诸如<strong>锁消除</strong>、<strong>栈上分配</strong>以及<strong>标量替换</strong>的优化。</p><p>对于锁消除，如果即时编译器能够证明<strong>锁对象（指的就是要被加锁的对象）</strong>不逃逸，那么对该锁对象的加锁解锁操作是没有意义的。因为其他线程无法获得该锁对象，也不可能对其进行加锁操作，即时编译器可以消除对该对象的加锁解锁操作。</p><p>传统编译器仅需证明锁对象不逃逸出线程，便可以进行锁消除。由于 Java 虚拟机即时编译的限制，上述条件被强化为<strong>证明锁对象不逃逸出当前编译</strong>的方法。</p><p>注意，上述场景并不多见，因为很少在方法内，基于新构建的对象进行加锁操作。一般都是某个类的公共成员属性进行加锁。</p><p>逃逸分析优化更多的是用在<strong>新建对象操作转换成栈上分配或者标量替换</strong>。</p><p>Java 虚拟机中对象都是在堆上分配的，而堆上的内容对任何线程都是可见的。同时，Java 虚拟机需要对所分配的堆内存进行管理，并且在对象不再被引用时回收其所占据的内存。</p><p>如果逃逸分析能够证明某些新建的对象不逃逸，<strong>那么 Java 虚拟机完全可以将其分配至栈上</strong>， 并且在 new 语句所在的方法退出时，通过<strong>弹出当前方法的栈桢来自动回收所分配的内存空间</strong>。这样一来，我们便无须借助垃圾回收器来处理不再被引用的对象。</p><p>实际上，HotSpot 并没有采用在栈上分配，而是采用了一种<strong>标量替换</strong>的技术。标量，指的是仅能存储一个值的变量。标量替换这项优化技术，可以看成将原本对<strong>对象的字段的访问</strong>，替换为一个个<strong>局部变量的访问</strong>。即将原本在内存中连续分配的对象，拆成了一个个单独的字段。这些字段既可以存储在栈上，也可以直接存储在寄存 器中。而该对象的对象头信息则直接消失了，不再被保存至内存之中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;逃逸分析&quot;&gt;&lt;a href=&quot;#逃逸分析&quot; class=&quot;headerlink&quot; title=&quot;逃逸分析&quot;&gt;&lt;/a&gt;逃逸分析&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;逃逸分析是“一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针”&lt;/strong&gt;&lt;/</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="虚拟机" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="Jvm" scheme="http://example.com/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>写倾斜</title>
    <link href="http://example.com/2023/11/30/%E5%86%99%E5%80%BE%E6%96%9C/"/>
    <id>http://example.com/2023/11/30/%E5%86%99%E5%80%BE%E6%96%9C/</id>
    <published>2023-11-30T08:45:49.000Z</published>
    <updated>2023-11-30T08:51:09.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写倾斜"><a href="#写倾斜" class="headerlink" title="写倾斜"></a>写倾斜</h1><p>举一个例子，现在有两个医生在值班，医院的规定是如果当前有两个医生在值班，那么就有一个医生可以暂时离开。如果这两个医生同时点击申请离开，会开启两个事务，两个事务会先判断是否有两个医生在值班，因为两个事务同时执行，<strong>暂时不考虑隔离性</strong>，那么两个事务判断都满足条件，然后进入下一阶段，医生离开，减少当前医生数量，然后医生数量就变为0。这显然不满足需求。</p><p>这既不是一种脏读，也不是更新丢失，两笔事务更新的是两个不同的对象（两个医生的值班状态）。</p><p>根据可串行化定义，多个事务并行执行，他们的结果与事务串行执行的要一致，可以发现事务并没有达到穿行的效果。</p><p>可以说，<strong>写倾斜是一种不易察觉到的更新丢失</strong>，或者将写倾斜定义为一种更广义的数据更新丢失问题。</p><p>即如果两个事务读取相同的一组对象，然后更新其中一部分：不同的事务更新不同的对象，则可能发生写倾斜。而不同的事务如果更新的是同一个对象，则可能发生脏写或更新丢失。</p><p>可以发现，首先他会查询一些数据（需要满足一定的条件），暂定为数据集A，然后根据这些数据去做下一步的操作。</p><p>我们根据数据集A去做一些判断，然后执行后续的操作。</p><p>在第二步判断成功后，有一些操作修改了数据集A里面的内容，导致了他不再满足第二步的判断，但此时第二步的判断已经结束了，开始执行后续的逻辑，就发生了写倾斜。</p><p>即发生写倾斜是因为后续的操作改变了满足之前查询结果的数据，或者使得之前的数据不满足曾经的判断条件，导致了写倾斜。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写倾斜&quot;&gt;&lt;a href=&quot;#写倾斜&quot; class=&quot;headerlink&quot; title=&quot;写倾斜&quot;&gt;&lt;/a&gt;写倾斜&lt;/h1&gt;&lt;p&gt;举一个例子，现在有两个医生在值班，医院的规定是如果当前有两个医生在值班，那么就有一个医生可以暂时离开。如果这两个医生同时点击申请离开</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>方法内联</title>
    <link href="http://example.com/2023/11/29/%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94/"/>
    <id>http://example.com/2023/11/29/%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94/</id>
    <published>2023-11-29T03:17:51.000Z</published>
    <updated>2023-11-29T03:18:45.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h1><p>方法内联指的是在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。它不仅可以消除调用本身带来的性能开销，还可以进一步触发更多的优化。</p><p>举个例子，如果没有方法内联，当调用getter&#x2F;setter方法时，程序需要保存当前方法的执行位置，创建并压入用于getter&#x2F;setter的栈帧，访问字段，弹出栈帧，最后再恢复当前方法的执行，当内联了对getter&#x2F;setter的方法调用后，上述操作仅剩字段访问。</p><blockquote><p>即时编译器首先解析字节码，并生成IR图，然后在该IR图上进行优化，优化是由一个个独立的优化阶段串联起来的，每个优化阶段都会对IR图进行转换，最后即时编译器根据IR图的节点以及调度顺序生成机器码。</p></blockquote><p>一个相对于IR图好理解的内联形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b , <span class="type">int</span> c, <span class="type">int</span> d)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(a, b) + add(c, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内联之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b , <span class="type">int</span> c, <span class="type">int</span> d)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现，内敛后少了两次方法的调用，那么就意味着少了两次的方法的入栈。</p><h2 id="内联的条件"><a href="#内联的条件" class="headerlink" title="内联的条件"></a>内联的条件</h2><ol><li>热点代码。如果一个方法的执行频率很高就表示优化的潜在价值就越大。这里是根据编译器的编译模式来决定的，如果是客户端模式，则次数是1500，服务端编译模式是10000，该大小可以通过<code>-XX:CompileThreshold来调整</code>。</li><li>方法体不能太大。jvm中被内联的方法会编译成机器码放在code cache中。如果方法体太大，则能缓存热点方法就少，反而会影响性能。</li><li>由 -XX:CompileCommand 中的 inline 指令指定的方法，以及由 @ForceInline 注 解的方法（仅限于 JDK 内部方法），会被强制内联。</li><li>如果调用字节码对应的符号引用未被解析、目标方法所在的类未被初始化，或者目标方 法是 native 方法，都将导致方法调用无法内联。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;方法内联&quot;&gt;&lt;a href=&quot;#方法内联&quot; class=&quot;headerlink&quot; title=&quot;方法内联&quot;&gt;&lt;/a&gt;方法内联&lt;/h1&gt;&lt;p&gt;方法内联指的是在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。它不仅可以消除调用</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="虚拟机" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="Jvm" scheme="http://example.com/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>即时编译（上）</title>
    <link href="http://example.com/2023/11/27/%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://example.com/2023/11/27/%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2023-11-27T03:02:18.000Z</published>
    <updated>2023-11-27T03:02:52.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="即时编译"><a href="#即时编译" class="headerlink" title="即时编译"></a>即时编译</h1><p>通常而言，代码会先被 <strong>Java 虚拟机解释执行</strong>，之后<strong>反复执行的热点代码则会被即时编译</strong>成为机器码，直接运行在底层硬件之上。</p><p>在Java7之前，需要根据程序的特性，选择对应的即时编译器。对于执行时间比较短的，或者对启动性能有要求的，采用编译较快的C1，执行时间较长，或对峰值性能有要求的，采用生成代码执行效率较快的C2。</p><p>Java7引入了分层编译。将虚拟机的执行状态分为了5个层次，分别是：</p><ol><li>解释执行</li><li>执行不带profiling的C1生成的机器码</li><li>执行仅带<strong>方法调用次数</strong>以及<strong>循环回边执行次数</strong>profiling的C1生成的机器码</li><li>执行带所有profiling的C1生成的机器码</li><li>执行C2生成的机器码</li></ol><p>其中，C2代码的执行效率要比C1代码的高，而对于C1代码的三种状态，效率由高到低，因为profiling 越多，其额外的性能开销越大。profiling 是指在程序执行过程中，收集能够反映程序执行状态的数据。这里所收集的数据，称之为程序profile。profiler 大多通过注入 （instrumentation）或者 JVMTI 事件来实现的。</p><p>在 5 个层次的执行状态中，1 层和 4 层为终止状态。当一个方法被终止状态编译过后，如果 编译后的代码并没有失效，那么 Java 虚拟机是不会再次发出该方法的编译请求的。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231127103204555.png" alt="image-20231127103204555" style="zoom:80%;" /><p>如果方法的字节码数目比较少，而且3层的profiling没有可收集的数据，那么虚拟机断定该方法对于C1和C2代码的执行效率相同。这种情况下，虚拟机会在3层编译后，直接选用1层的C1编译，这是一个终止状态，虚拟机不会再继续用4层的C2编译。</p><p>后两种展示了C1忙碌和C2忙碌的情况。</p><h2 id="即时编译的触发"><a href="#即时编译的触发" class="headerlink" title="即时编译的触发"></a>即时编译的触发</h2><p>Java 虚拟机是根据<strong>方法的调用次数</strong>以及<strong>循环回边的执行次数</strong>来触发即时编译的。Java 虚拟机在 0 层、2 层和 3 层执行状态时进行 profiling，其中就包含方法的调用次数和循环回边的执行次数。</p><p>这里的循环回边是一个控制流图中的概念。在字节码中，可以简单理解为往回跳转的指令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java虚拟机并不会对这些计数操作进行同步，收集的数据并不需要准确，当数值足够大，就可以说明包含热点代码。</p><p>具体来说，在不启动分层编译的情况下，当方法调用次数和循环回边的次数和，超过阈值（由参数-XX:CompileThreshold指定，使用C1时为1500，使用C2时该值为10000），便会触发即时编译。</p><p>当采用分层编译，Java虚拟机将不再采用由参数<code>-XX:CompileThreshold </code>指定的阈值，而是使用另一套阈值系统，这里该阈值是动态调整的。</p><h2 id="OSR编译"><a href="#OSR编译" class="headerlink" title="OSR编译"></a>OSR编译</h2><p>决定一个方法是否为热点代码的因素有两个：方法的调用次数、循环回边的执行次数。即时编译器是根据这两个计数器的和来触发的，为什么不维护两个不同的计数器呢？</p><p>除了以方法为单位的即时编译之外，Java 虚拟机还存在着另一种以循环为单位的即时编译，叫做 On-Stack-Replacement（OSR）编译。循环回边计数器便是用来触发这种类 型的编译的。</p><p>OSR 实际上是一种技术，它指的是在程序执行过程中，动态地替换掉 Java 方法栈桢，从而使 得程序能够在非方法入口处进行解释执行和编译后的代码之间的切换。事实上，去优化 （deoptimization）采用的技术也可以称之为 OSR。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;即时编译&quot;&gt;&lt;a href=&quot;#即时编译&quot; class=&quot;headerlink&quot; title=&quot;即时编译&quot;&gt;&lt;/a&gt;即时编译&lt;/h1&gt;&lt;p&gt;通常而言，代码会先被 &lt;strong&gt;Java 虚拟机解释执行&lt;/strong&gt;，之后&lt;strong&gt;反复执行的热点代码则会</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="虚拟机" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="Jvm" scheme="http://example.com/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized</title>
    <link href="http://example.com/2023/11/25/Synchronized/"/>
    <id>http://example.com/2023/11/25/Synchronized/</id>
    <published>2023-11-25T06:33:00.000Z</published>
    <updated>2023-11-25T06:34:31.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>synchronized可以用来对程序加锁，synchronized内的代码又叫做同步代码块，它既可以用来声明一个synchronized代码块，也可以直接标记静态方法或者实例方法。</p><p>当声明 <strong>synchronized 代码块</strong>时，编译而成的字节码将包含 <code>monitorenter</code> 和 <code>monitorexit</code> 指令。这两种指令均会消耗操作数栈上的一个引用类型的元素（也就是synchronized 关键字括 号里的引用），作为要加锁解锁的对象。</p><p>当查看使用了synchronized 关键字的代码编译过后的字节码时，可以发现会存在一个<code>monitorenter</code> 和多个<code>monitorexit</code> ，这是因为虚拟机需要保证加锁之后，不论是正常执行还是异常执行，都需要能够释放锁。</p><p>当用<strong>synchronized 标记方法</strong>时，虚拟机在进入该方法后进行<code>monitorenter</code> ，而退出方法时，不论是正常结束还是抛出异常，都需要进行<code>monitorexit</code> 。这里的<code>monitorenter</code> 和<code>monitorexit</code> 操作所对应的锁对象是隐式的。</p><p>对于实例方法来说，这两个操作对应的<strong>锁对象是this，即该实例本身</strong>，而对于静态方法来说，这两个操作对应的锁对象是<strong>所在类的Class实例</strong>。</p><h2 id="monitorenter-和-monitorexit"><a href="#monitorenter-和-monitorexit" class="headerlink" title="monitorenter 和 monitorexit"></a>monitorenter 和 monitorexit</h2><p>关于 <code>monitorenter</code> 和 <code>monitorexit</code> 的作用，我们可以抽象地理解为每个锁对象拥有一个锁计 数器和一个指向持有该锁的线程的指针。当执行<code>monitorenter</code> 时，如果锁对象的计数器为0，则说明他没有被其他线程所持有，<strong>虚拟机会将该锁对象的持有线程设置为当前线程</strong>，并将计数器加1。如果计数器不为0，那么判断持有锁的线程是否是当前线程，如果是则加1，否则需要等待持有锁的线程释放锁。当执行 <code>monitorexit</code> 时，Java 虚拟机则需将锁对象的计数器减 1。当计数器减为 0 时，那便 代表该锁已经被释放掉了。</p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>在这种状态下，Java 虚拟机会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。而Java线程的阻塞和唤醒，都是需要依赖于操作系统来完成的。对于符合posix接口的操作系统，这些操作是通过pthread的互斥锁(mutex)来实现的，<strong>这些操作都涉及到系统调用，需要从用户态切换至核心态</strong>，开销很大。</p><p>为了避免这些切换，Java虚拟机在线程进入阻塞状态前，以及被唤醒后竞争不到锁的情况下，会进入自旋状态，在处理器空跑并且轮询锁是否被释放。如果此时被释放，则不需要进入阻塞状态，直接获取锁。</p><p>与线程阻塞相比，自旋可能会浪费大量CPU资源。这里自旋并非一定会持续下去，虚拟机采用的是自适应自旋，根据以往自旋等待时是否能 够获得锁，来动态调整自旋的时间（循环数目）。</p><p>自旋还会导致一个问题，即处于阻塞状态的线程无法立刻竞争这把锁，而处于自旋状态的可能会优先获取锁，也就是说并不公平。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>多个线程在<strong>不同的时间段</strong>请求同一把锁，也就是说<strong>没有锁竞争</strong>。针对这种情形，Java 虚拟机采用了轻量级锁，来避免重量级锁的阻塞以及唤醒。</p><h3 id="如何区分轻量级和重量级锁"><a href="#如何区分轻量级和重量级锁" class="headerlink" title="如何区分轻量级和重量级锁"></a>如何区分轻量级和重量级锁</h3><p>Java对象头中有一个标记字段，它的最后两位便被用来表示该对象的锁状态，00代表轻量级锁，01代表无锁或偏向锁，10代表重量级锁，11则跟垃圾回收算法的标记有关。</p><h2 id="加锁和释放锁"><a href="#加锁和释放锁" class="headerlink" title="加锁和释放锁"></a>加锁和释放锁</h2><p>在进行加锁时，虚拟机会判断是否已经是重量级锁，如果不是，它会在当前线程的栈帧中划出一块空间，作为该锁的锁记录，并且将锁对象的标记字段复制到该锁记录中。</p><p>然后，虚拟机会尝试使用CAS操作<strong>替换锁对象的标记字段</strong>，先判断标记为是否为01，如果是，则替换为刚刚分配的锁记录的地址。</p><blockquote><p>注意，上述整个过程可以理解为一个CAS操作。当进行加锁时，判断对象标记为并不是重量级锁，那么就先在当前线程的栈帧中开辟空间，然后将对象的标记字段复制到栈帧中，之后是采用CAS对比栈帧中的标记字段和对象的标记字段是否相同，如果相同则将对象的标记字段替换为刚刚分配栈帧中的地址。然后加锁就成功了。这里，<strong>是将标记字段替换为了线程私有栈帧中的地址。</strong></p></blockquote><p>如果比较不相同，则有两种可能：</p><ul><li><p>第一是该线程重复获取同一把锁，这时候虚拟机会将锁记录清零，一戴白哦该锁重复获取。</p></li><li><p>第二是有其他线程持有该锁，那么虚拟机将会把这把锁膨胀为重量级锁，并阻塞当前线程。</p></li></ul><p>当进行解锁操作时， 如果当前所记录的值为0，则代表重复进入同一把锁，直接返回即可。（可以将线程的所有所记录想象为一个栈结构，每次加锁压入一条所记录，解锁弹出一条锁记录，当前锁记录指的就是栈顶的锁记录）</p><p>如果不是0，则虚拟机会尝试使用CAS操作，比较锁对象的<strong>标记字段的值</strong>是否为当前锁记录的地址，如果是，则替换为锁对象原本标记字段的值（该值在加锁时被复制到了线程私有的栈帧中，然后将值替换为具体的地址，这里是通过地址将原先的值复制回来）。然后释放锁成功。</p><p>如果不是该地址，说明锁被升级为重量级锁，此时需要进入重量级锁的释放流程，唤醒因竞争该锁而被阻塞的线程。</p><blockquote><p>这里，可能是该线程之前加锁成功，在加锁过程中有另外的线程试图获取锁，或者在加了轻量级锁后有线程试图加锁，那么该锁会被升级为重量级锁。</p></blockquote><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>在线程进行加锁时，如果该锁对象支持偏向锁，那么 Java 虚拟机会通过 CAS 操作，将<strong>当前线程的地址记录在锁对象的标记字段之中</strong>，并且将标记字段的最后三位设置为 101。（这里是将线程的地址写入对应的对象，而轻量级锁是复制对象的内容到线程的栈帧）。</p><p>之后，每当有线程请求这把锁，虚拟机只需要判断锁对象标记字段中最后三位是否为101，是否包含当前线程的地址，以及epoch值是否和锁对象的类的eopch值相同。如果都满足，则当前偏向锁就属于该对象，直接返回即可。</p><h3 id="eopch"><a href="#eopch" class="headerlink" title="eopch"></a>eopch</h3><p>当**请求加锁的线程 **和 <strong>锁对象标记字段</strong> 保持的线程地址不匹配时（epoch值相等，如果不相等，当前线程可以将该偏向锁偏向至自己），虚拟机需要撤销该偏向锁，过程比较麻烦，要求持有偏向锁的线程到达安全点，再将偏向锁替换成轻量级锁。如果某一类的锁对象撤销次数超过一个阈值（对应 Java 虚拟机参数 - XX:BiasedLockingBulkRebiasThreshold，默认为 20），虚拟机会让该偏向锁失效。</p><p>具体的做法便是在每个类中维护一个 epoch 值，可以理解为第几代偏向锁。当设置偏向锁 时，Java 虚拟机需要将该 epoch 值复制到锁对象的标记字段中。当某个偏向锁失效时，会将该类的epoch值加1，表示之前那一代的偏向锁已经失效，新设置的偏向锁需要复制新的epoch值。</p><p>为了保证当前持有偏向锁并且已加锁的线程不至于因此丢锁，Java 虚拟机需要遍历所有线程 的 Java 栈，找出该类已加锁的实例，并且将它们标记字段中的 epoch 值加 1。该操作需要所 有线程处于安全点状态。</p><p>总撤销次数超过阈值（对应 Java 虚拟机参数 - XX:BiasedLockingBulkRevokeThreshold，默认值为 40），那么虚拟机会认为该类已经不再适合偏向锁，虚拟机会撤销该类的偏向锁，并在后续加锁过程中直接加轻量级锁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;synchronized&quot;&gt;&lt;a href=&quot;#synchronized&quot; class=&quot;headerlink&quot; title=&quot;synchronized&quot;&gt;&lt;/a&gt;synchronized&lt;/h1&gt;&lt;p&gt;synchronized可以用来对程序加锁，synchron</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="虚拟机" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="Jvm" scheme="http://example.com/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>2^32 怎么表示4GB</title>
    <link href="http://example.com/2023/11/21/%E5%86%85%E5%AD%98%E8%A1%A8%E7%A4%BA/"/>
    <id>http://example.com/2023/11/21/%E5%86%85%E5%AD%98%E8%A1%A8%E7%A4%BA/</id>
    <published>2023-11-21T03:11:54.000Z</published>
    <updated>2023-11-21T03:18:29.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-32-怎么表示4GB"><a href="#2-32-怎么表示4GB" class="headerlink" title="2^32 怎么表示4GB"></a>2^32 怎么表示4GB</h1><p>一般来说，32位最大支持4GB内存，怎么计算出来的呢？</p><p>如果按照这样计算： 2^32 bit &#x3D; 2^29 byte &#x3D; 2^19 KB &#x3D; 2^9 MB &#x3D; 0.5 GB，其实并不够4GB。</p><p>但其实，计算机规定8bit&#x3D;1byte 就是1字节&#x3D;8位，内存的大小就根据格子的多少来进行计算的。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231121111621868.png" alt="image-20231121111621868" style="zoom:67%;" /><p>实际上，4GB &#x3D;  2^2 GB &#x3D; 2^12 MB &#x3D; 2^22 KB &#x3D; 2^32 byte &#x3D; 2^35 bit。也就是说，4GB需要35位。</p><p><strong>实际上内存是把8个bit排成1组， 每1组成为1个单位， 大小是1byte(字节）， cpu每一次只能访问1个byte， 而不能单独去访问具体的1个小格子(bit). 1个byte字节就是内存的最小的IO单位。</strong></p><p>即这里3^32次方，后面的单位并不是bit，而是byte。</p><p>计算机操作系统会给内存每1个字节分配1个内存地址, cpu只需要知道某个数据类型的地址, 就可以直接去到读影的内存位置去提取数据了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2-32-怎么表示4GB&quot;&gt;&lt;a href=&quot;#2-32-怎么表示4GB&quot; class=&quot;headerlink&quot; title=&quot;2^32 怎么表示4GB&quot;&gt;&lt;/a&gt;2^32 怎么表示4GB&lt;/h1&gt;&lt;p&gt;一般来说，32位最大支持4GB内存，怎么计算出来的呢？&lt;/p</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java的方法调用</title>
    <link href="http://example.com/2023/11/17/Java%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/"/>
    <id>http://example.com/2023/11/17/Java%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</id>
    <published>2023-11-17T01:21:21.000Z</published>
    <updated>2023-11-21T07:04:37.908Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>Java中方法的重载，在编译过程中可以完成识别，而具体调用哪一个方法，Java编译器会根据所传入<strong>参数的声明类型（注意与实际类型区分比如声明的是一个List，实际实例化传入的可能是一个ArrayList）</strong>来选取重载方法。选取过程分以下三个阶段：</p><ol><li>在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法；（这里是只找普通方法）</li><li>如果在第 1 个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；（加入自动装箱拆箱的方法）</li><li>如果在第 2 个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况 下选取重载方法。（所有方法）</li></ol><p>如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么它会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是<strong>形式参数类型的继承关系</strong>。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(String s, Object obj, Object... args)</span> &#123; ... &#125;</span><br><span class="line">invoke(<span class="literal">null</span>, <span class="number">1</span>); <span class="comment">// 调用第二个invoke方法</span></span><br><span class="line">invoke(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用第二个invoke方法</span></span><br><span class="line">invoke(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">1</span>&#125;); <span class="comment">// 只有手动绕开可变长参数的语法糖</span></span><br></pre></td></tr></table></figure><p>为什么会调用第二个呢？因为String 类型 是Object 的子类，所以编译器会认为它更贴合（范围更小）。</p><p>而如果子类继承父类，而且有一个方法和父类中非私有的方法同名，而且参数相同，如果两个方法都是静态的，那么子类中会隐藏父类的方法，如果不是静态切都不是私有的，那么子类的方法相当于重写了父类的方法。</p><h4 id="JVM-的静态绑定和动态绑定"><a href="#JVM-的静态绑定和动态绑定" class="headerlink" title="JVM 的静态绑定和动态绑定"></a>JVM 的静态绑定和动态绑定</h4><p>Java 虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）。方法描述符，是由方法的<strong>参数类型</strong>以及<strong>返回类型</strong>所构成。在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么 Java 虚拟机会在<strong>类的验证阶段</strong>报错。</p><p>因为描述符包含了返回类型，所以说并不会限制同一个类中有方法名和参数一样，但返回值不一样的方法。而在上述提到的子类有一个父类同名，同返回值，同参数的非私有，非静态方法，才会被虚拟机判定为重写。</p><p>因为重载方法在编译阶段已经区分，可以认为虚拟机层面没有重载的概念。因此，<strong>重载也被称为静态绑定</strong>（static binding），或者编译时多态 （compile-time polymorphism）；而<strong>重写则被称为动态绑定</strong>（dynamic binding）。</p><p>这个说法在虚拟机语境下并不完全正确，因为某个类的重载方法可能会被它的子类所重写，因此，Java编译器会对所有非私有方法的调用，编译为需要动态绑定的类型（考虑子类继承父类，并重写父类的方法。此时通过子类调用重写的方法，并不能在编译期间确定）。</p><p>确切地说，Java 虚拟机中的<strong>静态绑定指的是在解析时便能够直接识别目标方法的情况</strong>，而<strong>动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法</strong>的情况。</p><h4 id="调用指令的符号引用"><a href="#调用指令的符号引用" class="headerlink" title="调用指令的符号引用"></a>调用指令的符号引用</h4><p>在编译过程中，并不知道目标方法的具体内存地址（编译阶段该对象并没有被实例化，似乎没实例化说法不太准确，gpt说是并不需要知到。有了符号引用后，在运行时，JVM会将符号引用解析为实际的地址引用）。</p><p>因此，Java 编译器会暂时用<strong>符号引用（这个符号引用应该就是暂时指代该方法）</strong>来表示该目标方法。这一符号引用包括目标方法所在的<strong>类</strong>或<strong>接口</strong>的名字，以及目标方法的<strong>方法名</strong>和<strong>方法描述符</strong>。</p><p>符号引用存储在 class 文件的常量池之中。根据目标方法是否为接口方法，这些引用可分为接口符号引用和非接口符号引用。</p><h4 id="虚方法调用"><a href="#虚方法调用" class="headerlink" title="虚方法调用"></a>虚方法调用</h4><p>Java 里所有非私有实例方法调用都会被编译成 invokevirtual 指令， 而接口方法调用都会被编译成 invokeinterface 指令。这两种指令，均属于 Java 虚拟机中的 <strong>虚方法调用</strong>。</p><p>Java 虚拟机需要根据调用者的动态类型，来确定虚方法调用的目标方法。这个过程我们称之为<strong>动态绑定</strong>。（这里，调用者的动态类型，应该是受Java多态的影响，即List list &#x3D; new ArrayList这种写法，List是一个接口，并不知道它的实例化是哪一个，需要根据具体的动态类型来决定调用的是它的哪一个实现）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里的打印结果是123</span></span><br><span class="line">        test.testExe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testExe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">        father.fatherMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="type">int</span> test;</span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fatherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">childMethod</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fatherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法表（用于优化动态绑定，即虚方法）"><a href="#方法表（用于优化动态绑定，即虚方法）" class="headerlink" title="方法表（用于优化动态绑定，即虚方法）"></a>方法表（用于优化动态绑定，即虚方法）</h4><p>Java 虚拟机中采取了一种用空间换取时间的策略来实现动态绑定。它为每个类生成一张方法表，用以快速定位目标方法。</p><p>方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。这些方法可能是具体的，可执行的方法，也可能是抽象的方法。方法表有以下两个特征：</p><ol><li>子类的方法表中包含了父类的方法表中的所有方法。</li><li>子类重写了父类方法时，该方法在子类中的索引值与父类中的一样。即通过索引只能找到子类的方法。</li></ol><p>在符号引用解析为实际引用的时候，对于静态绑定的调用而言，实际引用是直接指向具体的目标方法，而动态绑定，则是实际引用则是指向了方法表的索引值（并不仅是索引值）。</p><p>在执行过程中，Java 虚拟机将获取调用者的实际类型，并在该实际类型的虚方法表中，根据 索引值获得目标方法。这个过程便是动态绑定。</p><p>使用了方法表的动态绑定与静态绑定相比，仅仅多出几个内存解引用操作：访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值所对应的目标方法。</p><p>这种优化仅存在于<strong>解释执行</strong>中，或者<strong>即时编译代码的最坏情况</strong>中。这是因为即时编译还有另外两种更好的优化，<strong>内联缓存</strong> （inlining cache）和<strong>方法内联</strong>（method inlining）。</p><h4 id="内联缓存"><a href="#内联缓存" class="headerlink" title="内联缓存"></a>内联缓存</h4><p>它能够缓存虚方法调用中调用者的<strong>动态类型</strong>，以及<strong>该类型所对应的目标方法</strong>。在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接 调用该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定，即当内联缓存没有命中的情况下，Java 虚拟机需要重新使用方法表进行动态绑定。</p><p>Java虚拟机采用的是单态的，即只会缓存对应方法的一种实例，那么在一种极端的情况下，两个不同的类型频繁调同一个 方法，就会导致缓存被频繁的切换，而且每次都需要去重新绑定一下。情况如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal makes a sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat meows&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 在不同的调用者（不同的对象类型）上轮流调用相同的虚方法</span></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                animal1.makeSound(); <span class="comment">// Dog 调用</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                animal2.makeSound(); <span class="comment">// Cat 调用</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;方法调用&quot;&gt;&lt;a href=&quot;#方法调用&quot; class=&quot;headerlink&quot; title=&quot;方法调用&quot;&gt;&lt;/a&gt;方法调用&lt;/h3&gt;&lt;p&gt;Java中方法的重载，在编译过程中可以完成识别，而具体调用哪一个方法，Java编译器会根据所传入&lt;strong&gt;参数的声明类</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="虚拟机" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="Jvm" scheme="http://example.com/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>AQS</title>
    <link href="http://example.com/2023/11/12/AQS/"/>
    <id>http://example.com/2023/11/12/AQS/</id>
    <published>2023-11-12T03:14:16.000Z</published>
    <updated>2023-11-21T07:04:21.712Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS是什么：AQS，是AbstractQueuedSynchronizer简称，直翻过来叫抽象的<code>队列式同步器</code>， 也可以称作队列同步器，它是java.util.concurrent.lock包下的一个工具类。直观来讲，AQS是Java提供的一个类，这个类是被Abstract修饰的，需要被子类继承。也就是说<strong>AQS是Java并发中用以解决多线程访问共享资源问题的同步机制的基本的框架</strong>（或者说是一种规范），<strong>为Java并发同步组件提供统一的底层支持</strong>。即，AQS是个为各个同步组件提供基本框架的一个抽象类。</p><p>AQS做了什么：<code>提供解决同步问题的基础框架</code>。AQS类内维护了一个volatile int型的变量state，用于表示同步状态（锁的释放与获取），同时提供了一些列诸如getstate、setstate、compareAndSetState的方法来管理该同步状态，这些方法是子类中需要重写的部分，并且，AQS提供了模板方法去调用这些重写的方法；另外，AQS用一个虚拟的CLH FIFO的双向队列来管理被阻塞的线程。</p><p>AQS的整体框架如下：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/82077ccf14127a87b77cefd1ccf562d3253591.png" alt="img"></p><ul><li><p>有颜色的为方法，没颜色的为属性。</p></li><li><p>框架共分为5层，从上到下，由浅入深，从AQS对外暴露的API到底层基础数据。</p></li><li><p>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。</p><p>当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</p></li></ul><h4 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h4><p>AQS核心思想是：</p><ul><li><p>如果被请求的共享资源空闲，那么就将当前<strong>请求资源的线程</strong>设置为有效的工作线程，将共享资源设置为锁定状态；</p></li><li><p>如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p></li></ul><p>CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的<strong>虚拟双向队列（FIFO）</strong>，AQS是通过将每条<strong>请求共享资源的线程</strong>封装成一个节点来实现锁的分配。</p><p>原理如下：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/7132e4cef44c26f62835b197b239147b18062.png" alt="img"></p><p>AOS使用一个Volatile修饰的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值得修改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;AQS&quot;&gt;&lt;a href=&quot;#AQS&quot; class=&quot;headerlink&quot; title=&quot;AQS&quot;&gt;&lt;/a&gt;AQS&lt;/h3&gt;&lt;p&gt;AQS是什么：AQS，是AbstractQueuedSynchronizer简称，直翻过来叫抽象的&lt;code&gt;队列式同步器&lt;/cod</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>文件系统</title>
    <link href="http://example.com/2023/11/10/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2023/11/10/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-11-10T02:04:48.000Z</published>
    <updated>2023-11-21T07:04:10.049Z</updated>
    
    <content type="html"><![CDATA[<p>文件系统将硬盘空间以块进行划分，每个文件占用其中的几个块，然后再通过一个<strong>文件控制块 FCB</strong> 记录每个文件占据的硬盘数据块。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231115093943594.png" alt="image-20231115093943594" style="zoom:67%;" /><p>在linux中，这个文件控制块就是inode，想要访问文件，就要先获取这个inode，然后在inode中查找文件数据块的索引表，根据索引中记录的硬盘地址信息来访问硬盘，读写数据。</p><p>inode的结构是固定的，只有15个索引，前12个索引直接指向数据块地址，第13个索引记录索引地址，即不直接指向数据块，而是指向一张索引表，每张索引表可以记录256个索引，访问这里的数据需要多一次查找。第 14 个索引记录二级索引地址，第 15 个索引记录三级索引地址。</p><h1 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h1><p>RAID，即独立硬盘冗余阵列，将多块硬盘通过硬件 RAID 卡或者软件 RAID 的方案管理起 来，使其共同对外提供服务。</p><p>RAID 的核心思路其实是利用文件系统<strong>将数据写入硬盘中不同数据块的特性</strong>，将多块硬盘上的空闲空间看做一个整体，进行数据写入，也就是说，一个文件的 多个数据块可能写入多个硬盘。</p><p>RAID常用的方式有5种，分别是 RAID 0、RAID 1、RAID 10、 RAID 5 和 RAID 6。</p><h2 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h2><p>该方式是将一个文件的数据分成N块，然后同时写入N个硬盘，这样单个文件可以存储在N个硬盘上，文件容量可以扩大N倍，理论上读写速度也扩大N倍。但是有一个问题，这N个磁盘任何一个损坏，就会导致文件的不完整。文件可用性降低。</p><h2 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h2><p>利用两块硬盘进行数据备份，文件同时向两块硬盘写入，这样任何一块硬盘损坏都不会出现文件数据丢失的情况，文件的可用性得到提升。</p><h2 id="RAID-10"><a href="#RAID-10" class="headerlink" title="RAID 10"></a>RAID 10</h2><p>将多块硬盘进行两两分组，文件数据分成 N 片，每个分组 写入一片，每个分组内的两块硬盘再进行数据备份。这样既扩大了文件的容量，又提高了文件 的可用性。但是这种方式硬盘的利用率只有 50%，有一半的硬盘被用来做数据备份。</p><h2 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID 5"></a>RAID 5</h2><p>RAID 5 针对 RAID 10 硬盘浪费的情况，将数据分成 N-1 片，再利用这 N-1 片数据进行位运算，计算一片校验数据，然后将这 N 片数据写入 N 个硬盘。这样任何一块硬盘损坏，都可以 利用校验片的数据和其他数据进行计算得到这片丢失的数据，而硬盘的利用率也提高到( N - 1&#x2F;N)。</p><h1 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h1><p>文件的inode，是以索引的方式记录每个文件所在的磁盘位置，如果这些索引记录的不是在本地的磁盘位置，而是记录一个其他服务器的地址，那么查询到的数据块就不止是本地磁盘，还可以是其他服务器的磁盘。这样磁盘的容量就是整个分布式集群的大小，读写速度也会加快。</p><p>这样的文件系统就是分布式文件系统，将文件分成很多片，同时向多台服务器写入，然后做好备份，解决单一服务器崩溃导致文件缺失的情况。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文件系统将硬盘空间以块进行划分，每个文件占用其中的几个块，然后再通过一个&lt;strong&gt;文件控制块 FCB&lt;/strong&gt; 记录每个文件占据的硬盘数据块。&lt;/p&gt;
&lt;img src=&quot;https://image-1314238346.cos.ap-chongqing.my</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="文件系统" scheme="http://example.com/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>索引下推</title>
    <link href="http://example.com/2023/11/07/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/"/>
    <id>http://example.com/2023/11/07/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8/</id>
    <published>2023-11-07T01:27:54.000Z</published>
    <updated>2023-11-07T01:28:17.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h1><p>首先，MySQL的结构图如下：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231107091604104.png" alt="image-20231107091604104" style="zoom:80%;" /><p>其中，Server层所做的事情，就是负责SQL的语法解析，生成执行计划，并调用存储引擎层去执行数据的存储核检索，<strong>判断引擎返回的数据是否满足where条件</strong>。<code>索引下推</code>就是指将上层（Server层）负责的事情，交给了下层（引擎层）去处理。具体的查询区别如下：</p><p>在没有使用索引下推时：</p><ul><li>存储引擎读取索引记录；</li><li>根据索引中的主键值，定位并读取完整的行记录；</li><li>存储引擎把记录交给<code>Server</code>层去检测该记录是否满足<code>WHERE</code>条件。</li></ul><p>而使用了索引下推的查询过程：</p><ul><li>存储引擎读取索引记录（不是完整的行记录）；</li><li>判断<code>WHERE</code>条件部分能否用<strong>索引中的列来做检查</strong>，条件不满足，则处理下一行索引记录；</li><li>条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；</li><li>存储引擎把记录交给<code>Server</code>层，<code>Server</code>层检测该记录是否满足<code>WHERE</code>条件的<strong>其余部分</strong>。</li></ul><p>这里的优化点在于，可以提前根据索引中的数据过滤掉一部分不满足的值，这一部分数据不需要回表查询，也不需要交由Server层去处理。</p><p>但是要注意，这个提前判断只能判断索引中存在的值，比如说where条件中有a , b , c 三个字段，但是这个索引（<strong>只能是二级索引，也叫辅助索引</strong>）是建立在a 和 b上面的，那么就只能提前判断a 和 b 是否满足，去除这两个不满足的，然后回表查询数据，返回给Server 然后去判断 c 是否满足条件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;索引下推&quot;&gt;&lt;a href=&quot;#索引下推&quot; class=&quot;headerlink&quot; title=&quot;索引下推&quot;&gt;&lt;/a&gt;索引下推&lt;/h1&gt;&lt;p&gt;首先，MySQL的结构图如下：&lt;/p&gt;
&lt;img src=&quot;https://image-1314238346.cos.ap-</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    <category term="索引" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/%E7%B4%A2%E5%BC%95/"/>
    
    
    <category term="索引" scheme="http://example.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的最左前缀原则</title>
    <link href="http://example.com/2023/11/03/MySQL/MySQL%E7%9A%84%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99/"/>
    <id>http://example.com/2023/11/03/MySQL/MySQL%E7%9A%84%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99/</id>
    <published>2023-11-03T08:09:51.000Z</published>
    <updated>2023-11-03T08:12:26.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h1><p>比如我们建立了一个（姓名，年龄）的索引，那么它可以用来匹配按名字的查找，但是按照年龄就不行。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p><p>MySQL的索引中，有一种形式，叫做联合索引。即它可以创建多个字段联合起来的索引。语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index index_name on table_name(column_1, column_2, column_3)</span><br></pre></td></tr></table></figure><p>这种联合索引的好处在于：</p><ol><li><p>创建联合索引，<strong>相当于</strong>创建了column_1，（column_1，column_2），（column_1，column_2，column_3）这三个索引。但是实际上只存在一个索引。这可以大大减小插入数据时修改索引所消耗的时间。</p></li><li><p>存在联合索引时，如果只查询联合索引这些字段，可以省去回表的时间。</p></li><li><p>通过联合索引可以筛选出来更少的数据。比如说下面的查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select from table where col1 = 1 and col2 = 2 and col3 = 3</span><br></pre></td></tr></table></figure><p>如果只有第一个索引，那么查询完满足第一个条件的数据后，还需要回表去看是否满足第二个条件，第二个条件满足完后还需要看第三个条件。但是如果有联合索引，可以直接查出来满足所有的，这里其实也是满足不回表。</p></li></ol><h1 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h1><p>假设存在联合索引（a，b，c），那么索引结构中，首先是按照a字段有序的，当a相同的时候，b是有序的，b相同后c才是有序的。但是整体来看，索引中b和c都是无序的。</p><p>所以说，当出现以下查询时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select from table where b = 1 and c = 1</span><br></pre></td></tr></table></figure><p>是无法走索引的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select from table where b = 1 and c = 1 and a = 1</span><br></pre></td></tr></table></figure><p>当有a的时候，是可以走索引的。因为MySQL执行器是有优化的，会把sql改成以下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select from table where a = 1 and b = 1 and c = 1</span><br></pre></td></tr></table></figure><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231103161043899.png" alt="image-20231103161043899"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最左匹配原则&quot;&gt;&lt;a href=&quot;#最左匹配原则&quot; class=&quot;headerlink&quot; title=&quot;最左匹配原则&quot;&gt;&lt;/a&gt;最左匹配原则&lt;/h1&gt;&lt;p&gt;比如我们建立了一个（姓名，年龄）的索引，那么它可以用来匹配按名字的查找，但是按照年龄就不行。这个最左前缀可以</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    <category term="索引" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/%E7%B4%A2%E5%BC%95/"/>
    
    
    <category term="索引" scheme="http://example.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL驱动加载</title>
    <link href="http://example.com/2023/11/02/MySQL/MySQL%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD/"/>
    <id>http://example.com/2023/11/02/MySQL/MySQL%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD/</id>
    <published>2023-11-02T01:40:52.000Z</published>
    <updated>2023-11-02T02:47:28.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h1><p>使用Java代码连接MySQL需要走以下流程（使用框架也要做对应的配置）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/db&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">driverClassName</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="comment">// 注册驱动</span></span><br><span class="line">    Class.forName(driverClassName);</span><br><span class="line">    <span class="comment">// 获取连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里边涉及到一个问题，为什么一定要写一句<code>Class.forName(driverClassName)</code>？</p><blockquote><p>这里首先涉及到Java的类加载机制</p><p>想要使用一个类，则必须要求该类已经被加载到JVM中，加载的过程实际上就是<strong>通过类的全限定名来获取定义该类二进制字节流</strong>，然后将这个字节流所表示的静态存储结构转换为方法去的动态运行时数据结构。同时在在内存中实例化一个java.lang.Class对象，作为方法区中该类的数据访问入口(供我们使用)。</p><p>​—— 出自《深入理解Java虚拟机》</p></blockquote><p>其实在一开始，我并不了解<code>Class.forName()</code>是干嘛的，后边了解到它用作加载类，官方解释为：在运行时动态的加载一个类，返回值为生成的Class对象。所以这行代码的目的，就是将<code>com.mysql.cj.jdbc.Driver</code>类加载到Jvm中了。</p><p>这里，<code>forName</code>方法的具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">// 注意这个true，该参数用来标识在将该类加载后是否进行初始化操作。</span></span><br><span class="line">    <span class="keyword">return</span> forName0(className, <span class="literal">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; forName0(String name, <span class="type">boolean</span> initialize,ClassLoader loader,Class&lt;?&gt; caller);</span><br></pre></td></tr></table></figure><p>到这里，也就是说这一行代码不仅加载了对应的类，也做了初始化操作。</p><p>至于说后续为什么可以直接在<code>DriverManager</code>使用，就要看Driver类里面实现了什么。</p><p>MySQL的驱动实现了Java官方提供的Driver接口，这也是每一个数据库厂商所必须要做的事情。而且他们都需要以下这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">extends</span> <span class="title class_">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title class_">java</span>.sql.Driver &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里也是规范的一种，要求每个厂商都把自己的驱动注册到驱动管理里面</span></span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该类中定义了一个静态代码块，静态代码快中创建了一个驱动类实例注册给了DriverManager，而静态代码块的内容会在初始化的过程中执行，所以才能通过<code>DriverManager.getConnection</code>直接获取一个连接。</p><h1 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h1><p>在jdbc4.0之后，使用了spi机制，破坏了双亲委派机制。也就是说我们不再需要写哪一行<code>Class.forName(driverClassName);</code></p><p>我们只需要将对应的驱动类的jar包放到工程的<code>class path</code>下，驱动类会 自动被加载。</p><blockquote><p>SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。</p><p>SPI的目的是为了提前使用某些未被实现的方法。定义一组接口，然后直接通过接口使用它的方法，但是这些方法还未被实现，留给第三方去实现，这就是spi的目的。</p><p>还有一种说法，SPI，为了解耦，从配置里获取某个接口的具体实现类。</p></blockquote><p>为了支持这个新特性，各个数据库厂商的jar包都有一个<code>META-INF/services</code>目录，里面有一个<code>java.sql.Driver</code>，这里指定了driver的全限定名。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231102102705989.png" alt="image-20231102102705989" style="zoom:80%;" /><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>JDBC的driver接口是定义在JDK中的，但是它的实现类，确在一个jar包中，放在classpath下。就存在以下问题：</p><ul><li><code>DriverManager</code>类会加载每个Driver接口的实现类并管理它们，但是<code>DriverManager</code>类自身是 <code>jre/lib/rt.jar</code> 里的类，是由<code>bootstrap classloader</code>加载的。</li><li>根据类加载机制，<strong>某个类需要引用其它类的时候，虚拟机将会用这个类的classloader去加载被引用的类</strong>，但是<code>bootstrap classloader</code>是无法加载这个driver的（<code>bootstrap classloader</code>只能加载Java 的核心类库包）。</li><li>因此只能在DriverManager里强行指定下层classloader来加载Driver实现类，而这就会打破双亲委派模型。</li></ul><p>具体的做法是，添加了一个线程上下文类加载器<code>Thread Context ClassLoader</code>，在启动类加载器中获取应用程序类加载器。<strong>Thread.setContextClassLoaser()</strong> 设置线程上下文类加载器，如果创建线程的时候没有设置，会从父类继承一个，默认应用程序类加载器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;传统方法&quot;&gt;&lt;a href=&quot;#传统方法&quot; class=&quot;headerlink&quot; title=&quot;传统方法&quot;&gt;&lt;/a&gt;传统方法&lt;/h1&gt;&lt;p&gt;使用Java代码连接MySQL需要走以下流程（使用框架也要做对应的配置）：&lt;/p&gt;
&lt;figure class=&quot;highl</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring事务失效场景</title>
    <link href="http://example.com/2023/10/31/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF/"/>
    <id>http://example.com/2023/10/31/Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF/</id>
    <published>2023-10-31T02:13:30.000Z</published>
    <updated>2023-10-31T02:15:26.166Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事务失效"><a href="#事务失效" class="headerlink" title="事务失效"></a>事务失效</h3><blockquote><p>写在前面</p><p><strong>Spring的事务是通过AOP这种代理的方式实现的。</strong></p></blockquote><p>事务失效的场景有以下几个</p><h4 id="1-访问权限问题"><a href="#1-访问权限问题" class="headerlink" title="1.访问权限问题"></a>1.访问权限问题</h4><p>java的访问权限主要有四种：private、default、protected、public，如果我们加注解的方法不是public，那么事务就会返回空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="comment">// 这里，方法不是public修饰，而spring要求被代理的方法必须是public</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">         saveData(userModel);</span><br><span class="line">         updateData(userModel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-方法用final修饰"><a href="#2-方法用final修饰" class="headerlink" title="2.方法用final修饰"></a>2.方法用final修饰</h4><p>一般用final修饰的方法，都是在该方法不想被子类重写，但是如果将事务方法定义为final，则会导致问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span>&#123;</span><br><span class="line">        saveData(userModel);</span><br><span class="line">        updateData(userModel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring的事务，是通过AOP实现的，而AOP则是通过jdk动态代理或者cglib动态代理，来帮我们生成一个代理类，然后重写对应的方法。final修饰的方法没有办法被重写，所以无法使用事务。</p><h4 id="3-方法内部调用"><a href="#3-方法内部调用" class="headerlink" title="3.方法内部调用"></a>3.方法内部调用</h4><p>在某个Service类的某个方法里，调用另一个事务方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        updateStatus(userModel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateStatus</span><span class="params">(UserModel userModel)</span> &#123;</span><br><span class="line">        doSameThing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法，调用的是该方法本身，想要事务生效，要走spring的调用。即需要调用<code>UserService.add()</code>, <code>userService.updateStatus()</code>，spring才能为其生成代理对象，然后事务才能生效，直接调用该方法事务无法生效。</p><p>如何解决：</p><p><strong>1、新增Service类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Servcie</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    prvate ServiceB serviceB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        queryData1();</span><br><span class="line">        queryData2();</span><br><span class="line">        serviceB.doSave(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Servcie</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceB</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSave</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        addData1();</span><br><span class="line">        updateData2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、在Service中注入自己（spring三级缓存会解决循环依赖问题）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Servcie</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    prvate ServiceA serviceA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        queryData1();</span><br><span class="line">        queryData2();</span><br><span class="line">        serviceA.doSave(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSave</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        addData1();</span><br><span class="line">        updateData2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、通过AopContent类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Servcie</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        queryData1();</span><br><span class="line">        queryData2();</span><br><span class="line">        ((ServiceA)AopContext.currentProxy()).doSave(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor=Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSave</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        addData1();</span><br><span class="line">        updateData2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-未被spring管理"><a href="#4-未被spring管理" class="headerlink" title="4.未被spring管理"></a>4.未被spring管理</h4><p>只有该bean被spring管理的情况下，才能生成代理对象，事务才可以生效。通过@Controller、@Service、@Component、@Repository等注解，可以自动实现bean实例化和依赖注入的功能，如果类没有这类注解，事务无法生效。</p><h4 id="5-多线程调用"><a href="#5-多线程调用" class="headerlink" title="5.多线程调用"></a>5.多线程调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RoleService roleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(UserModel userModel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            roleService.doOtherThing();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOtherThing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存role表数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述案例中，<code>add</code>方法在调用另一个事务方法<code>doOtherThing</code>的时候，开启了一个新的线程，这会导致一个问题，即两个方法不是在同一个线程里面调用的，那么他们两个获取到的数据库连接就不是同一个，那他们就是两个事务。</p><p>原因：<strong>spring的事务是通过数据库连接来实现的，当前线程中保存一个map，key是数据源，value是数据库连接。</strong>通常所说的事务，指的是同一个数据库连接，同一个数据库连接才能同时提交和回滚，不同的线程无法实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;事务失效&quot;&gt;&lt;a href=&quot;#事务失效&quot; class=&quot;headerlink&quot; title=&quot;事务失效&quot;&gt;&lt;/a&gt;事务失效&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;写在前面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring的事务是通过AOP这种代理的方式实现的。&lt;/s</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Spring" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Spring/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>可重复读隔离级别会出现幻读吗</title>
    <link href="http://example.com/2023/10/30/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%B9%BB%E8%AF%BB%E5%90%97/"/>
    <id>http://example.com/2023/10/30/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%B9%BB%E8%AF%BB%E5%90%97/</id>
    <published>2023-10-30T01:10:16.000Z</published>
    <updated>2023-10-30T01:12:09.965Z</updated>
    
    <content type="html"><![CDATA[<p>放在最前面：<strong>InnoDB的默认事务隔离级别是可重复读</strong></p><h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><p>MySQL的隔离级别包括四种：<strong>读未提交</strong>（read uncommitted）、<strong>读提交</strong>（read committed）、<strong>可重复读</strong>（repeatable read）和<strong>串行化</strong>（serializable ）。</p><ul><li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化，对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><p>前两种隔离级别，是一定会出现幻读。而<strong>可重复读隔离级</strong>别是采用MVCC，即一致性视图来解决<strong>不可重复读的问题</strong>。具体而言，就是采用快照的方式，事务开启的时候会有一个版本号，然后数据是否可见都是基于版本号来判断的，低于该版本号的数据可见，高于的都不可见。</p><p>而可重复读隔离级别下，如果事务A开启后，事务B做了一定的修改并提交事务，在事务A还未提交的时候，对事务B提交的数据做了修改，这个修改是在事务B提交数据的基础上进行修改的，因为不这样的话会导致事务B提交的数据丢失。那也就意味着此次修改会修改数据的事务版本号，后续进行查询的时候，该版本号就可能会导致幻读的问题，以及查询结果与认为中的不一致问题。这也是为什么在可重复读隔离级别下仍然会出现幻读的问题。</p><p>上述问题有一个原因：<strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。</strong>当前读意味着会读取最新的数据。</p><p>其实除了Update语句外，select语句如果加了锁，即<code>for share</code>或者<code>for update </code>也是当前读。</p><p>实现可重复读的核心是<strong>一致性读</strong>，而更新数据必须使用<strong>当前读</strong>，这也是为什么会失效的原因。</p><h1 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h1><p>在可重复读的隔离级别下，普通读都是<strong>快照读</strong>，是看不见其他事务修改的数据的，幻读的问题只会发生在<strong>当前读</strong>。即<code>select for update</code>  或者<code>select for share</code>这种。</p><p>幻读是指在一个事务（假定事务A）的两次查询中，第二次查询查到了第一次没有的数据。发生幻读的根本原因是另外的事务（假定事务B）添加或修改了数据，该数据正好满足事务A的查询条件。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>可重复读的隔离级别，在某些场景下是无法防止幻读的问题，需要用到间隙锁来解决。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;放在最前面：&lt;strong&gt;InnoDB的默认事务隔离级别是可重复读&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;隔离级别&quot;&gt;&lt;a href=&quot;#隔离级别&quot; class=&quot;headerlink&quot; title=&quot;隔离级别&quot;&gt;&lt;/a&gt;隔离级别&lt;/h1&gt;&lt;p&gt;MySQL的隔离级别包</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="场景分析" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    
    
    <category term="场景分析" scheme="http://example.com/tags/%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
