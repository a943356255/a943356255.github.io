<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随便起个名字吧</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-03-20T07:23:03.026Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Guo Junhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java中的NIO与I/O多路复用</title>
    <link href="http://example.com/2024/03/20/Java%E4%B8%AD%E7%9A%84NIO%E4%B8%8EI-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>http://example.com/2024/03/20/Java%E4%B8%AD%E7%9A%84NIO%E4%B8%8EI-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2024-03-20T07:08:17.000Z</published>
    <updated>2024-03-20T07:23:03.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java的NIO"><a href="#Java的NIO" class="headerlink" title="Java的NIO"></a>Java的NIO</h1><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20240320151336501.png" alt="image-20240320151336501" style="zoom:67%;" /><p>它的大致模型如上图所示，采用了I&#x2F;O多路复用的Reactor模型。</p><h2 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h2><p>上图展示的是单线程模型，也就是说Reactor这里是单线程的，每当有一个事件过来，只有一个线程可以处理该事件，当有下一个事件需要处理时，必须等待上一个事件结束后，才能够被处理。这里与Redis 的模型一致。Redis是采用了一个队列，存储所有的待处理命令，然后有一个线程依次从队列中取出执行。</p><h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><p>为了提高处理效率，也有Reactor多线程模型，即Reactor这里变为多线程。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20240320152214537.png" alt="image-20240320152214537" style="zoom:67%;" /><p>由上图可以看到，当有一个事件变的待处理时，不再是原来的一个线程，而是从线程池中选择一个线程去处理对应的事件，提高了处理效率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java的NIO&quot;&gt;&lt;a href=&quot;#Java的NIO&quot; class=&quot;headerlink&quot; title=&quot;Java的NIO&quot;&gt;&lt;/a&gt;Java的NIO&lt;/h1&gt;&lt;img src=&quot;https://image-1314238346.cos.ap-chongqi</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    
    <category term="I/O" scheme="http://example.com/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的组提交</title>
    <link href="http://example.com/2024/03/08/MySQL%E7%9A%84%E7%BB%84%E6%8F%90%E4%BA%A4/"/>
    <id>http://example.com/2024/03/08/MySQL%E7%9A%84%E7%BB%84%E6%8F%90%E4%BA%A4/</id>
    <published>2024-03-08T03:32:21.000Z</published>
    <updated>2024-03-09T10:43:24.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要组提交"><a href="#为什么要组提交" class="headerlink" title="为什么要组提交"></a>为什么要组提交</h1><p>因为MySQL为了保证redo log 和binlog的数据一致性，而采用了两阶段提交。即redo log 会先处理prepare状态，然后写binlog，当binlog写完之后，才去修改事务的最终状态为commit状态。</p><p>如果配置了双1，那么就会在prepare阶段，将redo log写入磁盘，而binlog也要刷盘，之后才可以提交事务，即一次事务要刷两次盘，影响性能。</p><p>并发事务的影响则更为明显，因为为了保证事务的顺序，需要加锁去保证，即一个事务完全写完之后，才能去写第二个。</p><p>因此，出现了组提交的优化。</p><h1 id="组提交"><a href="#组提交" class="headerlink" title="组提交"></a>组提交</h1><blockquote><p> 以下的分析都是针对于双1配置。</p></blockquote><p>在组提交中，prepare阶段不发生太多的变化，只是写完redo log 后，不再执行刷盘。</p><p>然后将commit阶段做了流水线处理，分为了三步，一共有3个队列，每个队列分别加锁：</p><ul><li>第一个队列，也就是flush stage：将存的一批事务，按其顺序将其redo log 刷盘，然后写binlog。但是这里的binlog只是写cache（缓存），不刷盘。</li><li>第二个队列，sync stage：将队列中积攒的不同事务的binlog 刷盘。</li><li>第三个队列，commit stage：将上述的队列按照顺序commit。</li></ul><p>通过这样优化，就可以将之前的多个事务，每个事务需要两次I&#x2F;O，且多个事务间一个执行完才能执行另一个，改为了多个事务一次I&#x2F;O操作，且锁的粒度更低，事务间并发度更高。</p><h1 id="注意的点"><a href="#注意的点" class="headerlink" title="注意的点"></a>注意的点</h1><p>首先，在非组提交时，两阶段协议中，redo log处于prepare阶段时已经刷盘，但此时事务还没有commit。而binlog 需要刷完盘之后，才可以让事务提交。</p><p>提交的事务就无法回滚，因为可能会覆盖其他事务的提交。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么要组提交&quot;&gt;&lt;a href=&quot;#为什么要组提交&quot; class=&quot;headerlink&quot; title=&quot;为什么要组提交&quot;&gt;&lt;/a&gt;为什么要组提交&lt;/h1&gt;&lt;p&gt;因为MySQL为了保证redo log 和binlog的数据一致性，而采用了两阶段提交。即redo </summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    
    <category term="MySQL45讲" scheme="http://example.com/tags/MySQL45%E8%AE%B2/"/>
    
  </entry>
  
  <entry>
    <title>Condition实现原理</title>
    <link href="http://example.com/2024/02/29/Condition%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2024/02/29/Condition%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2024-02-29T04:24:45.000Z</published>
    <updated>2024-03-14T13:16:10.695Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章也是参考了  <a href="https://javadoop.com/post/AbstractQueuedSynchronizer-2">https://javadoop.com/post/AbstractQueuedSynchronizer-2</a>     这篇文章，总结思路。</p><h1 id="Condition的实现原理"><a href="#Condition的实现原理" class="headerlink" title="Condition的实现原理"></a>Condition的实现原理</h1><p>condition的一个简单的demo如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BoundedBuffer</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// condition 依赖于 lock 来产生</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();  <span class="comment">// 队列已满，等待，直到 not full 才能继续生产</span></span><br><span class="line">            items[putptr] = x;</span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal(); <span class="comment">// 生产成功，队列已经 not empty 了，发个通知出去</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消费</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await(); <span class="comment">// 队列为空，等待，直到队列 not empty，才能继续消费</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> items[takeptr];</span><br><span class="line">            <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal(); <span class="comment">// 被我消费掉一个，队列 not full 了，发个通知出去</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出，在使用 condition 时，必须先持有相应的锁。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20240229105213024.png" alt="image-20240229105213024"></p><p>如上图所示，如果一个调用condition.await()，那么调用该方法的线程会被包装为一个Node，然后加入condition1的<strong>条件队列</strong>中，然后阻塞在这里。如果调用了condition.signal()，那么会唤醒对应condition队列中第一个节点，然后将其加入<strong>阻塞队列的末尾</strong>，等待获取锁然后执行。</p><h1 id="condition的await实现流程"><a href="#condition的await实现流程" class="headerlink" title="condition的await实现流程"></a>condition的await实现流程</h1><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20240229122417553.png" alt="image-20240229122417553"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在节点入条件队列的时候，初始化时设置了 waitStatus = Node.CONDITION</span></span><br><span class="line"><span class="comment">// 前面我提到，signal 的时候需要将节点从条件队列移到阻塞队列，</span></span><br><span class="line"><span class="comment">// 这个方法就是判断 node 是否已经移动到阻塞队列了</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOnSyncQueue</span><span class="params">(Node node)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动过去的时候，node 的 waitStatus 会置为 0，这个之后在说 signal 方法的时候会说到</span></span><br><span class="line">    <span class="comment">// 如果 waitStatus 还是 Node.CONDITION，也就是 -2，那肯定就是还在条件队列中</span></span><br><span class="line">    <span class="comment">// 如果 node 的前驱 prev 指向还是 null，说明肯定没有在 阻塞队列(prev是阻塞队列链表中使用的)</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 如果 node 已经有后继节点 next 的时候，那肯定是在阻塞队列了</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="literal">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这个方法从阻塞队列的队尾开始从后往前遍历找，如果找到相等的，说明在阻塞队列，否则就是不在阻塞队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以通过判断 node.prev() != null 来推断出 node 在阻塞队列吗？答案是：不能。</span></span><br><span class="line">    <span class="comment">// AQS 的入队方法，首先设置的是 node.prev 指向 tail，</span></span><br><span class="line">    <span class="comment">// 然后是 CAS 操作将自己设置为新的 tail，可是这次的 CAS 是可能失败的。</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从阻塞队列的队尾往前遍历，如果找到，返回 true</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">findNodeFromTail</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文章也是参考了  &lt;a href=&quot;https://javadoop.com/post/AbstractQueuedSynchronizer-2&quot;&gt;https://javadoop.com/post/AbstractQueuedSynchronizer-2&lt;/a&gt;   </summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>AQS的执行过程</title>
    <link href="http://example.com/2024/02/28/AQS%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2024/02/28/AQS%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</id>
    <published>2024-02-28T06:48:56.000Z</published>
    <updated>2024-03-14T13:16:27.959Z</updated>
    
    <content type="html"><![CDATA[<p>本文是参考了<a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer">https://www.javadoop.com/post/AbstractQueuedSynchronizer</a>    该篇博客，然后根据他写的思路将加锁的过程转化为流程图。</p><blockquote><p>流程图不太标准。</p></blockquote><h1 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h1><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件"></p><h1 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h1><p>释放的流程就不再画图，过程如下：</p><ol><li><p>首先调用<code>release(1)</code>方法。</p></li><li><p>该方法内部，会先调用<code>tryRelease(1)</code>方法。</p></li><li><p>tryRelease方法中，会先判断当前线程是否是持有锁的线程，如果不是就返回异常，如果是，则判断释放一次锁后锁的标志位是否为0，如果为0则意味着没有重入，直接全部释放，否则不能完全释放。</p></li><li><p>如果调用<code>tryRelease(1)</code>成功，则会回到release方法中。后续会先获取到头节点，并判断状态，如果都没事，就唤醒后继节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">        unparkSuccessor(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>unparkSuccessor方法内部，会先判断头节点状态，如果不是0就改为0。之后获取后继节点，如果不为空，则唤醒，如果为空，则从队列的队尾从前遍历，将其中status小于0的设置为下一个待唤醒的线程。</p></li></ol><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><p>waitStatus 初始化为0，然后是后一个节点修改前一个节点的waitStatus 的值。一般都是改为-1。waitStatus 为-1表示的是后继节点需要唤醒。</p><p>即这个waitStatus 并不代表自身的状态，而是后继节点的状态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是参考了&lt;a href=&quot;https://www.javadoop.com/post/AbstractQueuedSynchronizer&quot;&gt;https://www.javadoop.com/post/AbstractQueuedSynchronizer&lt;/a&gt;    </summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Redis6.0新特性之多线程</title>
    <link href="http://example.com/2024/01/18/Redis6-0%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2024/01/18/Redis6-0%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2024-01-18T02:15:33.000Z</published>
    <updated>2024-03-05T02:58:17.127Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><blockquote><p><strong>需要注意的是，Redis 多 IO 线程模型只用来处理网络读写请求，对于 Redis 的读写命令，依然是单线程处理</strong>。</p></blockquote><p>要采用多线程原因：随着硬件性能提升，Redis 的性能瓶颈可能出现网络 IO 的读写，也就是：<strong>单个线程处理网络读写的速度跟不上底层网络硬件的速度</strong>。</p><img src="C:\Users\郭俊豪\AppData\Roaming\Typora\typora-user-images\image-20240114100625559.png" alt="image-20240114100625559" style="zoom:80%;" /><p>多线程下处理请求流程如下：</p><p>一、<strong>服务端和客户端建立 Socket 连接，并分配处理线程</strong></p><p>首先，<strong>主线程负责接收建立连接请求</strong>。当有客户端请求和实例建立 Socket 连接时，主线程会创建和客户端的连接，并把 Socket 放入全局等待队列中。紧接着，主线程通过轮询方法把 Socket 连接分配给 IO 线程。</p><p>二、<strong>IO 线程读取并解析请求</strong></p><p>主线程一旦把 Socket 分配给 IO 线程，就会进入阻塞状态，等待 IO 线程完成客户端请求读取和解析。因为有多个 IO 线程（<strong>这里就体现了多线程</strong>）在并行处理，所以，这个过程很快就可以完成。</p><p>三、<strong>主线程执行请求操作</strong></p><p>等到 IO 线程解析完请求，主线程还是会以单线程的方式执行这些命令操作。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/1460000040376115" alt="Redis多线程与IO线程" style="zoom:67%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线程&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是，Redis 多 IO 线程模型只用来处理网络读写请求，对于 Redis 的读</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Redis" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized锁升级的过程</title>
    <link href="http://example.com/2024/01/14/Synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2024/01/14/Synchronized%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E8%BF%87%E7%A8%8B/</id>
    <published>2024-01-14T04:18:56.000Z</published>
    <updated>2024-03-01T04:20:57.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Synchronized锁升级的过程"><a href="#Synchronized锁升级的过程" class="headerlink" title="Synchronized锁升级的过程"></a>Synchronized锁升级的过程</h1><p>首先是偏向锁，该锁是偏向某一个线程，在加锁时如果发现只有一个线程在竞争锁，该锁会直接偏向该线程。并在<strong>线程栈</strong>中创建一个LR（锁记录），并将markword拷贝到LR中。同时锁中（或者说被加锁对象）的markword中的指针也会指向加锁线程栈中的LR。</p><blockquote><p>因为Synchronized是可重入锁，所以说LR可以用来表示加了几次锁，每当解锁时，就从线程栈中弹出一个LR。</p></blockquote><p>如果有多个线程同时竞争锁时，就会将锁升级为<strong>轻量级锁（自旋锁）</strong>。</p><p>当一个线程加偏向锁成功时，另一个线程过来抢占锁发现已被占用，此时这把偏向锁会被撤销，然后两个线程通过<strong>自旋 + CAS</strong>的方式抢占锁，谁抢到就将markword的锁记录指向对应线程的LR，代表该线程获得锁，另一个线程会一直自旋，当自旋到一定次数后，就会将该锁升级为重量级锁。</p><p>对于<strong>重量级锁</strong>，早期加锁以及释放锁的过程需要<strong>用户态与内核态</strong>的切换。因为它需要向系统申请锁，申请成功后还需要将这把锁从内核态返回给用户态。</p><p>原因：JVM中synchronized重量级锁的底层原理monitorenter和monitorexit字节码依赖于底层的操作系统的Mutex Lock来实现的。</p><blockquote><p>用户态只能执行用户可以访问的指令，而内核态可以执行操作系统所有的指令。</p></blockquote><p>当重量级锁抢占成功后，markword里记录的不再是一个线程栈内的LR，而是指向一个C++对象的ObjectMonitor。没有抢到锁的线程会被放入一个队列当中，持有锁的线程执行完毕后会唤醒队列中的线程去竞争锁。这个队列中的线程都处于阻塞状态，且是操作系统层面的阻塞。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Synchronized锁升级的过程&quot;&gt;&lt;a href=&quot;#Synchronized锁升级的过程&quot; class=&quot;headerlink&quot; title=&quot;Synchronized锁升级的过程&quot;&gt;&lt;/a&gt;Synchronized锁升级的过程&lt;/h1&gt;&lt;p&gt;首先是偏向锁</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="虚拟机" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="Jvm" scheme="http://example.com/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>乐观锁踩坑记录</title>
    <link href="http://example.com/2024/01/10/%E4%B9%90%E8%A7%82%E9%94%81%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://example.com/2024/01/10/%E4%B9%90%E8%A7%82%E9%94%81%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</id>
    <published>2024-01-10T15:44:10.000Z</published>
    <updated>2024-01-10T16:10:01.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h1><p>背景：Excel的导入导出。由于数据量大，为了优化导出时的分页查询，插入数据时采用的是手动维护的自增id。</p><p>具体场景：如果有多个专家同时导入题库，如何保证手动维护自增id的不重复。</p><p>分析：由于同时多个专家同时导入的情况并不多见，为了不影响绝大多数的场景的性能，这里准备使用乐观锁来解决并发。</p><h1 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h1><p>使用EasyExcel，具体策略是单线程读取，然后使用线程池处理数据插入。核心的<code>LockCityDataListener</code>代码如下：</p><blockquote><p>注意，这一版代码是存在问题的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springboot_vue.utils.excel_util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.context.AnalysisContext;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.read.listener.ReadListener;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.util.ListUtils;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.toolkit.CollectionUtils;</span><br><span class="line"><span class="keyword">import</span> com.example.springboot_vue.mapper.CityMapper;</span><br><span class="line"><span class="keyword">import</span> com.example.springboot_vue.pojo.city.City;</span><br><span class="line"><span class="keyword">import</span> com.example.springboot_vue.rabbitmq_test.RabbitMQProvider;</span><br><span class="line"><span class="keyword">import</span> lombok.SneakyThrows;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.defaults.DefaultSqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.DataSourceTransactionManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionDefinition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.TransactionStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.support.DefaultTransactionDefinition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockCityDataListener</span> <span class="keyword">implements</span> <span class="title class_">ReadListener</span>&lt;City&gt; &#123;</span><br><span class="line"></span><br><span class="line">    CityMapper cityMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于标记当前申请的mark_id是否用完</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手动开启事务</span></span><br><span class="line">    DataSourceTransactionManager dataSourceTransactionManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前申请到的起始id</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">currentStartNumber</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里是设置批量插入数据的大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BATCH_COUNT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;City&gt; cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">20</span>, <span class="number">40</span>, <span class="number">10</span>, TimeUnit.MINUTES, <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储所有错误数据，暂时没用</span></span><br><span class="line">    List&lt;List&lt;City&gt;&gt; wrongList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于使主线程等待所有异步线程结束</span></span><br><span class="line">    List&lt;CompletableFuture&lt;Integer&gt;&gt; allFutures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LockCityDataListener</span><span class="params">(CityMapper cityMapper, DataSourceTransactionManager dataSourceTransactionManager)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cityMapper = cityMapper;</span><br><span class="line">        <span class="built_in">this</span>.dataSourceTransactionManager = dataSourceTransactionManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(City city, AnalysisContext analysisContext)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里是手动开启事务</span></span><br><span class="line">            <span class="type">DefaultTransactionDefinition</span> <span class="variable">df</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>();</span><br><span class="line">            df.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW);</span><br><span class="line">            <span class="type">TransactionStatus</span> <span class="variable">transaction</span> <span class="operator">=</span> dataSourceTransactionManager.getTransaction(df);</span><br><span class="line">            <span class="comment">// 注意</span></span><br><span class="line">            Map&lt;String, Object&gt; map = cityMapper.getTotalData();</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentData</span> <span class="operator">=</span> (<span class="type">int</span>) map.get(<span class="string">&quot;column_count&quot;</span>);</span><br><span class="line">            <span class="comment">// 获取总行数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rowNumber</span> <span class="operator">=</span> analysisContext.readSheetHolder().getApproximateTotalRowNumber() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">resultNumber</span> <span class="operator">=</span> currentData + rowNumber;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> cityMapper.setData((Integer) map.get(<span class="string">&quot;version&quot;</span>), resultNumber);</span><br><span class="line">            <span class="comment">// 如果更新失败，就继续尝试更新</span></span><br><span class="line">            <span class="keyword">while</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 注意</span></span><br><span class="line">                map = cityMapper.getTotalData();</span><br><span class="line">                resultNumber = rowNumber + (<span class="type">int</span>) map.get(<span class="string">&quot;column_count&quot;</span>);</span><br><span class="line">                <span class="comment">// 注意</span></span><br><span class="line">                res = cityMapper.setData((Integer) map.get(<span class="string">&quot;version&quot;</span>), resultNumber);</span><br><span class="line">            &#125;</span><br><span class="line">            index = rowNumber;</span><br><span class="line">            currentStartNumber = (<span class="type">int</span>) map.get(<span class="string">&quot;column_count&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 手动提交事务</span></span><br><span class="line">            dataSourceTransactionManager.commit(transaction);</span><br><span class="line">        &#125;</span><br><span class="line">        city.setMarkId(++currentStartNumber);</span><br><span class="line">        cachedDataList.add(city);</span><br><span class="line">        index--;</span><br><span class="line">        <span class="comment">// 一次1000条，如果超过1000条，就清除之前的内容</span></span><br><span class="line">        <span class="keyword">if</span> (cachedDataList.size() &gt;= BATCH_COUNT) &#123;</span><br><span class="line">            List&lt;City&gt; tempList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(cachedDataList);</span><br><span class="line">            <span class="comment">// 存储完成清理 list</span></span><br><span class="line">            cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);</span><br><span class="line">            CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; saveData(tempList), executorService)</span><br><span class="line">                    .exceptionally(ex -&gt; &#123;</span><br><span class="line">                        wrongList.add(tempList);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;);</span><br><span class="line">            allFutures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里是处理遗留的数据</span></span><br><span class="line"><span class="comment">     * 注意：这里是每一个sheet读取完成后都会触发一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext analysisContext)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(cachedDataList)) &#123;</span><br><span class="line">            saveData(cachedDataList);</span><br><span class="line">            <span class="comment">// 这里如果不进行重置，如果每个sheet不是1000条数据，会存在多插入的情况</span></span><br><span class="line">            cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        CompletableFuture&lt;Void&gt; allCompleted = CompletableFuture.allOf(allFutures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>]));</span><br><span class="line">        allCompleted.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">saveData</span><span class="params">(List&lt;City&gt; cachedDataList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cityMapper.insertCityAll(cachedDataList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SQL如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select column_count, version from version_lock&quot;)</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getTotalData</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&lt;insert id=<span class="string">&quot;insertCityAll&quot;</span> parameterType=<span class="string">&quot;java.util.List&quot;</span>&gt;</span><br><span class="line">    insert into <span class="title function_">city</span><span class="params">(`name`, parent_name, `number`, column_1, column_2, mark_id)</span> values</span><br><span class="line">    &lt;foreach collection=<span class="string">&quot;list&quot;</span> separator=<span class="string">&quot;,&quot;</span> item=<span class="string">&quot;item&quot;</span>&gt;</span><br><span class="line">    (#&#123;item.name&#125;, #&#123;item.parentName&#125;, #&#123;item.number&#125;, #&#123;item.test&#125;, #&#123;item.test2&#125;, #&#123;item.markId&#125;)</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>当有两个线程同时进行插入时，但凡出现冲突，就会导致其中一个线程无限循环，另一个线程等待锁超时。</p><h1 id="具体原因"><a href="#具体原因" class="headerlink" title="具体原因"></a>具体原因</h1><p>问题出现在一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询数据</span></span><br><span class="line">Map&lt;String, Object&gt; map = cityMapper.getTotalData();</span><br><span class="line"><span class="comment">// 省略几行代码...</span></span><br><span class="line"><span class="comment">// 修改数据</span></span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> cityMapper.setData((Integer) map.get(<span class="string">&quot;version&quot;</span>), resultNumber);</span><br><span class="line"><span class="comment">// 如果更新失败，就继续尝试更新</span></span><br><span class="line"><span class="keyword">while</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 注意</span></span><br><span class="line">    map = cityMapper.getTotalData();</span><br><span class="line">    resultNumber = rowNumber + (<span class="type">int</span>) map.get(<span class="string">&quot;column_count&quot;</span>);</span><br><span class="line">    <span class="comment">// 注意</span></span><br><span class="line">    res = cityMapper.setData((Integer) map.get(<span class="string">&quot;version&quot;</span>), resultNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想一下，如果res为0，意味着两个线程同时查询数据，然后进行了更新，但是只有一个线程可以更新成功。另一个线程由于版本号不对进如while循环。</p><p>关键点来了，就是这个while循环，在进入时，当前事务并未结束（假设事务A），虽然另外一个线程提交了它的事务（假设事务B），但由于默认的隔离级别是<strong>可重复读</strong>，这意味着其他事务（事务B）所做的修改对于当前事务（事务A）是不可见的。也就意味着，哪怕事务A进入了循环，重新执行了查询，但是它查询到的数据和while循环之外查询到的是一致的。而Update进行修改时，它所做的是当前读，也就是说它可以读取到最新的数据。所以修改永远无法成功。</p><p>这样就出现了上面的场景，一个线程无限循环，而另一个线程由于无限循环的事务没有提交，一直处于等待状态，最终超时断开连接。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;业务场景&quot;&gt;&lt;a href=&quot;#业务场景&quot; class=&quot;headerlink&quot; title=&quot;业务场景&quot;&gt;&lt;/a&gt;业务场景&lt;/h1&gt;&lt;p&gt;背景：Excel的导入导出。由于数据量大，为了优化导出时的分页查询，插入数据时采用的是手动维护的自增id。&lt;/p&gt;
&lt;p&gt;具</summary>
      
    
    
    
    <category term="个人心得" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E4%B8%AA%E4%BA%BA%E5%BF%83%E5%BE%97/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Redis变慢的原因</title>
    <link href="http://example.com/2023/12/29/Redis%E5%8F%98%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
    <id>http://example.com/2023/12/29/Redis%E5%8F%98%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0/</id>
    <published>2023-12-29T03:53:48.000Z</published>
    <updated>2023-12-29T03:54:24.177Z</updated>
    
    <content type="html"><![CDATA[<h3 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h3><p>这里主要涉及到一些时间复杂度比较高的查询或者聚合计算，要根据实际情况，使用合适的命令。可以通过<strong>查看 Redis 的响应延迟</strong>，来判断Redis是否真的变慢。</p><h3 id="文件系统AOF"><a href="#文件系统AOF" class="headerlink" title="文件系统AOF"></a>文件系统AOF</h3><p>Redis虽然是内存数据库，但为了保证数据不丢失，需要把数据写入到磁盘当中。而AOF的刷盘策略有以下三种：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231229113951578.png" alt="image-20231229113951578"></p><p>当使用<strong>evertsec</strong>时，允许丢失一秒的数据。这时候，使用后台子线程来进行fsync，并且是异步执行。这种情况下对主进程的影响并不会很大。</p><p>但是当写回策略配置为always时，情况就不一样了。为了确保每条数据都写入磁盘，Redis就不能使用后台子线程来进行fsync，因为这样无法知道是否写入完成。所以只能由主进程来执行，这大概率会影响性能。</p><p>另一方面，随着AOF文件的增大，还需要执行AOF重写，AOF重写采用的是后台子线程来进行，但是需要注意的是：</p><blockquote><p>AOF 重写会对磁盘进行大量 IO 操作，同时，fsync 又需要等到数据写到磁盘后才能返回，所以，当 AOF 重写的压力比较大时，就会导致 fsync 被阻塞。虽然 fsync 是由后台子线程负责执行的，但是，主线程会监控 fsync 的执行进度。</p><p>当主线程使用后台子线程执行了一次 fsync，需要再次把新接收的操作记录写回磁盘时，如果主线程发现上一次的 fsync 还没有执行完，那么它就会阻塞。</p><p>也就是说，当需要执行fsync时，并且此时正好在执行AOF重写，磁盘压力比较大，就会导致子线程的fsync操作被阻塞，这将会影响到下一次的主线程的写入。</p></blockquote><h3 id="操作系统Swap"><a href="#操作系统Swap" class="headerlink" title="操作系统Swap"></a>操作系统Swap</h3><p>内存 swap 是操作系统里将内存数据在内存和磁盘间来回换入和换出的机制。</p><p>这里就需要注意，如果物理机的内存不够时，就有可能将Redis中的数据换出，放入磁盘当中。这是出现查找命令，发现内存中没有，就需要从磁盘中加载到内存当中，这会严重影响性能。</p><h3 id="操作系统：内存大页"><a href="#操作系统：内存大页" class="headerlink" title="操作系统：内存大页"></a>操作系统：内存大页</h3><p>内存大页是linux新支持的一种机制。该机制支持2MB的大页，而通常的内存页分配是4KB。</p><p>内存大页一定程度上可以给Redis内存分配带来优势，但是需要注意的是，Redis 为了提供数据可靠性保证，需要将数据做持久化保存。这个写入过程由额外的线程执行，所以，此时，Redis 主线程仍然可以接收客户端写请求。</p><blockquote><p>客户端的写请求可能会修改正在进行持久化的数据。在这一过程中，Redis 就会采用<strong>写时复制机制</strong>，也就是说，一旦有数据要被修改，<strong>Redis 并不会直接修改内存中的数据</strong>，而是将这些数据拷贝一份，然后再进行修改。</p></blockquote><p>如果采用了内存大页，那么，即使客户端请求只修改 100B 的数据，Redis 也需要拷贝 2MB 的大页。解决方法就是关闭内存大页。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;命令使用&quot;&gt;&lt;a href=&quot;#命令使用&quot; class=&quot;headerlink&quot; title=&quot;命令使用&quot;&gt;&lt;/a&gt;命令使用&lt;/h3&gt;&lt;p&gt;这里主要涉及到一些时间复杂度比较高的查询或者聚合计算，要根据实际情况，使用合适的命令。可以通过&lt;strong&gt;查看 Redi</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Redis" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis的切片集群</title>
    <link href="http://example.com/2023/12/21/Redis%E7%9A%84%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4/"/>
    <id>http://example.com/2023/12/21/Redis%E7%9A%84%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4/</id>
    <published>2023-12-21T02:03:42.000Z</published>
    <updated>2023-12-23T02:04:55.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="切片集群"><a href="#切片集群" class="headerlink" title="切片集群"></a>切片集群</h2><p>切片集群，也叫分片集群，就是指启动多个 Redis 实例组成一个集群，然后按照一定的规则，把收到的数据划分成多份，每一份用一个实例来保存。</p><blockquote><p>这里需要注意的是，这多个实例对外其实是提供一个服务，因为每个实例只有所有数据的一部分，他们内部是5个，客户端在使用时其实只会感知到1个。</p></blockquote><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231221112358729.png" alt="image-20231221112358729"></p><h3 id="如何保存更多数据"><a href="#如何保存更多数据" class="headerlink" title="如何保存更多数据"></a>如何保存更多数据</h3><p>Redis应对数据量增多有两种办法：</p><ul><li>纵向扩展（scale up）：指的是升级单个Redis实例的配置资源，包括增加容量，使用更高配CPU等。</li><li>横向扩展（scale out）：增加Redis实例的个数。</li></ul><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231221112825594.png" alt="image-20231221112825594" style="zoom:80%;" /><p>纵向扩展实现起来最简单，换一个机器就可以，但是会面临问题，即内存越大，单实例存储的数据就越多，在进行RDB持久化时，主线程fork子进程时就可能阻塞。如果不要求持久化，是一个不错的选择。</p><p>而针对于特别大的数据量，更好的方案是切片集群。</p><h3 id="数据切片和实例的对应分布"><a href="#数据切片和实例的对应分布" class="headerlink" title="数据切片和实例的对应分布"></a>数据切片和实例的对应分布</h3><p>数据和实例之间如何对应，与Redis Cluster有关。</p><p>具体来说，Redis Cluster 方案采用哈希槽（Hash Slot，接下来我会直接称之为 Slot），来处理数据和实例之间的映射关系。在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。</p><p>首先根据键值对的 key，按照CRC16 算法计算一个 16 bit 的值；然后，再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。</p><p>在部署 Redis Cluster 方案时，可以使用 cluster create 命令创建集群，此时，Redis 会自动把这些槽平均分布在集群实例上。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231221154113991.png" alt="image-20231221154113991" style="zoom:80%;" /><p><strong>在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作</strong>。</p><h3 id="客户端定位"><a href="#客户端定位" class="headerlink" title="客户端定位"></a>客户端定位</h3><p>在定位键值对数据时，它所处的哈希槽是可以通过计算得到的，这个计算可以在客户端发送请求时来执行。</p><p>客户端和集群建立连接后。实例就会把哈希槽的分配信息发送给客户端。但是刚创建的时候，每个实例只知道自己的哈希槽，不知道其他的哈希槽信息，这时<strong>Redis实例会把自己的哈希槽信息发送给它相连接的其他实例，来完成哈希槽信息分配的扩散</strong>。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。</p><p>但是，哈希槽并不是一直不变的，最常见的有以下两种变化：</p><ul><li><p>在集群中，实例有新增或删除，Redis 需要重新分配哈希槽；</p></li><li><p>为了负载均衡，Redis 需要把哈希槽在所有实例上重新分布一遍。</p></li></ul><p>此时，Redis实例之间可以通过相互传递消息，获得最新的哈希槽分配。但是客户端是无从感知的。Redis Cluster提供了一种<strong>重定向机制</strong>。该机制，指的是客户端给一个实例发送读写操作时，这个实例上没有对应的数据，客户端需要给一个新的实例发送数据。</p><p>具体来说，如果请求的实例没有数据，那么该实例会给客户端返回拥有该数据的实例，然后客户端再次请求即可。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231221161342141.png" alt="image-20231221161342141" style="zoom:80%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;切片集群&quot;&gt;&lt;a href=&quot;#切片集群&quot; class=&quot;headerlink&quot; title=&quot;切片集群&quot;&gt;&lt;/a&gt;切片集群&lt;/h2&gt;&lt;p&gt;切片集群，也叫分片集群，就是指启动多个 Redis 实例组成一个集群，然后按照一定的规则，把收到的数据划分成多份，每一份用一</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Redis" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis的String</title>
    <link href="http://example.com/2023/12/15/Redis%E7%9A%84String/"/>
    <id>http://example.com/2023/12/15/Redis%E7%9A%84String/</id>
    <published>2023-12-15T02:06:27.000Z</published>
    <updated>2023-12-23T02:07:34.200Z</updated>
    
    <content type="html"><![CDATA[<p>假设，我们用String 类型存储一个键值对，他们的长度都是10位数，其实用两个8字节的Long类型表示就可以了。Long最大可以表示2^64次方，表示10为数字绝对没问题。</p><p>但是Redis中的String 类型表示这一对 key 和 val 却用了64字节，这是因为<strong>String类型实际上还需要额外的内存空间记录数据长度，空间使用，</strong>等信息。如果用String存储比较小的数据，额外的空间就显得比较大。</p><p>当我们保存64位有符号整数时，String类型会把它保存为一个8字节的Long类型整数，这种保存也叫 <strong>int 编码</strong>。如果保存的数据中包含字符串时，String 类型就会用 <strong>简单动态字符串（SDS）</strong>来保存。其结构如下图所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231222104741805.png" alt="image-20231222104741805" style="zoom:67%;" /><ul><li>buf：字节数组，保存实际的数据，为了表示数据结束，会在数组后加一个”\0”，这就会额外占用1个字节的开销。</li><li>len：占4个字节，表示buf已使用的长度。</li><li>alloc：占4个字节，表示buf的实际分配长度，一般大于len。</li></ul><p>对于String，除了SDS的额外开销，还有一个来自于<strong>RedisObjec</strong>t结构体的开销。</p><p>Redis 的数据类型有很多，而且，不同数据类型都有些相同的元数据要记录（比如最后一次访问的时间、被引用的次数等），所以，Redis 会用一个 RedisObject 结构体来统一记录这些元数据，同时指向实际数据。</p><p>一个 RedisObject 包含了 8 字节的元数据和一个 8 字节指针，这个指针再进一步指向具体数据类型的实际数据所在：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231222105622386.png" alt="image-20231222105622386" style="zoom:67%;" /><p>为了节省空间，Redis对Long类型和SDS的内存布局做了专门的设计。</p><p>一方面，当保存的是Long类型整数时，RedisObject中的指针就直接赋值为整数数据，不再使用额外的指针指向整数，节省了指针的空间开销。</p><p>另一方面，当保存的是字符串数据，并且字符串小于等于44时，RedisObject 中的元数据、指针和 SDS 是一块连续的内存区域，这样就可以避免内存碎片，这种布局被称为<strong>embstr编码</strong>。当字符串大于44字节时，Redis就不再把SDS和RedisObject布局在一起，而是给SDS分配单独空间，并用指针指向SDS结构，这种被称为<strong>raw编码</strong>。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231222111057985.png" alt="image-20231222111057985" style="zoom: 80%;" /><p>至此，十位数的key和十位数的val是Long类型整数，可以直接用int编码的RedisObject保存。每个int编码的RedisObject元数据部分占8字节，指针部分被直接赋值为8字节整数。此时，每个ID会使用16字节，加起来一共是32字节。与64字节还差32字节。</p><p>其实，<strong>Redis会使用一个全局哈希表保存所有键值对，哈希表每一项是一个dictEntry的结构体，用来指向一个键值对</strong>，三个指针一共24字节，如下图所示：</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231222111723672.png" alt="image-20231222111723672" style="zoom:80%;" /><p>但是这样也只有24字节，还差了8字节。这里涉及到Redis使用的内存分配库<code>jemalloc</code>，该函数在分配内存时，会根据我们申请的字节数N，找一个比N大，但是最接近N的2的幂次数作为分配的空间，这样可以减少频繁分配次数。</p><p><strong>如何节省内存？</strong></p><p>Redis 有一种底层数据结构，叫压缩列表（ziplist）。压缩列表表头有三个字段，zlbytes、zltail 和 zllen，分别表示列表长度，列表尾的偏移量以及列表中的entry个数。压缩列表尾还有一个 zlend，表示列表结束。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231222112339962.png" alt="image-20231222112339962" style="zoom:80%;" /><p>每个entry又有以下及部分：</p><ul><li><strong>prev_len</strong>，表示前一个 entry 的长度。prev_len 有两种取值情况：1 字节或 5 字节。取值 1 字节时，表示上一个 entry 的长度小于 254 字节，取5时表示大于255字节。</li><li><strong>len</strong>：表示自身长度，4字节。</li><li><strong>encoding</strong>：表示编码方式，1字节。</li><li><strong>content</strong>：保存实际数据。</li></ul><p>这些 entry 会挨个儿放置在内存中，不需要再用额外的指针进行连接，这样就可以节省指针所占用的空间。</p><p>Redis 基于压缩列表实现了 List、Hash 和 Sorted Set 这样的集合类型，这样做的最大好处就是节省了 dictEntry 的开销。当你用 String 类型时，一个键值对就有一个 dictEntry，要用 32 字节空间。但采用集合类型时，一个 key 就对应一个集合的数据，能保存的数据多了很多，但也只用了一个 dictEntry，这样就节省了内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;假设，我们用String 类型存储一个键值对，他们的长度都是10位数，其实用两个8字节的Long类型表示就可以了。Long最大可以表示2^64次方，表示10为数字绝对没问题。&lt;/p&gt;
&lt;p&gt;但是Redis中的String 类型表示这一对 key 和 val 却用了64字节，</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Redis" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Redis/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>如何保证消息不丢失</title>
    <link href="http://example.com/2023/12/11/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/"/>
    <id>http://example.com/2023/12/11/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/</id>
    <published>2023-12-11T01:48:02.000Z</published>
    <updated>2023-12-11T01:48:45.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何保证消息不丢失"><a href="#如何保证消息不丢失" class="headerlink" title="如何保证消息不丢失"></a>如何保证消息不丢失</h2><p>一般来讲，消息队列都会有一定的机制去保证消息的不丢失，丢失消息大多数是使用问题。</p><h3 id="检测消息是否丢失"><a href="#检测消息是否丢失" class="headerlink" title="检测消息是否丢失"></a>检测消息是否丢失</h3><p>这里有一个逻辑上的处理办法，就是发送消息时，给消息一个编号，然后利用消息的有序性来判断消息是否丢失。这里需要配合消息队列客户端的拦截机制去做，在拦截器中去检测消息的连续性，这样检测消息连续性的代码就不会侵入业务层。</p><p>但是需要注意的一点是，像Kafka和RocketMQ这种消息队列，<strong>他们并不能保证消息在Topic上是连续的，只能保证在分区内是连续的</strong>，那么我们在编号时，就需要按照分区来做消息的递增，确保编号连续性的检测是在每一个分区内部进行的。</p><p>如果producer是多实例的，由于并不好协调不同producer之间发送的顺序，所以该编号最好也是按照每个Producer单独递增的。</p><p>Consumer 实例的数量最好和分区数量一致，做到 Consumer 和分区一一对应，这样会比较方便地在 Consumer 内检测消息序号的连续性。</p><p>这里还需要考虑一种情况，就是消息重复发送的问题。因为难免会出现消息确认延迟，但实际上消息发送成功了，这时候，在消息的消费端，就需要保证消息的幂等性。要么给每条消息做标记，确保该消息只会消费一次，多次发送并不会消费该消息，要么保证一条消息多次消费的结果是一样的。</p><h3 id="确保消息的可靠传递"><a href="#确保消息的可靠传递" class="headerlink" title="确保消息的可靠传递"></a>确保消息的可靠传递</h3><p>消息的生产和消费一般分为一下几个阶段。</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231207110009586.png" alt="image-20231207110009586"></p><ul><li><strong>生产阶段</strong>: 在这个阶段，从消息在 Producer 创建出来，经过网络传输发送到 Broker 端。</li><li><strong>存储阶段</strong>: 在这个阶段，消息在 Broker 端存储，如果是集群，消息会在这个阶段被复制到其他的副本上。</li><li><strong>消费阶段</strong>: 在这个阶段，Consumer 从 Broker 上拉取消息，经过网络传输发送到 Consumer 上。</li></ul><p>首先生产阶段，在编写代码时要注意，等收到Broker的响应确认后，再认为消息发送成功，否则进行重试。这样就可以保证在发送阶段消息的不丢失，换种说法，可以保证该条消息一定可以发送到Broker当中。</p><p>如果消息是异步发送的，我们需要在回调中，检查消息的发送结果。</p><p>而在于存储阶段，Broker不宕机是不会出现消息丢失的情况，这里涉及到刷盘策略，如果对于可靠性要求很高，可以将刷盘的频率调至最高频率。如果Broker是集群部署，则要确保发送到2个以上的节点，再给生产者返回存储成功。</p><p>消费阶段，这个阶段也是最容易代码编写出问题的阶段。该阶段不能在接收到消息后就给Broker返回消息确认，应该在业务代码全部执行完毕后，再返回消息确认，这时候Broker的ACK指针才会前移。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如何保证消息不丢失&quot;&gt;&lt;a href=&quot;#如何保证消息不丢失&quot; class=&quot;headerlink&quot; title=&quot;如何保证消息不丢失&quot;&gt;&lt;/a&gt;如何保证消息不丢失&lt;/h2&gt;&lt;p&gt;一般来讲，消息队列都会有一定的机制去保证消息的不丢失，丢失消息大多数是使用问题。&lt;/</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="消息队列" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>消息积压该如何处理</title>
    <link href="http://example.com/2023/12/09/%E6%B6%88%E6%81%AF%E6%8C%A4%E5%8E%8B%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/"/>
    <id>http://example.com/2023/12/09/%E6%B6%88%E6%81%AF%E6%8C%A4%E5%8E%8B%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/</id>
    <published>2023-12-09T02:25:09.000Z</published>
    <updated>2023-12-11T02:26:09.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息积压该如何处理"><a href="#消息积压该如何处理" class="headerlink" title="消息积压该如何处理"></a>消息积压该如何处理</h2><p>一般来说，消息积压的直接原因，是因为系统中某个部分出了问题，来不及处理上游发送的消息，才会导致消息积压。</p><h3 id="优化性能避免消息积压"><a href="#优化性能避免消息积压" class="headerlink" title="优化性能避免消息积压"></a>优化性能避免消息积压</h3><p>一般来说，我们并不需要考虑消息队列本身的性能，因为它的处理消息的能力要远强于我们业务处理能力。也就是说，性能瓶颈一般出现在生产者和消费者这两端。</p><h4 id="1-发送端性能优化"><a href="#1-发送端性能优化" class="headerlink" title="1. 发送端性能优化"></a>1. 发送端性能优化</h4><p>发送端一般都是执行完业务逻辑后，才开始发送消息。如果发送端速度过慢，则考虑是否是因为发送端业务逻辑执行太慢。</p><p>Producer 发送消息的过程：Producer 发消息给 Broker，Broker 收到消息后返回确认响应，这是一次完整的交互，它的耗时是以下几个步骤耗时的和：</p><ul><li>发送端准备数据、序列化消息、构造请求等逻辑的时间，也就是发送端在发送网络请求之前的耗时；</li><li>发送消息和返回响应在网络传输中的耗时；</li><li>Broker 处理消息的时延。</li></ul><p>这里，如果想提高发送端的性能，最好的办法就是多线程发送消息。如果是一般的web项目，那么它本身就是多线程的，并不需要我们手动开多线程去发送消息（消息的产生与业务相关，手动开多线程没有太大的意义）。如果是一些特殊场景，则可以尝试手动开多线程发送数据，比如日志的推送。</p><p>如果是一个离线系统，不关心时延，则可以采用批量发送，kafka还是什么就采用了这种优化，它并不会一有消息就发出去，而是稍微等待一下，达到一定量再发送。</p><h4 id="2-消费端性能优化"><a href="#2-消费端性能优化" class="headerlink" title="2. 消费端性能优化"></a>2. 消费端性能优化</h4><p>如果消息积压，那么就需要考虑为什么消费者的消费速度跟不上生产速度。一般的优化手段是，对消费端进行水平进行扩容，来提升总体的消费性能。但是需要注意的是：<strong>在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区（Partition）（也叫队列）数量，确保 Consumer 的实例数和分区数量是相等的</strong>，如果Consumer的数量超过了分区（或者队列）的数量，扩容是没有效果的，因为每个分区只支持单线程消费。</p><p>还有一种处理办法，就是只从消息队列中取消息，然后放入本地内存队列当中，这样可以避免消息堆积。但是这并非一个很好的解决方案，甚至可以说是一个错误的解决方案。因为它很容易导致消息的丢失。本地节点如果挂了，消息就没了。</p><h4 id="积压了如何处理"><a href="#积压了如何处理" class="headerlink" title="积压了如何处理"></a>积压了如何处理</h4><p>积压无外乎两种情况导致的，一是发送速度过快了，二是消费速度变慢了。这个时候就要配合监控日志去排查到底是什么原因，然后采取相对应的解决办法。</p><p>还有一种情况是，频繁的出现消费错误，然后一直重试，导致消费变慢，这种情况就要去查看日志，看是否有大量的报错。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;消息积压该如何处理&quot;&gt;&lt;a href=&quot;#消息积压该如何处理&quot; class=&quot;headerlink&quot; title=&quot;消息积压该如何处理&quot;&gt;&lt;/a&gt;消息积压该如何处理&lt;/h2&gt;&lt;p&gt;一般来说，消息积压的直接原因，是因为系统中某个部分出了问题，来不及处理上游发送的消息</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="消息队列" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>逃逸分析</title>
    <link href="http://example.com/2023/12/01/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2023/12/01/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</id>
    <published>2023-12-01T04:23:38.000Z</published>
    <updated>2023-12-01T04:24:16.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h1><p><strong>逃逸分析是“一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针”</strong></p><p>在Java虚拟机的即时编译环境下，逃逸分析将判断<strong>新建的对象</strong>是否逃逸。判断逃逸的依据是：</p><ol><li>对象是否被存入堆中（静态字段或堆中对象的实例字段）</li><li>对象是否被传入未知代码中。</li></ol><p>前者很好理解，一旦对象放入堆中，其他线程就可以获得该对象的引用。即时编译器也因此无法追踪所有引用该对象代码的位置。</p><p>对于第二点，由于Java编译器的编译是以方法为单位的，对于方法中未被内联的方法调用，编译器会将其当作未知代码，因为无法确认该方法调用是否会将调用者或传入的参数存储至堆当中。所以可以把方法调用的调用者以及参数是逃逸的。</p><h2 id="基于逃逸分析的优化"><a href="#基于逃逸分析的优化" class="headerlink" title="基于逃逸分析的优化"></a>基于逃逸分析的优化</h2><p>即时编译器可以根据逃逸分析的结果进行诸如<strong>锁消除</strong>、<strong>栈上分配</strong>以及<strong>标量替换</strong>的优化。</p><p>对于锁消除，如果即时编译器能够证明<strong>锁对象（指的就是要被加锁的对象）</strong>不逃逸，那么对该锁对象的加锁解锁操作是没有意义的。因为其他线程无法获得该锁对象，也不可能对其进行加锁操作，即时编译器可以消除对该对象的加锁解锁操作。</p><p>传统编译器仅需证明锁对象不逃逸出线程，便可以进行锁消除。由于 Java 虚拟机即时编译的限制，上述条件被强化为<strong>证明锁对象不逃逸出当前编译</strong>的方法。</p><p>注意，上述场景并不多见，因为很少在方法内，基于新构建的对象进行加锁操作。一般都是某个类的公共成员属性进行加锁。</p><p>逃逸分析优化更多的是用在<strong>新建对象操作转换成栈上分配或者标量替换</strong>。</p><p>Java 虚拟机中对象都是在堆上分配的，而堆上的内容对任何线程都是可见的。同时，Java 虚拟机需要对所分配的堆内存进行管理，并且在对象不再被引用时回收其所占据的内存。</p><p>如果逃逸分析能够证明某些新建的对象不逃逸，<strong>那么 Java 虚拟机完全可以将其分配至栈上</strong>， 并且在 new 语句所在的方法退出时，通过<strong>弹出当前方法的栈桢来自动回收所分配的内存空间</strong>。这样一来，我们便无须借助垃圾回收器来处理不再被引用的对象。</p><p>实际上，HotSpot 并没有采用在栈上分配，而是采用了一种<strong>标量替换</strong>的技术。标量，指的是仅能存储一个值的变量。标量替换这项优化技术，可以看成将原本对<strong>对象的字段的访问</strong>，替换为一个个<strong>局部变量的访问</strong>。即将原本在内存中连续分配的对象，拆成了一个个单独的字段。这些字段既可以存储在栈上，也可以直接存储在寄存 器中。而该对象的对象头信息则直接消失了，不再被保存至内存之中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;逃逸分析&quot;&gt;&lt;a href=&quot;#逃逸分析&quot; class=&quot;headerlink&quot; title=&quot;逃逸分析&quot;&gt;&lt;/a&gt;逃逸分析&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;逃逸分析是“一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针”&lt;/strong&gt;&lt;/</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="虚拟机" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="Jvm" scheme="http://example.com/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>写倾斜</title>
    <link href="http://example.com/2023/11/30/%E5%86%99%E5%80%BE%E6%96%9C/"/>
    <id>http://example.com/2023/11/30/%E5%86%99%E5%80%BE%E6%96%9C/</id>
    <published>2023-11-30T08:45:49.000Z</published>
    <updated>2023-11-30T08:51:09.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写倾斜"><a href="#写倾斜" class="headerlink" title="写倾斜"></a>写倾斜</h1><p>举一个例子，现在有两个医生在值班，医院的规定是如果当前有两个医生在值班，那么就有一个医生可以暂时离开。如果这两个医生同时点击申请离开，会开启两个事务，两个事务会先判断是否有两个医生在值班，因为两个事务同时执行，<strong>暂时不考虑隔离性</strong>，那么两个事务判断都满足条件，然后进入下一阶段，医生离开，减少当前医生数量，然后医生数量就变为0。这显然不满足需求。</p><p>这既不是一种脏读，也不是更新丢失，两笔事务更新的是两个不同的对象（两个医生的值班状态）。</p><p>根据可串行化定义，多个事务并行执行，他们的结果与事务串行执行的要一致，可以发现事务并没有达到穿行的效果。</p><p>可以说，<strong>写倾斜是一种不易察觉到的更新丢失</strong>，或者将写倾斜定义为一种更广义的数据更新丢失问题。</p><p>即如果两个事务读取相同的一组对象，然后更新其中一部分：不同的事务更新不同的对象，则可能发生写倾斜。而不同的事务如果更新的是同一个对象，则可能发生脏写或更新丢失。</p><p>可以发现，首先他会查询一些数据（需要满足一定的条件），暂定为数据集A，然后根据这些数据去做下一步的操作。</p><p>我们根据数据集A去做一些判断，然后执行后续的操作。</p><p>在第二步判断成功后，有一些操作修改了数据集A里面的内容，导致了他不再满足第二步的判断，但此时第二步的判断已经结束了，开始执行后续的逻辑，就发生了写倾斜。</p><p>即发生写倾斜是因为后续的操作改变了满足之前查询结果的数据，或者使得之前的数据不满足曾经的判断条件，导致了写倾斜。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写倾斜&quot;&gt;&lt;a href=&quot;#写倾斜&quot; class=&quot;headerlink&quot; title=&quot;写倾斜&quot;&gt;&lt;/a&gt;写倾斜&lt;/h1&gt;&lt;p&gt;举一个例子，现在有两个医生在值班，医院的规定是如果当前有两个医生在值班，那么就有一个医生可以暂时离开。如果这两个医生同时点击申请离开</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MySQL" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>方法内联</title>
    <link href="http://example.com/2023/11/29/%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94/"/>
    <id>http://example.com/2023/11/29/%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94/</id>
    <published>2023-11-29T03:17:51.000Z</published>
    <updated>2023-11-29T03:18:45.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h1><p>方法内联指的是在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。它不仅可以消除调用本身带来的性能开销，还可以进一步触发更多的优化。</p><p>举个例子，如果没有方法内联，当调用getter&#x2F;setter方法时，程序需要保存当前方法的执行位置，创建并压入用于getter&#x2F;setter的栈帧，访问字段，弹出栈帧，最后再恢复当前方法的执行，当内联了对getter&#x2F;setter的方法调用后，上述操作仅剩字段访问。</p><blockquote><p>即时编译器首先解析字节码，并生成IR图，然后在该IR图上进行优化，优化是由一个个独立的优化阶段串联起来的，每个优化阶段都会对IR图进行转换，最后即时编译器根据IR图的节点以及调度顺序生成机器码。</p></blockquote><p>一个相对于IR图好理解的内联形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b , <span class="type">int</span> c, <span class="type">int</span> d)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(a, b) + add(c, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内联之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b , <span class="type">int</span> c, <span class="type">int</span> d)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现，内敛后少了两次方法的调用，那么就意味着少了两次的方法的入栈。</p><h2 id="内联的条件"><a href="#内联的条件" class="headerlink" title="内联的条件"></a>内联的条件</h2><ol><li>热点代码。如果一个方法的执行频率很高就表示优化的潜在价值就越大。这里是根据编译器的编译模式来决定的，如果是客户端模式，则次数是1500，服务端编译模式是10000，该大小可以通过<code>-XX:CompileThreshold来调整</code>。</li><li>方法体不能太大。jvm中被内联的方法会编译成机器码放在code cache中。如果方法体太大，则能缓存热点方法就少，反而会影响性能。</li><li>由 -XX:CompileCommand 中的 inline 指令指定的方法，以及由 @ForceInline 注 解的方法（仅限于 JDK 内部方法），会被强制内联。</li><li>如果调用字节码对应的符号引用未被解析、目标方法所在的类未被初始化，或者目标方 法是 native 方法，都将导致方法调用无法内联。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;方法内联&quot;&gt;&lt;a href=&quot;#方法内联&quot; class=&quot;headerlink&quot; title=&quot;方法内联&quot;&gt;&lt;/a&gt;方法内联&lt;/h1&gt;&lt;p&gt;方法内联指的是在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。它不仅可以消除调用</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="虚拟机" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="Jvm" scheme="http://example.com/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>即时编译（上）</title>
    <link href="http://example.com/2023/11/27/%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://example.com/2023/11/27/%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2023-11-27T03:02:18.000Z</published>
    <updated>2023-11-27T03:02:52.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="即时编译"><a href="#即时编译" class="headerlink" title="即时编译"></a>即时编译</h1><p>通常而言，代码会先被 <strong>Java 虚拟机解释执行</strong>，之后<strong>反复执行的热点代码则会被即时编译</strong>成为机器码，直接运行在底层硬件之上。</p><p>在Java7之前，需要根据程序的特性，选择对应的即时编译器。对于执行时间比较短的，或者对启动性能有要求的，采用编译较快的C1，执行时间较长，或对峰值性能有要求的，采用生成代码执行效率较快的C2。</p><p>Java7引入了分层编译。将虚拟机的执行状态分为了5个层次，分别是：</p><ol><li>解释执行</li><li>执行不带profiling的C1生成的机器码</li><li>执行仅带<strong>方法调用次数</strong>以及<strong>循环回边执行次数</strong>profiling的C1生成的机器码</li><li>执行带所有profiling的C1生成的机器码</li><li>执行C2生成的机器码</li></ol><p>其中，C2代码的执行效率要比C1代码的高，而对于C1代码的三种状态，效率由高到低，因为profiling 越多，其额外的性能开销越大。profiling 是指在程序执行过程中，收集能够反映程序执行状态的数据。这里所收集的数据，称之为程序profile。profiler 大多通过注入 （instrumentation）或者 JVMTI 事件来实现的。</p><p>在 5 个层次的执行状态中，1 层和 4 层为终止状态。当一个方法被终止状态编译过后，如果 编译后的代码并没有失效，那么 Java 虚拟机是不会再次发出该方法的编译请求的。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231127103204555.png" alt="image-20231127103204555" style="zoom:80%;" /><p>如果方法的字节码数目比较少，而且3层的profiling没有可收集的数据，那么虚拟机断定该方法对于C1和C2代码的执行效率相同。这种情况下，虚拟机会在3层编译后，直接选用1层的C1编译，这是一个终止状态，虚拟机不会再继续用4层的C2编译。</p><p>后两种展示了C1忙碌和C2忙碌的情况。</p><h2 id="即时编译的触发"><a href="#即时编译的触发" class="headerlink" title="即时编译的触发"></a>即时编译的触发</h2><p>Java 虚拟机是根据<strong>方法的调用次数</strong>以及<strong>循环回边的执行次数</strong>来触发即时编译的。Java 虚拟机在 0 层、2 层和 3 层执行状态时进行 profiling，其中就包含方法的调用次数和循环回边的执行次数。</p><p>这里的循环回边是一个控制流图中的概念。在字节码中，可以简单理解为往回跳转的指令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java虚拟机并不会对这些计数操作进行同步，收集的数据并不需要准确，当数值足够大，就可以说明包含热点代码。</p><p>具体来说，在不启动分层编译的情况下，当方法调用次数和循环回边的次数和，超过阈值（由参数-XX:CompileThreshold指定，使用C1时为1500，使用C2时该值为10000），便会触发即时编译。</p><p>当采用分层编译，Java虚拟机将不再采用由参数<code>-XX:CompileThreshold </code>指定的阈值，而是使用另一套阈值系统，这里该阈值是动态调整的。</p><h2 id="OSR编译"><a href="#OSR编译" class="headerlink" title="OSR编译"></a>OSR编译</h2><p>决定一个方法是否为热点代码的因素有两个：方法的调用次数、循环回边的执行次数。即时编译器是根据这两个计数器的和来触发的，为什么不维护两个不同的计数器呢？</p><p>除了以方法为单位的即时编译之外，Java 虚拟机还存在着另一种以循环为单位的即时编译，叫做 On-Stack-Replacement（OSR）编译。循环回边计数器便是用来触发这种类 型的编译的。</p><p>OSR 实际上是一种技术，它指的是在程序执行过程中，动态地替换掉 Java 方法栈桢，从而使 得程序能够在非方法入口处进行解释执行和编译后的代码之间的切换。事实上，去优化 （deoptimization）采用的技术也可以称之为 OSR。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;即时编译&quot;&gt;&lt;a href=&quot;#即时编译&quot; class=&quot;headerlink&quot; title=&quot;即时编译&quot;&gt;&lt;/a&gt;即时编译&lt;/h1&gt;&lt;p&gt;通常而言，代码会先被 &lt;strong&gt;Java 虚拟机解释执行&lt;/strong&gt;，之后&lt;strong&gt;反复执行的热点代码则会</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="虚拟机" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="Jvm" scheme="http://example.com/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized</title>
    <link href="http://example.com/2023/11/25/Synchronized/"/>
    <id>http://example.com/2023/11/25/Synchronized/</id>
    <published>2023-11-25T06:33:00.000Z</published>
    <updated>2024-03-01T03:06:19.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>synchronized可以用来对程序加锁，synchronized内的代码又叫做同步代码块，它既可以用来声明一个synchronized代码块，也可以直接标记静态方法或者实例方法。</p><p>当声明 <strong>synchronized 代码块</strong>时，编译而成的字节码将包含 <code>monitorenter</code> 和 <code>monitorexit</code> 指令。这两种指令均会消耗操作数栈上的一个引用类型的元素（也就是synchronized 关键字括号里的引用），作为要加锁解锁的对象。</p><p>当查看使用了synchronized 关键字的代码编译过后的字节码时，可以发现会存在一个<code>monitorenter</code> 和多个<code>monitorexit</code> ，这是因为虚拟机需要保证加锁之后，不论是正常执行还是异常执行，都需要能够释放锁。</p><p>当用<strong>synchronized 标记方法</strong>时，虚拟机在进入该方法后进行<code>monitorenter</code> ，而退出方法时，不论是正常结束还是抛出异常，都需要进行<code>monitorexit</code> 。这里的<code>monitorenter</code> 和<code>monitorexit</code> 操作所对应的锁对象是隐式的。</p><p>对于实例方法来说，这两个操作对应的<strong>锁对象是this，即该实例本身</strong>，而对于静态方法来说，这两个操作对应的锁对象是<strong>所在类的Class实例</strong>。</p><h2 id="monitorenter-和-monitorexit"><a href="#monitorenter-和-monitorexit" class="headerlink" title="monitorenter 和 monitorexit"></a>monitorenter 和 monitorexit</h2><p>关于 <code>monitorenter</code> 和 <code>monitorexit</code> 的作用，我们可以抽象地理解为每个锁对象拥有一个锁计 数器和一个指向持有该锁的线程的指针。当执行<code>monitorenter</code> 时，如果锁对象的计数器为0，则说明他没有被其他线程所持有，<strong>虚拟机会将该锁对象的持有线程设置为当前线程</strong>，并将计数器加1。如果计数器不为0，那么判断持有锁的线程是否是当前线程，如果是则加1，否则需要等待持有锁的线程释放锁。当执行 <code>monitorexit</code> 时，Java 虚拟机则需将锁对象的计数器减 1。当计数器减为 0 时，那便 代表该锁已经被释放掉了。</p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>在这种状态下，Java 虚拟机会阻塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。而Java线程的阻塞和唤醒，都是需要依赖于操作系统来完成的。对于符合posix接口的操作系统，这些操作是通过pthread的互斥锁(mutex)来实现的，<strong>这些操作都涉及到系统调用，需要从用户态切换至核心态</strong>，开销很大。</p><p>为了避免这些切换，Java虚拟机在线程进入阻塞状态前，以及被唤醒后竞争不到锁的情况下，会进入自旋状态，在处理器空跑并且轮询锁是否被释放。如果此时被释放，则不需要进入阻塞状态，直接获取锁。</p><p>与线程阻塞相比，自旋可能会浪费大量CPU资源。这里自旋并非一定会持续下去，虚拟机采用的是自适应自旋，根据以往自旋等待时是否能够获得锁，来动态调整自旋的时间（循环数目）。</p><p>自旋还会导致一个问题，即处于阻塞状态的线程无法立刻竞争这把锁，而处于自旋状态的可能会优先获取锁，也就是说并不公平。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>多个线程在<strong>不同的时间段</strong>请求同一把锁，也就是说<strong>没有锁竞争</strong>。针对这种情形，Java 虚拟机采用了轻量级锁，来避免重量级锁的阻塞以及唤醒。</p><h3 id="如何区分轻量级和重量级锁"><a href="#如何区分轻量级和重量级锁" class="headerlink" title="如何区分轻量级和重量级锁"></a>如何区分轻量级和重量级锁</h3><p>Java对象头中有一个标记字段，它的最后两位便被用来表示该对象的锁状态，00代表轻量级锁，01代表无锁或偏向锁，10代表重量级锁，11则跟垃圾回收算法的标记有关。</p><h2 id="加锁和释放锁"><a href="#加锁和释放锁" class="headerlink" title="加锁和释放锁"></a>加锁和释放锁</h2><p>在进行加锁时，虚拟机会判断是否已经是重量级锁，如果不是，它会在当前线程的栈帧中划出一块空间，作为该锁的锁记录，并且将锁对象的标记字段复制到该锁记录中。</p><p>然后，虚拟机会尝试使用CAS操作<strong>替换锁对象的标记字段</strong>，先判断标记为是否为01，如果是，则替换为刚刚分配的锁记录的地址。</p><blockquote><p>注意，上述整个过程可以理解为一个CAS操作。当进行加锁时，判断对象标记为并不是重量级锁，那么就先在当前线程的栈帧中开辟空间，然后将对象的标记字段复制到栈帧中，之后是采用CAS对比栈帧中的标记字段和对象的标记字段是否相同，如果相同则将对象的标记字段替换为刚刚分配栈帧中的地址。然后加锁就成功了。这里，<strong>是将标记字段替换为了线程私有栈帧中的地址。</strong></p></blockquote><p>如果比较不相同，则有两种可能：</p><ul><li><p>第一是该线程重复获取同一把锁，这时候虚拟机会将锁记录清零，一戴白哦该锁重复获取。</p></li><li><p>第二是有其他线程持有该锁，那么虚拟机将会把这把锁膨胀为重量级锁，并阻塞当前线程。</p></li></ul><p>当进行解锁操作时， 如果当前所记录的值为0，则代表重复进入同一把锁，直接返回即可。（可以将线程的所有所记录想象为一个栈结构，每次加锁压入一条所记录，解锁弹出一条锁记录，当前锁记录指的就是栈顶的锁记录）</p><p>如果不是0，则虚拟机会尝试使用CAS操作，比较锁对象的<strong>标记字段的值</strong>是否为当前锁记录的地址，如果是，则替换为锁对象原本标记字段的值（该值在加锁时被复制到了线程私有的栈帧中，然后将值替换为具体的地址，这里是通过地址将原先的值复制回来）。然后释放锁成功。</p><p>如果不是该地址，说明锁被升级为重量级锁，此时需要进入重量级锁的释放流程，唤醒因竞争该锁而被阻塞的线程。</p><blockquote><p>这里，可能是该线程之前加锁成功，在加锁过程中有另外的线程试图获取锁，或者在加了轻量级锁后有线程试图加锁，那么该锁会被升级为重量级锁。</p></blockquote><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>在线程进行加锁时，如果该锁对象支持偏向锁，那么 Java 虚拟机会通过 CAS 操作，将<strong>当前线程的地址记录在锁对象的标记字段之中</strong>，并且将标记字段的最后三位设置为 101。（这里是将线程的地址写入对应的对象，而轻量级锁是复制对象的内容到线程的栈帧）。</p><p>之后，每当有线程请求这把锁，虚拟机只需要判断锁对象标记字段中最后三位是否为101，是否包含当前线程的地址，以及epoch值是否和锁对象的类的eopch值相同。如果都满足，则当前偏向锁就属于该对象，直接返回即可。</p><h3 id="eopch"><a href="#eopch" class="headerlink" title="eopch"></a>eopch</h3><p>当<strong>请求加锁的线程</strong>和<strong>锁对象标记字段</strong> 保持的线程地址不匹配时（epoch值相等，如果不相等，当前线程可以将该偏向锁偏向至自己），虚拟机需要撤销该偏向锁，过程比较麻烦，要求持有偏向锁的线程到达安全点，再将偏向锁替换成轻量级锁。如果某一类的锁对象撤销次数超过一个阈值（对应 Java 虚拟机参数 - XX:BiasedLockingBulkRebiasThreshold，默认为 20），虚拟机会让该偏向锁失效。</p><p>具体的做法便是在每个类中维护一个 epoch 值，可以理解为第几代偏向锁。当设置偏向锁 时，Java 虚拟机需要将该 epoch 值复制到锁对象的标记字段中。当某个偏向锁失效时，会将该类的epoch值加1，表示之前那一代的偏向锁已经失效，新设置的偏向锁需要复制新的epoch值。</p><p>为了保证当前持有偏向锁并且已加锁的线程不至于因此丢锁，Java 虚拟机需要遍历所有线程 的 Java 栈，找出该类已加锁的实例，并且将它们标记字段中的 epoch 值加 1。该操作需要所 有线程处于安全点状态。</p><p>总撤销次数超过阈值（对应 Java 虚拟机参数 - XX:BiasedLockingBulkRevokeThreshold，默认值为 40），那么虚拟机会认为该类已经不再适合偏向锁，虚拟机会撤销该类的偏向锁，并在后续加锁过程中直接加轻量级锁。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;synchronized&quot;&gt;&lt;a href=&quot;#synchronized&quot; class=&quot;headerlink&quot; title=&quot;synchronized&quot;&gt;&lt;/a&gt;synchronized&lt;/h1&gt;&lt;p&gt;synchronized可以用来对程序加锁，synchron</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="虚拟机" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="Jvm" scheme="http://example.com/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>2^32 怎么表示4GB</title>
    <link href="http://example.com/2023/11/21/%E5%86%85%E5%AD%98%E8%A1%A8%E7%A4%BA/"/>
    <id>http://example.com/2023/11/21/%E5%86%85%E5%AD%98%E8%A1%A8%E7%A4%BA/</id>
    <published>2023-11-21T03:11:54.000Z</published>
    <updated>2023-11-21T03:18:29.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-32-怎么表示4GB"><a href="#2-32-怎么表示4GB" class="headerlink" title="2^32 怎么表示4GB"></a>2^32 怎么表示4GB</h1><p>一般来说，32位最大支持4GB内存，怎么计算出来的呢？</p><p>如果按照这样计算： 2^32 bit &#x3D; 2^29 byte &#x3D; 2^19 KB &#x3D; 2^9 MB &#x3D; 0.5 GB，其实并不够4GB。</p><p>但其实，计算机规定8bit&#x3D;1byte 就是1字节&#x3D;8位，内存的大小就根据格子的多少来进行计算的。</p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/image-20231121111621868.png" alt="image-20231121111621868" style="zoom:67%;" /><p>实际上，4GB &#x3D;  2^2 GB &#x3D; 2^12 MB &#x3D; 2^22 KB &#x3D; 2^32 byte &#x3D; 2^35 bit。也就是说，4GB需要35位。</p><p><strong>实际上内存是把8个bit排成1组， 每1组成为1个单位， 大小是1byte(字节）， cpu每一次只能访问1个byte， 而不能单独去访问具体的1个小格子(bit). 1个byte字节就是内存的最小的IO单位。</strong></p><p>即这里3^32次方，后面的单位并不是bit，而是byte。</p><p>计算机操作系统会给内存每1个字节分配1个内存地址, cpu只需要知道某个数据类型的地址, 就可以直接去到读影的内存位置去提取数据了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2-32-怎么表示4GB&quot;&gt;&lt;a href=&quot;#2-32-怎么表示4GB&quot; class=&quot;headerlink&quot; title=&quot;2^32 怎么表示4GB&quot;&gt;&lt;/a&gt;2^32 怎么表示4GB&lt;/h1&gt;&lt;p&gt;一般来说，32位最大支持4GB内存，怎么计算出来的呢？&lt;/p</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>Java的方法调用</title>
    <link href="http://example.com/2023/11/17/Java%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/"/>
    <id>http://example.com/2023/11/17/Java%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</id>
    <published>2023-11-17T01:21:21.000Z</published>
    <updated>2023-11-21T07:04:37.908Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>Java中方法的重载，在编译过程中可以完成识别，而具体调用哪一个方法，Java编译器会根据所传入<strong>参数的声明类型（注意与实际类型区分比如声明的是一个List，实际实例化传入的可能是一个ArrayList）</strong>来选取重载方法。选取过程分以下三个阶段：</p><ol><li>在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法；（这里是只找普通方法）</li><li>如果在第 1 个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；（加入自动装箱拆箱的方法）</li><li>如果在第 2 个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况 下选取重载方法。（所有方法）</li></ol><p>如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么它会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是<strong>形式参数类型的继承关系</strong>。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(String s, Object obj, Object... args)</span> &#123; ... &#125;</span><br><span class="line">invoke(<span class="literal">null</span>, <span class="number">1</span>); <span class="comment">// 调用第二个invoke方法</span></span><br><span class="line">invoke(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用第二个invoke方法</span></span><br><span class="line">invoke(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">1</span>&#125;); <span class="comment">// 只有手动绕开可变长参数的语法糖</span></span><br></pre></td></tr></table></figure><p>为什么会调用第二个呢？因为String 类型 是Object 的子类，所以编译器会认为它更贴合（范围更小）。</p><p>而如果子类继承父类，而且有一个方法和父类中非私有的方法同名，而且参数相同，如果两个方法都是静态的，那么子类中会隐藏父类的方法，如果不是静态切都不是私有的，那么子类的方法相当于重写了父类的方法。</p><h4 id="JVM-的静态绑定和动态绑定"><a href="#JVM-的静态绑定和动态绑定" class="headerlink" title="JVM 的静态绑定和动态绑定"></a>JVM 的静态绑定和动态绑定</h4><p>Java 虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）。方法描述符，是由方法的<strong>参数类型</strong>以及<strong>返回类型</strong>所构成。在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么 Java 虚拟机会在<strong>类的验证阶段</strong>报错。</p><p>因为描述符包含了返回类型，所以说并不会限制同一个类中有方法名和参数一样，但返回值不一样的方法。而在上述提到的子类有一个父类同名，同返回值，同参数的非私有，非静态方法，才会被虚拟机判定为重写。</p><p>因为重载方法在编译阶段已经区分，可以认为虚拟机层面没有重载的概念。因此，<strong>重载也被称为静态绑定</strong>（static binding），或者编译时多态 （compile-time polymorphism）；而<strong>重写则被称为动态绑定</strong>（dynamic binding）。</p><p>这个说法在虚拟机语境下并不完全正确，因为某个类的重载方法可能会被它的子类所重写，因此，Java编译器会对所有非私有方法的调用，编译为需要动态绑定的类型（考虑子类继承父类，并重写父类的方法。此时通过子类调用重写的方法，并不能在编译期间确定）。</p><p>确切地说，Java 虚拟机中的<strong>静态绑定指的是在解析时便能够直接识别目标方法的情况</strong>，而<strong>动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法</strong>的情况。</p><h4 id="调用指令的符号引用"><a href="#调用指令的符号引用" class="headerlink" title="调用指令的符号引用"></a>调用指令的符号引用</h4><p>在编译过程中，并不知道目标方法的具体内存地址（编译阶段该对象并没有被实例化，似乎没实例化说法不太准确，gpt说是并不需要知到。有了符号引用后，在运行时，JVM会将符号引用解析为实际的地址引用）。</p><p>因此，Java 编译器会暂时用<strong>符号引用（这个符号引用应该就是暂时指代该方法）</strong>来表示该目标方法。这一符号引用包括目标方法所在的<strong>类</strong>或<strong>接口</strong>的名字，以及目标方法的<strong>方法名</strong>和<strong>方法描述符</strong>。</p><p>符号引用存储在 class 文件的常量池之中。根据目标方法是否为接口方法，这些引用可分为接口符号引用和非接口符号引用。</p><h4 id="虚方法调用"><a href="#虚方法调用" class="headerlink" title="虚方法调用"></a>虚方法调用</h4><p>Java 里所有非私有实例方法调用都会被编译成 invokevirtual 指令， 而接口方法调用都会被编译成 invokeinterface 指令。这两种指令，均属于 Java 虚拟机中的 <strong>虚方法调用</strong>。</p><p>Java 虚拟机需要根据调用者的动态类型，来确定虚方法调用的目标方法。这个过程我们称之为<strong>动态绑定</strong>。（这里，调用者的动态类型，应该是受Java多态的影响，即List list &#x3D; new ArrayList这种写法，List是一个接口，并不知道它的实例化是哪一个，需要根据具体的动态类型来决定调用的是它的哪一个实现）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里的打印结果是123</span></span><br><span class="line">        test.testExe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testExe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">        father.fatherMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="type">int</span> test;</span><br><span class="line">    <span class="type">int</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fatherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">childMethod</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fatherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法表（用于优化动态绑定，即虚方法）"><a href="#方法表（用于优化动态绑定，即虚方法）" class="headerlink" title="方法表（用于优化动态绑定，即虚方法）"></a>方法表（用于优化动态绑定，即虚方法）</h4><p>Java 虚拟机中采取了一种用空间换取时间的策略来实现动态绑定。它为每个类生成一张方法表，用以快速定位目标方法。</p><p>方法表本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法。这些方法可能是具体的，可执行的方法，也可能是抽象的方法。方法表有以下两个特征：</p><ol><li>子类的方法表中包含了父类的方法表中的所有方法。</li><li>子类重写了父类方法时，该方法在子类中的索引值与父类中的一样。即通过索引只能找到子类的方法。</li></ol><p>在符号引用解析为实际引用的时候，对于静态绑定的调用而言，实际引用是直接指向具体的目标方法，而动态绑定，则是实际引用则是指向了方法表的索引值（并不仅是索引值）。</p><p>在执行过程中，Java 虚拟机将获取调用者的实际类型，并在该实际类型的虚方法表中，根据 索引值获得目标方法。这个过程便是动态绑定。</p><p>使用了方法表的动态绑定与静态绑定相比，仅仅多出几个内存解引用操作：访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值所对应的目标方法。</p><p>这种优化仅存在于<strong>解释执行</strong>中，或者<strong>即时编译代码的最坏情况</strong>中。这是因为即时编译还有另外两种更好的优化，<strong>内联缓存</strong> （inlining cache）和<strong>方法内联</strong>（method inlining）。</p><h4 id="内联缓存"><a href="#内联缓存" class="headerlink" title="内联缓存"></a>内联缓存</h4><p>它能够缓存虚方法调用中调用者的<strong>动态类型</strong>，以及<strong>该类型所对应的目标方法</strong>。在之后的执行过程中，如果碰到已缓存的类型，内联缓存便会直接 调用该类型所对应的目标方法。如果没有碰到已缓存的类型，内联缓存则会退化至使用基于方法表的动态绑定，即当内联缓存没有命中的情况下，Java 虚拟机需要重新使用方法表进行动态绑定。</p><p>Java虚拟机采用的是单态的，即只会缓存对应方法的一种实例，那么在一种极端的情况下，两个不同的类型频繁调同一个 方法，就会导致缓存被频繁的切换，而且每次都需要去重新绑定一下。情况如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal makes a sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Cat meows&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 在不同的调用者（不同的对象类型）上轮流调用相同的虚方法</span></span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                animal1.makeSound(); <span class="comment">// Dog 调用</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                animal2.makeSound(); <span class="comment">// Cat 调用</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;方法调用&quot;&gt;&lt;a href=&quot;#方法调用&quot; class=&quot;headerlink&quot; title=&quot;方法调用&quot;&gt;&lt;/a&gt;方法调用&lt;/h3&gt;&lt;p&gt;Java中方法的重载，在编译过程中可以完成识别，而具体调用哪一个方法，Java编译器会根据所传入&lt;strong&gt;参数的声明类</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="虚拟机" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="Jvm" scheme="http://example.com/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>AQS</title>
    <link href="http://example.com/2023/11/12/AQS/"/>
    <id>http://example.com/2023/11/12/AQS/</id>
    <published>2023-11-12T03:14:16.000Z</published>
    <updated>2023-11-21T07:04:21.712Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS是什么：AQS，是AbstractQueuedSynchronizer简称，直翻过来叫抽象的<code>队列式同步器</code>， 也可以称作队列同步器，它是java.util.concurrent.lock包下的一个工具类。直观来讲，AQS是Java提供的一个类，这个类是被Abstract修饰的，需要被子类继承。也就是说<strong>AQS是Java并发中用以解决多线程访问共享资源问题的同步机制的基本的框架</strong>（或者说是一种规范），<strong>为Java并发同步组件提供统一的底层支持</strong>。即，AQS是个为各个同步组件提供基本框架的一个抽象类。</p><p>AQS做了什么：<code>提供解决同步问题的基础框架</code>。AQS类内维护了一个volatile int型的变量state，用于表示同步状态（锁的释放与获取），同时提供了一些列诸如getstate、setstate、compareAndSetState的方法来管理该同步状态，这些方法是子类中需要重写的部分，并且，AQS提供了模板方法去调用这些重写的方法；另外，AQS用一个虚拟的CLH FIFO的双向队列来管理被阻塞的线程。</p><p>AQS的整体框架如下：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/82077ccf14127a87b77cefd1ccf562d3253591.png" alt="img"></p><ul><li><p>有颜色的为方法，没颜色的为属性。</p></li><li><p>框架共分为5层，从上到下，由浅入深，从AQS对外暴露的API到底层基础数据。</p></li><li><p>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。</p><p>当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</p></li></ul><h4 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h4><p>AQS核心思想是：</p><ul><li><p>如果被请求的共享资源空闲，那么就将当前<strong>请求资源的线程</strong>设置为有效的工作线程，将共享资源设置为锁定状态；</p></li><li><p>如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p></li></ul><p>CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的<strong>虚拟双向队列（FIFO）</strong>，AQS是通过将每条<strong>请求共享资源的线程</strong>封装成一个节点来实现锁的分配。</p><p>原理如下：</p><p><img src="https://image-1314238346.cos.ap-chongqing.myqcloud.com/7132e4cef44c26f62835b197b239147b18062.png" alt="img"></p><p>AOS使用一个Volatile修饰的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值得修改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;AQS&quot;&gt;&lt;a href=&quot;#AQS&quot; class=&quot;headerlink&quot; title=&quot;AQS&quot;&gt;&lt;/a&gt;AQS&lt;/h3&gt;&lt;p&gt;AQS是什么：AQS，是AbstractQueuedSynchronizer简称，直翻过来叫抽象的&lt;code&gt;队列式同步器&lt;/cod</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Java" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/"/>
    
    <category term="并发" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Java/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
